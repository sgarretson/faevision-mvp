/**
 * Client
 **/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model Input
 *
 */
export type Input = $Result.DefaultSelection<Prisma.$InputPayload>;
/**
 * Model Comment
 *
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>;
/**
 * Model Vote
 *
 */
export type Vote = $Result.DefaultSelection<Prisma.$VotePayload>;
/**
 * Model InputGroup
 *
 */
export type InputGroup = $Result.DefaultSelection<Prisma.$InputGroupPayload>;
/**
 * Model Solution
 *
 */
export type Solution = $Result.DefaultSelection<Prisma.$SolutionPayload>;
/**
 * Model Task
 *
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>;
/**
 * Model Requirement
 *
 */
export type Requirement = $Result.DefaultSelection<Prisma.$RequirementPayload>;
/**
 * Model FRDDocument
 *
 */
export type FRDDocument = $Result.DefaultSelection<Prisma.$FRDDocumentPayload>;
/**
 * Model AuditLog
 *
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>;
/**
 * Model Notification
 *
 */
export type Notification =
  $Result.DefaultSelection<Prisma.$NotificationPayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
    ADMIN: 'ADMIN';
    EXECUTIVE: 'EXECUTIVE';
    CONTRIBUTOR: 'CONTRIBUTOR';
  };

  export type UserRole = (typeof UserRole)[keyof typeof UserRole];

  export const InputType: {
    PROBLEM: 'PROBLEM';
    OPPORTUNITY: 'OPPORTUNITY';
    GENERAL: 'GENERAL';
  };

  export type InputType = (typeof InputType)[keyof typeof InputType];

  export const InputStatus: {
    NEW: 'NEW';
    DISCUSSING: 'DISCUSSING';
    ORGANIZED: 'ORGANIZED';
    IN_SOLUTION: 'IN_SOLUTION';
    ARCHIVED: 'ARCHIVED';
  };

  export type InputStatus = (typeof InputStatus)[keyof typeof InputStatus];

  export const IssueType: {
    PROCESS: 'PROCESS';
    TECHNOLOGY: 'TECHNOLOGY';
    COMMUNICATION: 'COMMUNICATION';
    RESOURCE: 'RESOURCE';
    OTHER: 'OTHER';
  };

  export type IssueType = (typeof IssueType)[keyof typeof IssueType];

  export const Priority: {
    LOW: 'LOW';
    MEDIUM: 'MEDIUM';
    HIGH: 'HIGH';
  };

  export type Priority = (typeof Priority)[keyof typeof Priority];

  export const GroupStatus: {
    ACTIVE: 'ACTIVE';
    ARCHIVED: 'ARCHIVED';
    CONVERTED_TO_SOLUTION: 'CONVERTED_TO_SOLUTION';
  };

  export type GroupStatus = (typeof GroupStatus)[keyof typeof GroupStatus];

  export const SolutionStatus: {
    PLANNING: 'PLANNING';
    ACTIVE: 'ACTIVE';
    ON_HOLD: 'ON_HOLD';
    COMPLETED: 'COMPLETED';
    CANCELLED: 'CANCELLED';
  };

  export type SolutionStatus =
    (typeof SolutionStatus)[keyof typeof SolutionStatus];

  export const TaskStatus: {
    NOT_STARTED: 'NOT_STARTED';
    IN_PROGRESS: 'IN_PROGRESS';
    COMPLETED: 'COMPLETED';
    BLOCKED: 'BLOCKED';
  };

  export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus];

  export const RequirementStatus: {
    DRAFT: 'DRAFT';
    REVIEW: 'REVIEW';
    APPROVED: 'APPROVED';
    REJECTED: 'REJECTED';
    REVISED: 'REVISED';
  };

  export type RequirementStatus =
    (typeof RequirementStatus)[keyof typeof RequirementStatus];

  export const FRDStatus: {
    DRAFT: 'DRAFT';
    REVIEW: 'REVIEW';
    APPROVED: 'APPROVED';
    PUBLISHED: 'PUBLISHED';
  };

  export type FRDStatus = (typeof FRDStatus)[keyof typeof FRDStatus];

  export const NotificationType: {
    COMMENT: 'COMMENT';
    VOTE: 'VOTE';
    STATUS_CHANGE: 'STATUS_CHANGE';
    ASSIGNMENT: 'ASSIGNMENT';
    DEADLINE: 'DEADLINE';
    SYSTEM: 'SYSTEM';
  };

  export type NotificationType =
    (typeof NotificationType)[keyof typeof NotificationType];
}

export type UserRole = $Enums.UserRole;

export const UserRole: typeof $Enums.UserRole;

export type InputType = $Enums.InputType;

export const InputType: typeof $Enums.InputType;

export type InputStatus = $Enums.InputStatus;

export const InputStatus: typeof $Enums.InputStatus;

export type IssueType = $Enums.IssueType;

export const IssueType: typeof $Enums.IssueType;

export type Priority = $Enums.Priority;

export const Priority: typeof $Enums.Priority;

export type GroupStatus = $Enums.GroupStatus;

export const GroupStatus: typeof $Enums.GroupStatus;

export type SolutionStatus = $Enums.SolutionStatus;

export const SolutionStatus: typeof $Enums.SolutionStatus;

export type TaskStatus = $Enums.TaskStatus;

export const TaskStatus: typeof $Enums.TaskStatus;

export type RequirementStatus = $Enums.RequirementStatus;

export const RequirementStatus: typeof $Enums.RequirementStatus;

export type FRDStatus = $Enums.FRDStatus;

export const FRDStatus: typeof $Enums.FRDStatus;

export type NotificationType = $Enums.NotificationType;

export const NotificationType: typeof $Enums.NotificationType;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions
    ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions['log']>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(
    optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>
  );
  $on<V extends U>(
    eventType: V,
    callback: (
      event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent
    ) => void
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>
    ) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    }
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    'extends',
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.input`: Exposes CRUD operations for the **Input** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Inputs
   * const inputs = await prisma.input.findMany()
   * ```
   */
  get input(): Prisma.InputDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Comments
   * const comments = await prisma.comment.findMany()
   * ```
   */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vote`: Exposes CRUD operations for the **Vote** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Votes
   * const votes = await prisma.vote.findMany()
   * ```
   */
  get vote(): Prisma.VoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inputGroup`: Exposes CRUD operations for the **InputGroup** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more InputGroups
   * const inputGroups = await prisma.inputGroup.findMany()
   * ```
   */
  get inputGroup(): Prisma.InputGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.solution`: Exposes CRUD operations for the **Solution** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Solutions
   * const solutions = await prisma.solution.findMany()
   * ```
   */
  get solution(): Prisma.SolutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Tasks
   * const tasks = await prisma.task.findMany()
   * ```
   */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requirement`: Exposes CRUD operations for the **Requirement** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Requirements
   * const requirements = await prisma.requirement.findMany()
   * ```
   */
  get requirement(): Prisma.RequirementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fRDDocument`: Exposes CRUD operations for the **FRDDocument** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FRDDocuments
   * const fRDDocuments = await prisma.fRDDocument.findMany()
   * ```
   */
  get fRDDocument(): Prisma.FRDDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AuditLogs
   * const auditLogs = await prisma.auditLog.findMany()
   * ```
   */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Notifications
   * const notifications = await prisma.notification.findMany()
   * ```
   */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 6.16.1
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> =
    T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<
    T extends (...args: any) => $Utils.JsPromise<any>,
  > = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<
    __Either<O, K>
  >;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = O extends unknown ? _Either<O, K, strict> : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>,
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T,
  > = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    User: 'User';
    Input: 'Input';
    Comment: 'Comment';
    Vote: 'Vote';
    InputGroup: 'InputGroup';
    Solution: 'Solution';
    Task: 'Task';
    Requirement: 'Requirement';
    FRDDocument: 'FRDDocument';
    AuditLog: 'AuditLog';
    Notification: 'Notification';
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<
      { extArgs: $Extensions.InternalArgs },
      $Utils.Record<string, any>
    > {
    returns: Prisma.TypeMap<
      this['params']['extArgs'],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | 'user'
        | 'input'
        | 'comment'
        | 'vote'
        | 'inputGroup'
        | 'solution'
        | 'task'
        | 'requirement'
        | 'fRDDocument'
        | 'auditLog'
        | 'notification';
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      Input: {
        payload: Prisma.$InputPayload<ExtArgs>;
        fields: Prisma.InputFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.InputFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InputPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.InputFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InputPayload>;
          };
          findFirst: {
            args: Prisma.InputFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InputPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.InputFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InputPayload>;
          };
          findMany: {
            args: Prisma.InputFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InputPayload>[];
          };
          create: {
            args: Prisma.InputCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InputPayload>;
          };
          createMany: {
            args: Prisma.InputCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.InputCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InputPayload>[];
          };
          delete: {
            args: Prisma.InputDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InputPayload>;
          };
          update: {
            args: Prisma.InputUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InputPayload>;
          };
          deleteMany: {
            args: Prisma.InputDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.InputUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.InputUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InputPayload>[];
          };
          upsert: {
            args: Prisma.InputUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InputPayload>;
          };
          aggregate: {
            args: Prisma.InputAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateInput>;
          };
          groupBy: {
            args: Prisma.InputGroupByArgs<ExtArgs>;
            result: $Utils.Optional<InputGroupByOutputType>[];
          };
          count: {
            args: Prisma.InputCountArgs<ExtArgs>;
            result: $Utils.Optional<InputCountAggregateOutputType> | number;
          };
        };
      };
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>;
        fields: Prisma.CommentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>;
          };
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>;
          };
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[];
          };
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>;
          };
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[];
          };
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>;
          };
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>;
          };
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[];
          };
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>;
          };
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateComment>;
          };
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CommentGroupByOutputType>[];
          };
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>;
            result: $Utils.Optional<CommentCountAggregateOutputType> | number;
          };
        };
      };
      Vote: {
        payload: Prisma.$VotePayload<ExtArgs>;
        fields: Prisma.VoteFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.VoteFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VotePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.VoteFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VotePayload>;
          };
          findFirst: {
            args: Prisma.VoteFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VotePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.VoteFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VotePayload>;
          };
          findMany: {
            args: Prisma.VoteFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[];
          };
          create: {
            args: Prisma.VoteCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VotePayload>;
          };
          createMany: {
            args: Prisma.VoteCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.VoteCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[];
          };
          delete: {
            args: Prisma.VoteDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VotePayload>;
          };
          update: {
            args: Prisma.VoteUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VotePayload>;
          };
          deleteMany: {
            args: Prisma.VoteDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.VoteUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.VoteUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[];
          };
          upsert: {
            args: Prisma.VoteUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VotePayload>;
          };
          aggregate: {
            args: Prisma.VoteAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateVote>;
          };
          groupBy: {
            args: Prisma.VoteGroupByArgs<ExtArgs>;
            result: $Utils.Optional<VoteGroupByOutputType>[];
          };
          count: {
            args: Prisma.VoteCountArgs<ExtArgs>;
            result: $Utils.Optional<VoteCountAggregateOutputType> | number;
          };
        };
      };
      InputGroup: {
        payload: Prisma.$InputGroupPayload<ExtArgs>;
        fields: Prisma.InputGroupFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.InputGroupFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InputGroupPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.InputGroupFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InputGroupPayload>;
          };
          findFirst: {
            args: Prisma.InputGroupFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InputGroupPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.InputGroupFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InputGroupPayload>;
          };
          findMany: {
            args: Prisma.InputGroupFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InputGroupPayload>[];
          };
          create: {
            args: Prisma.InputGroupCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InputGroupPayload>;
          };
          createMany: {
            args: Prisma.InputGroupCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.InputGroupCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InputGroupPayload>[];
          };
          delete: {
            args: Prisma.InputGroupDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InputGroupPayload>;
          };
          update: {
            args: Prisma.InputGroupUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InputGroupPayload>;
          };
          deleteMany: {
            args: Prisma.InputGroupDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.InputGroupUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.InputGroupUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InputGroupPayload>[];
          };
          upsert: {
            args: Prisma.InputGroupUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$InputGroupPayload>;
          };
          aggregate: {
            args: Prisma.InputGroupAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateInputGroup>;
          };
          groupBy: {
            args: Prisma.InputGroupGroupByArgs<ExtArgs>;
            result: $Utils.Optional<InputGroupGroupByOutputType>[];
          };
          count: {
            args: Prisma.InputGroupCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<InputGroupCountAggregateOutputType>
              | number;
          };
        };
      };
      Solution: {
        payload: Prisma.$SolutionPayload<ExtArgs>;
        fields: Prisma.SolutionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SolutionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SolutionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SolutionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SolutionPayload>;
          };
          findFirst: {
            args: Prisma.SolutionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SolutionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SolutionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SolutionPayload>;
          };
          findMany: {
            args: Prisma.SolutionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SolutionPayload>[];
          };
          create: {
            args: Prisma.SolutionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SolutionPayload>;
          };
          createMany: {
            args: Prisma.SolutionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SolutionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SolutionPayload>[];
          };
          delete: {
            args: Prisma.SolutionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SolutionPayload>;
          };
          update: {
            args: Prisma.SolutionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SolutionPayload>;
          };
          deleteMany: {
            args: Prisma.SolutionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SolutionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SolutionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SolutionPayload>[];
          };
          upsert: {
            args: Prisma.SolutionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SolutionPayload>;
          };
          aggregate: {
            args: Prisma.SolutionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSolution>;
          };
          groupBy: {
            args: Prisma.SolutionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SolutionGroupByOutputType>[];
          };
          count: {
            args: Prisma.SolutionCountArgs<ExtArgs>;
            result: $Utils.Optional<SolutionCountAggregateOutputType> | number;
          };
        };
      };
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>;
        fields: Prisma.TaskFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>;
          };
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>;
          };
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[];
          };
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>;
          };
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[];
          };
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>;
          };
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>;
          };
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[];
          };
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>;
          };
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTask>;
          };
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TaskGroupByOutputType>[];
          };
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>;
            result: $Utils.Optional<TaskCountAggregateOutputType> | number;
          };
        };
      };
      Requirement: {
        payload: Prisma.$RequirementPayload<ExtArgs>;
        fields: Prisma.RequirementFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.RequirementFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.RequirementFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>;
          };
          findFirst: {
            args: Prisma.RequirementFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.RequirementFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>;
          };
          findMany: {
            args: Prisma.RequirementFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>[];
          };
          create: {
            args: Prisma.RequirementCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>;
          };
          createMany: {
            args: Prisma.RequirementCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.RequirementCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>[];
          };
          delete: {
            args: Prisma.RequirementDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>;
          };
          update: {
            args: Prisma.RequirementUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>;
          };
          deleteMany: {
            args: Prisma.RequirementDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.RequirementUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.RequirementUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>[];
          };
          upsert: {
            args: Prisma.RequirementUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>;
          };
          aggregate: {
            args: Prisma.RequirementAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRequirement>;
          };
          groupBy: {
            args: Prisma.RequirementGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RequirementGroupByOutputType>[];
          };
          count: {
            args: Prisma.RequirementCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<RequirementCountAggregateOutputType>
              | number;
          };
        };
      };
      FRDDocument: {
        payload: Prisma.$FRDDocumentPayload<ExtArgs>;
        fields: Prisma.FRDDocumentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FRDDocumentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FRDDocumentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FRDDocumentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FRDDocumentPayload>;
          };
          findFirst: {
            args: Prisma.FRDDocumentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FRDDocumentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FRDDocumentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FRDDocumentPayload>;
          };
          findMany: {
            args: Prisma.FRDDocumentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FRDDocumentPayload>[];
          };
          create: {
            args: Prisma.FRDDocumentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FRDDocumentPayload>;
          };
          createMany: {
            args: Prisma.FRDDocumentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.FRDDocumentCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FRDDocumentPayload>[];
          };
          delete: {
            args: Prisma.FRDDocumentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FRDDocumentPayload>;
          };
          update: {
            args: Prisma.FRDDocumentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FRDDocumentPayload>;
          };
          deleteMany: {
            args: Prisma.FRDDocumentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FRDDocumentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.FRDDocumentUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FRDDocumentPayload>[];
          };
          upsert: {
            args: Prisma.FRDDocumentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FRDDocumentPayload>;
          };
          aggregate: {
            args: Prisma.FRDDocumentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFRDDocument>;
          };
          groupBy: {
            args: Prisma.FRDDocumentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FRDDocumentGroupByOutputType>[];
          };
          count: {
            args: Prisma.FRDDocumentCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<FRDDocumentCountAggregateOutputType>
              | number;
          };
        };
      };
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>;
        fields: Prisma.AuditLogFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
          };
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
          };
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
          };
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAuditLog>;
          };
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AuditLogGroupByOutputType>[];
          };
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>;
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number;
          };
        };
      };
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>;
        fields: Prisma.NotificationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[];
          };
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[];
          };
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[];
          };
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNotification>;
          };
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NotificationGroupByOutputType>[];
          };
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<NotificationCountAggregateOutputType>
              | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    'define',
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal';
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null;
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    user?: UserOmit;
    input?: InputOmit;
    comment?: CommentOmit;
    vote?: VoteOmit;
    inputGroup?: InputGroupOmit;
    solution?: SolutionOmit;
    task?: TaskOmit;
    requirement?: RequirementOmit;
    fRDDocument?: FRDDocumentOmit;
    auditLog?: AuditLogOmit;
    notification?: NotificationOmit;
  };

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error';
  export type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
  };

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> =
    T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy';

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>
  ): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<
    Prisma.DefaultPrismaClient,
    runtime.ITXClientDenyList
  >;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    inputs: number;
    solutions: number;
    comments: number;
    votes: number;
    requirements: number;
    frdDocuments: number;
    approvedFRDs: number;
    auditLogs: number;
    notifications: number;
    inputGroups: number;
    tasks: number;
  };

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    inputs?: boolean | UserCountOutputTypeCountInputsArgs;
    solutions?: boolean | UserCountOutputTypeCountSolutionsArgs;
    comments?: boolean | UserCountOutputTypeCountCommentsArgs;
    votes?: boolean | UserCountOutputTypeCountVotesArgs;
    requirements?: boolean | UserCountOutputTypeCountRequirementsArgs;
    frdDocuments?: boolean | UserCountOutputTypeCountFrdDocumentsArgs;
    approvedFRDs?: boolean | UserCountOutputTypeCountApprovedFRDsArgs;
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs;
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs;
    inputGroups?: boolean | UserCountOutputTypeCountInputGroupsArgs;
    tasks?: boolean | UserCountOutputTypeCountTasksArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInputsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: InputWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSolutionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SolutionWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CommentWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVotesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: VoteWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRequirementsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RequirementWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFrdDocumentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FRDDocumentWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedFRDsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FRDDocumentWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AuditLogWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInputGroupsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: InputGroupWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TaskWhereInput;
  };

  /**
   * Count Type InputCountOutputType
   */

  export type InputCountOutputType = {
    solutions: number;
    comments: number;
    votes: number;
    groups: number;
  };

  export type InputCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    solutions?: boolean | InputCountOutputTypeCountSolutionsArgs;
    comments?: boolean | InputCountOutputTypeCountCommentsArgs;
    votes?: boolean | InputCountOutputTypeCountVotesArgs;
    groups?: boolean | InputCountOutputTypeCountGroupsArgs;
  };

  // Custom InputTypes
  /**
   * InputCountOutputType without action
   */
  export type InputCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InputCountOutputType
     */
    select?: InputCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * InputCountOutputType without action
   */
  export type InputCountOutputTypeCountSolutionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SolutionWhereInput;
  };

  /**
   * InputCountOutputType without action
   */
  export type InputCountOutputTypeCountCommentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CommentWhereInput;
  };

  /**
   * InputCountOutputType without action
   */
  export type InputCountOutputTypeCountVotesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: VoteWhereInput;
  };

  /**
   * InputCountOutputType without action
   */
  export type InputCountOutputTypeCountGroupsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: InputGroupWhereInput;
  };

  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    replies: number;
  };

  export type CommentCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs;
  };

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CommentWhereInput;
  };

  /**
   * Count Type InputGroupCountOutputType
   */

  export type InputGroupCountOutputType = {
    inputs: number;
  };

  export type InputGroupCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    inputs?: boolean | InputGroupCountOutputTypeCountInputsArgs;
  };

  // Custom InputTypes
  /**
   * InputGroupCountOutputType without action
   */
  export type InputGroupCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InputGroupCountOutputType
     */
    select?: InputGroupCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * InputGroupCountOutputType without action
   */
  export type InputGroupCountOutputTypeCountInputsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: InputWhereInput;
  };

  /**
   * Count Type SolutionCountOutputType
   */

  export type SolutionCountOutputType = {
    inputs: number;
    tasks: number;
    comments: number;
    votes: number;
    requirements: number;
    frdDocuments: number;
  };

  export type SolutionCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    inputs?: boolean | SolutionCountOutputTypeCountInputsArgs;
    tasks?: boolean | SolutionCountOutputTypeCountTasksArgs;
    comments?: boolean | SolutionCountOutputTypeCountCommentsArgs;
    votes?: boolean | SolutionCountOutputTypeCountVotesArgs;
    requirements?: boolean | SolutionCountOutputTypeCountRequirementsArgs;
    frdDocuments?: boolean | SolutionCountOutputTypeCountFrdDocumentsArgs;
  };

  // Custom InputTypes
  /**
   * SolutionCountOutputType without action
   */
  export type SolutionCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SolutionCountOutputType
     */
    select?: SolutionCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * SolutionCountOutputType without action
   */
  export type SolutionCountOutputTypeCountInputsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: InputWhereInput;
  };

  /**
   * SolutionCountOutputType without action
   */
  export type SolutionCountOutputTypeCountTasksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TaskWhereInput;
  };

  /**
   * SolutionCountOutputType without action
   */
  export type SolutionCountOutputTypeCountCommentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CommentWhereInput;
  };

  /**
   * SolutionCountOutputType without action
   */
  export type SolutionCountOutputTypeCountVotesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: VoteWhereInput;
  };

  /**
   * SolutionCountOutputType without action
   */
  export type SolutionCountOutputTypeCountRequirementsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RequirementWhereInput;
  };

  /**
   * SolutionCountOutputType without action
   */
  export type SolutionCountOutputTypeCountFrdDocumentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FRDDocumentWhereInput;
  };

  /**
   * Count Type RequirementCountOutputType
   */

  export type RequirementCountOutputType = {
    comments: number;
  };

  export type RequirementCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    comments?: boolean | RequirementCountOutputTypeCountCommentsArgs;
  };

  // Custom InputTypes
  /**
   * RequirementCountOutputType without action
   */
  export type RequirementCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RequirementCountOutputType
     */
    select?: RequirementCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * RequirementCountOutputType without action
   */
  export type RequirementCountOutputTypeCountCommentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CommentWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserMinAggregateOutputType = {
    id: string | null;
    email: string | null;
    name: string | null;
    role: $Enums.UserRole | null;
    department: string | null;
    avatar: string | null;
    passwordHash: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type UserMaxAggregateOutputType = {
    id: string | null;
    email: string | null;
    name: string | null;
    role: $Enums.UserRole | null;
    department: string | null;
    avatar: string | null;
    passwordHash: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type UserCountAggregateOutputType = {
    id: number;
    email: number;
    name: number;
    role: number;
    department: number;
    avatar: number;
    passwordHash: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type UserMinAggregateInputType = {
    id?: true;
    email?: true;
    name?: true;
    role?: true;
    department?: true;
    avatar?: true;
    passwordHash?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type UserMaxAggregateInputType = {
    id?: true;
    email?: true;
    name?: true;
    role?: true;
    department?: true;
    avatar?: true;
    passwordHash?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type UserCountAggregateInputType = {
    id?: true;
    email?: true;
    name?: true;
    role?: true;
    department?: true;
    avatar?: true;
    passwordHash?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserWhereInput;
    orderBy?:
      | UserOrderByWithAggregationInput
      | UserOrderByWithAggregationInput[];
    by: UserScalarFieldEnum[] | UserScalarFieldEnum;
    having?: UserScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserCountAggregateInputType | true;
    _min?: UserMinAggregateInputType;
    _max?: UserMaxAggregateInputType;
  };

  export type UserGroupByOutputType = {
    id: string;
    email: string;
    name: string;
    role: $Enums.UserRole;
    department: string | null;
    avatar: string | null;
    passwordHash: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      name?: boolean;
      role?: boolean;
      department?: boolean;
      avatar?: boolean;
      passwordHash?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      inputs?: boolean | User$inputsArgs<ExtArgs>;
      solutions?: boolean | User$solutionsArgs<ExtArgs>;
      comments?: boolean | User$commentsArgs<ExtArgs>;
      votes?: boolean | User$votesArgs<ExtArgs>;
      requirements?: boolean | User$requirementsArgs<ExtArgs>;
      frdDocuments?: boolean | User$frdDocumentsArgs<ExtArgs>;
      approvedFRDs?: boolean | User$approvedFRDsArgs<ExtArgs>;
      auditLogs?: boolean | User$auditLogsArgs<ExtArgs>;
      notifications?: boolean | User$notificationsArgs<ExtArgs>;
      inputGroups?: boolean | User$inputGroupsArgs<ExtArgs>;
      tasks?: boolean | User$tasksArgs<ExtArgs>;
      _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      name?: boolean;
      role?: boolean;
      department?: boolean;
      avatar?: boolean;
      passwordHash?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      name?: boolean;
      role?: boolean;
      department?: boolean;
      avatar?: boolean;
      passwordHash?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectScalar = {
    id?: boolean;
    email?: boolean;
    name?: boolean;
    role?: boolean;
    department?: boolean;
    avatar?: boolean;
    passwordHash?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type UserOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'email'
    | 'name'
    | 'role'
    | 'department'
    | 'avatar'
    | 'passwordHash'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['user']
  >;
  export type UserInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    inputs?: boolean | User$inputsArgs<ExtArgs>;
    solutions?: boolean | User$solutionsArgs<ExtArgs>;
    comments?: boolean | User$commentsArgs<ExtArgs>;
    votes?: boolean | User$votesArgs<ExtArgs>;
    requirements?: boolean | User$requirementsArgs<ExtArgs>;
    frdDocuments?: boolean | User$frdDocumentsArgs<ExtArgs>;
    approvedFRDs?: boolean | User$approvedFRDsArgs<ExtArgs>;
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>;
    notifications?: boolean | User$notificationsArgs<ExtArgs>;
    inputGroups?: boolean | User$inputGroupsArgs<ExtArgs>;
    tasks?: boolean | User$tasksArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type UserIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type UserIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $UserPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'User';
    objects: {
      inputs: Prisma.$InputPayload<ExtArgs>[];
      solutions: Prisma.$SolutionPayload<ExtArgs>[];
      comments: Prisma.$CommentPayload<ExtArgs>[];
      votes: Prisma.$VotePayload<ExtArgs>[];
      requirements: Prisma.$RequirementPayload<ExtArgs>[];
      frdDocuments: Prisma.$FRDDocumentPayload<ExtArgs>[];
      approvedFRDs: Prisma.$FRDDocumentPayload<ExtArgs>[];
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[];
      notifications: Prisma.$NotificationPayload<ExtArgs>[];
      inputGroups: Prisma.$InputGroupPayload<ExtArgs>[];
      tasks: Prisma.$TaskPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        email: string;
        name: string;
        role: $Enums.UserRole;
        department: string | null;
        avatar: string | null;
        passwordHash: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['user']
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> =
    $Result.GetResult<Prisma.$UserPayload, S>;

  type UserCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['User'];
      meta: { name: 'User' };
    };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetUserGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    inputs<T extends User$inputsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$inputsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$InputPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    solutions<T extends User$solutionsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$solutionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$SolutionPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    comments<T extends User$commentsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$commentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CommentPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    votes<T extends User$votesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$votesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$VotePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    requirements<T extends User$requirementsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$requirementsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$RequirementPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    frdDocuments<T extends User$frdDocumentsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$frdDocumentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$FRDDocumentPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    approvedFRDs<T extends User$approvedFRDsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$approvedFRDsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$FRDDocumentPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$auditLogsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AuditLogPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$notificationsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$NotificationPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    inputGroups<T extends User$inputGroupsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$inputGroupsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$InputGroupPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    tasks<T extends User$tasksArgs<ExtArgs> = {}>(
      args?: Subset<T, User$tasksArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TaskPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<'User', 'String'>;
    readonly email: FieldRef<'User', 'String'>;
    readonly name: FieldRef<'User', 'String'>;
    readonly role: FieldRef<'User', 'UserRole'>;
    readonly department: FieldRef<'User', 'String'>;
    readonly avatar: FieldRef<'User', 'String'>;
    readonly passwordHash: FieldRef<'User', 'String'>;
    readonly createdAt: FieldRef<'User', 'DateTime'>;
    readonly updatedAt: FieldRef<'User', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User create
   */
  export type UserCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User update
   */
  export type UserUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to delete.
     */
    limit?: number;
  };

  /**
   * User.inputs
   */
  export type User$inputsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null;
    where?: InputWhereInput;
    orderBy?: InputOrderByWithRelationInput | InputOrderByWithRelationInput[];
    cursor?: InputWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: InputScalarFieldEnum | InputScalarFieldEnum[];
  };

  /**
   * User.solutions
   */
  export type User$solutionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null;
    where?: SolutionWhereInput;
    orderBy?:
      | SolutionOrderByWithRelationInput
      | SolutionOrderByWithRelationInput[];
    cursor?: SolutionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SolutionScalarFieldEnum | SolutionScalarFieldEnum[];
  };

  /**
   * User.comments
   */
  export type User$commentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    where?: CommentWhereInput;
    orderBy?:
      | CommentOrderByWithRelationInput
      | CommentOrderByWithRelationInput[];
    cursor?: CommentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[];
  };

  /**
   * User.votes
   */
  export type User$votesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null;
    where?: VoteWhereInput;
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[];
    cursor?: VoteWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[];
  };

  /**
   * User.requirements
   */
  export type User$requirementsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null;
    where?: RequirementWhereInput;
    orderBy?:
      | RequirementOrderByWithRelationInput
      | RequirementOrderByWithRelationInput[];
    cursor?: RequirementWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[];
  };

  /**
   * User.frdDocuments
   */
  export type User$frdDocumentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null;
    where?: FRDDocumentWhereInput;
    orderBy?:
      | FRDDocumentOrderByWithRelationInput
      | FRDDocumentOrderByWithRelationInput[];
    cursor?: FRDDocumentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FRDDocumentScalarFieldEnum | FRDDocumentScalarFieldEnum[];
  };

  /**
   * User.approvedFRDs
   */
  export type User$approvedFRDsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null;
    where?: FRDDocumentWhereInput;
    orderBy?:
      | FRDDocumentOrderByWithRelationInput
      | FRDDocumentOrderByWithRelationInput[];
    cursor?: FRDDocumentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FRDDocumentScalarFieldEnum | FRDDocumentScalarFieldEnum[];
  };

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    where?: AuditLogWhereInput;
    orderBy?:
      | AuditLogOrderByWithRelationInput
      | AuditLogOrderByWithRelationInput[];
    cursor?: AuditLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * User.notifications
   */
  export type User$notificationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    where?: NotificationWhereInput;
    orderBy?:
      | NotificationOrderByWithRelationInput
      | NotificationOrderByWithRelationInput[];
    cursor?: NotificationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * User.inputGroups
   */
  export type User$inputGroupsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null;
    where?: InputGroupWhereInput;
    orderBy?:
      | InputGroupOrderByWithRelationInput
      | InputGroupOrderByWithRelationInput[];
    cursor?: InputGroupWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: InputGroupScalarFieldEnum | InputGroupScalarFieldEnum[];
  };

  /**
   * User.tasks
   */
  export type User$tasksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    where?: TaskWhereInput;
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[];
    cursor?: TaskWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
  };

  /**
   * Model Input
   */

  export type AggregateInput = {
    _count: InputCountAggregateOutputType | null;
    _min: InputMinAggregateOutputType | null;
    _max: InputMaxAggregateOutputType | null;
  };

  export type InputMinAggregateOutputType = {
    id: string | null;
    title: string | null;
    description: string | null;
    type: $Enums.InputType | null;
    status: $Enums.InputStatus | null;
    createdBy: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    department: string | null;
    issueType: $Enums.IssueType | null;
    rootCause: string | null;
    priority: $Enums.Priority | null;
    aiProcessed: boolean | null;
  };

  export type InputMaxAggregateOutputType = {
    id: string | null;
    title: string | null;
    description: string | null;
    type: $Enums.InputType | null;
    status: $Enums.InputStatus | null;
    createdBy: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    department: string | null;
    issueType: $Enums.IssueType | null;
    rootCause: string | null;
    priority: $Enums.Priority | null;
    aiProcessed: boolean | null;
  };

  export type InputCountAggregateOutputType = {
    id: number;
    title: number;
    description: number;
    type: number;
    status: number;
    createdBy: number;
    createdAt: number;
    updatedAt: number;
    department: number;
    issueType: number;
    rootCause: number;
    priority: number;
    aiProcessed: number;
    aiTags: number;
    aiSuggestions: number;
    _all: number;
  };

  export type InputMinAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    type?: true;
    status?: true;
    createdBy?: true;
    createdAt?: true;
    updatedAt?: true;
    department?: true;
    issueType?: true;
    rootCause?: true;
    priority?: true;
    aiProcessed?: true;
  };

  export type InputMaxAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    type?: true;
    status?: true;
    createdBy?: true;
    createdAt?: true;
    updatedAt?: true;
    department?: true;
    issueType?: true;
    rootCause?: true;
    priority?: true;
    aiProcessed?: true;
  };

  export type InputCountAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    type?: true;
    status?: true;
    createdBy?: true;
    createdAt?: true;
    updatedAt?: true;
    department?: true;
    issueType?: true;
    rootCause?: true;
    priority?: true;
    aiProcessed?: true;
    aiTags?: true;
    aiSuggestions?: true;
    _all?: true;
  };

  export type InputAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Input to aggregate.
     */
    where?: InputWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Inputs to fetch.
     */
    orderBy?: InputOrderByWithRelationInput | InputOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: InputWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Inputs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Inputs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Inputs
     **/
    _count?: true | InputCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: InputMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: InputMaxAggregateInputType;
  };

  export type GetInputAggregateType<T extends InputAggregateArgs> = {
    [P in keyof T & keyof AggregateInput]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInput[P]>
      : GetScalarType<T[P], AggregateInput[P]>;
  };

  export type InputGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: InputWhereInput;
    orderBy?:
      | InputOrderByWithAggregationInput
      | InputOrderByWithAggregationInput[];
    by: InputScalarFieldEnum[] | InputScalarFieldEnum;
    having?: InputScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: InputCountAggregateInputType | true;
    _min?: InputMinAggregateInputType;
    _max?: InputMaxAggregateInputType;
  };

  export type InputGroupByOutputType = {
    id: string;
    title: string;
    description: string;
    type: $Enums.InputType;
    status: $Enums.InputStatus;
    createdBy: string;
    createdAt: Date;
    updatedAt: Date;
    department: string | null;
    issueType: $Enums.IssueType | null;
    rootCause: string | null;
    priority: $Enums.Priority;
    aiProcessed: boolean;
    aiTags: JsonValue | null;
    aiSuggestions: JsonValue | null;
    _count: InputCountAggregateOutputType | null;
    _min: InputMinAggregateOutputType | null;
    _max: InputMaxAggregateOutputType | null;
  };

  type GetInputGroupByPayload<T extends InputGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<InputGroupByOutputType, T['by']> & {
          [P in keyof T & keyof InputGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InputGroupByOutputType[P]>
            : GetScalarType<T[P], InputGroupByOutputType[P]>;
        }
      >
    >;

  export type InputSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      type?: boolean;
      status?: boolean;
      createdBy?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      department?: boolean;
      issueType?: boolean;
      rootCause?: boolean;
      priority?: boolean;
      aiProcessed?: boolean;
      aiTags?: boolean;
      aiSuggestions?: boolean;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
      solutions?: boolean | Input$solutionsArgs<ExtArgs>;
      comments?: boolean | Input$commentsArgs<ExtArgs>;
      votes?: boolean | Input$votesArgs<ExtArgs>;
      groups?: boolean | Input$groupsArgs<ExtArgs>;
      _count?: boolean | InputCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['input']
  >;

  export type InputSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      type?: boolean;
      status?: boolean;
      createdBy?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      department?: boolean;
      issueType?: boolean;
      rootCause?: boolean;
      priority?: boolean;
      aiProcessed?: boolean;
      aiTags?: boolean;
      aiSuggestions?: boolean;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['input']
  >;

  export type InputSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      type?: boolean;
      status?: boolean;
      createdBy?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      department?: boolean;
      issueType?: boolean;
      rootCause?: boolean;
      priority?: boolean;
      aiProcessed?: boolean;
      aiTags?: boolean;
      aiSuggestions?: boolean;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['input']
  >;

  export type InputSelectScalar = {
    id?: boolean;
    title?: boolean;
    description?: boolean;
    type?: boolean;
    status?: boolean;
    createdBy?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    department?: boolean;
    issueType?: boolean;
    rootCause?: boolean;
    priority?: boolean;
    aiProcessed?: boolean;
    aiTags?: boolean;
    aiSuggestions?: boolean;
  };

  export type InputOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'title'
    | 'description'
    | 'type'
    | 'status'
    | 'createdBy'
    | 'createdAt'
    | 'updatedAt'
    | 'department'
    | 'issueType'
    | 'rootCause'
    | 'priority'
    | 'aiProcessed'
    | 'aiTags'
    | 'aiSuggestions',
    ExtArgs['result']['input']
  >;
  export type InputInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    creator?: boolean | UserDefaultArgs<ExtArgs>;
    solutions?: boolean | Input$solutionsArgs<ExtArgs>;
    comments?: boolean | Input$commentsArgs<ExtArgs>;
    votes?: boolean | Input$votesArgs<ExtArgs>;
    groups?: boolean | Input$groupsArgs<ExtArgs>;
    _count?: boolean | InputCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type InputIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    creator?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type InputIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    creator?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $InputPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Input';
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>;
      solutions: Prisma.$SolutionPayload<ExtArgs>[];
      comments: Prisma.$CommentPayload<ExtArgs>[];
      votes: Prisma.$VotePayload<ExtArgs>[];
      groups: Prisma.$InputGroupPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        title: string;
        description: string;
        type: $Enums.InputType;
        status: $Enums.InputStatus;
        createdBy: string;
        createdAt: Date;
        updatedAt: Date;
        department: string | null;
        issueType: $Enums.IssueType | null;
        rootCause: string | null;
        priority: $Enums.Priority;
        aiProcessed: boolean;
        aiTags: Prisma.JsonValue | null;
        aiSuggestions: Prisma.JsonValue | null;
      },
      ExtArgs['result']['input']
    >;
    composites: {};
  };

  type InputGetPayload<
    S extends boolean | null | undefined | InputDefaultArgs,
  > = $Result.GetResult<Prisma.$InputPayload, S>;

  type InputCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<InputFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: InputCountAggregateInputType | true;
  };

  export interface InputDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Input'];
      meta: { name: 'Input' };
    };
    /**
     * Find zero or one Input that matches the filter.
     * @param {InputFindUniqueArgs} args - Arguments to find a Input
     * @example
     * // Get one Input
     * const input = await prisma.input.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InputFindUniqueArgs>(
      args: SelectSubset<T, InputFindUniqueArgs<ExtArgs>>
    ): Prisma__InputClient<
      $Result.GetResult<
        Prisma.$InputPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Input that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InputFindUniqueOrThrowArgs} args - Arguments to find a Input
     * @example
     * // Get one Input
     * const input = await prisma.input.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InputFindUniqueOrThrowArgs>(
      args: SelectSubset<T, InputFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InputClient<
      $Result.GetResult<
        Prisma.$InputPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Input that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputFindFirstArgs} args - Arguments to find a Input
     * @example
     * // Get one Input
     * const input = await prisma.input.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InputFindFirstArgs>(
      args?: SelectSubset<T, InputFindFirstArgs<ExtArgs>>
    ): Prisma__InputClient<
      $Result.GetResult<
        Prisma.$InputPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Input that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputFindFirstOrThrowArgs} args - Arguments to find a Input
     * @example
     * // Get one Input
     * const input = await prisma.input.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InputFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InputFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InputClient<
      $Result.GetResult<
        Prisma.$InputPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Inputs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inputs
     * const inputs = await prisma.input.findMany()
     *
     * // Get first 10 Inputs
     * const inputs = await prisma.input.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const inputWithIdOnly = await prisma.input.findMany({ select: { id: true } })
     *
     */
    findMany<T extends InputFindManyArgs>(
      args?: SelectSubset<T, InputFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$InputPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Input.
     * @param {InputCreateArgs} args - Arguments to create a Input.
     * @example
     * // Create one Input
     * const Input = await prisma.input.create({
     *   data: {
     *     // ... data to create a Input
     *   }
     * })
     *
     */
    create<T extends InputCreateArgs>(
      args: SelectSubset<T, InputCreateArgs<ExtArgs>>
    ): Prisma__InputClient<
      $Result.GetResult<
        Prisma.$InputPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Inputs.
     * @param {InputCreateManyArgs} args - Arguments to create many Inputs.
     * @example
     * // Create many Inputs
     * const input = await prisma.input.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends InputCreateManyArgs>(
      args?: SelectSubset<T, InputCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Inputs and returns the data saved in the database.
     * @param {InputCreateManyAndReturnArgs} args - Arguments to create many Inputs.
     * @example
     * // Create many Inputs
     * const input = await prisma.input.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Inputs and only return the `id`
     * const inputWithIdOnly = await prisma.input.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends InputCreateManyAndReturnArgs>(
      args?: SelectSubset<T, InputCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$InputPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Input.
     * @param {InputDeleteArgs} args - Arguments to delete one Input.
     * @example
     * // Delete one Input
     * const Input = await prisma.input.delete({
     *   where: {
     *     // ... filter to delete one Input
     *   }
     * })
     *
     */
    delete<T extends InputDeleteArgs>(
      args: SelectSubset<T, InputDeleteArgs<ExtArgs>>
    ): Prisma__InputClient<
      $Result.GetResult<
        Prisma.$InputPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Input.
     * @param {InputUpdateArgs} args - Arguments to update one Input.
     * @example
     * // Update one Input
     * const input = await prisma.input.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends InputUpdateArgs>(
      args: SelectSubset<T, InputUpdateArgs<ExtArgs>>
    ): Prisma__InputClient<
      $Result.GetResult<
        Prisma.$InputPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Inputs.
     * @param {InputDeleteManyArgs} args - Arguments to filter Inputs to delete.
     * @example
     * // Delete a few Inputs
     * const { count } = await prisma.input.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends InputDeleteManyArgs>(
      args?: SelectSubset<T, InputDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Inputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inputs
     * const input = await prisma.input.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends InputUpdateManyArgs>(
      args: SelectSubset<T, InputUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Inputs and returns the data updated in the database.
     * @param {InputUpdateManyAndReturnArgs} args - Arguments to update many Inputs.
     * @example
     * // Update many Inputs
     * const input = await prisma.input.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Inputs and only return the `id`
     * const inputWithIdOnly = await prisma.input.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends InputUpdateManyAndReturnArgs>(
      args: SelectSubset<T, InputUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$InputPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Input.
     * @param {InputUpsertArgs} args - Arguments to update or create a Input.
     * @example
     * // Update or create a Input
     * const input = await prisma.input.upsert({
     *   create: {
     *     // ... data to create a Input
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Input we want to update
     *   }
     * })
     */
    upsert<T extends InputUpsertArgs>(
      args: SelectSubset<T, InputUpsertArgs<ExtArgs>>
    ): Prisma__InputClient<
      $Result.GetResult<
        Prisma.$InputPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Inputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputCountArgs} args - Arguments to filter Inputs to count.
     * @example
     * // Count the number of Inputs
     * const count = await prisma.input.count({
     *   where: {
     *     // ... the filter for the Inputs we want to count
     *   }
     * })
     **/
    count<T extends InputCountArgs>(
      args?: Subset<T, InputCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InputCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Input.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends InputAggregateArgs>(
      args: Subset<T, InputAggregateArgs>
    ): Prisma.PrismaPromise<GetInputAggregateType<T>>;

    /**
     * Group by Input.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends InputGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InputGroupByArgs['orderBy'] }
        : { orderBy?: InputGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, InputGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetInputGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Input model
     */
    readonly fields: InputFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Input.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InputClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    solutions<T extends Input$solutionsArgs<ExtArgs> = {}>(
      args?: Subset<T, Input$solutionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$SolutionPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    comments<T extends Input$commentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Input$commentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CommentPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    votes<T extends Input$votesArgs<ExtArgs> = {}>(
      args?: Subset<T, Input$votesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$VotePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    groups<T extends Input$groupsArgs<ExtArgs> = {}>(
      args?: Subset<T, Input$groupsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$InputGroupPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Input model
   */
  interface InputFieldRefs {
    readonly id: FieldRef<'Input', 'String'>;
    readonly title: FieldRef<'Input', 'String'>;
    readonly description: FieldRef<'Input', 'String'>;
    readonly type: FieldRef<'Input', 'InputType'>;
    readonly status: FieldRef<'Input', 'InputStatus'>;
    readonly createdBy: FieldRef<'Input', 'String'>;
    readonly createdAt: FieldRef<'Input', 'DateTime'>;
    readonly updatedAt: FieldRef<'Input', 'DateTime'>;
    readonly department: FieldRef<'Input', 'String'>;
    readonly issueType: FieldRef<'Input', 'IssueType'>;
    readonly rootCause: FieldRef<'Input', 'String'>;
    readonly priority: FieldRef<'Input', 'Priority'>;
    readonly aiProcessed: FieldRef<'Input', 'Boolean'>;
    readonly aiTags: FieldRef<'Input', 'Json'>;
    readonly aiSuggestions: FieldRef<'Input', 'Json'>;
  }

  // Custom InputTypes
  /**
   * Input findUnique
   */
  export type InputFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null;
    /**
     * Filter, which Input to fetch.
     */
    where: InputWhereUniqueInput;
  };

  /**
   * Input findUniqueOrThrow
   */
  export type InputFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null;
    /**
     * Filter, which Input to fetch.
     */
    where: InputWhereUniqueInput;
  };

  /**
   * Input findFirst
   */
  export type InputFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null;
    /**
     * Filter, which Input to fetch.
     */
    where?: InputWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Inputs to fetch.
     */
    orderBy?: InputOrderByWithRelationInput | InputOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Inputs.
     */
    cursor?: InputWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Inputs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Inputs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Inputs.
     */
    distinct?: InputScalarFieldEnum | InputScalarFieldEnum[];
  };

  /**
   * Input findFirstOrThrow
   */
  export type InputFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null;
    /**
     * Filter, which Input to fetch.
     */
    where?: InputWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Inputs to fetch.
     */
    orderBy?: InputOrderByWithRelationInput | InputOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Inputs.
     */
    cursor?: InputWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Inputs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Inputs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Inputs.
     */
    distinct?: InputScalarFieldEnum | InputScalarFieldEnum[];
  };

  /**
   * Input findMany
   */
  export type InputFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null;
    /**
     * Filter, which Inputs to fetch.
     */
    where?: InputWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Inputs to fetch.
     */
    orderBy?: InputOrderByWithRelationInput | InputOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Inputs.
     */
    cursor?: InputWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Inputs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Inputs.
     */
    skip?: number;
    distinct?: InputScalarFieldEnum | InputScalarFieldEnum[];
  };

  /**
   * Input create
   */
  export type InputCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null;
    /**
     * The data needed to create a Input.
     */
    data: XOR<InputCreateInput, InputUncheckedCreateInput>;
  };

  /**
   * Input createMany
   */
  export type InputCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Inputs.
     */
    data: InputCreateManyInput | InputCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Input createManyAndReturn
   */
  export type InputCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null;
    /**
     * The data used to create many Inputs.
     */
    data: InputCreateManyInput | InputCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Input update
   */
  export type InputUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null;
    /**
     * The data needed to update a Input.
     */
    data: XOR<InputUpdateInput, InputUncheckedUpdateInput>;
    /**
     * Choose, which Input to update.
     */
    where: InputWhereUniqueInput;
  };

  /**
   * Input updateMany
   */
  export type InputUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Inputs.
     */
    data: XOR<InputUpdateManyMutationInput, InputUncheckedUpdateManyInput>;
    /**
     * Filter which Inputs to update
     */
    where?: InputWhereInput;
    /**
     * Limit how many Inputs to update.
     */
    limit?: number;
  };

  /**
   * Input updateManyAndReturn
   */
  export type InputUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null;
    /**
     * The data used to update Inputs.
     */
    data: XOR<InputUpdateManyMutationInput, InputUncheckedUpdateManyInput>;
    /**
     * Filter which Inputs to update
     */
    where?: InputWhereInput;
    /**
     * Limit how many Inputs to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Input upsert
   */
  export type InputUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null;
    /**
     * The filter to search for the Input to update in case it exists.
     */
    where: InputWhereUniqueInput;
    /**
     * In case the Input found by the `where` argument doesn't exist, create a new Input with this data.
     */
    create: XOR<InputCreateInput, InputUncheckedCreateInput>;
    /**
     * In case the Input was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InputUpdateInput, InputUncheckedUpdateInput>;
  };

  /**
   * Input delete
   */
  export type InputDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null;
    /**
     * Filter which Input to delete.
     */
    where: InputWhereUniqueInput;
  };

  /**
   * Input deleteMany
   */
  export type InputDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Inputs to delete
     */
    where?: InputWhereInput;
    /**
     * Limit how many Inputs to delete.
     */
    limit?: number;
  };

  /**
   * Input.solutions
   */
  export type Input$solutionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null;
    where?: SolutionWhereInput;
    orderBy?:
      | SolutionOrderByWithRelationInput
      | SolutionOrderByWithRelationInput[];
    cursor?: SolutionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SolutionScalarFieldEnum | SolutionScalarFieldEnum[];
  };

  /**
   * Input.comments
   */
  export type Input$commentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    where?: CommentWhereInput;
    orderBy?:
      | CommentOrderByWithRelationInput
      | CommentOrderByWithRelationInput[];
    cursor?: CommentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[];
  };

  /**
   * Input.votes
   */
  export type Input$votesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null;
    where?: VoteWhereInput;
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[];
    cursor?: VoteWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[];
  };

  /**
   * Input.groups
   */
  export type Input$groupsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null;
    where?: InputGroupWhereInput;
    orderBy?:
      | InputGroupOrderByWithRelationInput
      | InputGroupOrderByWithRelationInput[];
    cursor?: InputGroupWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: InputGroupScalarFieldEnum | InputGroupScalarFieldEnum[];
  };

  /**
   * Input without action
   */
  export type InputDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null;
  };

  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null;
    _min: CommentMinAggregateOutputType | null;
    _max: CommentMaxAggregateOutputType | null;
  };

  export type CommentMinAggregateOutputType = {
    id: string | null;
    content: string | null;
    authorId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    inputId: string | null;
    solutionId: string | null;
    requirementId: string | null;
    parentId: string | null;
  };

  export type CommentMaxAggregateOutputType = {
    id: string | null;
    content: string | null;
    authorId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    inputId: string | null;
    solutionId: string | null;
    requirementId: string | null;
    parentId: string | null;
  };

  export type CommentCountAggregateOutputType = {
    id: number;
    content: number;
    authorId: number;
    createdAt: number;
    updatedAt: number;
    inputId: number;
    solutionId: number;
    requirementId: number;
    parentId: number;
    _all: number;
  };

  export type CommentMinAggregateInputType = {
    id?: true;
    content?: true;
    authorId?: true;
    createdAt?: true;
    updatedAt?: true;
    inputId?: true;
    solutionId?: true;
    requirementId?: true;
    parentId?: true;
  };

  export type CommentMaxAggregateInputType = {
    id?: true;
    content?: true;
    authorId?: true;
    createdAt?: true;
    updatedAt?: true;
    inputId?: true;
    solutionId?: true;
    requirementId?: true;
    parentId?: true;
  };

  export type CommentCountAggregateInputType = {
    id?: true;
    content?: true;
    authorId?: true;
    createdAt?: true;
    updatedAt?: true;
    inputId?: true;
    solutionId?: true;
    requirementId?: true;
    parentId?: true;
    _all?: true;
  };

  export type CommentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Comments to fetch.
     */
    orderBy?:
      | CommentOrderByWithRelationInput
      | CommentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Comments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Comments
     **/
    _count?: true | CommentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CommentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CommentMaxAggregateInputType;
  };

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
    [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>;
  };

  export type CommentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CommentWhereInput;
    orderBy?:
      | CommentOrderByWithAggregationInput
      | CommentOrderByWithAggregationInput[];
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum;
    having?: CommentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CommentCountAggregateInputType | true;
    _min?: CommentMinAggregateInputType;
    _max?: CommentMaxAggregateInputType;
  };

  export type CommentGroupByOutputType = {
    id: string;
    content: string;
    authorId: string;
    createdAt: Date;
    updatedAt: Date;
    inputId: string | null;
    solutionId: string | null;
    requirementId: string | null;
    parentId: string | null;
    _count: CommentCountAggregateOutputType | null;
    _min: CommentMinAggregateOutputType | null;
    _max: CommentMaxAggregateOutputType | null;
  };

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CommentGroupByOutputType, T['by']> & {
          [P in keyof T & keyof CommentGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>;
        }
      >
    >;

  export type CommentSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      content?: boolean;
      authorId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      inputId?: boolean;
      solutionId?: boolean;
      requirementId?: boolean;
      parentId?: boolean;
      replies?: boolean | Comment$repliesArgs<ExtArgs>;
      author?: boolean | UserDefaultArgs<ExtArgs>;
      input?: boolean | Comment$inputArgs<ExtArgs>;
      solution?: boolean | Comment$solutionArgs<ExtArgs>;
      requirement?: boolean | Comment$requirementArgs<ExtArgs>;
      parent?: boolean | Comment$parentArgs<ExtArgs>;
      _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['comment']
  >;

  export type CommentSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      content?: boolean;
      authorId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      inputId?: boolean;
      solutionId?: boolean;
      requirementId?: boolean;
      parentId?: boolean;
      author?: boolean | UserDefaultArgs<ExtArgs>;
      input?: boolean | Comment$inputArgs<ExtArgs>;
      solution?: boolean | Comment$solutionArgs<ExtArgs>;
      requirement?: boolean | Comment$requirementArgs<ExtArgs>;
      parent?: boolean | Comment$parentArgs<ExtArgs>;
    },
    ExtArgs['result']['comment']
  >;

  export type CommentSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      content?: boolean;
      authorId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      inputId?: boolean;
      solutionId?: boolean;
      requirementId?: boolean;
      parentId?: boolean;
      author?: boolean | UserDefaultArgs<ExtArgs>;
      input?: boolean | Comment$inputArgs<ExtArgs>;
      solution?: boolean | Comment$solutionArgs<ExtArgs>;
      requirement?: boolean | Comment$requirementArgs<ExtArgs>;
      parent?: boolean | Comment$parentArgs<ExtArgs>;
    },
    ExtArgs['result']['comment']
  >;

  export type CommentSelectScalar = {
    id?: boolean;
    content?: boolean;
    authorId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    inputId?: boolean;
    solutionId?: boolean;
    requirementId?: boolean;
    parentId?: boolean;
  };

  export type CommentOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'content'
    | 'authorId'
    | 'createdAt'
    | 'updatedAt'
    | 'inputId'
    | 'solutionId'
    | 'requirementId'
    | 'parentId',
    ExtArgs['result']['comment']
  >;
  export type CommentInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    replies?: boolean | Comment$repliesArgs<ExtArgs>;
    author?: boolean | UserDefaultArgs<ExtArgs>;
    input?: boolean | Comment$inputArgs<ExtArgs>;
    solution?: boolean | Comment$solutionArgs<ExtArgs>;
    requirement?: boolean | Comment$requirementArgs<ExtArgs>;
    parent?: boolean | Comment$parentArgs<ExtArgs>;
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type CommentIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    author?: boolean | UserDefaultArgs<ExtArgs>;
    input?: boolean | Comment$inputArgs<ExtArgs>;
    solution?: boolean | Comment$solutionArgs<ExtArgs>;
    requirement?: boolean | Comment$requirementArgs<ExtArgs>;
    parent?: boolean | Comment$parentArgs<ExtArgs>;
  };
  export type CommentIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    author?: boolean | UserDefaultArgs<ExtArgs>;
    input?: boolean | Comment$inputArgs<ExtArgs>;
    solution?: boolean | Comment$solutionArgs<ExtArgs>;
    requirement?: boolean | Comment$requirementArgs<ExtArgs>;
    parent?: boolean | Comment$parentArgs<ExtArgs>;
  };

  export type $CommentPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Comment';
    objects: {
      replies: Prisma.$CommentPayload<ExtArgs>[];
      author: Prisma.$UserPayload<ExtArgs>;
      input: Prisma.$InputPayload<ExtArgs> | null;
      solution: Prisma.$SolutionPayload<ExtArgs> | null;
      requirement: Prisma.$RequirementPayload<ExtArgs> | null;
      parent: Prisma.$CommentPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        content: string;
        authorId: string;
        createdAt: Date;
        updatedAt: Date;
        inputId: string | null;
        solutionId: string | null;
        requirementId: string | null;
        parentId: string | null;
      },
      ExtArgs['result']['comment']
    >;
    composites: {};
  };

  type CommentGetPayload<
    S extends boolean | null | undefined | CommentDefaultArgs,
  > = $Result.GetResult<Prisma.$CommentPayload, S>;

  type CommentCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: CommentCountAggregateInputType | true;
  };

  export interface CommentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Comment'];
      meta: { name: 'Comment' };
    };
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(
      args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<
        Prisma.$CommentPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<
        Prisma.$CommentPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(
      args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<
        Prisma.$CommentPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<
        Prisma.$CommentPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     *
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CommentFindManyArgs>(
      args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CommentPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     *
     */
    create<T extends CommentCreateArgs>(
      args: SelectSubset<T, CommentCreateArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<
        Prisma.$CommentPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CommentCreateManyArgs>(
      args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(
      args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CommentPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     *
     */
    delete<T extends CommentDeleteArgs>(
      args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<
        Prisma.$CommentPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CommentUpdateArgs>(
      args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<
        Prisma.$CommentPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CommentDeleteManyArgs>(
      args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CommentUpdateManyArgs>(
      args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(
      args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CommentPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(
      args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<
        Prisma.$CommentPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
     **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CommentAggregateArgs>(
      args: Subset<T, CommentAggregateArgs>
    ): Prisma.PrismaPromise<GetCommentAggregateType<T>>;

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetCommentGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Comment model
     */
    readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(
      args?: Subset<T, Comment$repliesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CommentPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    author<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    input<T extends Comment$inputArgs<ExtArgs> = {}>(
      args?: Subset<T, Comment$inputArgs<ExtArgs>>
    ): Prisma__InputClient<
      $Result.GetResult<
        Prisma.$InputPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    solution<T extends Comment$solutionArgs<ExtArgs> = {}>(
      args?: Subset<T, Comment$solutionArgs<ExtArgs>>
    ): Prisma__SolutionClient<
      $Result.GetResult<
        Prisma.$SolutionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    requirement<T extends Comment$requirementArgs<ExtArgs> = {}>(
      args?: Subset<T, Comment$requirementArgs<ExtArgs>>
    ): Prisma__RequirementClient<
      $Result.GetResult<
        Prisma.$RequirementPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    parent<T extends Comment$parentArgs<ExtArgs> = {}>(
      args?: Subset<T, Comment$parentArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<
        Prisma.$CommentPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<'Comment', 'String'>;
    readonly content: FieldRef<'Comment', 'String'>;
    readonly authorId: FieldRef<'Comment', 'String'>;
    readonly createdAt: FieldRef<'Comment', 'DateTime'>;
    readonly updatedAt: FieldRef<'Comment', 'DateTime'>;
    readonly inputId: FieldRef<'Comment', 'String'>;
    readonly solutionId: FieldRef<'Comment', 'String'>;
    readonly requirementId: FieldRef<'Comment', 'String'>;
    readonly parentId: FieldRef<'Comment', 'String'>;
  }

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput;
  };

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput;
  };

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Comments to fetch.
     */
    orderBy?:
      | CommentOrderByWithRelationInput
      | CommentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Comments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[];
  };

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Comments to fetch.
     */
    orderBy?:
      | CommentOrderByWithRelationInput
      | CommentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Comments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[];
  };

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Comments to fetch.
     */
    orderBy?:
      | CommentOrderByWithRelationInput
      | CommentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Comments.
     */
    skip?: number;
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[];
  };

  /**
   * Comment create
   */
  export type CommentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>;
  };

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Comment update
   */
  export type CommentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>;
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput;
  };

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>;
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput;
    /**
     * Limit how many Comments to update.
     */
    limit?: number;
  };

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>;
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput;
    /**
     * Limit how many Comments to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput;
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>;
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>;
  };

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput;
  };

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput;
    /**
     * Limit how many Comments to delete.
     */
    limit?: number;
  };

  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    where?: CommentWhereInput;
    orderBy?:
      | CommentOrderByWithRelationInput
      | CommentOrderByWithRelationInput[];
    cursor?: CommentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[];
  };

  /**
   * Comment.input
   */
  export type Comment$inputArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null;
    where?: InputWhereInput;
  };

  /**
   * Comment.solution
   */
  export type Comment$solutionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null;
    where?: SolutionWhereInput;
  };

  /**
   * Comment.requirement
   */
  export type Comment$requirementArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null;
    where?: RequirementWhereInput;
  };

  /**
   * Comment.parent
   */
  export type Comment$parentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    where?: CommentWhereInput;
  };

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
  };

  /**
   * Model Vote
   */

  export type AggregateVote = {
    _count: VoteCountAggregateOutputType | null;
    _avg: VoteAvgAggregateOutputType | null;
    _sum: VoteSumAggregateOutputType | null;
    _min: VoteMinAggregateOutputType | null;
    _max: VoteMaxAggregateOutputType | null;
  };

  export type VoteAvgAggregateOutputType = {
    value: number | null;
  };

  export type VoteSumAggregateOutputType = {
    value: number | null;
  };

  export type VoteMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    value: number | null;
    createdAt: Date | null;
    inputId: string | null;
    solutionId: string | null;
  };

  export type VoteMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    value: number | null;
    createdAt: Date | null;
    inputId: string | null;
    solutionId: string | null;
  };

  export type VoteCountAggregateOutputType = {
    id: number;
    userId: number;
    value: number;
    createdAt: number;
    inputId: number;
    solutionId: number;
    _all: number;
  };

  export type VoteAvgAggregateInputType = {
    value?: true;
  };

  export type VoteSumAggregateInputType = {
    value?: true;
  };

  export type VoteMinAggregateInputType = {
    id?: true;
    userId?: true;
    value?: true;
    createdAt?: true;
    inputId?: true;
    solutionId?: true;
  };

  export type VoteMaxAggregateInputType = {
    id?: true;
    userId?: true;
    value?: true;
    createdAt?: true;
    inputId?: true;
    solutionId?: true;
  };

  export type VoteCountAggregateInputType = {
    id?: true;
    userId?: true;
    value?: true;
    createdAt?: true;
    inputId?: true;
    solutionId?: true;
    _all?: true;
  };

  export type VoteAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Vote to aggregate.
     */
    where?: VoteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: VoteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Votes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Votes
     **/
    _count?: true | VoteCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: VoteAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: VoteSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: VoteMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: VoteMaxAggregateInputType;
  };

  export type GetVoteAggregateType<T extends VoteAggregateArgs> = {
    [P in keyof T & keyof AggregateVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVote[P]>
      : GetScalarType<T[P], AggregateVote[P]>;
  };

  export type VoteGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: VoteWhereInput;
    orderBy?:
      | VoteOrderByWithAggregationInput
      | VoteOrderByWithAggregationInput[];
    by: VoteScalarFieldEnum[] | VoteScalarFieldEnum;
    having?: VoteScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: VoteCountAggregateInputType | true;
    _avg?: VoteAvgAggregateInputType;
    _sum?: VoteSumAggregateInputType;
    _min?: VoteMinAggregateInputType;
    _max?: VoteMaxAggregateInputType;
  };

  export type VoteGroupByOutputType = {
    id: string;
    userId: string;
    value: number;
    createdAt: Date;
    inputId: string | null;
    solutionId: string | null;
    _count: VoteCountAggregateOutputType | null;
    _avg: VoteAvgAggregateOutputType | null;
    _sum: VoteSumAggregateOutputType | null;
    _min: VoteMinAggregateOutputType | null;
    _max: VoteMaxAggregateOutputType | null;
  };

  type GetVoteGroupByPayload<T extends VoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoteGroupByOutputType, T['by']> & {
        [P in keyof T & keyof VoteGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], VoteGroupByOutputType[P]>
          : GetScalarType<T[P], VoteGroupByOutputType[P]>;
      }
    >
  >;

  export type VoteSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      value?: boolean;
      createdAt?: boolean;
      inputId?: boolean;
      solutionId?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      input?: boolean | Vote$inputArgs<ExtArgs>;
      solution?: boolean | Vote$solutionArgs<ExtArgs>;
    },
    ExtArgs['result']['vote']
  >;

  export type VoteSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      value?: boolean;
      createdAt?: boolean;
      inputId?: boolean;
      solutionId?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      input?: boolean | Vote$inputArgs<ExtArgs>;
      solution?: boolean | Vote$solutionArgs<ExtArgs>;
    },
    ExtArgs['result']['vote']
  >;

  export type VoteSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      value?: boolean;
      createdAt?: boolean;
      inputId?: boolean;
      solutionId?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      input?: boolean | Vote$inputArgs<ExtArgs>;
      solution?: boolean | Vote$solutionArgs<ExtArgs>;
    },
    ExtArgs['result']['vote']
  >;

  export type VoteSelectScalar = {
    id?: boolean;
    userId?: boolean;
    value?: boolean;
    createdAt?: boolean;
    inputId?: boolean;
    solutionId?: boolean;
  };

  export type VoteOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'userId' | 'value' | 'createdAt' | 'inputId' | 'solutionId',
    ExtArgs['result']['vote']
  >;
  export type VoteInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    input?: boolean | Vote$inputArgs<ExtArgs>;
    solution?: boolean | Vote$solutionArgs<ExtArgs>;
  };
  export type VoteIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    input?: boolean | Vote$inputArgs<ExtArgs>;
    solution?: boolean | Vote$solutionArgs<ExtArgs>;
  };
  export type VoteIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    input?: boolean | Vote$inputArgs<ExtArgs>;
    solution?: boolean | Vote$solutionArgs<ExtArgs>;
  };

  export type $VotePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Vote';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      input: Prisma.$InputPayload<ExtArgs> | null;
      solution: Prisma.$SolutionPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        value: number;
        createdAt: Date;
        inputId: string | null;
        solutionId: string | null;
      },
      ExtArgs['result']['vote']
    >;
    composites: {};
  };

  type VoteGetPayload<S extends boolean | null | undefined | VoteDefaultArgs> =
    $Result.GetResult<Prisma.$VotePayload, S>;

  type VoteCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<VoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: VoteCountAggregateInputType | true;
  };

  export interface VoteDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Vote'];
      meta: { name: 'Vote' };
    };
    /**
     * Find zero or one Vote that matches the filter.
     * @param {VoteFindUniqueArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoteFindUniqueArgs>(
      args: SelectSubset<T, VoteFindUniqueArgs<ExtArgs>>
    ): Prisma__VoteClient<
      $Result.GetResult<
        Prisma.$VotePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Vote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoteFindUniqueOrThrowArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoteFindUniqueOrThrowArgs>(
      args: SelectSubset<T, VoteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VoteClient<
      $Result.GetResult<
        Prisma.$VotePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Vote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindFirstArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoteFindFirstArgs>(
      args?: SelectSubset<T, VoteFindFirstArgs<ExtArgs>>
    ): Prisma__VoteClient<
      $Result.GetResult<
        Prisma.$VotePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Vote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindFirstOrThrowArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VoteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VoteClient<
      $Result.GetResult<
        Prisma.$VotePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Votes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Votes
     * const votes = await prisma.vote.findMany()
     *
     * // Get first 10 Votes
     * const votes = await prisma.vote.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const voteWithIdOnly = await prisma.vote.findMany({ select: { id: true } })
     *
     */
    findMany<T extends VoteFindManyArgs>(
      args?: SelectSubset<T, VoteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VotePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Vote.
     * @param {VoteCreateArgs} args - Arguments to create a Vote.
     * @example
     * // Create one Vote
     * const Vote = await prisma.vote.create({
     *   data: {
     *     // ... data to create a Vote
     *   }
     * })
     *
     */
    create<T extends VoteCreateArgs>(
      args: SelectSubset<T, VoteCreateArgs<ExtArgs>>
    ): Prisma__VoteClient<
      $Result.GetResult<
        Prisma.$VotePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Votes.
     * @param {VoteCreateManyArgs} args - Arguments to create many Votes.
     * @example
     * // Create many Votes
     * const vote = await prisma.vote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends VoteCreateManyArgs>(
      args?: SelectSubset<T, VoteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Votes and returns the data saved in the database.
     * @param {VoteCreateManyAndReturnArgs} args - Arguments to create many Votes.
     * @example
     * // Create many Votes
     * const vote = await prisma.vote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Votes and only return the `id`
     * const voteWithIdOnly = await prisma.vote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends VoteCreateManyAndReturnArgs>(
      args?: SelectSubset<T, VoteCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VotePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Vote.
     * @param {VoteDeleteArgs} args - Arguments to delete one Vote.
     * @example
     * // Delete one Vote
     * const Vote = await prisma.vote.delete({
     *   where: {
     *     // ... filter to delete one Vote
     *   }
     * })
     *
     */
    delete<T extends VoteDeleteArgs>(
      args: SelectSubset<T, VoteDeleteArgs<ExtArgs>>
    ): Prisma__VoteClient<
      $Result.GetResult<
        Prisma.$VotePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Vote.
     * @param {VoteUpdateArgs} args - Arguments to update one Vote.
     * @example
     * // Update one Vote
     * const vote = await prisma.vote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends VoteUpdateArgs>(
      args: SelectSubset<T, VoteUpdateArgs<ExtArgs>>
    ): Prisma__VoteClient<
      $Result.GetResult<
        Prisma.$VotePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Votes.
     * @param {VoteDeleteManyArgs} args - Arguments to filter Votes to delete.
     * @example
     * // Delete a few Votes
     * const { count } = await prisma.vote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends VoteDeleteManyArgs>(
      args?: SelectSubset<T, VoteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Votes
     * const vote = await prisma.vote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends VoteUpdateManyArgs>(
      args: SelectSubset<T, VoteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Votes and returns the data updated in the database.
     * @param {VoteUpdateManyAndReturnArgs} args - Arguments to update many Votes.
     * @example
     * // Update many Votes
     * const vote = await prisma.vote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Votes and only return the `id`
     * const voteWithIdOnly = await prisma.vote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends VoteUpdateManyAndReturnArgs>(
      args: SelectSubset<T, VoteUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VotePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Vote.
     * @param {VoteUpsertArgs} args - Arguments to update or create a Vote.
     * @example
     * // Update or create a Vote
     * const vote = await prisma.vote.upsert({
     *   create: {
     *     // ... data to create a Vote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vote we want to update
     *   }
     * })
     */
    upsert<T extends VoteUpsertArgs>(
      args: SelectSubset<T, VoteUpsertArgs<ExtArgs>>
    ): Prisma__VoteClient<
      $Result.GetResult<
        Prisma.$VotePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteCountArgs} args - Arguments to filter Votes to count.
     * @example
     * // Count the number of Votes
     * const count = await prisma.vote.count({
     *   where: {
     *     // ... the filter for the Votes we want to count
     *   }
     * })
     **/
    count<T extends VoteCountArgs>(
      args?: Subset<T, VoteCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoteCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends VoteAggregateArgs>(
      args: Subset<T, VoteAggregateArgs>
    ): Prisma.PrismaPromise<GetVoteAggregateType<T>>;

    /**
     * Group by Vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends VoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoteGroupByArgs['orderBy'] }
        : { orderBy?: VoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, VoteGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetVoteGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Vote model
     */
    readonly fields: VoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoteClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    input<T extends Vote$inputArgs<ExtArgs> = {}>(
      args?: Subset<T, Vote$inputArgs<ExtArgs>>
    ): Prisma__InputClient<
      $Result.GetResult<
        Prisma.$InputPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    solution<T extends Vote$solutionArgs<ExtArgs> = {}>(
      args?: Subset<T, Vote$solutionArgs<ExtArgs>>
    ): Prisma__SolutionClient<
      $Result.GetResult<
        Prisma.$SolutionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Vote model
   */
  interface VoteFieldRefs {
    readonly id: FieldRef<'Vote', 'String'>;
    readonly userId: FieldRef<'Vote', 'String'>;
    readonly value: FieldRef<'Vote', 'Int'>;
    readonly createdAt: FieldRef<'Vote', 'DateTime'>;
    readonly inputId: FieldRef<'Vote', 'String'>;
    readonly solutionId: FieldRef<'Vote', 'String'>;
  }

  // Custom InputTypes
  /**
   * Vote findUnique
   */
  export type VoteFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null;
    /**
     * Filter, which Vote to fetch.
     */
    where: VoteWhereUniqueInput;
  };

  /**
   * Vote findUniqueOrThrow
   */
  export type VoteFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null;
    /**
     * Filter, which Vote to fetch.
     */
    where: VoteWhereUniqueInput;
  };

  /**
   * Vote findFirst
   */
  export type VoteFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null;
    /**
     * Filter, which Vote to fetch.
     */
    where?: VoteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Votes.
     */
    cursor?: VoteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Votes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Votes.
     */
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[];
  };

  /**
   * Vote findFirstOrThrow
   */
  export type VoteFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null;
    /**
     * Filter, which Vote to fetch.
     */
    where?: VoteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Votes.
     */
    cursor?: VoteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Votes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Votes.
     */
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[];
  };

  /**
   * Vote findMany
   */
  export type VoteFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null;
    /**
     * Filter, which Votes to fetch.
     */
    where?: VoteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Votes.
     */
    cursor?: VoteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Votes.
     */
    skip?: number;
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[];
  };

  /**
   * Vote create
   */
  export type VoteCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null;
    /**
     * The data needed to create a Vote.
     */
    data: XOR<VoteCreateInput, VoteUncheckedCreateInput>;
  };

  /**
   * Vote createMany
   */
  export type VoteCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Votes.
     */
    data: VoteCreateManyInput | VoteCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Vote createManyAndReturn
   */
  export type VoteCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null;
    /**
     * The data used to create many Votes.
     */
    data: VoteCreateManyInput | VoteCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Vote update
   */
  export type VoteUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null;
    /**
     * The data needed to update a Vote.
     */
    data: XOR<VoteUpdateInput, VoteUncheckedUpdateInput>;
    /**
     * Choose, which Vote to update.
     */
    where: VoteWhereUniqueInput;
  };

  /**
   * Vote updateMany
   */
  export type VoteUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Votes.
     */
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyInput>;
    /**
     * Filter which Votes to update
     */
    where?: VoteWhereInput;
    /**
     * Limit how many Votes to update.
     */
    limit?: number;
  };

  /**
   * Vote updateManyAndReturn
   */
  export type VoteUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null;
    /**
     * The data used to update Votes.
     */
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyInput>;
    /**
     * Filter which Votes to update
     */
    where?: VoteWhereInput;
    /**
     * Limit how many Votes to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Vote upsert
   */
  export type VoteUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null;
    /**
     * The filter to search for the Vote to update in case it exists.
     */
    where: VoteWhereUniqueInput;
    /**
     * In case the Vote found by the `where` argument doesn't exist, create a new Vote with this data.
     */
    create: XOR<VoteCreateInput, VoteUncheckedCreateInput>;
    /**
     * In case the Vote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoteUpdateInput, VoteUncheckedUpdateInput>;
  };

  /**
   * Vote delete
   */
  export type VoteDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null;
    /**
     * Filter which Vote to delete.
     */
    where: VoteWhereUniqueInput;
  };

  /**
   * Vote deleteMany
   */
  export type VoteDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Votes to delete
     */
    where?: VoteWhereInput;
    /**
     * Limit how many Votes to delete.
     */
    limit?: number;
  };

  /**
   * Vote.input
   */
  export type Vote$inputArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null;
    where?: InputWhereInput;
  };

  /**
   * Vote.solution
   */
  export type Vote$solutionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null;
    where?: SolutionWhereInput;
  };

  /**
   * Vote without action
   */
  export type VoteDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null;
  };

  /**
   * Model InputGroup
   */

  export type AggregateInputGroup = {
    _count: InputGroupCountAggregateOutputType | null;
    _avg: InputGroupAvgAggregateOutputType | null;
    _sum: InputGroupSumAggregateOutputType | null;
    _min: InputGroupMinAggregateOutputType | null;
    _max: InputGroupMaxAggregateOutputType | null;
  };

  export type InputGroupAvgAggregateOutputType = {
    aiSimilarity: number | null;
  };

  export type InputGroupSumAggregateOutputType = {
    aiSimilarity: number | null;
  };

  export type InputGroupMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    ownerId: string | null;
    status: $Enums.GroupStatus | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    aiSuggested: boolean | null;
    aiSimilarity: number | null;
    aiTheme: string | null;
  };

  export type InputGroupMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    ownerId: string | null;
    status: $Enums.GroupStatus | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    aiSuggested: boolean | null;
    aiSimilarity: number | null;
    aiTheme: string | null;
  };

  export type InputGroupCountAggregateOutputType = {
    id: number;
    name: number;
    description: number;
    ownerId: number;
    status: number;
    createdAt: number;
    updatedAt: number;
    aiSuggested: number;
    aiSimilarity: number;
    aiTheme: number;
    _all: number;
  };

  export type InputGroupAvgAggregateInputType = {
    aiSimilarity?: true;
  };

  export type InputGroupSumAggregateInputType = {
    aiSimilarity?: true;
  };

  export type InputGroupMinAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    ownerId?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
    aiSuggested?: true;
    aiSimilarity?: true;
    aiTheme?: true;
  };

  export type InputGroupMaxAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    ownerId?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
    aiSuggested?: true;
    aiSimilarity?: true;
    aiTheme?: true;
  };

  export type InputGroupCountAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    ownerId?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
    aiSuggested?: true;
    aiSimilarity?: true;
    aiTheme?: true;
    _all?: true;
  };

  export type InputGroupAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which InputGroup to aggregate.
     */
    where?: InputGroupWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of InputGroups to fetch.
     */
    orderBy?:
      | InputGroupOrderByWithRelationInput
      | InputGroupOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: InputGroupWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` InputGroups from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` InputGroups.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned InputGroups
     **/
    _count?: true | InputGroupCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: InputGroupAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: InputGroupSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: InputGroupMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: InputGroupMaxAggregateInputType;
  };

  export type GetInputGroupAggregateType<T extends InputGroupAggregateArgs> = {
    [P in keyof T & keyof AggregateInputGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInputGroup[P]>
      : GetScalarType<T[P], AggregateInputGroup[P]>;
  };

  export type InputGroupGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: InputGroupWhereInput;
    orderBy?:
      | InputGroupOrderByWithAggregationInput
      | InputGroupOrderByWithAggregationInput[];
    by: InputGroupScalarFieldEnum[] | InputGroupScalarFieldEnum;
    having?: InputGroupScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: InputGroupCountAggregateInputType | true;
    _avg?: InputGroupAvgAggregateInputType;
    _sum?: InputGroupSumAggregateInputType;
    _min?: InputGroupMinAggregateInputType;
    _max?: InputGroupMaxAggregateInputType;
  };

  export type InputGroupGroupByOutputType = {
    id: string;
    name: string;
    description: string | null;
    ownerId: string;
    status: $Enums.GroupStatus;
    createdAt: Date;
    updatedAt: Date;
    aiSuggested: boolean;
    aiSimilarity: number | null;
    aiTheme: string | null;
    _count: InputGroupCountAggregateOutputType | null;
    _avg: InputGroupAvgAggregateOutputType | null;
    _sum: InputGroupSumAggregateOutputType | null;
    _min: InputGroupMinAggregateOutputType | null;
    _max: InputGroupMaxAggregateOutputType | null;
  };

  type GetInputGroupGroupByPayload<T extends InputGroupGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<InputGroupGroupByOutputType, T['by']> & {
          [P in keyof T & keyof InputGroupGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InputGroupGroupByOutputType[P]>
            : GetScalarType<T[P], InputGroupGroupByOutputType[P]>;
        }
      >
    >;

  export type InputGroupSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      ownerId?: boolean;
      status?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      aiSuggested?: boolean;
      aiSimilarity?: boolean;
      aiTheme?: boolean;
      owner?: boolean | UserDefaultArgs<ExtArgs>;
      inputs?: boolean | InputGroup$inputsArgs<ExtArgs>;
      _count?: boolean | InputGroupCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['inputGroup']
  >;

  export type InputGroupSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      ownerId?: boolean;
      status?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      aiSuggested?: boolean;
      aiSimilarity?: boolean;
      aiTheme?: boolean;
      owner?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['inputGroup']
  >;

  export type InputGroupSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      ownerId?: boolean;
      status?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      aiSuggested?: boolean;
      aiSimilarity?: boolean;
      aiTheme?: boolean;
      owner?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['inputGroup']
  >;

  export type InputGroupSelectScalar = {
    id?: boolean;
    name?: boolean;
    description?: boolean;
    ownerId?: boolean;
    status?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    aiSuggested?: boolean;
    aiSimilarity?: boolean;
    aiTheme?: boolean;
  };

  export type InputGroupOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'name'
    | 'description'
    | 'ownerId'
    | 'status'
    | 'createdAt'
    | 'updatedAt'
    | 'aiSuggested'
    | 'aiSimilarity'
    | 'aiTheme',
    ExtArgs['result']['inputGroup']
  >;
  export type InputGroupInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    owner?: boolean | UserDefaultArgs<ExtArgs>;
    inputs?: boolean | InputGroup$inputsArgs<ExtArgs>;
    _count?: boolean | InputGroupCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type InputGroupIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    owner?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type InputGroupIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    owner?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $InputGroupPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'InputGroup';
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>;
      inputs: Prisma.$InputPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        description: string | null;
        ownerId: string;
        status: $Enums.GroupStatus;
        createdAt: Date;
        updatedAt: Date;
        aiSuggested: boolean;
        aiSimilarity: number | null;
        aiTheme: string | null;
      },
      ExtArgs['result']['inputGroup']
    >;
    composites: {};
  };

  type InputGroupGetPayload<
    S extends boolean | null | undefined | InputGroupDefaultArgs,
  > = $Result.GetResult<Prisma.$InputGroupPayload, S>;

  type InputGroupCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    InputGroupFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: InputGroupCountAggregateInputType | true;
  };

  export interface InputGroupDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['InputGroup'];
      meta: { name: 'InputGroup' };
    };
    /**
     * Find zero or one InputGroup that matches the filter.
     * @param {InputGroupFindUniqueArgs} args - Arguments to find a InputGroup
     * @example
     * // Get one InputGroup
     * const inputGroup = await prisma.inputGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InputGroupFindUniqueArgs>(
      args: SelectSubset<T, InputGroupFindUniqueArgs<ExtArgs>>
    ): Prisma__InputGroupClient<
      $Result.GetResult<
        Prisma.$InputGroupPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one InputGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InputGroupFindUniqueOrThrowArgs} args - Arguments to find a InputGroup
     * @example
     * // Get one InputGroup
     * const inputGroup = await prisma.inputGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InputGroupFindUniqueOrThrowArgs>(
      args: SelectSubset<T, InputGroupFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InputGroupClient<
      $Result.GetResult<
        Prisma.$InputGroupPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first InputGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputGroupFindFirstArgs} args - Arguments to find a InputGroup
     * @example
     * // Get one InputGroup
     * const inputGroup = await prisma.inputGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InputGroupFindFirstArgs>(
      args?: SelectSubset<T, InputGroupFindFirstArgs<ExtArgs>>
    ): Prisma__InputGroupClient<
      $Result.GetResult<
        Prisma.$InputGroupPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first InputGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputGroupFindFirstOrThrowArgs} args - Arguments to find a InputGroup
     * @example
     * // Get one InputGroup
     * const inputGroup = await prisma.inputGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InputGroupFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InputGroupFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InputGroupClient<
      $Result.GetResult<
        Prisma.$InputGroupPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more InputGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InputGroups
     * const inputGroups = await prisma.inputGroup.findMany()
     *
     * // Get first 10 InputGroups
     * const inputGroups = await prisma.inputGroup.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const inputGroupWithIdOnly = await prisma.inputGroup.findMany({ select: { id: true } })
     *
     */
    findMany<T extends InputGroupFindManyArgs>(
      args?: SelectSubset<T, InputGroupFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$InputGroupPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a InputGroup.
     * @param {InputGroupCreateArgs} args - Arguments to create a InputGroup.
     * @example
     * // Create one InputGroup
     * const InputGroup = await prisma.inputGroup.create({
     *   data: {
     *     // ... data to create a InputGroup
     *   }
     * })
     *
     */
    create<T extends InputGroupCreateArgs>(
      args: SelectSubset<T, InputGroupCreateArgs<ExtArgs>>
    ): Prisma__InputGroupClient<
      $Result.GetResult<
        Prisma.$InputGroupPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many InputGroups.
     * @param {InputGroupCreateManyArgs} args - Arguments to create many InputGroups.
     * @example
     * // Create many InputGroups
     * const inputGroup = await prisma.inputGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends InputGroupCreateManyArgs>(
      args?: SelectSubset<T, InputGroupCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many InputGroups and returns the data saved in the database.
     * @param {InputGroupCreateManyAndReturnArgs} args - Arguments to create many InputGroups.
     * @example
     * // Create many InputGroups
     * const inputGroup = await prisma.inputGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many InputGroups and only return the `id`
     * const inputGroupWithIdOnly = await prisma.inputGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends InputGroupCreateManyAndReturnArgs>(
      args?: SelectSubset<T, InputGroupCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$InputGroupPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a InputGroup.
     * @param {InputGroupDeleteArgs} args - Arguments to delete one InputGroup.
     * @example
     * // Delete one InputGroup
     * const InputGroup = await prisma.inputGroup.delete({
     *   where: {
     *     // ... filter to delete one InputGroup
     *   }
     * })
     *
     */
    delete<T extends InputGroupDeleteArgs>(
      args: SelectSubset<T, InputGroupDeleteArgs<ExtArgs>>
    ): Prisma__InputGroupClient<
      $Result.GetResult<
        Prisma.$InputGroupPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one InputGroup.
     * @param {InputGroupUpdateArgs} args - Arguments to update one InputGroup.
     * @example
     * // Update one InputGroup
     * const inputGroup = await prisma.inputGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends InputGroupUpdateArgs>(
      args: SelectSubset<T, InputGroupUpdateArgs<ExtArgs>>
    ): Prisma__InputGroupClient<
      $Result.GetResult<
        Prisma.$InputGroupPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more InputGroups.
     * @param {InputGroupDeleteManyArgs} args - Arguments to filter InputGroups to delete.
     * @example
     * // Delete a few InputGroups
     * const { count } = await prisma.inputGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends InputGroupDeleteManyArgs>(
      args?: SelectSubset<T, InputGroupDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more InputGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InputGroups
     * const inputGroup = await prisma.inputGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends InputGroupUpdateManyArgs>(
      args: SelectSubset<T, InputGroupUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more InputGroups and returns the data updated in the database.
     * @param {InputGroupUpdateManyAndReturnArgs} args - Arguments to update many InputGroups.
     * @example
     * // Update many InputGroups
     * const inputGroup = await prisma.inputGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more InputGroups and only return the `id`
     * const inputGroupWithIdOnly = await prisma.inputGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends InputGroupUpdateManyAndReturnArgs>(
      args: SelectSubset<T, InputGroupUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$InputGroupPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one InputGroup.
     * @param {InputGroupUpsertArgs} args - Arguments to update or create a InputGroup.
     * @example
     * // Update or create a InputGroup
     * const inputGroup = await prisma.inputGroup.upsert({
     *   create: {
     *     // ... data to create a InputGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InputGroup we want to update
     *   }
     * })
     */
    upsert<T extends InputGroupUpsertArgs>(
      args: SelectSubset<T, InputGroupUpsertArgs<ExtArgs>>
    ): Prisma__InputGroupClient<
      $Result.GetResult<
        Prisma.$InputGroupPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of InputGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputGroupCountArgs} args - Arguments to filter InputGroups to count.
     * @example
     * // Count the number of InputGroups
     * const count = await prisma.inputGroup.count({
     *   where: {
     *     // ... the filter for the InputGroups we want to count
     *   }
     * })
     **/
    count<T extends InputGroupCountArgs>(
      args?: Subset<T, InputGroupCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InputGroupCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a InputGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends InputGroupAggregateArgs>(
      args: Subset<T, InputGroupAggregateArgs>
    ): Prisma.PrismaPromise<GetInputGroupAggregateType<T>>;

    /**
     * Group by InputGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends InputGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InputGroupGroupByArgs['orderBy'] }
        : { orderBy?: InputGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, InputGroupGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetInputGroupGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the InputGroup model
     */
    readonly fields: InputGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InputGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InputGroupClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    inputs<T extends InputGroup$inputsArgs<ExtArgs> = {}>(
      args?: Subset<T, InputGroup$inputsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$InputPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the InputGroup model
   */
  interface InputGroupFieldRefs {
    readonly id: FieldRef<'InputGroup', 'String'>;
    readonly name: FieldRef<'InputGroup', 'String'>;
    readonly description: FieldRef<'InputGroup', 'String'>;
    readonly ownerId: FieldRef<'InputGroup', 'String'>;
    readonly status: FieldRef<'InputGroup', 'GroupStatus'>;
    readonly createdAt: FieldRef<'InputGroup', 'DateTime'>;
    readonly updatedAt: FieldRef<'InputGroup', 'DateTime'>;
    readonly aiSuggested: FieldRef<'InputGroup', 'Boolean'>;
    readonly aiSimilarity: FieldRef<'InputGroup', 'Float'>;
    readonly aiTheme: FieldRef<'InputGroup', 'String'>;
  }

  // Custom InputTypes
  /**
   * InputGroup findUnique
   */
  export type InputGroupFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null;
    /**
     * Filter, which InputGroup to fetch.
     */
    where: InputGroupWhereUniqueInput;
  };

  /**
   * InputGroup findUniqueOrThrow
   */
  export type InputGroupFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null;
    /**
     * Filter, which InputGroup to fetch.
     */
    where: InputGroupWhereUniqueInput;
  };

  /**
   * InputGroup findFirst
   */
  export type InputGroupFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null;
    /**
     * Filter, which InputGroup to fetch.
     */
    where?: InputGroupWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of InputGroups to fetch.
     */
    orderBy?:
      | InputGroupOrderByWithRelationInput
      | InputGroupOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for InputGroups.
     */
    cursor?: InputGroupWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` InputGroups from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` InputGroups.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of InputGroups.
     */
    distinct?: InputGroupScalarFieldEnum | InputGroupScalarFieldEnum[];
  };

  /**
   * InputGroup findFirstOrThrow
   */
  export type InputGroupFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null;
    /**
     * Filter, which InputGroup to fetch.
     */
    where?: InputGroupWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of InputGroups to fetch.
     */
    orderBy?:
      | InputGroupOrderByWithRelationInput
      | InputGroupOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for InputGroups.
     */
    cursor?: InputGroupWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` InputGroups from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` InputGroups.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of InputGroups.
     */
    distinct?: InputGroupScalarFieldEnum | InputGroupScalarFieldEnum[];
  };

  /**
   * InputGroup findMany
   */
  export type InputGroupFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null;
    /**
     * Filter, which InputGroups to fetch.
     */
    where?: InputGroupWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of InputGroups to fetch.
     */
    orderBy?:
      | InputGroupOrderByWithRelationInput
      | InputGroupOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing InputGroups.
     */
    cursor?: InputGroupWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` InputGroups from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` InputGroups.
     */
    skip?: number;
    distinct?: InputGroupScalarFieldEnum | InputGroupScalarFieldEnum[];
  };

  /**
   * InputGroup create
   */
  export type InputGroupCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null;
    /**
     * The data needed to create a InputGroup.
     */
    data: XOR<InputGroupCreateInput, InputGroupUncheckedCreateInput>;
  };

  /**
   * InputGroup createMany
   */
  export type InputGroupCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many InputGroups.
     */
    data: InputGroupCreateManyInput | InputGroupCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * InputGroup createManyAndReturn
   */
  export type InputGroupCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null;
    /**
     * The data used to create many InputGroups.
     */
    data: InputGroupCreateManyInput | InputGroupCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * InputGroup update
   */
  export type InputGroupUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null;
    /**
     * The data needed to update a InputGroup.
     */
    data: XOR<InputGroupUpdateInput, InputGroupUncheckedUpdateInput>;
    /**
     * Choose, which InputGroup to update.
     */
    where: InputGroupWhereUniqueInput;
  };

  /**
   * InputGroup updateMany
   */
  export type InputGroupUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update InputGroups.
     */
    data: XOR<
      InputGroupUpdateManyMutationInput,
      InputGroupUncheckedUpdateManyInput
    >;
    /**
     * Filter which InputGroups to update
     */
    where?: InputGroupWhereInput;
    /**
     * Limit how many InputGroups to update.
     */
    limit?: number;
  };

  /**
   * InputGroup updateManyAndReturn
   */
  export type InputGroupUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null;
    /**
     * The data used to update InputGroups.
     */
    data: XOR<
      InputGroupUpdateManyMutationInput,
      InputGroupUncheckedUpdateManyInput
    >;
    /**
     * Filter which InputGroups to update
     */
    where?: InputGroupWhereInput;
    /**
     * Limit how many InputGroups to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * InputGroup upsert
   */
  export type InputGroupUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null;
    /**
     * The filter to search for the InputGroup to update in case it exists.
     */
    where: InputGroupWhereUniqueInput;
    /**
     * In case the InputGroup found by the `where` argument doesn't exist, create a new InputGroup with this data.
     */
    create: XOR<InputGroupCreateInput, InputGroupUncheckedCreateInput>;
    /**
     * In case the InputGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InputGroupUpdateInput, InputGroupUncheckedUpdateInput>;
  };

  /**
   * InputGroup delete
   */
  export type InputGroupDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null;
    /**
     * Filter which InputGroup to delete.
     */
    where: InputGroupWhereUniqueInput;
  };

  /**
   * InputGroup deleteMany
   */
  export type InputGroupDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which InputGroups to delete
     */
    where?: InputGroupWhereInput;
    /**
     * Limit how many InputGroups to delete.
     */
    limit?: number;
  };

  /**
   * InputGroup.inputs
   */
  export type InputGroup$inputsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null;
    where?: InputWhereInput;
    orderBy?: InputOrderByWithRelationInput | InputOrderByWithRelationInput[];
    cursor?: InputWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: InputScalarFieldEnum | InputScalarFieldEnum[];
  };

  /**
   * InputGroup without action
   */
  export type InputGroupDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null;
  };

  /**
   * Model Solution
   */

  export type AggregateSolution = {
    _count: SolutionCountAggregateOutputType | null;
    _min: SolutionMinAggregateOutputType | null;
    _max: SolutionMaxAggregateOutputType | null;
  };

  export type SolutionMinAggregateOutputType = {
    id: string | null;
    title: string | null;
    description: string | null;
    ownerId: string | null;
    status: $Enums.SolutionStatus | null;
    priority: $Enums.Priority | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    estimatedEffort: string | null;
    targetCompletion: Date | null;
    actualCompletion: Date | null;
  };

  export type SolutionMaxAggregateOutputType = {
    id: string | null;
    title: string | null;
    description: string | null;
    ownerId: string | null;
    status: $Enums.SolutionStatus | null;
    priority: $Enums.Priority | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    estimatedEffort: string | null;
    targetCompletion: Date | null;
    actualCompletion: Date | null;
  };

  export type SolutionCountAggregateOutputType = {
    id: number;
    title: number;
    description: number;
    ownerId: number;
    status: number;
    priority: number;
    createdAt: number;
    updatedAt: number;
    estimatedEffort: number;
    targetCompletion: number;
    actualCompletion: number;
    successCriteria: number;
    _all: number;
  };

  export type SolutionMinAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    ownerId?: true;
    status?: true;
    priority?: true;
    createdAt?: true;
    updatedAt?: true;
    estimatedEffort?: true;
    targetCompletion?: true;
    actualCompletion?: true;
  };

  export type SolutionMaxAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    ownerId?: true;
    status?: true;
    priority?: true;
    createdAt?: true;
    updatedAt?: true;
    estimatedEffort?: true;
    targetCompletion?: true;
    actualCompletion?: true;
  };

  export type SolutionCountAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    ownerId?: true;
    status?: true;
    priority?: true;
    createdAt?: true;
    updatedAt?: true;
    estimatedEffort?: true;
    targetCompletion?: true;
    actualCompletion?: true;
    successCriteria?: true;
    _all?: true;
  };

  export type SolutionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Solution to aggregate.
     */
    where?: SolutionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Solutions to fetch.
     */
    orderBy?:
      | SolutionOrderByWithRelationInput
      | SolutionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SolutionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Solutions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Solutions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Solutions
     **/
    _count?: true | SolutionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SolutionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SolutionMaxAggregateInputType;
  };

  export type GetSolutionAggregateType<T extends SolutionAggregateArgs> = {
    [P in keyof T & keyof AggregateSolution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSolution[P]>
      : GetScalarType<T[P], AggregateSolution[P]>;
  };

  export type SolutionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SolutionWhereInput;
    orderBy?:
      | SolutionOrderByWithAggregationInput
      | SolutionOrderByWithAggregationInput[];
    by: SolutionScalarFieldEnum[] | SolutionScalarFieldEnum;
    having?: SolutionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SolutionCountAggregateInputType | true;
    _min?: SolutionMinAggregateInputType;
    _max?: SolutionMaxAggregateInputType;
  };

  export type SolutionGroupByOutputType = {
    id: string;
    title: string;
    description: string;
    ownerId: string;
    status: $Enums.SolutionStatus;
    priority: $Enums.Priority;
    createdAt: Date;
    updatedAt: Date;
    estimatedEffort: string | null;
    targetCompletion: Date | null;
    actualCompletion: Date | null;
    successCriteria: JsonValue | null;
    _count: SolutionCountAggregateOutputType | null;
    _min: SolutionMinAggregateOutputType | null;
    _max: SolutionMaxAggregateOutputType | null;
  };

  type GetSolutionGroupByPayload<T extends SolutionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SolutionGroupByOutputType, T['by']> & {
          [P in keyof T & keyof SolutionGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SolutionGroupByOutputType[P]>
            : GetScalarType<T[P], SolutionGroupByOutputType[P]>;
        }
      >
    >;

  export type SolutionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      ownerId?: boolean;
      status?: boolean;
      priority?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      estimatedEffort?: boolean;
      targetCompletion?: boolean;
      actualCompletion?: boolean;
      successCriteria?: boolean;
      owner?: boolean | UserDefaultArgs<ExtArgs>;
      inputs?: boolean | Solution$inputsArgs<ExtArgs>;
      tasks?: boolean | Solution$tasksArgs<ExtArgs>;
      comments?: boolean | Solution$commentsArgs<ExtArgs>;
      votes?: boolean | Solution$votesArgs<ExtArgs>;
      requirements?: boolean | Solution$requirementsArgs<ExtArgs>;
      frdDocuments?: boolean | Solution$frdDocumentsArgs<ExtArgs>;
      _count?: boolean | SolutionCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['solution']
  >;

  export type SolutionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      ownerId?: boolean;
      status?: boolean;
      priority?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      estimatedEffort?: boolean;
      targetCompletion?: boolean;
      actualCompletion?: boolean;
      successCriteria?: boolean;
      owner?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['solution']
  >;

  export type SolutionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      ownerId?: boolean;
      status?: boolean;
      priority?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      estimatedEffort?: boolean;
      targetCompletion?: boolean;
      actualCompletion?: boolean;
      successCriteria?: boolean;
      owner?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['solution']
  >;

  export type SolutionSelectScalar = {
    id?: boolean;
    title?: boolean;
    description?: boolean;
    ownerId?: boolean;
    status?: boolean;
    priority?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    estimatedEffort?: boolean;
    targetCompletion?: boolean;
    actualCompletion?: boolean;
    successCriteria?: boolean;
  };

  export type SolutionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'title'
    | 'description'
    | 'ownerId'
    | 'status'
    | 'priority'
    | 'createdAt'
    | 'updatedAt'
    | 'estimatedEffort'
    | 'targetCompletion'
    | 'actualCompletion'
    | 'successCriteria',
    ExtArgs['result']['solution']
  >;
  export type SolutionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    owner?: boolean | UserDefaultArgs<ExtArgs>;
    inputs?: boolean | Solution$inputsArgs<ExtArgs>;
    tasks?: boolean | Solution$tasksArgs<ExtArgs>;
    comments?: boolean | Solution$commentsArgs<ExtArgs>;
    votes?: boolean | Solution$votesArgs<ExtArgs>;
    requirements?: boolean | Solution$requirementsArgs<ExtArgs>;
    frdDocuments?: boolean | Solution$frdDocumentsArgs<ExtArgs>;
    _count?: boolean | SolutionCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type SolutionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    owner?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type SolutionIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    owner?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $SolutionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Solution';
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>;
      inputs: Prisma.$InputPayload<ExtArgs>[];
      tasks: Prisma.$TaskPayload<ExtArgs>[];
      comments: Prisma.$CommentPayload<ExtArgs>[];
      votes: Prisma.$VotePayload<ExtArgs>[];
      requirements: Prisma.$RequirementPayload<ExtArgs>[];
      frdDocuments: Prisma.$FRDDocumentPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        title: string;
        description: string;
        ownerId: string;
        status: $Enums.SolutionStatus;
        priority: $Enums.Priority;
        createdAt: Date;
        updatedAt: Date;
        estimatedEffort: string | null;
        targetCompletion: Date | null;
        actualCompletion: Date | null;
        successCriteria: Prisma.JsonValue | null;
      },
      ExtArgs['result']['solution']
    >;
    composites: {};
  };

  type SolutionGetPayload<
    S extends boolean | null | undefined | SolutionDefaultArgs,
  > = $Result.GetResult<Prisma.$SolutionPayload, S>;

  type SolutionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<SolutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: SolutionCountAggregateInputType | true;
  };

  export interface SolutionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Solution'];
      meta: { name: 'Solution' };
    };
    /**
     * Find zero or one Solution that matches the filter.
     * @param {SolutionFindUniqueArgs} args - Arguments to find a Solution
     * @example
     * // Get one Solution
     * const solution = await prisma.solution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SolutionFindUniqueArgs>(
      args: SelectSubset<T, SolutionFindUniqueArgs<ExtArgs>>
    ): Prisma__SolutionClient<
      $Result.GetResult<
        Prisma.$SolutionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Solution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SolutionFindUniqueOrThrowArgs} args - Arguments to find a Solution
     * @example
     * // Get one Solution
     * const solution = await prisma.solution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SolutionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SolutionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SolutionClient<
      $Result.GetResult<
        Prisma.$SolutionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Solution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolutionFindFirstArgs} args - Arguments to find a Solution
     * @example
     * // Get one Solution
     * const solution = await prisma.solution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SolutionFindFirstArgs>(
      args?: SelectSubset<T, SolutionFindFirstArgs<ExtArgs>>
    ): Prisma__SolutionClient<
      $Result.GetResult<
        Prisma.$SolutionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Solution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolutionFindFirstOrThrowArgs} args - Arguments to find a Solution
     * @example
     * // Get one Solution
     * const solution = await prisma.solution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SolutionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SolutionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SolutionClient<
      $Result.GetResult<
        Prisma.$SolutionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Solutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Solutions
     * const solutions = await prisma.solution.findMany()
     *
     * // Get first 10 Solutions
     * const solutions = await prisma.solution.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const solutionWithIdOnly = await prisma.solution.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SolutionFindManyArgs>(
      args?: SelectSubset<T, SolutionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SolutionPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Solution.
     * @param {SolutionCreateArgs} args - Arguments to create a Solution.
     * @example
     * // Create one Solution
     * const Solution = await prisma.solution.create({
     *   data: {
     *     // ... data to create a Solution
     *   }
     * })
     *
     */
    create<T extends SolutionCreateArgs>(
      args: SelectSubset<T, SolutionCreateArgs<ExtArgs>>
    ): Prisma__SolutionClient<
      $Result.GetResult<
        Prisma.$SolutionPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Solutions.
     * @param {SolutionCreateManyArgs} args - Arguments to create many Solutions.
     * @example
     * // Create many Solutions
     * const solution = await prisma.solution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SolutionCreateManyArgs>(
      args?: SelectSubset<T, SolutionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Solutions and returns the data saved in the database.
     * @param {SolutionCreateManyAndReturnArgs} args - Arguments to create many Solutions.
     * @example
     * // Create many Solutions
     * const solution = await prisma.solution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Solutions and only return the `id`
     * const solutionWithIdOnly = await prisma.solution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SolutionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SolutionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SolutionPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Solution.
     * @param {SolutionDeleteArgs} args - Arguments to delete one Solution.
     * @example
     * // Delete one Solution
     * const Solution = await prisma.solution.delete({
     *   where: {
     *     // ... filter to delete one Solution
     *   }
     * })
     *
     */
    delete<T extends SolutionDeleteArgs>(
      args: SelectSubset<T, SolutionDeleteArgs<ExtArgs>>
    ): Prisma__SolutionClient<
      $Result.GetResult<
        Prisma.$SolutionPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Solution.
     * @param {SolutionUpdateArgs} args - Arguments to update one Solution.
     * @example
     * // Update one Solution
     * const solution = await prisma.solution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SolutionUpdateArgs>(
      args: SelectSubset<T, SolutionUpdateArgs<ExtArgs>>
    ): Prisma__SolutionClient<
      $Result.GetResult<
        Prisma.$SolutionPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Solutions.
     * @param {SolutionDeleteManyArgs} args - Arguments to filter Solutions to delete.
     * @example
     * // Delete a few Solutions
     * const { count } = await prisma.solution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SolutionDeleteManyArgs>(
      args?: SelectSubset<T, SolutionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Solutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Solutions
     * const solution = await prisma.solution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SolutionUpdateManyArgs>(
      args: SelectSubset<T, SolutionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Solutions and returns the data updated in the database.
     * @param {SolutionUpdateManyAndReturnArgs} args - Arguments to update many Solutions.
     * @example
     * // Update many Solutions
     * const solution = await prisma.solution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Solutions and only return the `id`
     * const solutionWithIdOnly = await prisma.solution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SolutionUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SolutionUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SolutionPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Solution.
     * @param {SolutionUpsertArgs} args - Arguments to update or create a Solution.
     * @example
     * // Update or create a Solution
     * const solution = await prisma.solution.upsert({
     *   create: {
     *     // ... data to create a Solution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Solution we want to update
     *   }
     * })
     */
    upsert<T extends SolutionUpsertArgs>(
      args: SelectSubset<T, SolutionUpsertArgs<ExtArgs>>
    ): Prisma__SolutionClient<
      $Result.GetResult<
        Prisma.$SolutionPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Solutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolutionCountArgs} args - Arguments to filter Solutions to count.
     * @example
     * // Count the number of Solutions
     * const count = await prisma.solution.count({
     *   where: {
     *     // ... the filter for the Solutions we want to count
     *   }
     * })
     **/
    count<T extends SolutionCountArgs>(
      args?: Subset<T, SolutionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SolutionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Solution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SolutionAggregateArgs>(
      args: Subset<T, SolutionAggregateArgs>
    ): Prisma.PrismaPromise<GetSolutionAggregateType<T>>;

    /**
     * Group by Solution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SolutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SolutionGroupByArgs['orderBy'] }
        : { orderBy?: SolutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SolutionGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetSolutionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Solution model
     */
    readonly fields: SolutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Solution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SolutionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    inputs<T extends Solution$inputsArgs<ExtArgs> = {}>(
      args?: Subset<T, Solution$inputsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$InputPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    tasks<T extends Solution$tasksArgs<ExtArgs> = {}>(
      args?: Subset<T, Solution$tasksArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TaskPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    comments<T extends Solution$commentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Solution$commentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CommentPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    votes<T extends Solution$votesArgs<ExtArgs> = {}>(
      args?: Subset<T, Solution$votesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$VotePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    requirements<T extends Solution$requirementsArgs<ExtArgs> = {}>(
      args?: Subset<T, Solution$requirementsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$RequirementPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    frdDocuments<T extends Solution$frdDocumentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Solution$frdDocumentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$FRDDocumentPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Solution model
   */
  interface SolutionFieldRefs {
    readonly id: FieldRef<'Solution', 'String'>;
    readonly title: FieldRef<'Solution', 'String'>;
    readonly description: FieldRef<'Solution', 'String'>;
    readonly ownerId: FieldRef<'Solution', 'String'>;
    readonly status: FieldRef<'Solution', 'SolutionStatus'>;
    readonly priority: FieldRef<'Solution', 'Priority'>;
    readonly createdAt: FieldRef<'Solution', 'DateTime'>;
    readonly updatedAt: FieldRef<'Solution', 'DateTime'>;
    readonly estimatedEffort: FieldRef<'Solution', 'String'>;
    readonly targetCompletion: FieldRef<'Solution', 'DateTime'>;
    readonly actualCompletion: FieldRef<'Solution', 'DateTime'>;
    readonly successCriteria: FieldRef<'Solution', 'Json'>;
  }

  // Custom InputTypes
  /**
   * Solution findUnique
   */
  export type SolutionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null;
    /**
     * Filter, which Solution to fetch.
     */
    where: SolutionWhereUniqueInput;
  };

  /**
   * Solution findUniqueOrThrow
   */
  export type SolutionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null;
    /**
     * Filter, which Solution to fetch.
     */
    where: SolutionWhereUniqueInput;
  };

  /**
   * Solution findFirst
   */
  export type SolutionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null;
    /**
     * Filter, which Solution to fetch.
     */
    where?: SolutionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Solutions to fetch.
     */
    orderBy?:
      | SolutionOrderByWithRelationInput
      | SolutionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Solutions.
     */
    cursor?: SolutionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Solutions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Solutions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Solutions.
     */
    distinct?: SolutionScalarFieldEnum | SolutionScalarFieldEnum[];
  };

  /**
   * Solution findFirstOrThrow
   */
  export type SolutionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null;
    /**
     * Filter, which Solution to fetch.
     */
    where?: SolutionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Solutions to fetch.
     */
    orderBy?:
      | SolutionOrderByWithRelationInput
      | SolutionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Solutions.
     */
    cursor?: SolutionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Solutions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Solutions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Solutions.
     */
    distinct?: SolutionScalarFieldEnum | SolutionScalarFieldEnum[];
  };

  /**
   * Solution findMany
   */
  export type SolutionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null;
    /**
     * Filter, which Solutions to fetch.
     */
    where?: SolutionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Solutions to fetch.
     */
    orderBy?:
      | SolutionOrderByWithRelationInput
      | SolutionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Solutions.
     */
    cursor?: SolutionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Solutions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Solutions.
     */
    skip?: number;
    distinct?: SolutionScalarFieldEnum | SolutionScalarFieldEnum[];
  };

  /**
   * Solution create
   */
  export type SolutionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Solution.
     */
    data: XOR<SolutionCreateInput, SolutionUncheckedCreateInput>;
  };

  /**
   * Solution createMany
   */
  export type SolutionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Solutions.
     */
    data: SolutionCreateManyInput | SolutionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Solution createManyAndReturn
   */
  export type SolutionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null;
    /**
     * The data used to create many Solutions.
     */
    data: SolutionCreateManyInput | SolutionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Solution update
   */
  export type SolutionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Solution.
     */
    data: XOR<SolutionUpdateInput, SolutionUncheckedUpdateInput>;
    /**
     * Choose, which Solution to update.
     */
    where: SolutionWhereUniqueInput;
  };

  /**
   * Solution updateMany
   */
  export type SolutionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Solutions.
     */
    data: XOR<
      SolutionUpdateManyMutationInput,
      SolutionUncheckedUpdateManyInput
    >;
    /**
     * Filter which Solutions to update
     */
    where?: SolutionWhereInput;
    /**
     * Limit how many Solutions to update.
     */
    limit?: number;
  };

  /**
   * Solution updateManyAndReturn
   */
  export type SolutionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null;
    /**
     * The data used to update Solutions.
     */
    data: XOR<
      SolutionUpdateManyMutationInput,
      SolutionUncheckedUpdateManyInput
    >;
    /**
     * Filter which Solutions to update
     */
    where?: SolutionWhereInput;
    /**
     * Limit how many Solutions to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Solution upsert
   */
  export type SolutionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Solution to update in case it exists.
     */
    where: SolutionWhereUniqueInput;
    /**
     * In case the Solution found by the `where` argument doesn't exist, create a new Solution with this data.
     */
    create: XOR<SolutionCreateInput, SolutionUncheckedCreateInput>;
    /**
     * In case the Solution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SolutionUpdateInput, SolutionUncheckedUpdateInput>;
  };

  /**
   * Solution delete
   */
  export type SolutionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null;
    /**
     * Filter which Solution to delete.
     */
    where: SolutionWhereUniqueInput;
  };

  /**
   * Solution deleteMany
   */
  export type SolutionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Solutions to delete
     */
    where?: SolutionWhereInput;
    /**
     * Limit how many Solutions to delete.
     */
    limit?: number;
  };

  /**
   * Solution.inputs
   */
  export type Solution$inputsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null;
    where?: InputWhereInput;
    orderBy?: InputOrderByWithRelationInput | InputOrderByWithRelationInput[];
    cursor?: InputWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: InputScalarFieldEnum | InputScalarFieldEnum[];
  };

  /**
   * Solution.tasks
   */
  export type Solution$tasksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    where?: TaskWhereInput;
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[];
    cursor?: TaskWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[];
  };

  /**
   * Solution.comments
   */
  export type Solution$commentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    where?: CommentWhereInput;
    orderBy?:
      | CommentOrderByWithRelationInput
      | CommentOrderByWithRelationInput[];
    cursor?: CommentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[];
  };

  /**
   * Solution.votes
   */
  export type Solution$votesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null;
    where?: VoteWhereInput;
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[];
    cursor?: VoteWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[];
  };

  /**
   * Solution.requirements
   */
  export type Solution$requirementsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null;
    where?: RequirementWhereInput;
    orderBy?:
      | RequirementOrderByWithRelationInput
      | RequirementOrderByWithRelationInput[];
    cursor?: RequirementWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[];
  };

  /**
   * Solution.frdDocuments
   */
  export type Solution$frdDocumentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null;
    where?: FRDDocumentWhereInput;
    orderBy?:
      | FRDDocumentOrderByWithRelationInput
      | FRDDocumentOrderByWithRelationInput[];
    cursor?: FRDDocumentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FRDDocumentScalarFieldEnum | FRDDocumentScalarFieldEnum[];
  };

  /**
   * Solution without action
   */
  export type SolutionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null;
  };

  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null;
    _avg: TaskAvgAggregateOutputType | null;
    _sum: TaskSumAggregateOutputType | null;
    _min: TaskMinAggregateOutputType | null;
    _max: TaskMaxAggregateOutputType | null;
  };

  export type TaskAvgAggregateOutputType = {
    estimatedHours: number | null;
    actualHours: number | null;
  };

  export type TaskSumAggregateOutputType = {
    estimatedHours: number | null;
    actualHours: number | null;
  };

  export type TaskMinAggregateOutputType = {
    id: string | null;
    title: string | null;
    description: string | null;
    solutionId: string | null;
    assigneeId: string | null;
    status: $Enums.TaskStatus | null;
    priority: $Enums.Priority | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    estimatedHours: number | null;
    actualHours: number | null;
    dueDate: Date | null;
  };

  export type TaskMaxAggregateOutputType = {
    id: string | null;
    title: string | null;
    description: string | null;
    solutionId: string | null;
    assigneeId: string | null;
    status: $Enums.TaskStatus | null;
    priority: $Enums.Priority | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    estimatedHours: number | null;
    actualHours: number | null;
    dueDate: Date | null;
  };

  export type TaskCountAggregateOutputType = {
    id: number;
    title: number;
    description: number;
    solutionId: number;
    assigneeId: number;
    status: number;
    priority: number;
    createdAt: number;
    updatedAt: number;
    estimatedHours: number;
    actualHours: number;
    dueDate: number;
    dependencies: number;
    _all: number;
  };

  export type TaskAvgAggregateInputType = {
    estimatedHours?: true;
    actualHours?: true;
  };

  export type TaskSumAggregateInputType = {
    estimatedHours?: true;
    actualHours?: true;
  };

  export type TaskMinAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    solutionId?: true;
    assigneeId?: true;
    status?: true;
    priority?: true;
    createdAt?: true;
    updatedAt?: true;
    estimatedHours?: true;
    actualHours?: true;
    dueDate?: true;
  };

  export type TaskMaxAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    solutionId?: true;
    assigneeId?: true;
    status?: true;
    priority?: true;
    createdAt?: true;
    updatedAt?: true;
    estimatedHours?: true;
    actualHours?: true;
    dueDate?: true;
  };

  export type TaskCountAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    solutionId?: true;
    assigneeId?: true;
    status?: true;
    priority?: true;
    createdAt?: true;
    updatedAt?: true;
    estimatedHours?: true;
    actualHours?: true;
    dueDate?: true;
    dependencies?: true;
    _all?: true;
  };

  export type TaskAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Tasks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Tasks
     **/
    _count?: true | TaskCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: TaskAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: TaskSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TaskMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TaskMaxAggregateInputType;
  };

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
    [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>;
  };

  export type TaskGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TaskWhereInput;
    orderBy?:
      | TaskOrderByWithAggregationInput
      | TaskOrderByWithAggregationInput[];
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum;
    having?: TaskScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TaskCountAggregateInputType | true;
    _avg?: TaskAvgAggregateInputType;
    _sum?: TaskSumAggregateInputType;
    _min?: TaskMinAggregateInputType;
    _max?: TaskMaxAggregateInputType;
  };

  export type TaskGroupByOutputType = {
    id: string;
    title: string;
    description: string | null;
    solutionId: string;
    assigneeId: string | null;
    status: $Enums.TaskStatus;
    priority: $Enums.Priority;
    createdAt: Date;
    updatedAt: Date;
    estimatedHours: number | null;
    actualHours: number | null;
    dueDate: Date | null;
    dependencies: JsonValue | null;
    _count: TaskCountAggregateOutputType | null;
    _avg: TaskAvgAggregateOutputType | null;
    _sum: TaskSumAggregateOutputType | null;
    _min: TaskMinAggregateOutputType | null;
    _max: TaskMaxAggregateOutputType | null;
  };

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> & {
        [P in keyof T & keyof TaskGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
          : GetScalarType<T[P], TaskGroupByOutputType[P]>;
      }
    >
  >;

  export type TaskSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      solutionId?: boolean;
      assigneeId?: boolean;
      status?: boolean;
      priority?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      estimatedHours?: boolean;
      actualHours?: boolean;
      dueDate?: boolean;
      dependencies?: boolean;
      solution?: boolean | SolutionDefaultArgs<ExtArgs>;
      assignee?: boolean | Task$assigneeArgs<ExtArgs>;
    },
    ExtArgs['result']['task']
  >;

  export type TaskSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      solutionId?: boolean;
      assigneeId?: boolean;
      status?: boolean;
      priority?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      estimatedHours?: boolean;
      actualHours?: boolean;
      dueDate?: boolean;
      dependencies?: boolean;
      solution?: boolean | SolutionDefaultArgs<ExtArgs>;
      assignee?: boolean | Task$assigneeArgs<ExtArgs>;
    },
    ExtArgs['result']['task']
  >;

  export type TaskSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      solutionId?: boolean;
      assigneeId?: boolean;
      status?: boolean;
      priority?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      estimatedHours?: boolean;
      actualHours?: boolean;
      dueDate?: boolean;
      dependencies?: boolean;
      solution?: boolean | SolutionDefaultArgs<ExtArgs>;
      assignee?: boolean | Task$assigneeArgs<ExtArgs>;
    },
    ExtArgs['result']['task']
  >;

  export type TaskSelectScalar = {
    id?: boolean;
    title?: boolean;
    description?: boolean;
    solutionId?: boolean;
    assigneeId?: boolean;
    status?: boolean;
    priority?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    estimatedHours?: boolean;
    actualHours?: boolean;
    dueDate?: boolean;
    dependencies?: boolean;
  };

  export type TaskOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'title'
    | 'description'
    | 'solutionId'
    | 'assigneeId'
    | 'status'
    | 'priority'
    | 'createdAt'
    | 'updatedAt'
    | 'estimatedHours'
    | 'actualHours'
    | 'dueDate'
    | 'dependencies',
    ExtArgs['result']['task']
  >;
  export type TaskInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    solution?: boolean | SolutionDefaultArgs<ExtArgs>;
    assignee?: boolean | Task$assigneeArgs<ExtArgs>;
  };
  export type TaskIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    solution?: boolean | SolutionDefaultArgs<ExtArgs>;
    assignee?: boolean | Task$assigneeArgs<ExtArgs>;
  };
  export type TaskIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    solution?: boolean | SolutionDefaultArgs<ExtArgs>;
    assignee?: boolean | Task$assigneeArgs<ExtArgs>;
  };

  export type $TaskPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Task';
    objects: {
      solution: Prisma.$SolutionPayload<ExtArgs>;
      assignee: Prisma.$UserPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        title: string;
        description: string | null;
        solutionId: string;
        assigneeId: string | null;
        status: $Enums.TaskStatus;
        priority: $Enums.Priority;
        createdAt: Date;
        updatedAt: Date;
        estimatedHours: number | null;
        actualHours: number | null;
        dueDate: Date | null;
        dependencies: Prisma.JsonValue | null;
      },
      ExtArgs['result']['task']
    >;
    composites: {};
  };

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> =
    $Result.GetResult<Prisma.$TaskPayload, S>;

  type TaskCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: TaskCountAggregateInputType | true;
  };

  export interface TaskDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Task'];
      meta: { name: 'Task' };
    };
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(
      args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>
    ): Prisma__TaskClient<
      $Result.GetResult<
        Prisma.$TaskPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TaskClient<
      $Result.GetResult<
        Prisma.$TaskPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(
      args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>
    ): Prisma__TaskClient<
      $Result.GetResult<
        Prisma.$TaskPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TaskClient<
      $Result.GetResult<
        Prisma.$TaskPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     *
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TaskFindManyArgs>(
      args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TaskPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     *
     */
    create<T extends TaskCreateArgs>(
      args: SelectSubset<T, TaskCreateArgs<ExtArgs>>
    ): Prisma__TaskClient<
      $Result.GetResult<
        Prisma.$TaskPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TaskCreateManyArgs>(
      args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(
      args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TaskPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     *
     */
    delete<T extends TaskDeleteArgs>(
      args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>
    ): Prisma__TaskClient<
      $Result.GetResult<
        Prisma.$TaskPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TaskUpdateArgs>(
      args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>
    ): Prisma__TaskClient<
      $Result.GetResult<
        Prisma.$TaskPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TaskDeleteManyArgs>(
      args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TaskUpdateManyArgs>(
      args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(
      args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TaskPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(
      args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>
    ): Prisma__TaskClient<
      $Result.GetResult<
        Prisma.$TaskPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
     **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TaskAggregateArgs>(
      args: Subset<T, TaskAggregateArgs>
    ): Prisma.PrismaPromise<GetTaskAggregateType<T>>;

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetTaskGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Task model
     */
    readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    solution<T extends SolutionDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, SolutionDefaultArgs<ExtArgs>>
    ): Prisma__SolutionClient<
      | $Result.GetResult<
          Prisma.$SolutionPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    assignee<T extends Task$assigneeArgs<ExtArgs> = {}>(
      args?: Subset<T, Task$assigneeArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<'Task', 'String'>;
    readonly title: FieldRef<'Task', 'String'>;
    readonly description: FieldRef<'Task', 'String'>;
    readonly solutionId: FieldRef<'Task', 'String'>;
    readonly assigneeId: FieldRef<'Task', 'String'>;
    readonly status: FieldRef<'Task', 'TaskStatus'>;
    readonly priority: FieldRef<'Task', 'Priority'>;
    readonly createdAt: FieldRef<'Task', 'DateTime'>;
    readonly updatedAt: FieldRef<'Task', 'DateTime'>;
    readonly estimatedHours: FieldRef<'Task', 'Float'>;
    readonly actualHours: FieldRef<'Task', 'Float'>;
    readonly dueDate: FieldRef<'Task', 'DateTime'>;
    readonly dependencies: FieldRef<'Task', 'Json'>;
  }

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput;
  };

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput;
  };

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Tasks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[];
  };

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Tasks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[];
  };

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Tasks.
     */
    skip?: number;
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[];
  };

  /**
   * Task create
   */
  export type TaskCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>;
  };

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Task update
   */
  export type TaskUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>;
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput;
  };

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>;
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput;
    /**
     * Limit how many Tasks to update.
     */
    limit?: number;
  };

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>;
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput;
    /**
     * Limit how many Tasks to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput;
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>;
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>;
  };

  /**
   * Task delete
   */
  export type TaskDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput;
  };

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput;
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number;
  };

  /**
   * Task.assignee
   */
  export type Task$assigneeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Task without action
   */
  export type TaskDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null;
  };

  /**
   * Model Requirement
   */

  export type AggregateRequirement = {
    _count: RequirementCountAggregateOutputType | null;
    _min: RequirementMinAggregateOutputType | null;
    _max: RequirementMaxAggregateOutputType | null;
  };

  export type RequirementMinAggregateOutputType = {
    id: string | null;
    title: string | null;
    description: string | null;
    priority: $Enums.Priority | null;
    status: $Enums.RequirementStatus | null;
    estimatedEffort: string | null;
    businessValue: string | null;
    riskAssessment: string | null;
    approvedBy: string | null;
    approvedAt: Date | null;
    rejectionReason: string | null;
    solutionId: string | null;
    createdBy: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RequirementMaxAggregateOutputType = {
    id: string | null;
    title: string | null;
    description: string | null;
    priority: $Enums.Priority | null;
    status: $Enums.RequirementStatus | null;
    estimatedEffort: string | null;
    businessValue: string | null;
    riskAssessment: string | null;
    approvedBy: string | null;
    approvedAt: Date | null;
    rejectionReason: string | null;
    solutionId: string | null;
    createdBy: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RequirementCountAggregateOutputType = {
    id: number;
    title: number;
    description: number;
    acceptanceCriteria: number;
    priority: number;
    status: number;
    estimatedEffort: number;
    dependencies: number;
    businessValue: number;
    riskAssessment: number;
    stakeholders: number;
    approvedBy: number;
    approvedAt: number;
    rejectionReason: number;
    solutionId: number;
    createdBy: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type RequirementMinAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    priority?: true;
    status?: true;
    estimatedEffort?: true;
    businessValue?: true;
    riskAssessment?: true;
    approvedBy?: true;
    approvedAt?: true;
    rejectionReason?: true;
    solutionId?: true;
    createdBy?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RequirementMaxAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    priority?: true;
    status?: true;
    estimatedEffort?: true;
    businessValue?: true;
    riskAssessment?: true;
    approvedBy?: true;
    approvedAt?: true;
    rejectionReason?: true;
    solutionId?: true;
    createdBy?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RequirementCountAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    acceptanceCriteria?: true;
    priority?: true;
    status?: true;
    estimatedEffort?: true;
    dependencies?: true;
    businessValue?: true;
    riskAssessment?: true;
    stakeholders?: true;
    approvedBy?: true;
    approvedAt?: true;
    rejectionReason?: true;
    solutionId?: true;
    createdBy?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type RequirementAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Requirement to aggregate.
     */
    where?: RequirementWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Requirements to fetch.
     */
    orderBy?:
      | RequirementOrderByWithRelationInput
      | RequirementOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: RequirementWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Requirements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Requirements.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Requirements
     **/
    _count?: true | RequirementCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RequirementMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RequirementMaxAggregateInputType;
  };

  export type GetRequirementAggregateType<T extends RequirementAggregateArgs> =
    {
      [P in keyof T & keyof AggregateRequirement]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateRequirement[P]>
        : GetScalarType<T[P], AggregateRequirement[P]>;
    };

  export type RequirementGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RequirementWhereInput;
    orderBy?:
      | RequirementOrderByWithAggregationInput
      | RequirementOrderByWithAggregationInput[];
    by: RequirementScalarFieldEnum[] | RequirementScalarFieldEnum;
    having?: RequirementScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RequirementCountAggregateInputType | true;
    _min?: RequirementMinAggregateInputType;
    _max?: RequirementMaxAggregateInputType;
  };

  export type RequirementGroupByOutputType = {
    id: string;
    title: string;
    description: string;
    acceptanceCriteria: JsonValue;
    priority: $Enums.Priority;
    status: $Enums.RequirementStatus;
    estimatedEffort: string | null;
    dependencies: JsonValue | null;
    businessValue: string | null;
    riskAssessment: string | null;
    stakeholders: JsonValue | null;
    approvedBy: string | null;
    approvedAt: Date | null;
    rejectionReason: string | null;
    solutionId: string;
    createdBy: string;
    createdAt: Date;
    updatedAt: Date;
    _count: RequirementCountAggregateOutputType | null;
    _min: RequirementMinAggregateOutputType | null;
    _max: RequirementMaxAggregateOutputType | null;
  };

  type GetRequirementGroupByPayload<T extends RequirementGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<RequirementGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof RequirementGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequirementGroupByOutputType[P]>
            : GetScalarType<T[P], RequirementGroupByOutputType[P]>;
        }
      >
    >;

  export type RequirementSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      acceptanceCriteria?: boolean;
      priority?: boolean;
      status?: boolean;
      estimatedEffort?: boolean;
      dependencies?: boolean;
      businessValue?: boolean;
      riskAssessment?: boolean;
      stakeholders?: boolean;
      approvedBy?: boolean;
      approvedAt?: boolean;
      rejectionReason?: boolean;
      solutionId?: boolean;
      createdBy?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      solution?: boolean | SolutionDefaultArgs<ExtArgs>;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
      comments?: boolean | Requirement$commentsArgs<ExtArgs>;
      _count?: boolean | RequirementCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['requirement']
  >;

  export type RequirementSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      acceptanceCriteria?: boolean;
      priority?: boolean;
      status?: boolean;
      estimatedEffort?: boolean;
      dependencies?: boolean;
      businessValue?: boolean;
      riskAssessment?: boolean;
      stakeholders?: boolean;
      approvedBy?: boolean;
      approvedAt?: boolean;
      rejectionReason?: boolean;
      solutionId?: boolean;
      createdBy?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      solution?: boolean | SolutionDefaultArgs<ExtArgs>;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['requirement']
  >;

  export type RequirementSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      acceptanceCriteria?: boolean;
      priority?: boolean;
      status?: boolean;
      estimatedEffort?: boolean;
      dependencies?: boolean;
      businessValue?: boolean;
      riskAssessment?: boolean;
      stakeholders?: boolean;
      approvedBy?: boolean;
      approvedAt?: boolean;
      rejectionReason?: boolean;
      solutionId?: boolean;
      createdBy?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      solution?: boolean | SolutionDefaultArgs<ExtArgs>;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['requirement']
  >;

  export type RequirementSelectScalar = {
    id?: boolean;
    title?: boolean;
    description?: boolean;
    acceptanceCriteria?: boolean;
    priority?: boolean;
    status?: boolean;
    estimatedEffort?: boolean;
    dependencies?: boolean;
    businessValue?: boolean;
    riskAssessment?: boolean;
    stakeholders?: boolean;
    approvedBy?: boolean;
    approvedAt?: boolean;
    rejectionReason?: boolean;
    solutionId?: boolean;
    createdBy?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type RequirementOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'title'
    | 'description'
    | 'acceptanceCriteria'
    | 'priority'
    | 'status'
    | 'estimatedEffort'
    | 'dependencies'
    | 'businessValue'
    | 'riskAssessment'
    | 'stakeholders'
    | 'approvedBy'
    | 'approvedAt'
    | 'rejectionReason'
    | 'solutionId'
    | 'createdBy'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['requirement']
  >;
  export type RequirementInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    solution?: boolean | SolutionDefaultArgs<ExtArgs>;
    creator?: boolean | UserDefaultArgs<ExtArgs>;
    comments?: boolean | Requirement$commentsArgs<ExtArgs>;
    _count?: boolean | RequirementCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type RequirementIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    solution?: boolean | SolutionDefaultArgs<ExtArgs>;
    creator?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type RequirementIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    solution?: boolean | SolutionDefaultArgs<ExtArgs>;
    creator?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $RequirementPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Requirement';
    objects: {
      solution: Prisma.$SolutionPayload<ExtArgs>;
      creator: Prisma.$UserPayload<ExtArgs>;
      comments: Prisma.$CommentPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        title: string;
        description: string;
        acceptanceCriteria: Prisma.JsonValue;
        priority: $Enums.Priority;
        status: $Enums.RequirementStatus;
        estimatedEffort: string | null;
        dependencies: Prisma.JsonValue | null;
        businessValue: string | null;
        riskAssessment: string | null;
        stakeholders: Prisma.JsonValue | null;
        approvedBy: string | null;
        approvedAt: Date | null;
        rejectionReason: string | null;
        solutionId: string;
        createdBy: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['requirement']
    >;
    composites: {};
  };

  type RequirementGetPayload<
    S extends boolean | null | undefined | RequirementDefaultArgs,
  > = $Result.GetResult<Prisma.$RequirementPayload, S>;

  type RequirementCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    RequirementFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: RequirementCountAggregateInputType | true;
  };

  export interface RequirementDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Requirement'];
      meta: { name: 'Requirement' };
    };
    /**
     * Find zero or one Requirement that matches the filter.
     * @param {RequirementFindUniqueArgs} args - Arguments to find a Requirement
     * @example
     * // Get one Requirement
     * const requirement = await prisma.requirement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequirementFindUniqueArgs>(
      args: SelectSubset<T, RequirementFindUniqueArgs<ExtArgs>>
    ): Prisma__RequirementClient<
      $Result.GetResult<
        Prisma.$RequirementPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Requirement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequirementFindUniqueOrThrowArgs} args - Arguments to find a Requirement
     * @example
     * // Get one Requirement
     * const requirement = await prisma.requirement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequirementFindUniqueOrThrowArgs>(
      args: SelectSubset<T, RequirementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RequirementClient<
      $Result.GetResult<
        Prisma.$RequirementPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Requirement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementFindFirstArgs} args - Arguments to find a Requirement
     * @example
     * // Get one Requirement
     * const requirement = await prisma.requirement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequirementFindFirstArgs>(
      args?: SelectSubset<T, RequirementFindFirstArgs<ExtArgs>>
    ): Prisma__RequirementClient<
      $Result.GetResult<
        Prisma.$RequirementPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Requirement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementFindFirstOrThrowArgs} args - Arguments to find a Requirement
     * @example
     * // Get one Requirement
     * const requirement = await prisma.requirement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequirementFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RequirementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RequirementClient<
      $Result.GetResult<
        Prisma.$RequirementPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Requirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Requirements
     * const requirements = await prisma.requirement.findMany()
     *
     * // Get first 10 Requirements
     * const requirements = await prisma.requirement.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const requirementWithIdOnly = await prisma.requirement.findMany({ select: { id: true } })
     *
     */
    findMany<T extends RequirementFindManyArgs>(
      args?: SelectSubset<T, RequirementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RequirementPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Requirement.
     * @param {RequirementCreateArgs} args - Arguments to create a Requirement.
     * @example
     * // Create one Requirement
     * const Requirement = await prisma.requirement.create({
     *   data: {
     *     // ... data to create a Requirement
     *   }
     * })
     *
     */
    create<T extends RequirementCreateArgs>(
      args: SelectSubset<T, RequirementCreateArgs<ExtArgs>>
    ): Prisma__RequirementClient<
      $Result.GetResult<
        Prisma.$RequirementPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Requirements.
     * @param {RequirementCreateManyArgs} args - Arguments to create many Requirements.
     * @example
     * // Create many Requirements
     * const requirement = await prisma.requirement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends RequirementCreateManyArgs>(
      args?: SelectSubset<T, RequirementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Requirements and returns the data saved in the database.
     * @param {RequirementCreateManyAndReturnArgs} args - Arguments to create many Requirements.
     * @example
     * // Create many Requirements
     * const requirement = await prisma.requirement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Requirements and only return the `id`
     * const requirementWithIdOnly = await prisma.requirement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends RequirementCreateManyAndReturnArgs>(
      args?: SelectSubset<T, RequirementCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RequirementPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Requirement.
     * @param {RequirementDeleteArgs} args - Arguments to delete one Requirement.
     * @example
     * // Delete one Requirement
     * const Requirement = await prisma.requirement.delete({
     *   where: {
     *     // ... filter to delete one Requirement
     *   }
     * })
     *
     */
    delete<T extends RequirementDeleteArgs>(
      args: SelectSubset<T, RequirementDeleteArgs<ExtArgs>>
    ): Prisma__RequirementClient<
      $Result.GetResult<
        Prisma.$RequirementPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Requirement.
     * @param {RequirementUpdateArgs} args - Arguments to update one Requirement.
     * @example
     * // Update one Requirement
     * const requirement = await prisma.requirement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends RequirementUpdateArgs>(
      args: SelectSubset<T, RequirementUpdateArgs<ExtArgs>>
    ): Prisma__RequirementClient<
      $Result.GetResult<
        Prisma.$RequirementPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Requirements.
     * @param {RequirementDeleteManyArgs} args - Arguments to filter Requirements to delete.
     * @example
     * // Delete a few Requirements
     * const { count } = await prisma.requirement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends RequirementDeleteManyArgs>(
      args?: SelectSubset<T, RequirementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Requirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Requirements
     * const requirement = await prisma.requirement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends RequirementUpdateManyArgs>(
      args: SelectSubset<T, RequirementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Requirements and returns the data updated in the database.
     * @param {RequirementUpdateManyAndReturnArgs} args - Arguments to update many Requirements.
     * @example
     * // Update many Requirements
     * const requirement = await prisma.requirement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Requirements and only return the `id`
     * const requirementWithIdOnly = await prisma.requirement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends RequirementUpdateManyAndReturnArgs>(
      args: SelectSubset<T, RequirementUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RequirementPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Requirement.
     * @param {RequirementUpsertArgs} args - Arguments to update or create a Requirement.
     * @example
     * // Update or create a Requirement
     * const requirement = await prisma.requirement.upsert({
     *   create: {
     *     // ... data to create a Requirement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Requirement we want to update
     *   }
     * })
     */
    upsert<T extends RequirementUpsertArgs>(
      args: SelectSubset<T, RequirementUpsertArgs<ExtArgs>>
    ): Prisma__RequirementClient<
      $Result.GetResult<
        Prisma.$RequirementPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Requirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementCountArgs} args - Arguments to filter Requirements to count.
     * @example
     * // Count the number of Requirements
     * const count = await prisma.requirement.count({
     *   where: {
     *     // ... the filter for the Requirements we want to count
     *   }
     * })
     **/
    count<T extends RequirementCountArgs>(
      args?: Subset<T, RequirementCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequirementCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Requirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RequirementAggregateArgs>(
      args: Subset<T, RequirementAggregateArgs>
    ): Prisma.PrismaPromise<GetRequirementAggregateType<T>>;

    /**
     * Group by Requirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RequirementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequirementGroupByArgs['orderBy'] }
        : { orderBy?: RequirementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, RequirementGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetRequirementGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Requirement model
     */
    readonly fields: RequirementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Requirement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequirementClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    solution<T extends SolutionDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, SolutionDefaultArgs<ExtArgs>>
    ): Prisma__SolutionClient<
      | $Result.GetResult<
          Prisma.$SolutionPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    comments<T extends Requirement$commentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Requirement$commentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CommentPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Requirement model
   */
  interface RequirementFieldRefs {
    readonly id: FieldRef<'Requirement', 'String'>;
    readonly title: FieldRef<'Requirement', 'String'>;
    readonly description: FieldRef<'Requirement', 'String'>;
    readonly acceptanceCriteria: FieldRef<'Requirement', 'Json'>;
    readonly priority: FieldRef<'Requirement', 'Priority'>;
    readonly status: FieldRef<'Requirement', 'RequirementStatus'>;
    readonly estimatedEffort: FieldRef<'Requirement', 'String'>;
    readonly dependencies: FieldRef<'Requirement', 'Json'>;
    readonly businessValue: FieldRef<'Requirement', 'String'>;
    readonly riskAssessment: FieldRef<'Requirement', 'String'>;
    readonly stakeholders: FieldRef<'Requirement', 'Json'>;
    readonly approvedBy: FieldRef<'Requirement', 'String'>;
    readonly approvedAt: FieldRef<'Requirement', 'DateTime'>;
    readonly rejectionReason: FieldRef<'Requirement', 'String'>;
    readonly solutionId: FieldRef<'Requirement', 'String'>;
    readonly createdBy: FieldRef<'Requirement', 'String'>;
    readonly createdAt: FieldRef<'Requirement', 'DateTime'>;
    readonly updatedAt: FieldRef<'Requirement', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Requirement findUnique
   */
  export type RequirementFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null;
    /**
     * Filter, which Requirement to fetch.
     */
    where: RequirementWhereUniqueInput;
  };

  /**
   * Requirement findUniqueOrThrow
   */
  export type RequirementFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null;
    /**
     * Filter, which Requirement to fetch.
     */
    where: RequirementWhereUniqueInput;
  };

  /**
   * Requirement findFirst
   */
  export type RequirementFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null;
    /**
     * Filter, which Requirement to fetch.
     */
    where?: RequirementWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Requirements to fetch.
     */
    orderBy?:
      | RequirementOrderByWithRelationInput
      | RequirementOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Requirements.
     */
    cursor?: RequirementWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Requirements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Requirements.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Requirements.
     */
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[];
  };

  /**
   * Requirement findFirstOrThrow
   */
  export type RequirementFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null;
    /**
     * Filter, which Requirement to fetch.
     */
    where?: RequirementWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Requirements to fetch.
     */
    orderBy?:
      | RequirementOrderByWithRelationInput
      | RequirementOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Requirements.
     */
    cursor?: RequirementWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Requirements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Requirements.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Requirements.
     */
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[];
  };

  /**
   * Requirement findMany
   */
  export type RequirementFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null;
    /**
     * Filter, which Requirements to fetch.
     */
    where?: RequirementWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Requirements to fetch.
     */
    orderBy?:
      | RequirementOrderByWithRelationInput
      | RequirementOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Requirements.
     */
    cursor?: RequirementWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Requirements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Requirements.
     */
    skip?: number;
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[];
  };

  /**
   * Requirement create
   */
  export type RequirementCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null;
    /**
     * The data needed to create a Requirement.
     */
    data: XOR<RequirementCreateInput, RequirementUncheckedCreateInput>;
  };

  /**
   * Requirement createMany
   */
  export type RequirementCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Requirements.
     */
    data: RequirementCreateManyInput | RequirementCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Requirement createManyAndReturn
   */
  export type RequirementCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null;
    /**
     * The data used to create many Requirements.
     */
    data: RequirementCreateManyInput | RequirementCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Requirement update
   */
  export type RequirementUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null;
    /**
     * The data needed to update a Requirement.
     */
    data: XOR<RequirementUpdateInput, RequirementUncheckedUpdateInput>;
    /**
     * Choose, which Requirement to update.
     */
    where: RequirementWhereUniqueInput;
  };

  /**
   * Requirement updateMany
   */
  export type RequirementUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Requirements.
     */
    data: XOR<
      RequirementUpdateManyMutationInput,
      RequirementUncheckedUpdateManyInput
    >;
    /**
     * Filter which Requirements to update
     */
    where?: RequirementWhereInput;
    /**
     * Limit how many Requirements to update.
     */
    limit?: number;
  };

  /**
   * Requirement updateManyAndReturn
   */
  export type RequirementUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null;
    /**
     * The data used to update Requirements.
     */
    data: XOR<
      RequirementUpdateManyMutationInput,
      RequirementUncheckedUpdateManyInput
    >;
    /**
     * Filter which Requirements to update
     */
    where?: RequirementWhereInput;
    /**
     * Limit how many Requirements to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Requirement upsert
   */
  export type RequirementUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null;
    /**
     * The filter to search for the Requirement to update in case it exists.
     */
    where: RequirementWhereUniqueInput;
    /**
     * In case the Requirement found by the `where` argument doesn't exist, create a new Requirement with this data.
     */
    create: XOR<RequirementCreateInput, RequirementUncheckedCreateInput>;
    /**
     * In case the Requirement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequirementUpdateInput, RequirementUncheckedUpdateInput>;
  };

  /**
   * Requirement delete
   */
  export type RequirementDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null;
    /**
     * Filter which Requirement to delete.
     */
    where: RequirementWhereUniqueInput;
  };

  /**
   * Requirement deleteMany
   */
  export type RequirementDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Requirements to delete
     */
    where?: RequirementWhereInput;
    /**
     * Limit how many Requirements to delete.
     */
    limit?: number;
  };

  /**
   * Requirement.comments
   */
  export type Requirement$commentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    where?: CommentWhereInput;
    orderBy?:
      | CommentOrderByWithRelationInput
      | CommentOrderByWithRelationInput[];
    cursor?: CommentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[];
  };

  /**
   * Requirement without action
   */
  export type RequirementDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null;
  };

  /**
   * Model FRDDocument
   */

  export type AggregateFRDDocument = {
    _count: FRDDocumentCountAggregateOutputType | null;
    _avg: FRDDocumentAvgAggregateOutputType | null;
    _sum: FRDDocumentSumAggregateOutputType | null;
    _min: FRDDocumentMinAggregateOutputType | null;
    _max: FRDDocumentMaxAggregateOutputType | null;
  };

  export type FRDDocumentAvgAggregateOutputType = {
    aiConfidence: number | null;
    generationTime: number | null;
    wordCount: number | null;
  };

  export type FRDDocumentSumAggregateOutputType = {
    aiConfidence: number | null;
    generationTime: number | null;
    wordCount: number | null;
  };

  export type FRDDocumentMinAggregateOutputType = {
    id: string | null;
    title: string | null;
    aiGenerated: boolean | null;
    aiConfidence: number | null;
    aiPromptUsed: string | null;
    version: string | null;
    status: $Enums.FRDStatus | null;
    executiveApproved: boolean | null;
    templateUsed: string | null;
    generationTime: number | null;
    wordCount: number | null;
    lastExportedAt: Date | null;
    solutionId: string | null;
    createdBy: string | null;
    approvedBy: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type FRDDocumentMaxAggregateOutputType = {
    id: string | null;
    title: string | null;
    aiGenerated: boolean | null;
    aiConfidence: number | null;
    aiPromptUsed: string | null;
    version: string | null;
    status: $Enums.FRDStatus | null;
    executiveApproved: boolean | null;
    templateUsed: string | null;
    generationTime: number | null;
    wordCount: number | null;
    lastExportedAt: Date | null;
    solutionId: string | null;
    createdBy: string | null;
    approvedBy: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type FRDDocumentCountAggregateOutputType = {
    id: number;
    title: number;
    content: number;
    aiGenerated: number;
    aiConfidence: number;
    aiPromptUsed: number;
    version: number;
    status: number;
    executiveApproved: number;
    exportFormats: number;
    templateUsed: number;
    generationTime: number;
    wordCount: number;
    lastExportedAt: number;
    solutionId: number;
    createdBy: number;
    approvedBy: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type FRDDocumentAvgAggregateInputType = {
    aiConfidence?: true;
    generationTime?: true;
    wordCount?: true;
  };

  export type FRDDocumentSumAggregateInputType = {
    aiConfidence?: true;
    generationTime?: true;
    wordCount?: true;
  };

  export type FRDDocumentMinAggregateInputType = {
    id?: true;
    title?: true;
    aiGenerated?: true;
    aiConfidence?: true;
    aiPromptUsed?: true;
    version?: true;
    status?: true;
    executiveApproved?: true;
    templateUsed?: true;
    generationTime?: true;
    wordCount?: true;
    lastExportedAt?: true;
    solutionId?: true;
    createdBy?: true;
    approvedBy?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type FRDDocumentMaxAggregateInputType = {
    id?: true;
    title?: true;
    aiGenerated?: true;
    aiConfidence?: true;
    aiPromptUsed?: true;
    version?: true;
    status?: true;
    executiveApproved?: true;
    templateUsed?: true;
    generationTime?: true;
    wordCount?: true;
    lastExportedAt?: true;
    solutionId?: true;
    createdBy?: true;
    approvedBy?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type FRDDocumentCountAggregateInputType = {
    id?: true;
    title?: true;
    content?: true;
    aiGenerated?: true;
    aiConfidence?: true;
    aiPromptUsed?: true;
    version?: true;
    status?: true;
    executiveApproved?: true;
    exportFormats?: true;
    templateUsed?: true;
    generationTime?: true;
    wordCount?: true;
    lastExportedAt?: true;
    solutionId?: true;
    createdBy?: true;
    approvedBy?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type FRDDocumentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FRDDocument to aggregate.
     */
    where?: FRDDocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FRDDocuments to fetch.
     */
    orderBy?:
      | FRDDocumentOrderByWithRelationInput
      | FRDDocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FRDDocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FRDDocuments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FRDDocuments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FRDDocuments
     **/
    _count?: true | FRDDocumentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FRDDocumentAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FRDDocumentSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FRDDocumentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FRDDocumentMaxAggregateInputType;
  };

  export type GetFRDDocumentAggregateType<T extends FRDDocumentAggregateArgs> =
    {
      [P in keyof T & keyof AggregateFRDDocument]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateFRDDocument[P]>
        : GetScalarType<T[P], AggregateFRDDocument[P]>;
    };

  export type FRDDocumentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FRDDocumentWhereInput;
    orderBy?:
      | FRDDocumentOrderByWithAggregationInput
      | FRDDocumentOrderByWithAggregationInput[];
    by: FRDDocumentScalarFieldEnum[] | FRDDocumentScalarFieldEnum;
    having?: FRDDocumentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FRDDocumentCountAggregateInputType | true;
    _avg?: FRDDocumentAvgAggregateInputType;
    _sum?: FRDDocumentSumAggregateInputType;
    _min?: FRDDocumentMinAggregateInputType;
    _max?: FRDDocumentMaxAggregateInputType;
  };

  export type FRDDocumentGroupByOutputType = {
    id: string;
    title: string;
    content: JsonValue;
    aiGenerated: boolean;
    aiConfidence: number | null;
    aiPromptUsed: string | null;
    version: string;
    status: $Enums.FRDStatus;
    executiveApproved: boolean;
    exportFormats: JsonValue | null;
    templateUsed: string | null;
    generationTime: number | null;
    wordCount: number | null;
    lastExportedAt: Date | null;
    solutionId: string;
    createdBy: string;
    approvedBy: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: FRDDocumentCountAggregateOutputType | null;
    _avg: FRDDocumentAvgAggregateOutputType | null;
    _sum: FRDDocumentSumAggregateOutputType | null;
    _min: FRDDocumentMinAggregateOutputType | null;
    _max: FRDDocumentMaxAggregateOutputType | null;
  };

  type GetFRDDocumentGroupByPayload<T extends FRDDocumentGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FRDDocumentGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof FRDDocumentGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FRDDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], FRDDocumentGroupByOutputType[P]>;
        }
      >
    >;

  export type FRDDocumentSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      content?: boolean;
      aiGenerated?: boolean;
      aiConfidence?: boolean;
      aiPromptUsed?: boolean;
      version?: boolean;
      status?: boolean;
      executiveApproved?: boolean;
      exportFormats?: boolean;
      templateUsed?: boolean;
      generationTime?: boolean;
      wordCount?: boolean;
      lastExportedAt?: boolean;
      solutionId?: boolean;
      createdBy?: boolean;
      approvedBy?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      solution?: boolean | SolutionDefaultArgs<ExtArgs>;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
      approver?: boolean | FRDDocument$approverArgs<ExtArgs>;
    },
    ExtArgs['result']['fRDDocument']
  >;

  export type FRDDocumentSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      content?: boolean;
      aiGenerated?: boolean;
      aiConfidence?: boolean;
      aiPromptUsed?: boolean;
      version?: boolean;
      status?: boolean;
      executiveApproved?: boolean;
      exportFormats?: boolean;
      templateUsed?: boolean;
      generationTime?: boolean;
      wordCount?: boolean;
      lastExportedAt?: boolean;
      solutionId?: boolean;
      createdBy?: boolean;
      approvedBy?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      solution?: boolean | SolutionDefaultArgs<ExtArgs>;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
      approver?: boolean | FRDDocument$approverArgs<ExtArgs>;
    },
    ExtArgs['result']['fRDDocument']
  >;

  export type FRDDocumentSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      content?: boolean;
      aiGenerated?: boolean;
      aiConfidence?: boolean;
      aiPromptUsed?: boolean;
      version?: boolean;
      status?: boolean;
      executiveApproved?: boolean;
      exportFormats?: boolean;
      templateUsed?: boolean;
      generationTime?: boolean;
      wordCount?: boolean;
      lastExportedAt?: boolean;
      solutionId?: boolean;
      createdBy?: boolean;
      approvedBy?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      solution?: boolean | SolutionDefaultArgs<ExtArgs>;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
      approver?: boolean | FRDDocument$approverArgs<ExtArgs>;
    },
    ExtArgs['result']['fRDDocument']
  >;

  export type FRDDocumentSelectScalar = {
    id?: boolean;
    title?: boolean;
    content?: boolean;
    aiGenerated?: boolean;
    aiConfidence?: boolean;
    aiPromptUsed?: boolean;
    version?: boolean;
    status?: boolean;
    executiveApproved?: boolean;
    exportFormats?: boolean;
    templateUsed?: boolean;
    generationTime?: boolean;
    wordCount?: boolean;
    lastExportedAt?: boolean;
    solutionId?: boolean;
    createdBy?: boolean;
    approvedBy?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type FRDDocumentOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'title'
    | 'content'
    | 'aiGenerated'
    | 'aiConfidence'
    | 'aiPromptUsed'
    | 'version'
    | 'status'
    | 'executiveApproved'
    | 'exportFormats'
    | 'templateUsed'
    | 'generationTime'
    | 'wordCount'
    | 'lastExportedAt'
    | 'solutionId'
    | 'createdBy'
    | 'approvedBy'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['fRDDocument']
  >;
  export type FRDDocumentInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    solution?: boolean | SolutionDefaultArgs<ExtArgs>;
    creator?: boolean | UserDefaultArgs<ExtArgs>;
    approver?: boolean | FRDDocument$approverArgs<ExtArgs>;
  };
  export type FRDDocumentIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    solution?: boolean | SolutionDefaultArgs<ExtArgs>;
    creator?: boolean | UserDefaultArgs<ExtArgs>;
    approver?: boolean | FRDDocument$approverArgs<ExtArgs>;
  };
  export type FRDDocumentIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    solution?: boolean | SolutionDefaultArgs<ExtArgs>;
    creator?: boolean | UserDefaultArgs<ExtArgs>;
    approver?: boolean | FRDDocument$approverArgs<ExtArgs>;
  };

  export type $FRDDocumentPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'FRDDocument';
    objects: {
      solution: Prisma.$SolutionPayload<ExtArgs>;
      creator: Prisma.$UserPayload<ExtArgs>;
      approver: Prisma.$UserPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        title: string;
        content: Prisma.JsonValue;
        aiGenerated: boolean;
        aiConfidence: number | null;
        aiPromptUsed: string | null;
        version: string;
        status: $Enums.FRDStatus;
        executiveApproved: boolean;
        exportFormats: Prisma.JsonValue | null;
        templateUsed: string | null;
        generationTime: number | null;
        wordCount: number | null;
        lastExportedAt: Date | null;
        solutionId: string;
        createdBy: string;
        approvedBy: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['fRDDocument']
    >;
    composites: {};
  };

  type FRDDocumentGetPayload<
    S extends boolean | null | undefined | FRDDocumentDefaultArgs,
  > = $Result.GetResult<Prisma.$FRDDocumentPayload, S>;

  type FRDDocumentCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    FRDDocumentFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: FRDDocumentCountAggregateInputType | true;
  };

  export interface FRDDocumentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['FRDDocument'];
      meta: { name: 'FRDDocument' };
    };
    /**
     * Find zero or one FRDDocument that matches the filter.
     * @param {FRDDocumentFindUniqueArgs} args - Arguments to find a FRDDocument
     * @example
     * // Get one FRDDocument
     * const fRDDocument = await prisma.fRDDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FRDDocumentFindUniqueArgs>(
      args: SelectSubset<T, FRDDocumentFindUniqueArgs<ExtArgs>>
    ): Prisma__FRDDocumentClient<
      $Result.GetResult<
        Prisma.$FRDDocumentPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one FRDDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FRDDocumentFindUniqueOrThrowArgs} args - Arguments to find a FRDDocument
     * @example
     * // Get one FRDDocument
     * const fRDDocument = await prisma.fRDDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FRDDocumentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FRDDocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FRDDocumentClient<
      $Result.GetResult<
        Prisma.$FRDDocumentPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FRDDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FRDDocumentFindFirstArgs} args - Arguments to find a FRDDocument
     * @example
     * // Get one FRDDocument
     * const fRDDocument = await prisma.fRDDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FRDDocumentFindFirstArgs>(
      args?: SelectSubset<T, FRDDocumentFindFirstArgs<ExtArgs>>
    ): Prisma__FRDDocumentClient<
      $Result.GetResult<
        Prisma.$FRDDocumentPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FRDDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FRDDocumentFindFirstOrThrowArgs} args - Arguments to find a FRDDocument
     * @example
     * // Get one FRDDocument
     * const fRDDocument = await prisma.fRDDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FRDDocumentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FRDDocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FRDDocumentClient<
      $Result.GetResult<
        Prisma.$FRDDocumentPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more FRDDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FRDDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FRDDocuments
     * const fRDDocuments = await prisma.fRDDocument.findMany()
     *
     * // Get first 10 FRDDocuments
     * const fRDDocuments = await prisma.fRDDocument.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const fRDDocumentWithIdOnly = await prisma.fRDDocument.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FRDDocumentFindManyArgs>(
      args?: SelectSubset<T, FRDDocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FRDDocumentPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a FRDDocument.
     * @param {FRDDocumentCreateArgs} args - Arguments to create a FRDDocument.
     * @example
     * // Create one FRDDocument
     * const FRDDocument = await prisma.fRDDocument.create({
     *   data: {
     *     // ... data to create a FRDDocument
     *   }
     * })
     *
     */
    create<T extends FRDDocumentCreateArgs>(
      args: SelectSubset<T, FRDDocumentCreateArgs<ExtArgs>>
    ): Prisma__FRDDocumentClient<
      $Result.GetResult<
        Prisma.$FRDDocumentPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many FRDDocuments.
     * @param {FRDDocumentCreateManyArgs} args - Arguments to create many FRDDocuments.
     * @example
     * // Create many FRDDocuments
     * const fRDDocument = await prisma.fRDDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FRDDocumentCreateManyArgs>(
      args?: SelectSubset<T, FRDDocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many FRDDocuments and returns the data saved in the database.
     * @param {FRDDocumentCreateManyAndReturnArgs} args - Arguments to create many FRDDocuments.
     * @example
     * // Create many FRDDocuments
     * const fRDDocument = await prisma.fRDDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many FRDDocuments and only return the `id`
     * const fRDDocumentWithIdOnly = await prisma.fRDDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FRDDocumentCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FRDDocumentCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FRDDocumentPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a FRDDocument.
     * @param {FRDDocumentDeleteArgs} args - Arguments to delete one FRDDocument.
     * @example
     * // Delete one FRDDocument
     * const FRDDocument = await prisma.fRDDocument.delete({
     *   where: {
     *     // ... filter to delete one FRDDocument
     *   }
     * })
     *
     */
    delete<T extends FRDDocumentDeleteArgs>(
      args: SelectSubset<T, FRDDocumentDeleteArgs<ExtArgs>>
    ): Prisma__FRDDocumentClient<
      $Result.GetResult<
        Prisma.$FRDDocumentPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one FRDDocument.
     * @param {FRDDocumentUpdateArgs} args - Arguments to update one FRDDocument.
     * @example
     * // Update one FRDDocument
     * const fRDDocument = await prisma.fRDDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FRDDocumentUpdateArgs>(
      args: SelectSubset<T, FRDDocumentUpdateArgs<ExtArgs>>
    ): Prisma__FRDDocumentClient<
      $Result.GetResult<
        Prisma.$FRDDocumentPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more FRDDocuments.
     * @param {FRDDocumentDeleteManyArgs} args - Arguments to filter FRDDocuments to delete.
     * @example
     * // Delete a few FRDDocuments
     * const { count } = await prisma.fRDDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FRDDocumentDeleteManyArgs>(
      args?: SelectSubset<T, FRDDocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FRDDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FRDDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FRDDocuments
     * const fRDDocument = await prisma.fRDDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FRDDocumentUpdateManyArgs>(
      args: SelectSubset<T, FRDDocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FRDDocuments and returns the data updated in the database.
     * @param {FRDDocumentUpdateManyAndReturnArgs} args - Arguments to update many FRDDocuments.
     * @example
     * // Update many FRDDocuments
     * const fRDDocument = await prisma.fRDDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more FRDDocuments and only return the `id`
     * const fRDDocumentWithIdOnly = await prisma.fRDDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends FRDDocumentUpdateManyAndReturnArgs>(
      args: SelectSubset<T, FRDDocumentUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FRDDocumentPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one FRDDocument.
     * @param {FRDDocumentUpsertArgs} args - Arguments to update or create a FRDDocument.
     * @example
     * // Update or create a FRDDocument
     * const fRDDocument = await prisma.fRDDocument.upsert({
     *   create: {
     *     // ... data to create a FRDDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FRDDocument we want to update
     *   }
     * })
     */
    upsert<T extends FRDDocumentUpsertArgs>(
      args: SelectSubset<T, FRDDocumentUpsertArgs<ExtArgs>>
    ): Prisma__FRDDocumentClient<
      $Result.GetResult<
        Prisma.$FRDDocumentPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of FRDDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FRDDocumentCountArgs} args - Arguments to filter FRDDocuments to count.
     * @example
     * // Count the number of FRDDocuments
     * const count = await prisma.fRDDocument.count({
     *   where: {
     *     // ... the filter for the FRDDocuments we want to count
     *   }
     * })
     **/
    count<T extends FRDDocumentCountArgs>(
      args?: Subset<T, FRDDocumentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FRDDocumentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a FRDDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FRDDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FRDDocumentAggregateArgs>(
      args: Subset<T, FRDDocumentAggregateArgs>
    ): Prisma.PrismaPromise<GetFRDDocumentAggregateType<T>>;

    /**
     * Group by FRDDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FRDDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FRDDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FRDDocumentGroupByArgs['orderBy'] }
        : { orderBy?: FRDDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FRDDocumentGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetFRDDocumentGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the FRDDocument model
     */
    readonly fields: FRDDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FRDDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FRDDocumentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    solution<T extends SolutionDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, SolutionDefaultArgs<ExtArgs>>
    ): Prisma__SolutionClient<
      | $Result.GetResult<
          Prisma.$SolutionPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    approver<T extends FRDDocument$approverArgs<ExtArgs> = {}>(
      args?: Subset<T, FRDDocument$approverArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the FRDDocument model
   */
  interface FRDDocumentFieldRefs {
    readonly id: FieldRef<'FRDDocument', 'String'>;
    readonly title: FieldRef<'FRDDocument', 'String'>;
    readonly content: FieldRef<'FRDDocument', 'Json'>;
    readonly aiGenerated: FieldRef<'FRDDocument', 'Boolean'>;
    readonly aiConfidence: FieldRef<'FRDDocument', 'Float'>;
    readonly aiPromptUsed: FieldRef<'FRDDocument', 'String'>;
    readonly version: FieldRef<'FRDDocument', 'String'>;
    readonly status: FieldRef<'FRDDocument', 'FRDStatus'>;
    readonly executiveApproved: FieldRef<'FRDDocument', 'Boolean'>;
    readonly exportFormats: FieldRef<'FRDDocument', 'Json'>;
    readonly templateUsed: FieldRef<'FRDDocument', 'String'>;
    readonly generationTime: FieldRef<'FRDDocument', 'Float'>;
    readonly wordCount: FieldRef<'FRDDocument', 'Int'>;
    readonly lastExportedAt: FieldRef<'FRDDocument', 'DateTime'>;
    readonly solutionId: FieldRef<'FRDDocument', 'String'>;
    readonly createdBy: FieldRef<'FRDDocument', 'String'>;
    readonly approvedBy: FieldRef<'FRDDocument', 'String'>;
    readonly createdAt: FieldRef<'FRDDocument', 'DateTime'>;
    readonly updatedAt: FieldRef<'FRDDocument', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * FRDDocument findUnique
   */
  export type FRDDocumentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null;
    /**
     * Filter, which FRDDocument to fetch.
     */
    where: FRDDocumentWhereUniqueInput;
  };

  /**
   * FRDDocument findUniqueOrThrow
   */
  export type FRDDocumentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null;
    /**
     * Filter, which FRDDocument to fetch.
     */
    where: FRDDocumentWhereUniqueInput;
  };

  /**
   * FRDDocument findFirst
   */
  export type FRDDocumentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null;
    /**
     * Filter, which FRDDocument to fetch.
     */
    where?: FRDDocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FRDDocuments to fetch.
     */
    orderBy?:
      | FRDDocumentOrderByWithRelationInput
      | FRDDocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FRDDocuments.
     */
    cursor?: FRDDocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FRDDocuments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FRDDocuments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FRDDocuments.
     */
    distinct?: FRDDocumentScalarFieldEnum | FRDDocumentScalarFieldEnum[];
  };

  /**
   * FRDDocument findFirstOrThrow
   */
  export type FRDDocumentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null;
    /**
     * Filter, which FRDDocument to fetch.
     */
    where?: FRDDocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FRDDocuments to fetch.
     */
    orderBy?:
      | FRDDocumentOrderByWithRelationInput
      | FRDDocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FRDDocuments.
     */
    cursor?: FRDDocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FRDDocuments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FRDDocuments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FRDDocuments.
     */
    distinct?: FRDDocumentScalarFieldEnum | FRDDocumentScalarFieldEnum[];
  };

  /**
   * FRDDocument findMany
   */
  export type FRDDocumentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null;
    /**
     * Filter, which FRDDocuments to fetch.
     */
    where?: FRDDocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FRDDocuments to fetch.
     */
    orderBy?:
      | FRDDocumentOrderByWithRelationInput
      | FRDDocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FRDDocuments.
     */
    cursor?: FRDDocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FRDDocuments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FRDDocuments.
     */
    skip?: number;
    distinct?: FRDDocumentScalarFieldEnum | FRDDocumentScalarFieldEnum[];
  };

  /**
   * FRDDocument create
   */
  export type FRDDocumentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null;
    /**
     * The data needed to create a FRDDocument.
     */
    data: XOR<FRDDocumentCreateInput, FRDDocumentUncheckedCreateInput>;
  };

  /**
   * FRDDocument createMany
   */
  export type FRDDocumentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FRDDocuments.
     */
    data: FRDDocumentCreateManyInput | FRDDocumentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * FRDDocument createManyAndReturn
   */
  export type FRDDocumentCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null;
    /**
     * The data used to create many FRDDocuments.
     */
    data: FRDDocumentCreateManyInput | FRDDocumentCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * FRDDocument update
   */
  export type FRDDocumentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null;
    /**
     * The data needed to update a FRDDocument.
     */
    data: XOR<FRDDocumentUpdateInput, FRDDocumentUncheckedUpdateInput>;
    /**
     * Choose, which FRDDocument to update.
     */
    where: FRDDocumentWhereUniqueInput;
  };

  /**
   * FRDDocument updateMany
   */
  export type FRDDocumentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FRDDocuments.
     */
    data: XOR<
      FRDDocumentUpdateManyMutationInput,
      FRDDocumentUncheckedUpdateManyInput
    >;
    /**
     * Filter which FRDDocuments to update
     */
    where?: FRDDocumentWhereInput;
    /**
     * Limit how many FRDDocuments to update.
     */
    limit?: number;
  };

  /**
   * FRDDocument updateManyAndReturn
   */
  export type FRDDocumentUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null;
    /**
     * The data used to update FRDDocuments.
     */
    data: XOR<
      FRDDocumentUpdateManyMutationInput,
      FRDDocumentUncheckedUpdateManyInput
    >;
    /**
     * Filter which FRDDocuments to update
     */
    where?: FRDDocumentWhereInput;
    /**
     * Limit how many FRDDocuments to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * FRDDocument upsert
   */
  export type FRDDocumentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null;
    /**
     * The filter to search for the FRDDocument to update in case it exists.
     */
    where: FRDDocumentWhereUniqueInput;
    /**
     * In case the FRDDocument found by the `where` argument doesn't exist, create a new FRDDocument with this data.
     */
    create: XOR<FRDDocumentCreateInput, FRDDocumentUncheckedCreateInput>;
    /**
     * In case the FRDDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FRDDocumentUpdateInput, FRDDocumentUncheckedUpdateInput>;
  };

  /**
   * FRDDocument delete
   */
  export type FRDDocumentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null;
    /**
     * Filter which FRDDocument to delete.
     */
    where: FRDDocumentWhereUniqueInput;
  };

  /**
   * FRDDocument deleteMany
   */
  export type FRDDocumentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FRDDocuments to delete
     */
    where?: FRDDocumentWhereInput;
    /**
     * Limit how many FRDDocuments to delete.
     */
    limit?: number;
  };

  /**
   * FRDDocument.approver
   */
  export type FRDDocument$approverArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * FRDDocument without action
   */
  export type FRDDocumentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null;
  };

  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null;
    _min: AuditLogMinAggregateOutputType | null;
    _max: AuditLogMaxAggregateOutputType | null;
  };

  export type AuditLogMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    action: string | null;
    entityType: string | null;
    entityId: string | null;
    ipAddress: string | null;
    userAgent: string | null;
    createdAt: Date | null;
  };

  export type AuditLogMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    action: string | null;
    entityType: string | null;
    entityId: string | null;
    ipAddress: string | null;
    userAgent: string | null;
    createdAt: Date | null;
  };

  export type AuditLogCountAggregateOutputType = {
    id: number;
    userId: number;
    action: number;
    entityType: number;
    entityId: number;
    changes: number;
    metadata: number;
    ipAddress: number;
    userAgent: number;
    createdAt: number;
    _all: number;
  };

  export type AuditLogMinAggregateInputType = {
    id?: true;
    userId?: true;
    action?: true;
    entityType?: true;
    entityId?: true;
    ipAddress?: true;
    userAgent?: true;
    createdAt?: true;
  };

  export type AuditLogMaxAggregateInputType = {
    id?: true;
    userId?: true;
    action?: true;
    entityType?: true;
    entityId?: true;
    ipAddress?: true;
    userAgent?: true;
    createdAt?: true;
  };

  export type AuditLogCountAggregateInputType = {
    id?: true;
    userId?: true;
    action?: true;
    entityType?: true;
    entityId?: true;
    changes?: true;
    metadata?: true;
    ipAddress?: true;
    userAgent?: true;
    createdAt?: true;
    _all?: true;
  };

  export type AuditLogAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?:
      | AuditLogOrderByWithRelationInput
      | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AuditLogs
     **/
    _count?: true | AuditLogCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AuditLogMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AuditLogMaxAggregateInputType;
  };

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
    [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>;
  };

  export type AuditLogGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AuditLogWhereInput;
    orderBy?:
      | AuditLogOrderByWithAggregationInput
      | AuditLogOrderByWithAggregationInput[];
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum;
    having?: AuditLogScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AuditLogCountAggregateInputType | true;
    _min?: AuditLogMinAggregateInputType;
    _max?: AuditLogMaxAggregateInputType;
  };

  export type AuditLogGroupByOutputType = {
    id: string;
    userId: string;
    action: string;
    entityType: string;
    entityId: string;
    changes: JsonValue | null;
    metadata: JsonValue | null;
    ipAddress: string | null;
    userAgent: string | null;
    createdAt: Date;
    _count: AuditLogCountAggregateOutputType | null;
    _min: AuditLogMinAggregateOutputType | null;
    _max: AuditLogMaxAggregateOutputType | null;
  };

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AuditLogGroupByOutputType, T['by']> & {
          [P in keyof T & keyof AuditLogGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>;
        }
      >
    >;

  export type AuditLogSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      action?: boolean;
      entityType?: boolean;
      entityId?: boolean;
      changes?: boolean;
      metadata?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['auditLog']
  >;

  export type AuditLogSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      action?: boolean;
      entityType?: boolean;
      entityId?: boolean;
      changes?: boolean;
      metadata?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['auditLog']
  >;

  export type AuditLogSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      action?: boolean;
      entityType?: boolean;
      entityId?: boolean;
      changes?: boolean;
      metadata?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['auditLog']
  >;

  export type AuditLogSelectScalar = {
    id?: boolean;
    userId?: boolean;
    action?: boolean;
    entityType?: boolean;
    entityId?: boolean;
    changes?: boolean;
    metadata?: boolean;
    ipAddress?: boolean;
    userAgent?: boolean;
    createdAt?: boolean;
  };

  export type AuditLogOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'userId'
    | 'action'
    | 'entityType'
    | 'entityId'
    | 'changes'
    | 'metadata'
    | 'ipAddress'
    | 'userAgent'
    | 'createdAt',
    ExtArgs['result']['auditLog']
  >;
  export type AuditLogInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type AuditLogIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type AuditLogIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $AuditLogPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'AuditLog';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        action: string;
        entityType: string;
        entityId: string;
        changes: Prisma.JsonValue | null;
        metadata: Prisma.JsonValue | null;
        ipAddress: string | null;
        userAgent: string | null;
        createdAt: Date;
      },
      ExtArgs['result']['auditLog']
    >;
    composites: {};
  };

  type AuditLogGetPayload<
    S extends boolean | null | undefined | AuditLogDefaultArgs,
  > = $Result.GetResult<Prisma.$AuditLogPayload, S>;

  type AuditLogCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: AuditLogCountAggregateInputType | true;
  };

  export interface AuditLogDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'];
      meta: { name: 'AuditLog' };
    };
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(
      args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(
      args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     *
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AuditLogFindManyArgs>(
      args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     *
     */
    create<T extends AuditLogCreateArgs>(
      args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AuditLogCreateManyArgs>(
      args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     *
     */
    delete<T extends AuditLogDeleteArgs>(
      args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AuditLogUpdateArgs>(
      args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(
      args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AuditLogUpdateManyArgs>(
      args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(
      args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
     **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AuditLogAggregateArgs>(
      args: Subset<T, AuditLogAggregateArgs>
    ): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>;

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAuditLogGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AuditLog model
     */
    readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<'AuditLog', 'String'>;
    readonly userId: FieldRef<'AuditLog', 'String'>;
    readonly action: FieldRef<'AuditLog', 'String'>;
    readonly entityType: FieldRef<'AuditLog', 'String'>;
    readonly entityId: FieldRef<'AuditLog', 'String'>;
    readonly changes: FieldRef<'AuditLog', 'Json'>;
    readonly metadata: FieldRef<'AuditLog', 'Json'>;
    readonly ipAddress: FieldRef<'AuditLog', 'String'>;
    readonly userAgent: FieldRef<'AuditLog', 'String'>;
    readonly createdAt: FieldRef<'AuditLog', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?:
      | AuditLogOrderByWithRelationInput
      | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?:
      | AuditLogOrderByWithRelationInput
      | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?:
      | AuditLogOrderByWithRelationInput
      | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>;
  };

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>;
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<
      AuditLogUpdateManyMutationInput,
      AuditLogUncheckedUpdateManyInput
    >;
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput;
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number;
  };

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<
      AuditLogUpdateManyMutationInput,
      AuditLogUncheckedUpdateManyInput
    >;
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput;
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput;
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>;
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>;
  };

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput;
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number;
  };

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
  };

  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null;
    _min: NotificationMinAggregateOutputType | null;
    _max: NotificationMaxAggregateOutputType | null;
  };

  export type NotificationMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    type: $Enums.NotificationType | null;
    title: string | null;
    message: string | null;
    readAt: Date | null;
    createdAt: Date | null;
  };

  export type NotificationMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    type: $Enums.NotificationType | null;
    title: string | null;
    message: string | null;
    readAt: Date | null;
    createdAt: Date | null;
  };

  export type NotificationCountAggregateOutputType = {
    id: number;
    userId: number;
    type: number;
    title: number;
    message: number;
    readAt: number;
    data: number;
    createdAt: number;
    _all: number;
  };

  export type NotificationMinAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    title?: true;
    message?: true;
    readAt?: true;
    createdAt?: true;
  };

  export type NotificationMaxAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    title?: true;
    message?: true;
    readAt?: true;
    createdAt?: true;
  };

  export type NotificationCountAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    title?: true;
    message?: true;
    readAt?: true;
    data?: true;
    createdAt?: true;
    _all?: true;
  };

  export type NotificationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?:
      | NotificationOrderByWithRelationInput
      | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Notifications
     **/
    _count?: true | NotificationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NotificationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NotificationMaxAggregateInputType;
  };

  export type GetNotificationAggregateType<
    T extends NotificationAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>;
  };

  export type NotificationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationWhereInput;
    orderBy?:
      | NotificationOrderByWithAggregationInput
      | NotificationOrderByWithAggregationInput[];
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum;
    having?: NotificationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificationCountAggregateInputType | true;
    _min?: NotificationMinAggregateInputType;
    _max?: NotificationMaxAggregateInputType;
  };

  export type NotificationGroupByOutputType = {
    id: string;
    userId: string;
    type: $Enums.NotificationType;
    title: string;
    message: string;
    readAt: Date | null;
    data: JsonValue | null;
    createdAt: Date;
    _count: NotificationCountAggregateOutputType | null;
    _min: NotificationMinAggregateOutputType | null;
    _max: NotificationMaxAggregateOutputType | null;
  };

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<NotificationGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof NotificationGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>;
        }
      >
    >;

  export type NotificationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      type?: boolean;
      title?: boolean;
      message?: boolean;
      readAt?: boolean;
      data?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notification']
  >;

  export type NotificationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      type?: boolean;
      title?: boolean;
      message?: boolean;
      readAt?: boolean;
      data?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notification']
  >;

  export type NotificationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      type?: boolean;
      title?: boolean;
      message?: boolean;
      readAt?: boolean;
      data?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notification']
  >;

  export type NotificationSelectScalar = {
    id?: boolean;
    userId?: boolean;
    type?: boolean;
    title?: boolean;
    message?: boolean;
    readAt?: boolean;
    data?: boolean;
    createdAt?: boolean;
  };

  export type NotificationOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'userId'
    | 'type'
    | 'title'
    | 'message'
    | 'readAt'
    | 'data'
    | 'createdAt',
    ExtArgs['result']['notification']
  >;
  export type NotificationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type NotificationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type NotificationIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $NotificationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Notification';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        type: $Enums.NotificationType;
        title: string;
        message: string;
        readAt: Date | null;
        data: Prisma.JsonValue | null;
        createdAt: Date;
      },
      ExtArgs['result']['notification']
    >;
    composites: {};
  };

  type NotificationGetPayload<
    S extends boolean | null | undefined | NotificationDefaultArgs,
  > = $Result.GetResult<Prisma.$NotificationPayload, S>;

  type NotificationCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    NotificationFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: NotificationCountAggregateInputType | true;
  };

  export interface NotificationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Notification'];
      meta: { name: 'Notification' };
    };
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(
      args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(
      args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     *
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     *
     */
    findMany<T extends NotificationFindManyArgs>(
      args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     *
     */
    create<T extends NotificationCreateArgs>(
      args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificationCreateManyArgs>(
      args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     *
     */
    delete<T extends NotificationDeleteArgs>(
      args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificationUpdateArgs>(
      args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificationDeleteManyArgs>(
      args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificationUpdateManyArgs>(
      args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(
      args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
     **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NotificationAggregateArgs>(
      args: Subset<T, NotificationAggregateArgs>
    ): Prisma.PrismaPromise<GetNotificationAggregateType<T>>;

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetNotificationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Notification model
     */
    readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<'Notification', 'String'>;
    readonly userId: FieldRef<'Notification', 'String'>;
    readonly type: FieldRef<'Notification', 'NotificationType'>;
    readonly title: FieldRef<'Notification', 'String'>;
    readonly message: FieldRef<'Notification', 'String'>;
    readonly readAt: FieldRef<'Notification', 'DateTime'>;
    readonly data: FieldRef<'Notification', 'Json'>;
    readonly createdAt: FieldRef<'Notification', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?:
      | NotificationOrderByWithRelationInput
      | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?:
      | NotificationOrderByWithRelationInput
      | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?:
      | NotificationOrderByWithRelationInput
      | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification create
   */
  export type NotificationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>;
  };

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>;
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<
      NotificationUpdateManyMutationInput,
      NotificationUncheckedUpdateManyInput
    >;
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to update.
     */
    limit?: number;
  };

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * The data used to update Notifications.
     */
    data: XOR<
      NotificationUpdateManyMutationInput,
      NotificationUncheckedUpdateManyInput
    >;
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput;
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>;
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>;
  };

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number;
  };

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted';
    ReadCommitted: 'ReadCommitted';
    RepeatableRead: 'RepeatableRead';
    Serializable: 'Serializable';
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const UserScalarFieldEnum: {
    id: 'id';
    email: 'email';
    name: 'name';
    role: 'role';
    department: 'department';
    avatar: 'avatar';
    passwordHash: 'passwordHash';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type UserScalarFieldEnum =
    (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const InputScalarFieldEnum: {
    id: 'id';
    title: 'title';
    description: 'description';
    type: 'type';
    status: 'status';
    createdBy: 'createdBy';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    department: 'department';
    issueType: 'issueType';
    rootCause: 'rootCause';
    priority: 'priority';
    aiProcessed: 'aiProcessed';
    aiTags: 'aiTags';
    aiSuggestions: 'aiSuggestions';
  };

  export type InputScalarFieldEnum =
    (typeof InputScalarFieldEnum)[keyof typeof InputScalarFieldEnum];

  export const CommentScalarFieldEnum: {
    id: 'id';
    content: 'content';
    authorId: 'authorId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    inputId: 'inputId';
    solutionId: 'solutionId';
    requirementId: 'requirementId';
    parentId: 'parentId';
  };

  export type CommentScalarFieldEnum =
    (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum];

  export const VoteScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    value: 'value';
    createdAt: 'createdAt';
    inputId: 'inputId';
    solutionId: 'solutionId';
  };

  export type VoteScalarFieldEnum =
    (typeof VoteScalarFieldEnum)[keyof typeof VoteScalarFieldEnum];

  export const InputGroupScalarFieldEnum: {
    id: 'id';
    name: 'name';
    description: 'description';
    ownerId: 'ownerId';
    status: 'status';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    aiSuggested: 'aiSuggested';
    aiSimilarity: 'aiSimilarity';
    aiTheme: 'aiTheme';
  };

  export type InputGroupScalarFieldEnum =
    (typeof InputGroupScalarFieldEnum)[keyof typeof InputGroupScalarFieldEnum];

  export const SolutionScalarFieldEnum: {
    id: 'id';
    title: 'title';
    description: 'description';
    ownerId: 'ownerId';
    status: 'status';
    priority: 'priority';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    estimatedEffort: 'estimatedEffort';
    targetCompletion: 'targetCompletion';
    actualCompletion: 'actualCompletion';
    successCriteria: 'successCriteria';
  };

  export type SolutionScalarFieldEnum =
    (typeof SolutionScalarFieldEnum)[keyof typeof SolutionScalarFieldEnum];

  export const TaskScalarFieldEnum: {
    id: 'id';
    title: 'title';
    description: 'description';
    solutionId: 'solutionId';
    assigneeId: 'assigneeId';
    status: 'status';
    priority: 'priority';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    estimatedHours: 'estimatedHours';
    actualHours: 'actualHours';
    dueDate: 'dueDate';
    dependencies: 'dependencies';
  };

  export type TaskScalarFieldEnum =
    (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum];

  export const RequirementScalarFieldEnum: {
    id: 'id';
    title: 'title';
    description: 'description';
    acceptanceCriteria: 'acceptanceCriteria';
    priority: 'priority';
    status: 'status';
    estimatedEffort: 'estimatedEffort';
    dependencies: 'dependencies';
    businessValue: 'businessValue';
    riskAssessment: 'riskAssessment';
    stakeholders: 'stakeholders';
    approvedBy: 'approvedBy';
    approvedAt: 'approvedAt';
    rejectionReason: 'rejectionReason';
    solutionId: 'solutionId';
    createdBy: 'createdBy';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type RequirementScalarFieldEnum =
    (typeof RequirementScalarFieldEnum)[keyof typeof RequirementScalarFieldEnum];

  export const FRDDocumentScalarFieldEnum: {
    id: 'id';
    title: 'title';
    content: 'content';
    aiGenerated: 'aiGenerated';
    aiConfidence: 'aiConfidence';
    aiPromptUsed: 'aiPromptUsed';
    version: 'version';
    status: 'status';
    executiveApproved: 'executiveApproved';
    exportFormats: 'exportFormats';
    templateUsed: 'templateUsed';
    generationTime: 'generationTime';
    wordCount: 'wordCount';
    lastExportedAt: 'lastExportedAt';
    solutionId: 'solutionId';
    createdBy: 'createdBy';
    approvedBy: 'approvedBy';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type FRDDocumentScalarFieldEnum =
    (typeof FRDDocumentScalarFieldEnum)[keyof typeof FRDDocumentScalarFieldEnum];

  export const AuditLogScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    action: 'action';
    entityType: 'entityType';
    entityId: 'entityId';
    changes: 'changes';
    metadata: 'metadata';
    ipAddress: 'ipAddress';
    userAgent: 'userAgent';
    createdAt: 'createdAt';
  };

  export type AuditLogScalarFieldEnum =
    (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum];

  export const NotificationScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    type: 'type';
    title: 'title';
    message: 'message';
    readAt: 'readAt';
    data: 'data';
    createdAt: 'createdAt';
  };

  export type NotificationScalarFieldEnum =
    (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum];

  export const SortOrder: {
    asc: 'asc';
    desc: 'desc';
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
  };

  export type NullableJsonNullValueInput =
    (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull;
  };

  export type JsonNullValueInput =
    (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput];

  export const QueryMode: {
    default: 'default';
    insensitive: 'insensitive';
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: 'first';
    last: 'last';
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };

  export type JsonNullValueFilter =
    (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'String'
  >;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'String[]'
  >;

  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'UserRole'
  >;

  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'UserRole[]'
  >;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime'
  >;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime[]'
  >;

  /**
   * Reference to a field of type 'InputType'
   */
  export type EnumInputTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'InputType'
  >;

  /**
   * Reference to a field of type 'InputType[]'
   */
  export type ListEnumInputTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'InputType[]'
  >;

  /**
   * Reference to a field of type 'InputStatus'
   */
  export type EnumInputStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'InputStatus'
  >;

  /**
   * Reference to a field of type 'InputStatus[]'
   */
  export type ListEnumInputStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'InputStatus[]'>;

  /**
   * Reference to a field of type 'IssueType'
   */
  export type EnumIssueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'IssueType'
  >;

  /**
   * Reference to a field of type 'IssueType[]'
   */
  export type ListEnumIssueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'IssueType[]'
  >;

  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Priority'
  >;

  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Priority[]'
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Boolean'
  >;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Json'
  >;

  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'QueryMode'
  >;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Int'
  >;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Int[]'
  >;

  /**
   * Reference to a field of type 'GroupStatus'
   */
  export type EnumGroupStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'GroupStatus'
  >;

  /**
   * Reference to a field of type 'GroupStatus[]'
   */
  export type ListEnumGroupStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'GroupStatus[]'>;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Float'
  >;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Float[]'
  >;

  /**
   * Reference to a field of type 'SolutionStatus'
   */
  export type EnumSolutionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'SolutionStatus'
  >;

  /**
   * Reference to a field of type 'SolutionStatus[]'
   */
  export type ListEnumSolutionStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'SolutionStatus[]'>;

  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'TaskStatus'
  >;

  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'TaskStatus[]'
  >;

  /**
   * Reference to a field of type 'RequirementStatus'
   */
  export type EnumRequirementStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'RequirementStatus'>;

  /**
   * Reference to a field of type 'RequirementStatus[]'
   */
  export type ListEnumRequirementStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'RequirementStatus[]'>;

  /**
   * Reference to a field of type 'FRDStatus'
   */
  export type EnumFRDStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'FRDStatus'
  >;

  /**
   * Reference to a field of type 'FRDStatus[]'
   */
  export type ListEnumFRDStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'FRDStatus[]'
  >;

  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'NotificationType'>;

  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'NotificationType[]'>;

  /**
   * Deep Input Types
   */

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: StringFilter<'User'> | string;
    email?: StringFilter<'User'> | string;
    name?: StringFilter<'User'> | string;
    role?: EnumUserRoleFilter<'User'> | $Enums.UserRole;
    department?: StringNullableFilter<'User'> | string | null;
    avatar?: StringNullableFilter<'User'> | string | null;
    passwordHash?: StringNullableFilter<'User'> | string | null;
    createdAt?: DateTimeFilter<'User'> | Date | string;
    updatedAt?: DateTimeFilter<'User'> | Date | string;
    inputs?: InputListRelationFilter;
    solutions?: SolutionListRelationFilter;
    comments?: CommentListRelationFilter;
    votes?: VoteListRelationFilter;
    requirements?: RequirementListRelationFilter;
    frdDocuments?: FRDDocumentListRelationFilter;
    approvedFRDs?: FRDDocumentListRelationFilter;
    auditLogs?: AuditLogListRelationFilter;
    notifications?: NotificationListRelationFilter;
    inputGroups?: InputGroupListRelationFilter;
    tasks?: TaskListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    id?: SortOrder;
    email?: SortOrder;
    name?: SortOrder;
    role?: SortOrder;
    department?: SortOrderInput | SortOrder;
    avatar?: SortOrderInput | SortOrder;
    passwordHash?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    inputs?: InputOrderByRelationAggregateInput;
    solutions?: SolutionOrderByRelationAggregateInput;
    comments?: CommentOrderByRelationAggregateInput;
    votes?: VoteOrderByRelationAggregateInput;
    requirements?: RequirementOrderByRelationAggregateInput;
    frdDocuments?: FRDDocumentOrderByRelationAggregateInput;
    approvedFRDs?: FRDDocumentOrderByRelationAggregateInput;
    auditLogs?: AuditLogOrderByRelationAggregateInput;
    notifications?: NotificationOrderByRelationAggregateInput;
    inputGroups?: InputGroupOrderByRelationAggregateInput;
    tasks?: TaskOrderByRelationAggregateInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      email?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      name?: StringFilter<'User'> | string;
      role?: EnumUserRoleFilter<'User'> | $Enums.UserRole;
      department?: StringNullableFilter<'User'> | string | null;
      avatar?: StringNullableFilter<'User'> | string | null;
      passwordHash?: StringNullableFilter<'User'> | string | null;
      createdAt?: DateTimeFilter<'User'> | Date | string;
      updatedAt?: DateTimeFilter<'User'> | Date | string;
      inputs?: InputListRelationFilter;
      solutions?: SolutionListRelationFilter;
      comments?: CommentListRelationFilter;
      votes?: VoteListRelationFilter;
      requirements?: RequirementListRelationFilter;
      frdDocuments?: FRDDocumentListRelationFilter;
      approvedFRDs?: FRDDocumentListRelationFilter;
      auditLogs?: AuditLogListRelationFilter;
      notifications?: NotificationListRelationFilter;
      inputGroups?: InputGroupListRelationFilter;
      tasks?: TaskListRelationFilter;
    },
    'id' | 'email'
  >;

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    email?: SortOrder;
    name?: SortOrder;
    role?: SortOrder;
    department?: SortOrderInput | SortOrder;
    avatar?: SortOrderInput | SortOrder;
    passwordHash?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'User'> | string;
    email?: StringWithAggregatesFilter<'User'> | string;
    name?: StringWithAggregatesFilter<'User'> | string;
    role?: EnumUserRoleWithAggregatesFilter<'User'> | $Enums.UserRole;
    department?: StringNullableWithAggregatesFilter<'User'> | string | null;
    avatar?: StringNullableWithAggregatesFilter<'User'> | string | null;
    passwordHash?: StringNullableWithAggregatesFilter<'User'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
  };

  export type InputWhereInput = {
    AND?: InputWhereInput | InputWhereInput[];
    OR?: InputWhereInput[];
    NOT?: InputWhereInput | InputWhereInput[];
    id?: StringFilter<'Input'> | string;
    title?: StringFilter<'Input'> | string;
    description?: StringFilter<'Input'> | string;
    type?: EnumInputTypeFilter<'Input'> | $Enums.InputType;
    status?: EnumInputStatusFilter<'Input'> | $Enums.InputStatus;
    createdBy?: StringFilter<'Input'> | string;
    createdAt?: DateTimeFilter<'Input'> | Date | string;
    updatedAt?: DateTimeFilter<'Input'> | Date | string;
    department?: StringNullableFilter<'Input'> | string | null;
    issueType?: EnumIssueTypeNullableFilter<'Input'> | $Enums.IssueType | null;
    rootCause?: StringNullableFilter<'Input'> | string | null;
    priority?: EnumPriorityFilter<'Input'> | $Enums.Priority;
    aiProcessed?: BoolFilter<'Input'> | boolean;
    aiTags?: JsonNullableFilter<'Input'>;
    aiSuggestions?: JsonNullableFilter<'Input'>;
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>;
    solutions?: SolutionListRelationFilter;
    comments?: CommentListRelationFilter;
    votes?: VoteListRelationFilter;
    groups?: InputGroupListRelationFilter;
  };

  export type InputOrderByWithRelationInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    type?: SortOrder;
    status?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    department?: SortOrderInput | SortOrder;
    issueType?: SortOrderInput | SortOrder;
    rootCause?: SortOrderInput | SortOrder;
    priority?: SortOrder;
    aiProcessed?: SortOrder;
    aiTags?: SortOrderInput | SortOrder;
    aiSuggestions?: SortOrderInput | SortOrder;
    creator?: UserOrderByWithRelationInput;
    solutions?: SolutionOrderByRelationAggregateInput;
    comments?: CommentOrderByRelationAggregateInput;
    votes?: VoteOrderByRelationAggregateInput;
    groups?: InputGroupOrderByRelationAggregateInput;
  };

  export type InputWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: InputWhereInput | InputWhereInput[];
      OR?: InputWhereInput[];
      NOT?: InputWhereInput | InputWhereInput[];
      title?: StringFilter<'Input'> | string;
      description?: StringFilter<'Input'> | string;
      type?: EnumInputTypeFilter<'Input'> | $Enums.InputType;
      status?: EnumInputStatusFilter<'Input'> | $Enums.InputStatus;
      createdBy?: StringFilter<'Input'> | string;
      createdAt?: DateTimeFilter<'Input'> | Date | string;
      updatedAt?: DateTimeFilter<'Input'> | Date | string;
      department?: StringNullableFilter<'Input'> | string | null;
      issueType?:
        | EnumIssueTypeNullableFilter<'Input'>
        | $Enums.IssueType
        | null;
      rootCause?: StringNullableFilter<'Input'> | string | null;
      priority?: EnumPriorityFilter<'Input'> | $Enums.Priority;
      aiProcessed?: BoolFilter<'Input'> | boolean;
      aiTags?: JsonNullableFilter<'Input'>;
      aiSuggestions?: JsonNullableFilter<'Input'>;
      creator?: XOR<UserScalarRelationFilter, UserWhereInput>;
      solutions?: SolutionListRelationFilter;
      comments?: CommentListRelationFilter;
      votes?: VoteListRelationFilter;
      groups?: InputGroupListRelationFilter;
    },
    'id'
  >;

  export type InputOrderByWithAggregationInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    type?: SortOrder;
    status?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    department?: SortOrderInput | SortOrder;
    issueType?: SortOrderInput | SortOrder;
    rootCause?: SortOrderInput | SortOrder;
    priority?: SortOrder;
    aiProcessed?: SortOrder;
    aiTags?: SortOrderInput | SortOrder;
    aiSuggestions?: SortOrderInput | SortOrder;
    _count?: InputCountOrderByAggregateInput;
    _max?: InputMaxOrderByAggregateInput;
    _min?: InputMinOrderByAggregateInput;
  };

  export type InputScalarWhereWithAggregatesInput = {
    AND?:
      | InputScalarWhereWithAggregatesInput
      | InputScalarWhereWithAggregatesInput[];
    OR?: InputScalarWhereWithAggregatesInput[];
    NOT?:
      | InputScalarWhereWithAggregatesInput
      | InputScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Input'> | string;
    title?: StringWithAggregatesFilter<'Input'> | string;
    description?: StringWithAggregatesFilter<'Input'> | string;
    type?: EnumInputTypeWithAggregatesFilter<'Input'> | $Enums.InputType;
    status?: EnumInputStatusWithAggregatesFilter<'Input'> | $Enums.InputStatus;
    createdBy?: StringWithAggregatesFilter<'Input'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'Input'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Input'> | Date | string;
    department?: StringNullableWithAggregatesFilter<'Input'> | string | null;
    issueType?:
      | EnumIssueTypeNullableWithAggregatesFilter<'Input'>
      | $Enums.IssueType
      | null;
    rootCause?: StringNullableWithAggregatesFilter<'Input'> | string | null;
    priority?: EnumPriorityWithAggregatesFilter<'Input'> | $Enums.Priority;
    aiProcessed?: BoolWithAggregatesFilter<'Input'> | boolean;
    aiTags?: JsonNullableWithAggregatesFilter<'Input'>;
    aiSuggestions?: JsonNullableWithAggregatesFilter<'Input'>;
  };

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[];
    OR?: CommentWhereInput[];
    NOT?: CommentWhereInput | CommentWhereInput[];
    id?: StringFilter<'Comment'> | string;
    content?: StringFilter<'Comment'> | string;
    authorId?: StringFilter<'Comment'> | string;
    createdAt?: DateTimeFilter<'Comment'> | Date | string;
    updatedAt?: DateTimeFilter<'Comment'> | Date | string;
    inputId?: StringNullableFilter<'Comment'> | string | null;
    solutionId?: StringNullableFilter<'Comment'> | string | null;
    requirementId?: StringNullableFilter<'Comment'> | string | null;
    parentId?: StringNullableFilter<'Comment'> | string | null;
    replies?: CommentListRelationFilter;
    author?: XOR<UserScalarRelationFilter, UserWhereInput>;
    input?: XOR<InputNullableScalarRelationFilter, InputWhereInput> | null;
    solution?: XOR<
      SolutionNullableScalarRelationFilter,
      SolutionWhereInput
    > | null;
    requirement?: XOR<
      RequirementNullableScalarRelationFilter,
      RequirementWhereInput
    > | null;
    parent?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null;
  };

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder;
    content?: SortOrder;
    authorId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    inputId?: SortOrderInput | SortOrder;
    solutionId?: SortOrderInput | SortOrder;
    requirementId?: SortOrderInput | SortOrder;
    parentId?: SortOrderInput | SortOrder;
    replies?: CommentOrderByRelationAggregateInput;
    author?: UserOrderByWithRelationInput;
    input?: InputOrderByWithRelationInput;
    solution?: SolutionOrderByWithRelationInput;
    requirement?: RequirementOrderByWithRelationInput;
    parent?: CommentOrderByWithRelationInput;
  };

  export type CommentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: CommentWhereInput | CommentWhereInput[];
      OR?: CommentWhereInput[];
      NOT?: CommentWhereInput | CommentWhereInput[];
      content?: StringFilter<'Comment'> | string;
      authorId?: StringFilter<'Comment'> | string;
      createdAt?: DateTimeFilter<'Comment'> | Date | string;
      updatedAt?: DateTimeFilter<'Comment'> | Date | string;
      inputId?: StringNullableFilter<'Comment'> | string | null;
      solutionId?: StringNullableFilter<'Comment'> | string | null;
      requirementId?: StringNullableFilter<'Comment'> | string | null;
      parentId?: StringNullableFilter<'Comment'> | string | null;
      replies?: CommentListRelationFilter;
      author?: XOR<UserScalarRelationFilter, UserWhereInput>;
      input?: XOR<InputNullableScalarRelationFilter, InputWhereInput> | null;
      solution?: XOR<
        SolutionNullableScalarRelationFilter,
        SolutionWhereInput
      > | null;
      requirement?: XOR<
        RequirementNullableScalarRelationFilter,
        RequirementWhereInput
      > | null;
      parent?: XOR<
        CommentNullableScalarRelationFilter,
        CommentWhereInput
      > | null;
    },
    'id'
  >;

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder;
    content?: SortOrder;
    authorId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    inputId?: SortOrderInput | SortOrder;
    solutionId?: SortOrderInput | SortOrder;
    requirementId?: SortOrderInput | SortOrder;
    parentId?: SortOrderInput | SortOrder;
    _count?: CommentCountOrderByAggregateInput;
    _max?: CommentMaxOrderByAggregateInput;
    _min?: CommentMinOrderByAggregateInput;
  };

  export type CommentScalarWhereWithAggregatesInput = {
    AND?:
      | CommentScalarWhereWithAggregatesInput
      | CommentScalarWhereWithAggregatesInput[];
    OR?: CommentScalarWhereWithAggregatesInput[];
    NOT?:
      | CommentScalarWhereWithAggregatesInput
      | CommentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Comment'> | string;
    content?: StringWithAggregatesFilter<'Comment'> | string;
    authorId?: StringWithAggregatesFilter<'Comment'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'Comment'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Comment'> | Date | string;
    inputId?: StringNullableWithAggregatesFilter<'Comment'> | string | null;
    solutionId?: StringNullableWithAggregatesFilter<'Comment'> | string | null;
    requirementId?:
      | StringNullableWithAggregatesFilter<'Comment'>
      | string
      | null;
    parentId?: StringNullableWithAggregatesFilter<'Comment'> | string | null;
  };

  export type VoteWhereInput = {
    AND?: VoteWhereInput | VoteWhereInput[];
    OR?: VoteWhereInput[];
    NOT?: VoteWhereInput | VoteWhereInput[];
    id?: StringFilter<'Vote'> | string;
    userId?: StringFilter<'Vote'> | string;
    value?: IntFilter<'Vote'> | number;
    createdAt?: DateTimeFilter<'Vote'> | Date | string;
    inputId?: StringNullableFilter<'Vote'> | string | null;
    solutionId?: StringNullableFilter<'Vote'> | string | null;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    input?: XOR<InputNullableScalarRelationFilter, InputWhereInput> | null;
    solution?: XOR<
      SolutionNullableScalarRelationFilter,
      SolutionWhereInput
    > | null;
  };

  export type VoteOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    value?: SortOrder;
    createdAt?: SortOrder;
    inputId?: SortOrderInput | SortOrder;
    solutionId?: SortOrderInput | SortOrder;
    user?: UserOrderByWithRelationInput;
    input?: InputOrderByWithRelationInput;
    solution?: SolutionOrderByWithRelationInput;
  };

  export type VoteWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId_inputId?: VoteUserIdInputIdCompoundUniqueInput;
      userId_solutionId?: VoteUserIdSolutionIdCompoundUniqueInput;
      AND?: VoteWhereInput | VoteWhereInput[];
      OR?: VoteWhereInput[];
      NOT?: VoteWhereInput | VoteWhereInput[];
      userId?: StringFilter<'Vote'> | string;
      value?: IntFilter<'Vote'> | number;
      createdAt?: DateTimeFilter<'Vote'> | Date | string;
      inputId?: StringNullableFilter<'Vote'> | string | null;
      solutionId?: StringNullableFilter<'Vote'> | string | null;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      input?: XOR<InputNullableScalarRelationFilter, InputWhereInput> | null;
      solution?: XOR<
        SolutionNullableScalarRelationFilter,
        SolutionWhereInput
      > | null;
    },
    'id' | 'userId_inputId' | 'userId_solutionId'
  >;

  export type VoteOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    value?: SortOrder;
    createdAt?: SortOrder;
    inputId?: SortOrderInput | SortOrder;
    solutionId?: SortOrderInput | SortOrder;
    _count?: VoteCountOrderByAggregateInput;
    _avg?: VoteAvgOrderByAggregateInput;
    _max?: VoteMaxOrderByAggregateInput;
    _min?: VoteMinOrderByAggregateInput;
    _sum?: VoteSumOrderByAggregateInput;
  };

  export type VoteScalarWhereWithAggregatesInput = {
    AND?:
      | VoteScalarWhereWithAggregatesInput
      | VoteScalarWhereWithAggregatesInput[];
    OR?: VoteScalarWhereWithAggregatesInput[];
    NOT?:
      | VoteScalarWhereWithAggregatesInput
      | VoteScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Vote'> | string;
    userId?: StringWithAggregatesFilter<'Vote'> | string;
    value?: IntWithAggregatesFilter<'Vote'> | number;
    createdAt?: DateTimeWithAggregatesFilter<'Vote'> | Date | string;
    inputId?: StringNullableWithAggregatesFilter<'Vote'> | string | null;
    solutionId?: StringNullableWithAggregatesFilter<'Vote'> | string | null;
  };

  export type InputGroupWhereInput = {
    AND?: InputGroupWhereInput | InputGroupWhereInput[];
    OR?: InputGroupWhereInput[];
    NOT?: InputGroupWhereInput | InputGroupWhereInput[];
    id?: StringFilter<'InputGroup'> | string;
    name?: StringFilter<'InputGroup'> | string;
    description?: StringNullableFilter<'InputGroup'> | string | null;
    ownerId?: StringFilter<'InputGroup'> | string;
    status?: EnumGroupStatusFilter<'InputGroup'> | $Enums.GroupStatus;
    createdAt?: DateTimeFilter<'InputGroup'> | Date | string;
    updatedAt?: DateTimeFilter<'InputGroup'> | Date | string;
    aiSuggested?: BoolFilter<'InputGroup'> | boolean;
    aiSimilarity?: FloatNullableFilter<'InputGroup'> | number | null;
    aiTheme?: StringNullableFilter<'InputGroup'> | string | null;
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>;
    inputs?: InputListRelationFilter;
  };

  export type InputGroupOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    ownerId?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    aiSuggested?: SortOrder;
    aiSimilarity?: SortOrderInput | SortOrder;
    aiTheme?: SortOrderInput | SortOrder;
    owner?: UserOrderByWithRelationInput;
    inputs?: InputOrderByRelationAggregateInput;
  };

  export type InputGroupWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: InputGroupWhereInput | InputGroupWhereInput[];
      OR?: InputGroupWhereInput[];
      NOT?: InputGroupWhereInput | InputGroupWhereInput[];
      name?: StringFilter<'InputGroup'> | string;
      description?: StringNullableFilter<'InputGroup'> | string | null;
      ownerId?: StringFilter<'InputGroup'> | string;
      status?: EnumGroupStatusFilter<'InputGroup'> | $Enums.GroupStatus;
      createdAt?: DateTimeFilter<'InputGroup'> | Date | string;
      updatedAt?: DateTimeFilter<'InputGroup'> | Date | string;
      aiSuggested?: BoolFilter<'InputGroup'> | boolean;
      aiSimilarity?: FloatNullableFilter<'InputGroup'> | number | null;
      aiTheme?: StringNullableFilter<'InputGroup'> | string | null;
      owner?: XOR<UserScalarRelationFilter, UserWhereInput>;
      inputs?: InputListRelationFilter;
    },
    'id'
  >;

  export type InputGroupOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    ownerId?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    aiSuggested?: SortOrder;
    aiSimilarity?: SortOrderInput | SortOrder;
    aiTheme?: SortOrderInput | SortOrder;
    _count?: InputGroupCountOrderByAggregateInput;
    _avg?: InputGroupAvgOrderByAggregateInput;
    _max?: InputGroupMaxOrderByAggregateInput;
    _min?: InputGroupMinOrderByAggregateInput;
    _sum?: InputGroupSumOrderByAggregateInput;
  };

  export type InputGroupScalarWhereWithAggregatesInput = {
    AND?:
      | InputGroupScalarWhereWithAggregatesInput
      | InputGroupScalarWhereWithAggregatesInput[];
    OR?: InputGroupScalarWhereWithAggregatesInput[];
    NOT?:
      | InputGroupScalarWhereWithAggregatesInput
      | InputGroupScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'InputGroup'> | string;
    name?: StringWithAggregatesFilter<'InputGroup'> | string;
    description?:
      | StringNullableWithAggregatesFilter<'InputGroup'>
      | string
      | null;
    ownerId?: StringWithAggregatesFilter<'InputGroup'> | string;
    status?:
      | EnumGroupStatusWithAggregatesFilter<'InputGroup'>
      | $Enums.GroupStatus;
    createdAt?: DateTimeWithAggregatesFilter<'InputGroup'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'InputGroup'> | Date | string;
    aiSuggested?: BoolWithAggregatesFilter<'InputGroup'> | boolean;
    aiSimilarity?:
      | FloatNullableWithAggregatesFilter<'InputGroup'>
      | number
      | null;
    aiTheme?: StringNullableWithAggregatesFilter<'InputGroup'> | string | null;
  };

  export type SolutionWhereInput = {
    AND?: SolutionWhereInput | SolutionWhereInput[];
    OR?: SolutionWhereInput[];
    NOT?: SolutionWhereInput | SolutionWhereInput[];
    id?: StringFilter<'Solution'> | string;
    title?: StringFilter<'Solution'> | string;
    description?: StringFilter<'Solution'> | string;
    ownerId?: StringFilter<'Solution'> | string;
    status?: EnumSolutionStatusFilter<'Solution'> | $Enums.SolutionStatus;
    priority?: EnumPriorityFilter<'Solution'> | $Enums.Priority;
    createdAt?: DateTimeFilter<'Solution'> | Date | string;
    updatedAt?: DateTimeFilter<'Solution'> | Date | string;
    estimatedEffort?: StringNullableFilter<'Solution'> | string | null;
    targetCompletion?:
      | DateTimeNullableFilter<'Solution'>
      | Date
      | string
      | null;
    actualCompletion?:
      | DateTimeNullableFilter<'Solution'>
      | Date
      | string
      | null;
    successCriteria?: JsonNullableFilter<'Solution'>;
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>;
    inputs?: InputListRelationFilter;
    tasks?: TaskListRelationFilter;
    comments?: CommentListRelationFilter;
    votes?: VoteListRelationFilter;
    requirements?: RequirementListRelationFilter;
    frdDocuments?: FRDDocumentListRelationFilter;
  };

  export type SolutionOrderByWithRelationInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    ownerId?: SortOrder;
    status?: SortOrder;
    priority?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    estimatedEffort?: SortOrderInput | SortOrder;
    targetCompletion?: SortOrderInput | SortOrder;
    actualCompletion?: SortOrderInput | SortOrder;
    successCriteria?: SortOrderInput | SortOrder;
    owner?: UserOrderByWithRelationInput;
    inputs?: InputOrderByRelationAggregateInput;
    tasks?: TaskOrderByRelationAggregateInput;
    comments?: CommentOrderByRelationAggregateInput;
    votes?: VoteOrderByRelationAggregateInput;
    requirements?: RequirementOrderByRelationAggregateInput;
    frdDocuments?: FRDDocumentOrderByRelationAggregateInput;
  };

  export type SolutionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: SolutionWhereInput | SolutionWhereInput[];
      OR?: SolutionWhereInput[];
      NOT?: SolutionWhereInput | SolutionWhereInput[];
      title?: StringFilter<'Solution'> | string;
      description?: StringFilter<'Solution'> | string;
      ownerId?: StringFilter<'Solution'> | string;
      status?: EnumSolutionStatusFilter<'Solution'> | $Enums.SolutionStatus;
      priority?: EnumPriorityFilter<'Solution'> | $Enums.Priority;
      createdAt?: DateTimeFilter<'Solution'> | Date | string;
      updatedAt?: DateTimeFilter<'Solution'> | Date | string;
      estimatedEffort?: StringNullableFilter<'Solution'> | string | null;
      targetCompletion?:
        | DateTimeNullableFilter<'Solution'>
        | Date
        | string
        | null;
      actualCompletion?:
        | DateTimeNullableFilter<'Solution'>
        | Date
        | string
        | null;
      successCriteria?: JsonNullableFilter<'Solution'>;
      owner?: XOR<UserScalarRelationFilter, UserWhereInput>;
      inputs?: InputListRelationFilter;
      tasks?: TaskListRelationFilter;
      comments?: CommentListRelationFilter;
      votes?: VoteListRelationFilter;
      requirements?: RequirementListRelationFilter;
      frdDocuments?: FRDDocumentListRelationFilter;
    },
    'id'
  >;

  export type SolutionOrderByWithAggregationInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    ownerId?: SortOrder;
    status?: SortOrder;
    priority?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    estimatedEffort?: SortOrderInput | SortOrder;
    targetCompletion?: SortOrderInput | SortOrder;
    actualCompletion?: SortOrderInput | SortOrder;
    successCriteria?: SortOrderInput | SortOrder;
    _count?: SolutionCountOrderByAggregateInput;
    _max?: SolutionMaxOrderByAggregateInput;
    _min?: SolutionMinOrderByAggregateInput;
  };

  export type SolutionScalarWhereWithAggregatesInput = {
    AND?:
      | SolutionScalarWhereWithAggregatesInput
      | SolutionScalarWhereWithAggregatesInput[];
    OR?: SolutionScalarWhereWithAggregatesInput[];
    NOT?:
      | SolutionScalarWhereWithAggregatesInput
      | SolutionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Solution'> | string;
    title?: StringWithAggregatesFilter<'Solution'> | string;
    description?: StringWithAggregatesFilter<'Solution'> | string;
    ownerId?: StringWithAggregatesFilter<'Solution'> | string;
    status?:
      | EnumSolutionStatusWithAggregatesFilter<'Solution'>
      | $Enums.SolutionStatus;
    priority?: EnumPriorityWithAggregatesFilter<'Solution'> | $Enums.Priority;
    createdAt?: DateTimeWithAggregatesFilter<'Solution'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Solution'> | Date | string;
    estimatedEffort?:
      | StringNullableWithAggregatesFilter<'Solution'>
      | string
      | null;
    targetCompletion?:
      | DateTimeNullableWithAggregatesFilter<'Solution'>
      | Date
      | string
      | null;
    actualCompletion?:
      | DateTimeNullableWithAggregatesFilter<'Solution'>
      | Date
      | string
      | null;
    successCriteria?: JsonNullableWithAggregatesFilter<'Solution'>;
  };

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[];
    OR?: TaskWhereInput[];
    NOT?: TaskWhereInput | TaskWhereInput[];
    id?: StringFilter<'Task'> | string;
    title?: StringFilter<'Task'> | string;
    description?: StringNullableFilter<'Task'> | string | null;
    solutionId?: StringFilter<'Task'> | string;
    assigneeId?: StringNullableFilter<'Task'> | string | null;
    status?: EnumTaskStatusFilter<'Task'> | $Enums.TaskStatus;
    priority?: EnumPriorityFilter<'Task'> | $Enums.Priority;
    createdAt?: DateTimeFilter<'Task'> | Date | string;
    updatedAt?: DateTimeFilter<'Task'> | Date | string;
    estimatedHours?: FloatNullableFilter<'Task'> | number | null;
    actualHours?: FloatNullableFilter<'Task'> | number | null;
    dueDate?: DateTimeNullableFilter<'Task'> | Date | string | null;
    dependencies?: JsonNullableFilter<'Task'>;
    solution?: XOR<SolutionScalarRelationFilter, SolutionWhereInput>;
    assignee?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
  };

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    solutionId?: SortOrder;
    assigneeId?: SortOrderInput | SortOrder;
    status?: SortOrder;
    priority?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    estimatedHours?: SortOrderInput | SortOrder;
    actualHours?: SortOrderInput | SortOrder;
    dueDate?: SortOrderInput | SortOrder;
    dependencies?: SortOrderInput | SortOrder;
    solution?: SolutionOrderByWithRelationInput;
    assignee?: UserOrderByWithRelationInput;
  };

  export type TaskWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: TaskWhereInput | TaskWhereInput[];
      OR?: TaskWhereInput[];
      NOT?: TaskWhereInput | TaskWhereInput[];
      title?: StringFilter<'Task'> | string;
      description?: StringNullableFilter<'Task'> | string | null;
      solutionId?: StringFilter<'Task'> | string;
      assigneeId?: StringNullableFilter<'Task'> | string | null;
      status?: EnumTaskStatusFilter<'Task'> | $Enums.TaskStatus;
      priority?: EnumPriorityFilter<'Task'> | $Enums.Priority;
      createdAt?: DateTimeFilter<'Task'> | Date | string;
      updatedAt?: DateTimeFilter<'Task'> | Date | string;
      estimatedHours?: FloatNullableFilter<'Task'> | number | null;
      actualHours?: FloatNullableFilter<'Task'> | number | null;
      dueDate?: DateTimeNullableFilter<'Task'> | Date | string | null;
      dependencies?: JsonNullableFilter<'Task'>;
      solution?: XOR<SolutionScalarRelationFilter, SolutionWhereInput>;
      assignee?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    },
    'id'
  >;

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    solutionId?: SortOrder;
    assigneeId?: SortOrderInput | SortOrder;
    status?: SortOrder;
    priority?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    estimatedHours?: SortOrderInput | SortOrder;
    actualHours?: SortOrderInput | SortOrder;
    dueDate?: SortOrderInput | SortOrder;
    dependencies?: SortOrderInput | SortOrder;
    _count?: TaskCountOrderByAggregateInput;
    _avg?: TaskAvgOrderByAggregateInput;
    _max?: TaskMaxOrderByAggregateInput;
    _min?: TaskMinOrderByAggregateInput;
    _sum?: TaskSumOrderByAggregateInput;
  };

  export type TaskScalarWhereWithAggregatesInput = {
    AND?:
      | TaskScalarWhereWithAggregatesInput
      | TaskScalarWhereWithAggregatesInput[];
    OR?: TaskScalarWhereWithAggregatesInput[];
    NOT?:
      | TaskScalarWhereWithAggregatesInput
      | TaskScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Task'> | string;
    title?: StringWithAggregatesFilter<'Task'> | string;
    description?: StringNullableWithAggregatesFilter<'Task'> | string | null;
    solutionId?: StringWithAggregatesFilter<'Task'> | string;
    assigneeId?: StringNullableWithAggregatesFilter<'Task'> | string | null;
    status?: EnumTaskStatusWithAggregatesFilter<'Task'> | $Enums.TaskStatus;
    priority?: EnumPriorityWithAggregatesFilter<'Task'> | $Enums.Priority;
    createdAt?: DateTimeWithAggregatesFilter<'Task'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Task'> | Date | string;
    estimatedHours?: FloatNullableWithAggregatesFilter<'Task'> | number | null;
    actualHours?: FloatNullableWithAggregatesFilter<'Task'> | number | null;
    dueDate?:
      | DateTimeNullableWithAggregatesFilter<'Task'>
      | Date
      | string
      | null;
    dependencies?: JsonNullableWithAggregatesFilter<'Task'>;
  };

  export type RequirementWhereInput = {
    AND?: RequirementWhereInput | RequirementWhereInput[];
    OR?: RequirementWhereInput[];
    NOT?: RequirementWhereInput | RequirementWhereInput[];
    id?: StringFilter<'Requirement'> | string;
    title?: StringFilter<'Requirement'> | string;
    description?: StringFilter<'Requirement'> | string;
    acceptanceCriteria?: JsonFilter<'Requirement'>;
    priority?: EnumPriorityFilter<'Requirement'> | $Enums.Priority;
    status?:
      | EnumRequirementStatusFilter<'Requirement'>
      | $Enums.RequirementStatus;
    estimatedEffort?: StringNullableFilter<'Requirement'> | string | null;
    dependencies?: JsonNullableFilter<'Requirement'>;
    businessValue?: StringNullableFilter<'Requirement'> | string | null;
    riskAssessment?: StringNullableFilter<'Requirement'> | string | null;
    stakeholders?: JsonNullableFilter<'Requirement'>;
    approvedBy?: StringNullableFilter<'Requirement'> | string | null;
    approvedAt?: DateTimeNullableFilter<'Requirement'> | Date | string | null;
    rejectionReason?: StringNullableFilter<'Requirement'> | string | null;
    solutionId?: StringFilter<'Requirement'> | string;
    createdBy?: StringFilter<'Requirement'> | string;
    createdAt?: DateTimeFilter<'Requirement'> | Date | string;
    updatedAt?: DateTimeFilter<'Requirement'> | Date | string;
    solution?: XOR<SolutionScalarRelationFilter, SolutionWhereInput>;
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>;
    comments?: CommentListRelationFilter;
  };

  export type RequirementOrderByWithRelationInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    acceptanceCriteria?: SortOrder;
    priority?: SortOrder;
    status?: SortOrder;
    estimatedEffort?: SortOrderInput | SortOrder;
    dependencies?: SortOrderInput | SortOrder;
    businessValue?: SortOrderInput | SortOrder;
    riskAssessment?: SortOrderInput | SortOrder;
    stakeholders?: SortOrderInput | SortOrder;
    approvedBy?: SortOrderInput | SortOrder;
    approvedAt?: SortOrderInput | SortOrder;
    rejectionReason?: SortOrderInput | SortOrder;
    solutionId?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    solution?: SolutionOrderByWithRelationInput;
    creator?: UserOrderByWithRelationInput;
    comments?: CommentOrderByRelationAggregateInput;
  };

  export type RequirementWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: RequirementWhereInput | RequirementWhereInput[];
      OR?: RequirementWhereInput[];
      NOT?: RequirementWhereInput | RequirementWhereInput[];
      title?: StringFilter<'Requirement'> | string;
      description?: StringFilter<'Requirement'> | string;
      acceptanceCriteria?: JsonFilter<'Requirement'>;
      priority?: EnumPriorityFilter<'Requirement'> | $Enums.Priority;
      status?:
        | EnumRequirementStatusFilter<'Requirement'>
        | $Enums.RequirementStatus;
      estimatedEffort?: StringNullableFilter<'Requirement'> | string | null;
      dependencies?: JsonNullableFilter<'Requirement'>;
      businessValue?: StringNullableFilter<'Requirement'> | string | null;
      riskAssessment?: StringNullableFilter<'Requirement'> | string | null;
      stakeholders?: JsonNullableFilter<'Requirement'>;
      approvedBy?: StringNullableFilter<'Requirement'> | string | null;
      approvedAt?: DateTimeNullableFilter<'Requirement'> | Date | string | null;
      rejectionReason?: StringNullableFilter<'Requirement'> | string | null;
      solutionId?: StringFilter<'Requirement'> | string;
      createdBy?: StringFilter<'Requirement'> | string;
      createdAt?: DateTimeFilter<'Requirement'> | Date | string;
      updatedAt?: DateTimeFilter<'Requirement'> | Date | string;
      solution?: XOR<SolutionScalarRelationFilter, SolutionWhereInput>;
      creator?: XOR<UserScalarRelationFilter, UserWhereInput>;
      comments?: CommentListRelationFilter;
    },
    'id'
  >;

  export type RequirementOrderByWithAggregationInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    acceptanceCriteria?: SortOrder;
    priority?: SortOrder;
    status?: SortOrder;
    estimatedEffort?: SortOrderInput | SortOrder;
    dependencies?: SortOrderInput | SortOrder;
    businessValue?: SortOrderInput | SortOrder;
    riskAssessment?: SortOrderInput | SortOrder;
    stakeholders?: SortOrderInput | SortOrder;
    approvedBy?: SortOrderInput | SortOrder;
    approvedAt?: SortOrderInput | SortOrder;
    rejectionReason?: SortOrderInput | SortOrder;
    solutionId?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: RequirementCountOrderByAggregateInput;
    _max?: RequirementMaxOrderByAggregateInput;
    _min?: RequirementMinOrderByAggregateInput;
  };

  export type RequirementScalarWhereWithAggregatesInput = {
    AND?:
      | RequirementScalarWhereWithAggregatesInput
      | RequirementScalarWhereWithAggregatesInput[];
    OR?: RequirementScalarWhereWithAggregatesInput[];
    NOT?:
      | RequirementScalarWhereWithAggregatesInput
      | RequirementScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Requirement'> | string;
    title?: StringWithAggregatesFilter<'Requirement'> | string;
    description?: StringWithAggregatesFilter<'Requirement'> | string;
    acceptanceCriteria?: JsonWithAggregatesFilter<'Requirement'>;
    priority?:
      | EnumPriorityWithAggregatesFilter<'Requirement'>
      | $Enums.Priority;
    status?:
      | EnumRequirementStatusWithAggregatesFilter<'Requirement'>
      | $Enums.RequirementStatus;
    estimatedEffort?:
      | StringNullableWithAggregatesFilter<'Requirement'>
      | string
      | null;
    dependencies?: JsonNullableWithAggregatesFilter<'Requirement'>;
    businessValue?:
      | StringNullableWithAggregatesFilter<'Requirement'>
      | string
      | null;
    riskAssessment?:
      | StringNullableWithAggregatesFilter<'Requirement'>
      | string
      | null;
    stakeholders?: JsonNullableWithAggregatesFilter<'Requirement'>;
    approvedBy?:
      | StringNullableWithAggregatesFilter<'Requirement'>
      | string
      | null;
    approvedAt?:
      | DateTimeNullableWithAggregatesFilter<'Requirement'>
      | Date
      | string
      | null;
    rejectionReason?:
      | StringNullableWithAggregatesFilter<'Requirement'>
      | string
      | null;
    solutionId?: StringWithAggregatesFilter<'Requirement'> | string;
    createdBy?: StringWithAggregatesFilter<'Requirement'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'Requirement'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Requirement'> | Date | string;
  };

  export type FRDDocumentWhereInput = {
    AND?: FRDDocumentWhereInput | FRDDocumentWhereInput[];
    OR?: FRDDocumentWhereInput[];
    NOT?: FRDDocumentWhereInput | FRDDocumentWhereInput[];
    id?: StringFilter<'FRDDocument'> | string;
    title?: StringFilter<'FRDDocument'> | string;
    content?: JsonFilter<'FRDDocument'>;
    aiGenerated?: BoolFilter<'FRDDocument'> | boolean;
    aiConfidence?: FloatNullableFilter<'FRDDocument'> | number | null;
    aiPromptUsed?: StringNullableFilter<'FRDDocument'> | string | null;
    version?: StringFilter<'FRDDocument'> | string;
    status?: EnumFRDStatusFilter<'FRDDocument'> | $Enums.FRDStatus;
    executiveApproved?: BoolFilter<'FRDDocument'> | boolean;
    exportFormats?: JsonNullableFilter<'FRDDocument'>;
    templateUsed?: StringNullableFilter<'FRDDocument'> | string | null;
    generationTime?: FloatNullableFilter<'FRDDocument'> | number | null;
    wordCount?: IntNullableFilter<'FRDDocument'> | number | null;
    lastExportedAt?:
      | DateTimeNullableFilter<'FRDDocument'>
      | Date
      | string
      | null;
    solutionId?: StringFilter<'FRDDocument'> | string;
    createdBy?: StringFilter<'FRDDocument'> | string;
    approvedBy?: StringNullableFilter<'FRDDocument'> | string | null;
    createdAt?: DateTimeFilter<'FRDDocument'> | Date | string;
    updatedAt?: DateTimeFilter<'FRDDocument'> | Date | string;
    solution?: XOR<SolutionScalarRelationFilter, SolutionWhereInput>;
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>;
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
  };

  export type FRDDocumentOrderByWithRelationInput = {
    id?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    aiGenerated?: SortOrder;
    aiConfidence?: SortOrderInput | SortOrder;
    aiPromptUsed?: SortOrderInput | SortOrder;
    version?: SortOrder;
    status?: SortOrder;
    executiveApproved?: SortOrder;
    exportFormats?: SortOrderInput | SortOrder;
    templateUsed?: SortOrderInput | SortOrder;
    generationTime?: SortOrderInput | SortOrder;
    wordCount?: SortOrderInput | SortOrder;
    lastExportedAt?: SortOrderInput | SortOrder;
    solutionId?: SortOrder;
    createdBy?: SortOrder;
    approvedBy?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    solution?: SolutionOrderByWithRelationInput;
    creator?: UserOrderByWithRelationInput;
    approver?: UserOrderByWithRelationInput;
  };

  export type FRDDocumentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: FRDDocumentWhereInput | FRDDocumentWhereInput[];
      OR?: FRDDocumentWhereInput[];
      NOT?: FRDDocumentWhereInput | FRDDocumentWhereInput[];
      title?: StringFilter<'FRDDocument'> | string;
      content?: JsonFilter<'FRDDocument'>;
      aiGenerated?: BoolFilter<'FRDDocument'> | boolean;
      aiConfidence?: FloatNullableFilter<'FRDDocument'> | number | null;
      aiPromptUsed?: StringNullableFilter<'FRDDocument'> | string | null;
      version?: StringFilter<'FRDDocument'> | string;
      status?: EnumFRDStatusFilter<'FRDDocument'> | $Enums.FRDStatus;
      executiveApproved?: BoolFilter<'FRDDocument'> | boolean;
      exportFormats?: JsonNullableFilter<'FRDDocument'>;
      templateUsed?: StringNullableFilter<'FRDDocument'> | string | null;
      generationTime?: FloatNullableFilter<'FRDDocument'> | number | null;
      wordCount?: IntNullableFilter<'FRDDocument'> | number | null;
      lastExportedAt?:
        | DateTimeNullableFilter<'FRDDocument'>
        | Date
        | string
        | null;
      solutionId?: StringFilter<'FRDDocument'> | string;
      createdBy?: StringFilter<'FRDDocument'> | string;
      approvedBy?: StringNullableFilter<'FRDDocument'> | string | null;
      createdAt?: DateTimeFilter<'FRDDocument'> | Date | string;
      updatedAt?: DateTimeFilter<'FRDDocument'> | Date | string;
      solution?: XOR<SolutionScalarRelationFilter, SolutionWhereInput>;
      creator?: XOR<UserScalarRelationFilter, UserWhereInput>;
      approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    },
    'id'
  >;

  export type FRDDocumentOrderByWithAggregationInput = {
    id?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    aiGenerated?: SortOrder;
    aiConfidence?: SortOrderInput | SortOrder;
    aiPromptUsed?: SortOrderInput | SortOrder;
    version?: SortOrder;
    status?: SortOrder;
    executiveApproved?: SortOrder;
    exportFormats?: SortOrderInput | SortOrder;
    templateUsed?: SortOrderInput | SortOrder;
    generationTime?: SortOrderInput | SortOrder;
    wordCount?: SortOrderInput | SortOrder;
    lastExportedAt?: SortOrderInput | SortOrder;
    solutionId?: SortOrder;
    createdBy?: SortOrder;
    approvedBy?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: FRDDocumentCountOrderByAggregateInput;
    _avg?: FRDDocumentAvgOrderByAggregateInput;
    _max?: FRDDocumentMaxOrderByAggregateInput;
    _min?: FRDDocumentMinOrderByAggregateInput;
    _sum?: FRDDocumentSumOrderByAggregateInput;
  };

  export type FRDDocumentScalarWhereWithAggregatesInput = {
    AND?:
      | FRDDocumentScalarWhereWithAggregatesInput
      | FRDDocumentScalarWhereWithAggregatesInput[];
    OR?: FRDDocumentScalarWhereWithAggregatesInput[];
    NOT?:
      | FRDDocumentScalarWhereWithAggregatesInput
      | FRDDocumentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'FRDDocument'> | string;
    title?: StringWithAggregatesFilter<'FRDDocument'> | string;
    content?: JsonWithAggregatesFilter<'FRDDocument'>;
    aiGenerated?: BoolWithAggregatesFilter<'FRDDocument'> | boolean;
    aiConfidence?:
      | FloatNullableWithAggregatesFilter<'FRDDocument'>
      | number
      | null;
    aiPromptUsed?:
      | StringNullableWithAggregatesFilter<'FRDDocument'>
      | string
      | null;
    version?: StringWithAggregatesFilter<'FRDDocument'> | string;
    status?:
      | EnumFRDStatusWithAggregatesFilter<'FRDDocument'>
      | $Enums.FRDStatus;
    executiveApproved?: BoolWithAggregatesFilter<'FRDDocument'> | boolean;
    exportFormats?: JsonNullableWithAggregatesFilter<'FRDDocument'>;
    templateUsed?:
      | StringNullableWithAggregatesFilter<'FRDDocument'>
      | string
      | null;
    generationTime?:
      | FloatNullableWithAggregatesFilter<'FRDDocument'>
      | number
      | null;
    wordCount?: IntNullableWithAggregatesFilter<'FRDDocument'> | number | null;
    lastExportedAt?:
      | DateTimeNullableWithAggregatesFilter<'FRDDocument'>
      | Date
      | string
      | null;
    solutionId?: StringWithAggregatesFilter<'FRDDocument'> | string;
    createdBy?: StringWithAggregatesFilter<'FRDDocument'> | string;
    approvedBy?:
      | StringNullableWithAggregatesFilter<'FRDDocument'>
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<'FRDDocument'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'FRDDocument'> | Date | string;
  };

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[];
    OR?: AuditLogWhereInput[];
    NOT?: AuditLogWhereInput | AuditLogWhereInput[];
    id?: StringFilter<'AuditLog'> | string;
    userId?: StringFilter<'AuditLog'> | string;
    action?: StringFilter<'AuditLog'> | string;
    entityType?: StringFilter<'AuditLog'> | string;
    entityId?: StringFilter<'AuditLog'> | string;
    changes?: JsonNullableFilter<'AuditLog'>;
    metadata?: JsonNullableFilter<'AuditLog'>;
    ipAddress?: StringNullableFilter<'AuditLog'> | string | null;
    userAgent?: StringNullableFilter<'AuditLog'> | string | null;
    createdAt?: DateTimeFilter<'AuditLog'> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    changes?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AuditLogWhereInput | AuditLogWhereInput[];
      OR?: AuditLogWhereInput[];
      NOT?: AuditLogWhereInput | AuditLogWhereInput[];
      userId?: StringFilter<'AuditLog'> | string;
      action?: StringFilter<'AuditLog'> | string;
      entityType?: StringFilter<'AuditLog'> | string;
      entityId?: StringFilter<'AuditLog'> | string;
      changes?: JsonNullableFilter<'AuditLog'>;
      metadata?: JsonNullableFilter<'AuditLog'>;
      ipAddress?: StringNullableFilter<'AuditLog'> | string | null;
      userAgent?: StringNullableFilter<'AuditLog'> | string | null;
      createdAt?: DateTimeFilter<'AuditLog'> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    changes?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: AuditLogCountOrderByAggregateInput;
    _max?: AuditLogMaxOrderByAggregateInput;
    _min?: AuditLogMinOrderByAggregateInput;
  };

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?:
      | AuditLogScalarWhereWithAggregatesInput
      | AuditLogScalarWhereWithAggregatesInput[];
    OR?: AuditLogScalarWhereWithAggregatesInput[];
    NOT?:
      | AuditLogScalarWhereWithAggregatesInput
      | AuditLogScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'AuditLog'> | string;
    userId?: StringWithAggregatesFilter<'AuditLog'> | string;
    action?: StringWithAggregatesFilter<'AuditLog'> | string;
    entityType?: StringWithAggregatesFilter<'AuditLog'> | string;
    entityId?: StringWithAggregatesFilter<'AuditLog'> | string;
    changes?: JsonNullableWithAggregatesFilter<'AuditLog'>;
    metadata?: JsonNullableWithAggregatesFilter<'AuditLog'>;
    ipAddress?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    userAgent?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'AuditLog'> | Date | string;
  };

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[];
    OR?: NotificationWhereInput[];
    NOT?: NotificationWhereInput | NotificationWhereInput[];
    id?: StringFilter<'Notification'> | string;
    userId?: StringFilter<'Notification'> | string;
    type?: EnumNotificationTypeFilter<'Notification'> | $Enums.NotificationType;
    title?: StringFilter<'Notification'> | string;
    message?: StringFilter<'Notification'> | string;
    readAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
    data?: JsonNullableFilter<'Notification'>;
    createdAt?: DateTimeFilter<'Notification'> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    readAt?: SortOrderInput | SortOrder;
    data?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type NotificationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: NotificationWhereInput | NotificationWhereInput[];
      OR?: NotificationWhereInput[];
      NOT?: NotificationWhereInput | NotificationWhereInput[];
      userId?: StringFilter<'Notification'> | string;
      type?:
        | EnumNotificationTypeFilter<'Notification'>
        | $Enums.NotificationType;
      title?: StringFilter<'Notification'> | string;
      message?: StringFilter<'Notification'> | string;
      readAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
      data?: JsonNullableFilter<'Notification'>;
      createdAt?: DateTimeFilter<'Notification'> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    readAt?: SortOrderInput | SortOrder;
    data?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: NotificationCountOrderByAggregateInput;
    _max?: NotificationMaxOrderByAggregateInput;
    _min?: NotificationMinOrderByAggregateInput;
  };

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?:
      | NotificationScalarWhereWithAggregatesInput
      | NotificationScalarWhereWithAggregatesInput[];
    OR?: NotificationScalarWhereWithAggregatesInput[];
    NOT?:
      | NotificationScalarWhereWithAggregatesInput
      | NotificationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Notification'> | string;
    userId?: StringWithAggregatesFilter<'Notification'> | string;
    type?:
      | EnumNotificationTypeWithAggregatesFilter<'Notification'>
      | $Enums.NotificationType;
    title?: StringWithAggregatesFilter<'Notification'> | string;
    message?: StringWithAggregatesFilter<'Notification'> | string;
    readAt?:
      | DateTimeNullableWithAggregatesFilter<'Notification'>
      | Date
      | string
      | null;
    data?: JsonNullableWithAggregatesFilter<'Notification'>;
    createdAt?: DateTimeWithAggregatesFilter<'Notification'> | Date | string;
  };

  export type UserCreateInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputs?: InputCreateNestedManyWithoutCreatorInput;
    solutions?: SolutionCreateNestedManyWithoutOwnerInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    votes?: VoteCreateNestedManyWithoutUserInput;
    requirements?: RequirementCreateNestedManyWithoutCreatorInput;
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput;
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    inputGroups?: InputGroupCreateNestedManyWithoutOwnerInput;
    tasks?: TaskCreateNestedManyWithoutAssigneeInput;
  };

  export type UserUncheckedCreateInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput;
    solutions?: SolutionUncheckedCreateNestedManyWithoutOwnerInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput;
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput;
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput;
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutOwnerInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput;
  };

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputs?: InputUpdateManyWithoutCreatorNestedInput;
    solutions?: SolutionUpdateManyWithoutOwnerNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    votes?: VoteUpdateManyWithoutUserNestedInput;
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput;
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput;
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    inputGroups?: InputGroupUpdateManyWithoutOwnerNestedInput;
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput;
    solutions?: SolutionUncheckedUpdateManyWithoutOwnerNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput;
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput;
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput;
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    inputGroups?: InputGroupUncheckedUpdateManyWithoutOwnerNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput;
  };

  export type UserCreateManyInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type InputCreateInput = {
    id?: string;
    title: string;
    description: string;
    type: $Enums.InputType;
    status?: $Enums.InputStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    department?: string | null;
    issueType?: $Enums.IssueType | null;
    rootCause?: string | null;
    priority?: $Enums.Priority;
    aiProcessed?: boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    creator: UserCreateNestedOneWithoutInputsInput;
    solutions?: SolutionCreateNestedManyWithoutInputsInput;
    comments?: CommentCreateNestedManyWithoutInputInput;
    votes?: VoteCreateNestedManyWithoutInputInput;
    groups?: InputGroupCreateNestedManyWithoutInputsInput;
  };

  export type InputUncheckedCreateInput = {
    id?: string;
    title: string;
    description: string;
    type: $Enums.InputType;
    status?: $Enums.InputStatus;
    createdBy: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    department?: string | null;
    issueType?: $Enums.IssueType | null;
    rootCause?: string | null;
    priority?: $Enums.Priority;
    aiProcessed?: boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    solutions?: SolutionUncheckedCreateNestedManyWithoutInputsInput;
    comments?: CommentUncheckedCreateNestedManyWithoutInputInput;
    votes?: VoteUncheckedCreateNestedManyWithoutInputInput;
    groups?: InputGroupUncheckedCreateNestedManyWithoutInputsInput;
  };

  export type InputUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType;
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    issueType?:
      | NullableEnumIssueTypeFieldUpdateOperationsInput
      | $Enums.IssueType
      | null;
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    creator?: UserUpdateOneRequiredWithoutInputsNestedInput;
    solutions?: SolutionUpdateManyWithoutInputsNestedInput;
    comments?: CommentUpdateManyWithoutInputNestedInput;
    votes?: VoteUpdateManyWithoutInputNestedInput;
    groups?: InputGroupUpdateManyWithoutInputsNestedInput;
  };

  export type InputUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType;
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    issueType?:
      | NullableEnumIssueTypeFieldUpdateOperationsInput
      | $Enums.IssueType
      | null;
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    solutions?: SolutionUncheckedUpdateManyWithoutInputsNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutInputNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutInputNestedInput;
    groups?: InputGroupUncheckedUpdateManyWithoutInputsNestedInput;
  };

  export type InputCreateManyInput = {
    id?: string;
    title: string;
    description: string;
    type: $Enums.InputType;
    status?: $Enums.InputStatus;
    createdBy: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    department?: string | null;
    issueType?: $Enums.IssueType | null;
    rootCause?: string | null;
    priority?: $Enums.Priority;
    aiProcessed?: boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type InputUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType;
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    issueType?:
      | NullableEnumIssueTypeFieldUpdateOperationsInput
      | $Enums.IssueType
      | null;
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type InputUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType;
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    issueType?:
      | NullableEnumIssueTypeFieldUpdateOperationsInput
      | $Enums.IssueType
      | null;
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type CommentCreateInput = {
    id?: string;
    content: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    replies?: CommentCreateNestedManyWithoutParentInput;
    author: UserCreateNestedOneWithoutCommentsInput;
    input?: InputCreateNestedOneWithoutCommentsInput;
    solution?: SolutionCreateNestedOneWithoutCommentsInput;
    requirement?: RequirementCreateNestedOneWithoutCommentsInput;
    parent?: CommentCreateNestedOneWithoutRepliesInput;
  };

  export type CommentUncheckedCreateInput = {
    id?: string;
    content: string;
    authorId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputId?: string | null;
    solutionId?: string | null;
    requirementId?: string | null;
    parentId?: string | null;
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput;
  };

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    replies?: CommentUpdateManyWithoutParentNestedInput;
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput;
    input?: InputUpdateOneWithoutCommentsNestedInput;
    solution?: SolutionUpdateOneWithoutCommentsNestedInput;
    requirement?: RequirementUpdateOneWithoutCommentsNestedInput;
    parent?: CommentUpdateOneWithoutRepliesNestedInput;
  };

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    authorId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputId?: NullableStringFieldUpdateOperationsInput | string | null;
    solutionId?: NullableStringFieldUpdateOperationsInput | string | null;
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput;
  };

  export type CommentCreateManyInput = {
    id?: string;
    content: string;
    authorId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputId?: string | null;
    solutionId?: string | null;
    requirementId?: string | null;
    parentId?: string | null;
  };

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    authorId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputId?: NullableStringFieldUpdateOperationsInput | string | null;
    solutionId?: NullableStringFieldUpdateOperationsInput | string | null;
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type VoteCreateInput = {
    id?: string;
    value: number;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutVotesInput;
    input?: InputCreateNestedOneWithoutVotesInput;
    solution?: SolutionCreateNestedOneWithoutVotesInput;
  };

  export type VoteUncheckedCreateInput = {
    id?: string;
    userId: string;
    value: number;
    createdAt?: Date | string;
    inputId?: string | null;
    solutionId?: string | null;
  };

  export type VoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    value?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutVotesNestedInput;
    input?: InputUpdateOneWithoutVotesNestedInput;
    solution?: SolutionUpdateOneWithoutVotesNestedInput;
  };

  export type VoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    value?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputId?: NullableStringFieldUpdateOperationsInput | string | null;
    solutionId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type VoteCreateManyInput = {
    id?: string;
    userId: string;
    value: number;
    createdAt?: Date | string;
    inputId?: string | null;
    solutionId?: string | null;
  };

  export type VoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    value?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    value?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputId?: NullableStringFieldUpdateOperationsInput | string | null;
    solutionId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type InputGroupCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    status?: $Enums.GroupStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    aiSuggested?: boolean;
    aiSimilarity?: number | null;
    aiTheme?: string | null;
    owner: UserCreateNestedOneWithoutInputGroupsInput;
    inputs?: InputCreateNestedManyWithoutGroupsInput;
  };

  export type InputGroupUncheckedCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    ownerId: string;
    status?: $Enums.GroupStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    aiSuggested?: boolean;
    aiSimilarity?: number | null;
    aiTheme?: string | null;
    inputs?: InputUncheckedCreateNestedManyWithoutGroupsInput;
  };

  export type InputGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumGroupStatusFieldUpdateOperationsInput | $Enums.GroupStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean;
    aiSimilarity?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    owner?: UserUpdateOneRequiredWithoutInputGroupsNestedInput;
    inputs?: InputUpdateManyWithoutGroupsNestedInput;
  };

  export type InputGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    ownerId?: StringFieldUpdateOperationsInput | string;
    status?: EnumGroupStatusFieldUpdateOperationsInput | $Enums.GroupStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean;
    aiSimilarity?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    inputs?: InputUncheckedUpdateManyWithoutGroupsNestedInput;
  };

  export type InputGroupCreateManyInput = {
    id?: string;
    name: string;
    description?: string | null;
    ownerId: string;
    status?: $Enums.GroupStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    aiSuggested?: boolean;
    aiSimilarity?: number | null;
    aiTheme?: string | null;
  };

  export type InputGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumGroupStatusFieldUpdateOperationsInput | $Enums.GroupStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean;
    aiSimilarity?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiTheme?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type InputGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    ownerId?: StringFieldUpdateOperationsInput | string;
    status?: EnumGroupStatusFieldUpdateOperationsInput | $Enums.GroupStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean;
    aiSimilarity?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiTheme?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SolutionCreateInput = {
    id?: string;
    title: string;
    description: string;
    status?: $Enums.SolutionStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedEffort?: string | null;
    targetCompletion?: Date | string | null;
    actualCompletion?: Date | string | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    owner: UserCreateNestedOneWithoutSolutionsInput;
    inputs?: InputCreateNestedManyWithoutSolutionsInput;
    tasks?: TaskCreateNestedManyWithoutSolutionInput;
    comments?: CommentCreateNestedManyWithoutSolutionInput;
    votes?: VoteCreateNestedManyWithoutSolutionInput;
    requirements?: RequirementCreateNestedManyWithoutSolutionInput;
    frdDocuments?: FRDDocumentCreateNestedManyWithoutSolutionInput;
  };

  export type SolutionUncheckedCreateInput = {
    id?: string;
    title: string;
    description: string;
    ownerId: string;
    status?: $Enums.SolutionStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedEffort?: string | null;
    targetCompletion?: Date | string | null;
    actualCompletion?: Date | string | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    inputs?: InputUncheckedCreateNestedManyWithoutSolutionsInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutSolutionInput;
    comments?: CommentUncheckedCreateNestedManyWithoutSolutionInput;
    votes?: VoteUncheckedCreateNestedManyWithoutSolutionInput;
    requirements?: RequirementUncheckedCreateNestedManyWithoutSolutionInput;
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutSolutionInput;
  };

  export type SolutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSolutionStatusFieldUpdateOperationsInput
      | $Enums.SolutionStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    targetCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    owner?: UserUpdateOneRequiredWithoutSolutionsNestedInput;
    inputs?: InputUpdateManyWithoutSolutionsNestedInput;
    tasks?: TaskUpdateManyWithoutSolutionNestedInput;
    comments?: CommentUpdateManyWithoutSolutionNestedInput;
    votes?: VoteUpdateManyWithoutSolutionNestedInput;
    requirements?: RequirementUpdateManyWithoutSolutionNestedInput;
    frdDocuments?: FRDDocumentUpdateManyWithoutSolutionNestedInput;
  };

  export type SolutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSolutionStatusFieldUpdateOperationsInput
      | $Enums.SolutionStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    targetCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    inputs?: InputUncheckedUpdateManyWithoutSolutionsNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutSolutionNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutSolutionNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutSolutionNestedInput;
    requirements?: RequirementUncheckedUpdateManyWithoutSolutionNestedInput;
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutSolutionNestedInput;
  };

  export type SolutionCreateManyInput = {
    id?: string;
    title: string;
    description: string;
    ownerId: string;
    status?: $Enums.SolutionStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedEffort?: string | null;
    targetCompletion?: Date | string | null;
    actualCompletion?: Date | string | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type SolutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSolutionStatusFieldUpdateOperationsInput
      | $Enums.SolutionStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    targetCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type SolutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSolutionStatusFieldUpdateOperationsInput
      | $Enums.SolutionStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    targetCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type TaskCreateInput = {
    id?: string;
    title: string;
    description?: string | null;
    status?: $Enums.TaskStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedHours?: number | null;
    actualHours?: number | null;
    dueDate?: Date | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    solution: SolutionCreateNestedOneWithoutTasksInput;
    assignee?: UserCreateNestedOneWithoutTasksInput;
  };

  export type TaskUncheckedCreateInput = {
    id?: string;
    title: string;
    description?: string | null;
    solutionId: string;
    assigneeId?: string | null;
    status?: $Enums.TaskStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedHours?: number | null;
    actualHours?: number | null;
    dueDate?: Date | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    solution?: SolutionUpdateOneRequiredWithoutTasksNestedInput;
    assignee?: UserUpdateOneWithoutTasksNestedInput;
  };

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    solutionId?: StringFieldUpdateOperationsInput | string;
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type TaskCreateManyInput = {
    id?: string;
    title: string;
    description?: string | null;
    solutionId: string;
    assigneeId?: string | null;
    status?: $Enums.TaskStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedHours?: number | null;
    actualHours?: number | null;
    dueDate?: Date | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    solutionId?: StringFieldUpdateOperationsInput | string;
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type RequirementCreateInput = {
    id?: string;
    title: string;
    description: string;
    acceptanceCriteria: JsonNullValueInput | InputJsonValue;
    priority?: $Enums.Priority;
    status?: $Enums.RequirementStatus;
    estimatedEffort?: string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: string | null;
    riskAssessment?: string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: string | null;
    approvedAt?: Date | string | null;
    rejectionReason?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    solution: SolutionCreateNestedOneWithoutRequirementsInput;
    creator: UserCreateNestedOneWithoutRequirementsInput;
    comments?: CommentCreateNestedManyWithoutRequirementInput;
  };

  export type RequirementUncheckedCreateInput = {
    id?: string;
    title: string;
    description: string;
    acceptanceCriteria: JsonNullValueInput | InputJsonValue;
    priority?: $Enums.Priority;
    status?: $Enums.RequirementStatus;
    estimatedEffort?: string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: string | null;
    riskAssessment?: string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: string | null;
    approvedAt?: Date | string | null;
    rejectionReason?: string | null;
    solutionId: string;
    createdBy: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    comments?: CommentUncheckedCreateNestedManyWithoutRequirementInput;
  };

  export type RequirementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    status?:
      | EnumRequirementStatusFieldUpdateOperationsInput
      | $Enums.RequirementStatus;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null;
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    solution?: SolutionUpdateOneRequiredWithoutRequirementsNestedInput;
    creator?: UserUpdateOneRequiredWithoutRequirementsNestedInput;
    comments?: CommentUpdateManyWithoutRequirementNestedInput;
  };

  export type RequirementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    status?:
      | EnumRequirementStatusFieldUpdateOperationsInput
      | $Enums.RequirementStatus;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null;
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    solutionId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    comments?: CommentUncheckedUpdateManyWithoutRequirementNestedInput;
  };

  export type RequirementCreateManyInput = {
    id?: string;
    title: string;
    description: string;
    acceptanceCriteria: JsonNullValueInput | InputJsonValue;
    priority?: $Enums.Priority;
    status?: $Enums.RequirementStatus;
    estimatedEffort?: string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: string | null;
    riskAssessment?: string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: string | null;
    approvedAt?: Date | string | null;
    rejectionReason?: string | null;
    solutionId: string;
    createdBy: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RequirementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    status?:
      | EnumRequirementStatusFieldUpdateOperationsInput
      | $Enums.RequirementStatus;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null;
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RequirementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    status?:
      | EnumRequirementStatusFieldUpdateOperationsInput
      | $Enums.RequirementStatus;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null;
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    solutionId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FRDDocumentCreateInput = {
    id?: string;
    title: string;
    content: JsonNullValueInput | InputJsonValue;
    aiGenerated?: boolean;
    aiConfidence?: number | null;
    aiPromptUsed?: string | null;
    version?: string;
    status?: $Enums.FRDStatus;
    executiveApproved?: boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: string | null;
    generationTime?: number | null;
    wordCount?: number | null;
    lastExportedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    solution: SolutionCreateNestedOneWithoutFrdDocumentsInput;
    creator: UserCreateNestedOneWithoutFrdDocumentsInput;
    approver?: UserCreateNestedOneWithoutApprovedFRDsInput;
  };

  export type FRDDocumentUncheckedCreateInput = {
    id?: string;
    title: string;
    content: JsonNullValueInput | InputJsonValue;
    aiGenerated?: boolean;
    aiConfidence?: number | null;
    aiPromptUsed?: string | null;
    version?: string;
    status?: $Enums.FRDStatus;
    executiveApproved?: boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: string | null;
    generationTime?: number | null;
    wordCount?: number | null;
    lastExportedAt?: Date | string | null;
    solutionId: string;
    createdBy: string;
    approvedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FRDDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    content?: JsonNullValueInput | InputJsonValue;
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean;
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    version?: StringFieldUpdateOperationsInput | string;
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus;
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null;
    lastExportedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    solution?: SolutionUpdateOneRequiredWithoutFrdDocumentsNestedInput;
    creator?: UserUpdateOneRequiredWithoutFrdDocumentsNestedInput;
    approver?: UserUpdateOneWithoutApprovedFRDsNestedInput;
  };

  export type FRDDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    content?: JsonNullValueInput | InputJsonValue;
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean;
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    version?: StringFieldUpdateOperationsInput | string;
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus;
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null;
    lastExportedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    solutionId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FRDDocumentCreateManyInput = {
    id?: string;
    title: string;
    content: JsonNullValueInput | InputJsonValue;
    aiGenerated?: boolean;
    aiConfidence?: number | null;
    aiPromptUsed?: string | null;
    version?: string;
    status?: $Enums.FRDStatus;
    executiveApproved?: boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: string | null;
    generationTime?: number | null;
    wordCount?: number | null;
    lastExportedAt?: Date | string | null;
    solutionId: string;
    createdBy: string;
    approvedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FRDDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    content?: JsonNullValueInput | InputJsonValue;
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean;
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    version?: StringFieldUpdateOperationsInput | string;
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus;
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null;
    lastExportedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FRDDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    content?: JsonNullValueInput | InputJsonValue;
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean;
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    version?: StringFieldUpdateOperationsInput | string;
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus;
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null;
    lastExportedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    solutionId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogCreateInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutAuditLogsInput;
  };

  export type AuditLogUncheckedCreateInput = {
    id?: string;
    userId: string;
    action: string;
    entityType: string;
    entityId: string;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput;
  };

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogCreateManyInput = {
    id?: string;
    userId: string;
    action: string;
    entityType: string;
    entityId: string;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationCreateInput = {
    id?: string;
    type: $Enums.NotificationType;
    title: string;
    message: string;
    readAt?: Date | string | null;
    data?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutNotificationsInput;
  };

  export type NotificationUncheckedCreateInput = {
    id?: string;
    userId: string;
    type: $Enums.NotificationType;
    title: string;
    message: string;
    readAt?: Date | string | null;
    data?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?:
      | EnumNotificationTypeFieldUpdateOperationsInput
      | $Enums.NotificationType;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    data?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput;
  };

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    type?:
      | EnumNotificationTypeFieldUpdateOperationsInput
      | $Enums.NotificationType;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    data?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationCreateManyInput = {
    id?: string;
    userId: string;
    type: $Enums.NotificationType;
    title: string;
    message: string;
    readAt?: Date | string | null;
    data?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?:
      | EnumNotificationTypeFieldUpdateOperationsInput
      | $Enums.NotificationType;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    data?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    type?:
      | EnumNotificationTypeFieldUpdateOperationsInput
      | $Enums.NotificationType;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    data?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type InputListRelationFilter = {
    every?: InputWhereInput;
    some?: InputWhereInput;
    none?: InputWhereInput;
  };

  export type SolutionListRelationFilter = {
    every?: SolutionWhereInput;
    some?: SolutionWhereInput;
    none?: SolutionWhereInput;
  };

  export type CommentListRelationFilter = {
    every?: CommentWhereInput;
    some?: CommentWhereInput;
    none?: CommentWhereInput;
  };

  export type VoteListRelationFilter = {
    every?: VoteWhereInput;
    some?: VoteWhereInput;
    none?: VoteWhereInput;
  };

  export type RequirementListRelationFilter = {
    every?: RequirementWhereInput;
    some?: RequirementWhereInput;
    none?: RequirementWhereInput;
  };

  export type FRDDocumentListRelationFilter = {
    every?: FRDDocumentWhereInput;
    some?: FRDDocumentWhereInput;
    none?: FRDDocumentWhereInput;
  };

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput;
    some?: AuditLogWhereInput;
    none?: AuditLogWhereInput;
  };

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput;
    some?: NotificationWhereInput;
    none?: NotificationWhereInput;
  };

  export type InputGroupListRelationFilter = {
    every?: InputGroupWhereInput;
    some?: InputGroupWhereInput;
    none?: InputGroupWhereInput;
  };

  export type TaskListRelationFilter = {
    every?: TaskWhereInput;
    some?: TaskWhereInput;
    none?: TaskWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type InputOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SolutionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type VoteOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type RequirementOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type FRDDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type InputGroupOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    name?: SortOrder;
    role?: SortOrder;
    department?: SortOrder;
    avatar?: SortOrder;
    passwordHash?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    name?: SortOrder;
    role?: SortOrder;
    department?: SortOrder;
    avatar?: SortOrder;
    passwordHash?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    name?: SortOrder;
    role?: SortOrder;
    department?: SortOrder;
    avatar?: SortOrder;
    passwordHash?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumUserRoleWithAggregatesFilter<$PrismaModel>
      | $Enums.UserRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumUserRoleFilter<$PrismaModel>;
    _max?: NestedEnumUserRoleFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type EnumInputTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InputType | EnumInputTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumInputTypeFilter<$PrismaModel> | $Enums.InputType;
  };

  export type EnumInputStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InputStatus | EnumInputStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.InputStatus[] | ListEnumInputStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.InputStatus[]
      | ListEnumInputStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumInputStatusFilter<$PrismaModel> | $Enums.InputStatus;
  };

  export type EnumIssueTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.IssueType | EnumIssueTypeFieldRefInput<$PrismaModel> | null;
    in?:
      | $Enums.IssueType[]
      | ListEnumIssueTypeFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.IssueType[]
      | ListEnumIssueTypeFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumIssueTypeNullableFilter<$PrismaModel>
      | $Enums.IssueType
      | null;
  };

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>;
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>;
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>
      >;

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type UserScalarRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type InputCountOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    type?: SortOrder;
    status?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    department?: SortOrder;
    issueType?: SortOrder;
    rootCause?: SortOrder;
    priority?: SortOrder;
    aiProcessed?: SortOrder;
    aiTags?: SortOrder;
    aiSuggestions?: SortOrder;
  };

  export type InputMaxOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    type?: SortOrder;
    status?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    department?: SortOrder;
    issueType?: SortOrder;
    rootCause?: SortOrder;
    priority?: SortOrder;
    aiProcessed?: SortOrder;
  };

  export type InputMinOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    type?: SortOrder;
    status?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    department?: SortOrder;
    issueType?: SortOrder;
    rootCause?: SortOrder;
    priority?: SortOrder;
    aiProcessed?: SortOrder;
  };

  export type EnumInputTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InputType | EnumInputTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumInputTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.InputType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumInputTypeFilter<$PrismaModel>;
    _max?: NestedEnumInputTypeFilter<$PrismaModel>;
  };

  export type EnumInputStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InputStatus | EnumInputStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.InputStatus[] | ListEnumInputStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.InputStatus[]
      | ListEnumInputStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumInputStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.InputStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumInputStatusFilter<$PrismaModel>;
    _max?: NestedEnumInputStatusFilter<$PrismaModel>;
  };

  export type EnumIssueTypeNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | $Enums.IssueType
        | EnumIssueTypeFieldRefInput<$PrismaModel>
        | null;
      in?:
        | $Enums.IssueType[]
        | ListEnumIssueTypeFieldRefInput<$PrismaModel>
        | null;
      notIn?:
        | $Enums.IssueType[]
        | ListEnumIssueTypeFieldRefInput<$PrismaModel>
        | null;
      not?:
        | NestedEnumIssueTypeNullableWithAggregatesFilter<$PrismaModel>
        | $Enums.IssueType
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedEnumIssueTypeNullableFilter<$PrismaModel>;
      _max?: NestedEnumIssueTypeNullableFilter<$PrismaModel>;
    };

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>;
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumPriorityWithAggregatesFilter<$PrismaModel>
      | $Enums.Priority;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumPriorityFilter<$PrismaModel>;
    _max?: NestedEnumPriorityFilter<$PrismaModel>;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
            'path'
          >
        >,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          'path'
        >
      >;

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedJsonNullableFilter<$PrismaModel>;
    _max?: NestedJsonNullableFilter<$PrismaModel>;
  };

  export type InputNullableScalarRelationFilter = {
    is?: InputWhereInput | null;
    isNot?: InputWhereInput | null;
  };

  export type SolutionNullableScalarRelationFilter = {
    is?: SolutionWhereInput | null;
    isNot?: SolutionWhereInput | null;
  };

  export type RequirementNullableScalarRelationFilter = {
    is?: RequirementWhereInput | null;
    isNot?: RequirementWhereInput | null;
  };

  export type CommentNullableScalarRelationFilter = {
    is?: CommentWhereInput | null;
    isNot?: CommentWhereInput | null;
  };

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder;
    content?: SortOrder;
    authorId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    inputId?: SortOrder;
    solutionId?: SortOrder;
    requirementId?: SortOrder;
    parentId?: SortOrder;
  };

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder;
    content?: SortOrder;
    authorId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    inputId?: SortOrder;
    solutionId?: SortOrder;
    requirementId?: SortOrder;
    parentId?: SortOrder;
  };

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder;
    content?: SortOrder;
    authorId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    inputId?: SortOrder;
    solutionId?: SortOrder;
    requirementId?: SortOrder;
    parentId?: SortOrder;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type VoteUserIdInputIdCompoundUniqueInput = {
    userId: string;
    inputId: string;
  };

  export type VoteUserIdSolutionIdCompoundUniqueInput = {
    userId: string;
    solutionId: string;
  };

  export type VoteCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    value?: SortOrder;
    createdAt?: SortOrder;
    inputId?: SortOrder;
    solutionId?: SortOrder;
  };

  export type VoteAvgOrderByAggregateInput = {
    value?: SortOrder;
  };

  export type VoteMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    value?: SortOrder;
    createdAt?: SortOrder;
    inputId?: SortOrder;
    solutionId?: SortOrder;
  };

  export type VoteMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    value?: SortOrder;
    createdAt?: SortOrder;
    inputId?: SortOrder;
    solutionId?: SortOrder;
  };

  export type VoteSumOrderByAggregateInput = {
    value?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type EnumGroupStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupStatus | EnumGroupStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.GroupStatus[] | ListEnumGroupStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.GroupStatus[]
      | ListEnumGroupStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumGroupStatusFilter<$PrismaModel> | $Enums.GroupStatus;
  };

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type InputGroupCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    ownerId?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    aiSuggested?: SortOrder;
    aiSimilarity?: SortOrder;
    aiTheme?: SortOrder;
  };

  export type InputGroupAvgOrderByAggregateInput = {
    aiSimilarity?: SortOrder;
  };

  export type InputGroupMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    ownerId?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    aiSuggested?: SortOrder;
    aiSimilarity?: SortOrder;
    aiTheme?: SortOrder;
  };

  export type InputGroupMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    ownerId?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    aiSuggested?: SortOrder;
    aiSimilarity?: SortOrder;
    aiTheme?: SortOrder;
  };

  export type InputGroupSumOrderByAggregateInput = {
    aiSimilarity?: SortOrder;
  };

  export type EnumGroupStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupStatus | EnumGroupStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.GroupStatus[] | ListEnumGroupStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.GroupStatus[]
      | ListEnumGroupStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumGroupStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.GroupStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumGroupStatusFilter<$PrismaModel>;
    _max?: NestedEnumGroupStatusFilter<$PrismaModel>;
  };

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type EnumSolutionStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.SolutionStatus
      | EnumSolutionStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.SolutionStatus[]
      | ListEnumSolutionStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.SolutionStatus[]
      | ListEnumSolutionStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumSolutionStatusFilter<$PrismaModel> | $Enums.SolutionStatus;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type SolutionCountOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    ownerId?: SortOrder;
    status?: SortOrder;
    priority?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    estimatedEffort?: SortOrder;
    targetCompletion?: SortOrder;
    actualCompletion?: SortOrder;
    successCriteria?: SortOrder;
  };

  export type SolutionMaxOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    ownerId?: SortOrder;
    status?: SortOrder;
    priority?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    estimatedEffort?: SortOrder;
    targetCompletion?: SortOrder;
    actualCompletion?: SortOrder;
  };

  export type SolutionMinOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    ownerId?: SortOrder;
    status?: SortOrder;
    priority?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    estimatedEffort?: SortOrder;
    targetCompletion?: SortOrder;
    actualCompletion?: SortOrder;
  };

  export type EnumSolutionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.SolutionStatus
      | EnumSolutionStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.SolutionStatus[]
      | ListEnumSolutionStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.SolutionStatus[]
      | ListEnumSolutionStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumSolutionStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.SolutionStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumSolutionStatusFilter<$PrismaModel>;
    _max?: NestedEnumSolutionStatusFilter<$PrismaModel>;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?:
      | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
      | Date
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus;
  };

  export type SolutionScalarRelationFilter = {
    is?: SolutionWhereInput;
    isNot?: SolutionWhereInput;
  };

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null;
    isNot?: UserWhereInput | null;
  };

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    solutionId?: SortOrder;
    assigneeId?: SortOrder;
    status?: SortOrder;
    priority?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    estimatedHours?: SortOrder;
    actualHours?: SortOrder;
    dueDate?: SortOrder;
    dependencies?: SortOrder;
  };

  export type TaskAvgOrderByAggregateInput = {
    estimatedHours?: SortOrder;
    actualHours?: SortOrder;
  };

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    solutionId?: SortOrder;
    assigneeId?: SortOrder;
    status?: SortOrder;
    priority?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    estimatedHours?: SortOrder;
    actualHours?: SortOrder;
    dueDate?: SortOrder;
  };

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    solutionId?: SortOrder;
    assigneeId?: SortOrder;
    status?: SortOrder;
    priority?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    estimatedHours?: SortOrder;
    actualHours?: SortOrder;
    dueDate?: SortOrder;
  };

  export type TaskSumOrderByAggregateInput = {
    estimatedHours?: SortOrder;
    actualHours?: SortOrder;
  };

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.TaskStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>;
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>;
  };
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type EnumRequirementStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.RequirementStatus
      | EnumRequirementStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.RequirementStatus[]
      | ListEnumRequirementStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.RequirementStatus[]
      | ListEnumRequirementStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumRequirementStatusFilter<$PrismaModel>
      | $Enums.RequirementStatus;
  };

  export type RequirementCountOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    acceptanceCriteria?: SortOrder;
    priority?: SortOrder;
    status?: SortOrder;
    estimatedEffort?: SortOrder;
    dependencies?: SortOrder;
    businessValue?: SortOrder;
    riskAssessment?: SortOrder;
    stakeholders?: SortOrder;
    approvedBy?: SortOrder;
    approvedAt?: SortOrder;
    rejectionReason?: SortOrder;
    solutionId?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RequirementMaxOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    priority?: SortOrder;
    status?: SortOrder;
    estimatedEffort?: SortOrder;
    businessValue?: SortOrder;
    riskAssessment?: SortOrder;
    approvedBy?: SortOrder;
    approvedAt?: SortOrder;
    rejectionReason?: SortOrder;
    solutionId?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RequirementMinOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    priority?: SortOrder;
    status?: SortOrder;
    estimatedEffort?: SortOrder;
    businessValue?: SortOrder;
    riskAssessment?: SortOrder;
    approvedBy?: SortOrder;
    approvedAt?: SortOrder;
    rejectionReason?: SortOrder;
    solutionId?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
            'path'
          >
        >,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>
      >;

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedJsonFilter<$PrismaModel>;
    _max?: NestedJsonFilter<$PrismaModel>;
  };

  export type EnumRequirementStatusWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | $Enums.RequirementStatus
        | EnumRequirementStatusFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.RequirementStatus[]
        | ListEnumRequirementStatusFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.RequirementStatus[]
        | ListEnumRequirementStatusFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumRequirementStatusWithAggregatesFilter<$PrismaModel>
        | $Enums.RequirementStatus;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumRequirementStatusFilter<$PrismaModel>;
      _max?: NestedEnumRequirementStatusFilter<$PrismaModel>;
    };

  export type EnumFRDStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FRDStatus | EnumFRDStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumFRDStatusFilter<$PrismaModel> | $Enums.FRDStatus;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type FRDDocumentCountOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    aiGenerated?: SortOrder;
    aiConfidence?: SortOrder;
    aiPromptUsed?: SortOrder;
    version?: SortOrder;
    status?: SortOrder;
    executiveApproved?: SortOrder;
    exportFormats?: SortOrder;
    templateUsed?: SortOrder;
    generationTime?: SortOrder;
    wordCount?: SortOrder;
    lastExportedAt?: SortOrder;
    solutionId?: SortOrder;
    createdBy?: SortOrder;
    approvedBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FRDDocumentAvgOrderByAggregateInput = {
    aiConfidence?: SortOrder;
    generationTime?: SortOrder;
    wordCount?: SortOrder;
  };

  export type FRDDocumentMaxOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    aiGenerated?: SortOrder;
    aiConfidence?: SortOrder;
    aiPromptUsed?: SortOrder;
    version?: SortOrder;
    status?: SortOrder;
    executiveApproved?: SortOrder;
    templateUsed?: SortOrder;
    generationTime?: SortOrder;
    wordCount?: SortOrder;
    lastExportedAt?: SortOrder;
    solutionId?: SortOrder;
    createdBy?: SortOrder;
    approvedBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FRDDocumentMinOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    aiGenerated?: SortOrder;
    aiConfidence?: SortOrder;
    aiPromptUsed?: SortOrder;
    version?: SortOrder;
    status?: SortOrder;
    executiveApproved?: SortOrder;
    templateUsed?: SortOrder;
    generationTime?: SortOrder;
    wordCount?: SortOrder;
    lastExportedAt?: SortOrder;
    solutionId?: SortOrder;
    createdBy?: SortOrder;
    approvedBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FRDDocumentSumOrderByAggregateInput = {
    aiConfidence?: SortOrder;
    generationTime?: SortOrder;
    wordCount?: SortOrder;
  };

  export type EnumFRDStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FRDStatus | EnumFRDStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumFRDStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.FRDStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumFRDStatusFilter<$PrismaModel>;
    _max?: NestedEnumFRDStatusFilter<$PrismaModel>;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    changes?: SortOrder;
    metadata?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    createdAt?: SortOrder;
  };

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    createdAt?: SortOrder;
  };

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    createdAt?: SortOrder;
  };

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.NotificationType
      | EnumNotificationTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.NotificationType[]
      | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.NotificationType[]
      | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumNotificationTypeFilter<$PrismaModel>
      | $Enums.NotificationType;
  };

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    readAt?: SortOrder;
    data?: SortOrder;
    createdAt?: SortOrder;
  };

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    readAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    readAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.NotificationType
      | EnumNotificationTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.NotificationType[]
      | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.NotificationType[]
      | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.NotificationType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>;
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>;
  };

  export type InputCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<
          InputCreateWithoutCreatorInput,
          InputUncheckedCreateWithoutCreatorInput
        >
      | InputCreateWithoutCreatorInput[]
      | InputUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | InputCreateOrConnectWithoutCreatorInput
      | InputCreateOrConnectWithoutCreatorInput[];
    createMany?: InputCreateManyCreatorInputEnvelope;
    connect?: InputWhereUniqueInput | InputWhereUniqueInput[];
  };

  export type SolutionCreateNestedManyWithoutOwnerInput = {
    create?:
      | XOR<
          SolutionCreateWithoutOwnerInput,
          SolutionUncheckedCreateWithoutOwnerInput
        >
      | SolutionCreateWithoutOwnerInput[]
      | SolutionUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | SolutionCreateOrConnectWithoutOwnerInput
      | SolutionCreateOrConnectWithoutOwnerInput[];
    createMany?: SolutionCreateManyOwnerInputEnvelope;
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[];
  };

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?:
      | XOR<
          CommentCreateWithoutAuthorInput,
          CommentUncheckedCreateWithoutAuthorInput
        >
      | CommentCreateWithoutAuthorInput[]
      | CommentUncheckedCreateWithoutAuthorInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutAuthorInput
      | CommentCreateOrConnectWithoutAuthorInput[];
    createMany?: CommentCreateManyAuthorInputEnvelope;
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
  };

  export type VoteCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<VoteCreateWithoutUserInput, VoteUncheckedCreateWithoutUserInput>
      | VoteCreateWithoutUserInput[]
      | VoteUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | VoteCreateOrConnectWithoutUserInput
      | VoteCreateOrConnectWithoutUserInput[];
    createMany?: VoteCreateManyUserInputEnvelope;
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
  };

  export type RequirementCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<
          RequirementCreateWithoutCreatorInput,
          RequirementUncheckedCreateWithoutCreatorInput
        >
      | RequirementCreateWithoutCreatorInput[]
      | RequirementUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | RequirementCreateOrConnectWithoutCreatorInput
      | RequirementCreateOrConnectWithoutCreatorInput[];
    createMany?: RequirementCreateManyCreatorInputEnvelope;
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[];
  };

  export type FRDDocumentCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<
          FRDDocumentCreateWithoutCreatorInput,
          FRDDocumentUncheckedCreateWithoutCreatorInput
        >
      | FRDDocumentCreateWithoutCreatorInput[]
      | FRDDocumentUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | FRDDocumentCreateOrConnectWithoutCreatorInput
      | FRDDocumentCreateOrConnectWithoutCreatorInput[];
    createMany?: FRDDocumentCreateManyCreatorInputEnvelope;
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
  };

  export type FRDDocumentCreateNestedManyWithoutApproverInput = {
    create?:
      | XOR<
          FRDDocumentCreateWithoutApproverInput,
          FRDDocumentUncheckedCreateWithoutApproverInput
        >
      | FRDDocumentCreateWithoutApproverInput[]
      | FRDDocumentUncheckedCreateWithoutApproverInput[];
    connectOrCreate?:
      | FRDDocumentCreateOrConnectWithoutApproverInput
      | FRDDocumentCreateOrConnectWithoutApproverInput[];
    createMany?: FRDDocumentCreateManyApproverInputEnvelope;
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
  };

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          AuditLogCreateWithoutUserInput,
          AuditLogUncheckedCreateWithoutUserInput
        >
      | AuditLogCreateWithoutUserInput[]
      | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutUserInput
      | AuditLogCreateOrConnectWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
  };

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          NotificationCreateWithoutUserInput,
          NotificationUncheckedCreateWithoutUserInput
        >
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
  };

  export type InputGroupCreateNestedManyWithoutOwnerInput = {
    create?:
      | XOR<
          InputGroupCreateWithoutOwnerInput,
          InputGroupUncheckedCreateWithoutOwnerInput
        >
      | InputGroupCreateWithoutOwnerInput[]
      | InputGroupUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | InputGroupCreateOrConnectWithoutOwnerInput
      | InputGroupCreateOrConnectWithoutOwnerInput[];
    createMany?: InputGroupCreateManyOwnerInputEnvelope;
    connect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[];
  };

  export type TaskCreateNestedManyWithoutAssigneeInput = {
    create?:
      | XOR<
          TaskCreateWithoutAssigneeInput,
          TaskUncheckedCreateWithoutAssigneeInput
        >
      | TaskCreateWithoutAssigneeInput[]
      | TaskUncheckedCreateWithoutAssigneeInput[];
    connectOrCreate?:
      | TaskCreateOrConnectWithoutAssigneeInput
      | TaskCreateOrConnectWithoutAssigneeInput[];
    createMany?: TaskCreateManyAssigneeInputEnvelope;
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
  };

  export type InputUncheckedCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<
          InputCreateWithoutCreatorInput,
          InputUncheckedCreateWithoutCreatorInput
        >
      | InputCreateWithoutCreatorInput[]
      | InputUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | InputCreateOrConnectWithoutCreatorInput
      | InputCreateOrConnectWithoutCreatorInput[];
    createMany?: InputCreateManyCreatorInputEnvelope;
    connect?: InputWhereUniqueInput | InputWhereUniqueInput[];
  };

  export type SolutionUncheckedCreateNestedManyWithoutOwnerInput = {
    create?:
      | XOR<
          SolutionCreateWithoutOwnerInput,
          SolutionUncheckedCreateWithoutOwnerInput
        >
      | SolutionCreateWithoutOwnerInput[]
      | SolutionUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | SolutionCreateOrConnectWithoutOwnerInput
      | SolutionCreateOrConnectWithoutOwnerInput[];
    createMany?: SolutionCreateManyOwnerInputEnvelope;
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[];
  };

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?:
      | XOR<
          CommentCreateWithoutAuthorInput,
          CommentUncheckedCreateWithoutAuthorInput
        >
      | CommentCreateWithoutAuthorInput[]
      | CommentUncheckedCreateWithoutAuthorInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutAuthorInput
      | CommentCreateOrConnectWithoutAuthorInput[];
    createMany?: CommentCreateManyAuthorInputEnvelope;
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
  };

  export type VoteUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<VoteCreateWithoutUserInput, VoteUncheckedCreateWithoutUserInput>
      | VoteCreateWithoutUserInput[]
      | VoteUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | VoteCreateOrConnectWithoutUserInput
      | VoteCreateOrConnectWithoutUserInput[];
    createMany?: VoteCreateManyUserInputEnvelope;
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
  };

  export type RequirementUncheckedCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<
          RequirementCreateWithoutCreatorInput,
          RequirementUncheckedCreateWithoutCreatorInput
        >
      | RequirementCreateWithoutCreatorInput[]
      | RequirementUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | RequirementCreateOrConnectWithoutCreatorInput
      | RequirementCreateOrConnectWithoutCreatorInput[];
    createMany?: RequirementCreateManyCreatorInputEnvelope;
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[];
  };

  export type FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<
          FRDDocumentCreateWithoutCreatorInput,
          FRDDocumentUncheckedCreateWithoutCreatorInput
        >
      | FRDDocumentCreateWithoutCreatorInput[]
      | FRDDocumentUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | FRDDocumentCreateOrConnectWithoutCreatorInput
      | FRDDocumentCreateOrConnectWithoutCreatorInput[];
    createMany?: FRDDocumentCreateManyCreatorInputEnvelope;
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
  };

  export type FRDDocumentUncheckedCreateNestedManyWithoutApproverInput = {
    create?:
      | XOR<
          FRDDocumentCreateWithoutApproverInput,
          FRDDocumentUncheckedCreateWithoutApproverInput
        >
      | FRDDocumentCreateWithoutApproverInput[]
      | FRDDocumentUncheckedCreateWithoutApproverInput[];
    connectOrCreate?:
      | FRDDocumentCreateOrConnectWithoutApproverInput
      | FRDDocumentCreateOrConnectWithoutApproverInput[];
    createMany?: FRDDocumentCreateManyApproverInputEnvelope;
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
  };

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          AuditLogCreateWithoutUserInput,
          AuditLogUncheckedCreateWithoutUserInput
        >
      | AuditLogCreateWithoutUserInput[]
      | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutUserInput
      | AuditLogCreateOrConnectWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
  };

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          NotificationCreateWithoutUserInput,
          NotificationUncheckedCreateWithoutUserInput
        >
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
  };

  export type InputGroupUncheckedCreateNestedManyWithoutOwnerInput = {
    create?:
      | XOR<
          InputGroupCreateWithoutOwnerInput,
          InputGroupUncheckedCreateWithoutOwnerInput
        >
      | InputGroupCreateWithoutOwnerInput[]
      | InputGroupUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | InputGroupCreateOrConnectWithoutOwnerInput
      | InputGroupCreateOrConnectWithoutOwnerInput[];
    createMany?: InputGroupCreateManyOwnerInputEnvelope;
    connect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[];
  };

  export type TaskUncheckedCreateNestedManyWithoutAssigneeInput = {
    create?:
      | XOR<
          TaskCreateWithoutAssigneeInput,
          TaskUncheckedCreateWithoutAssigneeInput
        >
      | TaskCreateWithoutAssigneeInput[]
      | TaskUncheckedCreateWithoutAssigneeInput[];
    connectOrCreate?:
      | TaskCreateOrConnectWithoutAssigneeInput
      | TaskCreateOrConnectWithoutAssigneeInput[];
    createMany?: TaskCreateManyAssigneeInputEnvelope;
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type InputUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<
          InputCreateWithoutCreatorInput,
          InputUncheckedCreateWithoutCreatorInput
        >
      | InputCreateWithoutCreatorInput[]
      | InputUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | InputCreateOrConnectWithoutCreatorInput
      | InputCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | InputUpsertWithWhereUniqueWithoutCreatorInput
      | InputUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: InputCreateManyCreatorInputEnvelope;
    set?: InputWhereUniqueInput | InputWhereUniqueInput[];
    disconnect?: InputWhereUniqueInput | InputWhereUniqueInput[];
    delete?: InputWhereUniqueInput | InputWhereUniqueInput[];
    connect?: InputWhereUniqueInput | InputWhereUniqueInput[];
    update?:
      | InputUpdateWithWhereUniqueWithoutCreatorInput
      | InputUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | InputUpdateManyWithWhereWithoutCreatorInput
      | InputUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: InputScalarWhereInput | InputScalarWhereInput[];
  };

  export type SolutionUpdateManyWithoutOwnerNestedInput = {
    create?:
      | XOR<
          SolutionCreateWithoutOwnerInput,
          SolutionUncheckedCreateWithoutOwnerInput
        >
      | SolutionCreateWithoutOwnerInput[]
      | SolutionUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | SolutionCreateOrConnectWithoutOwnerInput
      | SolutionCreateOrConnectWithoutOwnerInput[];
    upsert?:
      | SolutionUpsertWithWhereUniqueWithoutOwnerInput
      | SolutionUpsertWithWhereUniqueWithoutOwnerInput[];
    createMany?: SolutionCreateManyOwnerInputEnvelope;
    set?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[];
    disconnect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[];
    delete?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[];
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[];
    update?:
      | SolutionUpdateWithWhereUniqueWithoutOwnerInput
      | SolutionUpdateWithWhereUniqueWithoutOwnerInput[];
    updateMany?:
      | SolutionUpdateManyWithWhereWithoutOwnerInput
      | SolutionUpdateManyWithWhereWithoutOwnerInput[];
    deleteMany?: SolutionScalarWhereInput | SolutionScalarWhereInput[];
  };

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?:
      | XOR<
          CommentCreateWithoutAuthorInput,
          CommentUncheckedCreateWithoutAuthorInput
        >
      | CommentCreateWithoutAuthorInput[]
      | CommentUncheckedCreateWithoutAuthorInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutAuthorInput
      | CommentCreateOrConnectWithoutAuthorInput[];
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutAuthorInput
      | CommentUpsertWithWhereUniqueWithoutAuthorInput[];
    createMany?: CommentCreateManyAuthorInputEnvelope;
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    update?:
      | CommentUpdateWithWhereUniqueWithoutAuthorInput
      | CommentUpdateWithWhereUniqueWithoutAuthorInput[];
    updateMany?:
      | CommentUpdateManyWithWhereWithoutAuthorInput
      | CommentUpdateManyWithWhereWithoutAuthorInput[];
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[];
  };

  export type VoteUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<VoteCreateWithoutUserInput, VoteUncheckedCreateWithoutUserInput>
      | VoteCreateWithoutUserInput[]
      | VoteUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | VoteCreateOrConnectWithoutUserInput
      | VoteCreateOrConnectWithoutUserInput[];
    upsert?:
      | VoteUpsertWithWhereUniqueWithoutUserInput
      | VoteUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: VoteCreateManyUserInputEnvelope;
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    update?:
      | VoteUpdateWithWhereUniqueWithoutUserInput
      | VoteUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | VoteUpdateManyWithWhereWithoutUserInput
      | VoteUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[];
  };

  export type RequirementUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<
          RequirementCreateWithoutCreatorInput,
          RequirementUncheckedCreateWithoutCreatorInput
        >
      | RequirementCreateWithoutCreatorInput[]
      | RequirementUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | RequirementCreateOrConnectWithoutCreatorInput
      | RequirementCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | RequirementUpsertWithWhereUniqueWithoutCreatorInput
      | RequirementUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: RequirementCreateManyCreatorInputEnvelope;
    set?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[];
    disconnect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[];
    delete?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[];
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[];
    update?:
      | RequirementUpdateWithWhereUniqueWithoutCreatorInput
      | RequirementUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | RequirementUpdateManyWithWhereWithoutCreatorInput
      | RequirementUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: RequirementScalarWhereInput | RequirementScalarWhereInput[];
  };

  export type FRDDocumentUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<
          FRDDocumentCreateWithoutCreatorInput,
          FRDDocumentUncheckedCreateWithoutCreatorInput
        >
      | FRDDocumentCreateWithoutCreatorInput[]
      | FRDDocumentUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | FRDDocumentCreateOrConnectWithoutCreatorInput
      | FRDDocumentCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | FRDDocumentUpsertWithWhereUniqueWithoutCreatorInput
      | FRDDocumentUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: FRDDocumentCreateManyCreatorInputEnvelope;
    set?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    disconnect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    delete?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    update?:
      | FRDDocumentUpdateWithWhereUniqueWithoutCreatorInput
      | FRDDocumentUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | FRDDocumentUpdateManyWithWhereWithoutCreatorInput
      | FRDDocumentUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: FRDDocumentScalarWhereInput | FRDDocumentScalarWhereInput[];
  };

  export type FRDDocumentUpdateManyWithoutApproverNestedInput = {
    create?:
      | XOR<
          FRDDocumentCreateWithoutApproverInput,
          FRDDocumentUncheckedCreateWithoutApproverInput
        >
      | FRDDocumentCreateWithoutApproverInput[]
      | FRDDocumentUncheckedCreateWithoutApproverInput[];
    connectOrCreate?:
      | FRDDocumentCreateOrConnectWithoutApproverInput
      | FRDDocumentCreateOrConnectWithoutApproverInput[];
    upsert?:
      | FRDDocumentUpsertWithWhereUniqueWithoutApproverInput
      | FRDDocumentUpsertWithWhereUniqueWithoutApproverInput[];
    createMany?: FRDDocumentCreateManyApproverInputEnvelope;
    set?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    disconnect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    delete?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    update?:
      | FRDDocumentUpdateWithWhereUniqueWithoutApproverInput
      | FRDDocumentUpdateWithWhereUniqueWithoutApproverInput[];
    updateMany?:
      | FRDDocumentUpdateManyWithWhereWithoutApproverInput
      | FRDDocumentUpdateManyWithWhereWithoutApproverInput[];
    deleteMany?: FRDDocumentScalarWhereInput | FRDDocumentScalarWhereInput[];
  };

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          AuditLogCreateWithoutUserInput,
          AuditLogUncheckedCreateWithoutUserInput
        >
      | AuditLogCreateWithoutUserInput[]
      | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutUserInput
      | AuditLogCreateOrConnectWithoutUserInput[];
    upsert?:
      | AuditLogUpsertWithWhereUniqueWithoutUserInput
      | AuditLogUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    update?:
      | AuditLogUpdateWithWhereUniqueWithoutUserInput
      | AuditLogUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AuditLogUpdateManyWithWhereWithoutUserInput
      | AuditLogUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
  };

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          NotificationCreateWithoutUserInput,
          NotificationUncheckedCreateWithoutUserInput
        >
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    upsert?:
      | NotificationUpsertWithWhereUniqueWithoutUserInput
      | NotificationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    update?:
      | NotificationUpdateWithWhereUniqueWithoutUserInput
      | NotificationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | NotificationUpdateManyWithWhereWithoutUserInput
      | NotificationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
  };

  export type InputGroupUpdateManyWithoutOwnerNestedInput = {
    create?:
      | XOR<
          InputGroupCreateWithoutOwnerInput,
          InputGroupUncheckedCreateWithoutOwnerInput
        >
      | InputGroupCreateWithoutOwnerInput[]
      | InputGroupUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | InputGroupCreateOrConnectWithoutOwnerInput
      | InputGroupCreateOrConnectWithoutOwnerInput[];
    upsert?:
      | InputGroupUpsertWithWhereUniqueWithoutOwnerInput
      | InputGroupUpsertWithWhereUniqueWithoutOwnerInput[];
    createMany?: InputGroupCreateManyOwnerInputEnvelope;
    set?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[];
    disconnect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[];
    delete?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[];
    connect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[];
    update?:
      | InputGroupUpdateWithWhereUniqueWithoutOwnerInput
      | InputGroupUpdateWithWhereUniqueWithoutOwnerInput[];
    updateMany?:
      | InputGroupUpdateManyWithWhereWithoutOwnerInput
      | InputGroupUpdateManyWithWhereWithoutOwnerInput[];
    deleteMany?: InputGroupScalarWhereInput | InputGroupScalarWhereInput[];
  };

  export type TaskUpdateManyWithoutAssigneeNestedInput = {
    create?:
      | XOR<
          TaskCreateWithoutAssigneeInput,
          TaskUncheckedCreateWithoutAssigneeInput
        >
      | TaskCreateWithoutAssigneeInput[]
      | TaskUncheckedCreateWithoutAssigneeInput[];
    connectOrCreate?:
      | TaskCreateOrConnectWithoutAssigneeInput
      | TaskCreateOrConnectWithoutAssigneeInput[];
    upsert?:
      | TaskUpsertWithWhereUniqueWithoutAssigneeInput
      | TaskUpsertWithWhereUniqueWithoutAssigneeInput[];
    createMany?: TaskCreateManyAssigneeInputEnvelope;
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    update?:
      | TaskUpdateWithWhereUniqueWithoutAssigneeInput
      | TaskUpdateWithWhereUniqueWithoutAssigneeInput[];
    updateMany?:
      | TaskUpdateManyWithWhereWithoutAssigneeInput
      | TaskUpdateManyWithWhereWithoutAssigneeInput[];
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[];
  };

  export type InputUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<
          InputCreateWithoutCreatorInput,
          InputUncheckedCreateWithoutCreatorInput
        >
      | InputCreateWithoutCreatorInput[]
      | InputUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | InputCreateOrConnectWithoutCreatorInput
      | InputCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | InputUpsertWithWhereUniqueWithoutCreatorInput
      | InputUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: InputCreateManyCreatorInputEnvelope;
    set?: InputWhereUniqueInput | InputWhereUniqueInput[];
    disconnect?: InputWhereUniqueInput | InputWhereUniqueInput[];
    delete?: InputWhereUniqueInput | InputWhereUniqueInput[];
    connect?: InputWhereUniqueInput | InputWhereUniqueInput[];
    update?:
      | InputUpdateWithWhereUniqueWithoutCreatorInput
      | InputUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | InputUpdateManyWithWhereWithoutCreatorInput
      | InputUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: InputScalarWhereInput | InputScalarWhereInput[];
  };

  export type SolutionUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?:
      | XOR<
          SolutionCreateWithoutOwnerInput,
          SolutionUncheckedCreateWithoutOwnerInput
        >
      | SolutionCreateWithoutOwnerInput[]
      | SolutionUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | SolutionCreateOrConnectWithoutOwnerInput
      | SolutionCreateOrConnectWithoutOwnerInput[];
    upsert?:
      | SolutionUpsertWithWhereUniqueWithoutOwnerInput
      | SolutionUpsertWithWhereUniqueWithoutOwnerInput[];
    createMany?: SolutionCreateManyOwnerInputEnvelope;
    set?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[];
    disconnect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[];
    delete?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[];
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[];
    update?:
      | SolutionUpdateWithWhereUniqueWithoutOwnerInput
      | SolutionUpdateWithWhereUniqueWithoutOwnerInput[];
    updateMany?:
      | SolutionUpdateManyWithWhereWithoutOwnerInput
      | SolutionUpdateManyWithWhereWithoutOwnerInput[];
    deleteMany?: SolutionScalarWhereInput | SolutionScalarWhereInput[];
  };

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?:
      | XOR<
          CommentCreateWithoutAuthorInput,
          CommentUncheckedCreateWithoutAuthorInput
        >
      | CommentCreateWithoutAuthorInput[]
      | CommentUncheckedCreateWithoutAuthorInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutAuthorInput
      | CommentCreateOrConnectWithoutAuthorInput[];
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutAuthorInput
      | CommentUpsertWithWhereUniqueWithoutAuthorInput[];
    createMany?: CommentCreateManyAuthorInputEnvelope;
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    update?:
      | CommentUpdateWithWhereUniqueWithoutAuthorInput
      | CommentUpdateWithWhereUniqueWithoutAuthorInput[];
    updateMany?:
      | CommentUpdateManyWithWhereWithoutAuthorInput
      | CommentUpdateManyWithWhereWithoutAuthorInput[];
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[];
  };

  export type VoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<VoteCreateWithoutUserInput, VoteUncheckedCreateWithoutUserInput>
      | VoteCreateWithoutUserInput[]
      | VoteUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | VoteCreateOrConnectWithoutUserInput
      | VoteCreateOrConnectWithoutUserInput[];
    upsert?:
      | VoteUpsertWithWhereUniqueWithoutUserInput
      | VoteUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: VoteCreateManyUserInputEnvelope;
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    update?:
      | VoteUpdateWithWhereUniqueWithoutUserInput
      | VoteUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | VoteUpdateManyWithWhereWithoutUserInput
      | VoteUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[];
  };

  export type RequirementUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<
          RequirementCreateWithoutCreatorInput,
          RequirementUncheckedCreateWithoutCreatorInput
        >
      | RequirementCreateWithoutCreatorInput[]
      | RequirementUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | RequirementCreateOrConnectWithoutCreatorInput
      | RequirementCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | RequirementUpsertWithWhereUniqueWithoutCreatorInput
      | RequirementUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: RequirementCreateManyCreatorInputEnvelope;
    set?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[];
    disconnect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[];
    delete?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[];
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[];
    update?:
      | RequirementUpdateWithWhereUniqueWithoutCreatorInput
      | RequirementUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | RequirementUpdateManyWithWhereWithoutCreatorInput
      | RequirementUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: RequirementScalarWhereInput | RequirementScalarWhereInput[];
  };

  export type FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<
          FRDDocumentCreateWithoutCreatorInput,
          FRDDocumentUncheckedCreateWithoutCreatorInput
        >
      | FRDDocumentCreateWithoutCreatorInput[]
      | FRDDocumentUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | FRDDocumentCreateOrConnectWithoutCreatorInput
      | FRDDocumentCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | FRDDocumentUpsertWithWhereUniqueWithoutCreatorInput
      | FRDDocumentUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: FRDDocumentCreateManyCreatorInputEnvelope;
    set?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    disconnect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    delete?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    update?:
      | FRDDocumentUpdateWithWhereUniqueWithoutCreatorInput
      | FRDDocumentUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | FRDDocumentUpdateManyWithWhereWithoutCreatorInput
      | FRDDocumentUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: FRDDocumentScalarWhereInput | FRDDocumentScalarWhereInput[];
  };

  export type FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput = {
    create?:
      | XOR<
          FRDDocumentCreateWithoutApproverInput,
          FRDDocumentUncheckedCreateWithoutApproverInput
        >
      | FRDDocumentCreateWithoutApproverInput[]
      | FRDDocumentUncheckedCreateWithoutApproverInput[];
    connectOrCreate?:
      | FRDDocumentCreateOrConnectWithoutApproverInput
      | FRDDocumentCreateOrConnectWithoutApproverInput[];
    upsert?:
      | FRDDocumentUpsertWithWhereUniqueWithoutApproverInput
      | FRDDocumentUpsertWithWhereUniqueWithoutApproverInput[];
    createMany?: FRDDocumentCreateManyApproverInputEnvelope;
    set?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    disconnect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    delete?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    update?:
      | FRDDocumentUpdateWithWhereUniqueWithoutApproverInput
      | FRDDocumentUpdateWithWhereUniqueWithoutApproverInput[];
    updateMany?:
      | FRDDocumentUpdateManyWithWhereWithoutApproverInput
      | FRDDocumentUpdateManyWithWhereWithoutApproverInput[];
    deleteMany?: FRDDocumentScalarWhereInput | FRDDocumentScalarWhereInput[];
  };

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          AuditLogCreateWithoutUserInput,
          AuditLogUncheckedCreateWithoutUserInput
        >
      | AuditLogCreateWithoutUserInput[]
      | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutUserInput
      | AuditLogCreateOrConnectWithoutUserInput[];
    upsert?:
      | AuditLogUpsertWithWhereUniqueWithoutUserInput
      | AuditLogUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    update?:
      | AuditLogUpdateWithWhereUniqueWithoutUserInput
      | AuditLogUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AuditLogUpdateManyWithWhereWithoutUserInput
      | AuditLogUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
  };

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          NotificationCreateWithoutUserInput,
          NotificationUncheckedCreateWithoutUserInput
        >
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    upsert?:
      | NotificationUpsertWithWhereUniqueWithoutUserInput
      | NotificationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    update?:
      | NotificationUpdateWithWhereUniqueWithoutUserInput
      | NotificationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | NotificationUpdateManyWithWhereWithoutUserInput
      | NotificationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
  };

  export type InputGroupUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?:
      | XOR<
          InputGroupCreateWithoutOwnerInput,
          InputGroupUncheckedCreateWithoutOwnerInput
        >
      | InputGroupCreateWithoutOwnerInput[]
      | InputGroupUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | InputGroupCreateOrConnectWithoutOwnerInput
      | InputGroupCreateOrConnectWithoutOwnerInput[];
    upsert?:
      | InputGroupUpsertWithWhereUniqueWithoutOwnerInput
      | InputGroupUpsertWithWhereUniqueWithoutOwnerInput[];
    createMany?: InputGroupCreateManyOwnerInputEnvelope;
    set?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[];
    disconnect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[];
    delete?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[];
    connect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[];
    update?:
      | InputGroupUpdateWithWhereUniqueWithoutOwnerInput
      | InputGroupUpdateWithWhereUniqueWithoutOwnerInput[];
    updateMany?:
      | InputGroupUpdateManyWithWhereWithoutOwnerInput
      | InputGroupUpdateManyWithWhereWithoutOwnerInput[];
    deleteMany?: InputGroupScalarWhereInput | InputGroupScalarWhereInput[];
  };

  export type TaskUncheckedUpdateManyWithoutAssigneeNestedInput = {
    create?:
      | XOR<
          TaskCreateWithoutAssigneeInput,
          TaskUncheckedCreateWithoutAssigneeInput
        >
      | TaskCreateWithoutAssigneeInput[]
      | TaskUncheckedCreateWithoutAssigneeInput[];
    connectOrCreate?:
      | TaskCreateOrConnectWithoutAssigneeInput
      | TaskCreateOrConnectWithoutAssigneeInput[];
    upsert?:
      | TaskUpsertWithWhereUniqueWithoutAssigneeInput
      | TaskUpsertWithWhereUniqueWithoutAssigneeInput[];
    createMany?: TaskCreateManyAssigneeInputEnvelope;
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    update?:
      | TaskUpdateWithWhereUniqueWithoutAssigneeInput
      | TaskUpdateWithWhereUniqueWithoutAssigneeInput[];
    updateMany?:
      | TaskUpdateManyWithWhereWithoutAssigneeInput
      | TaskUpdateManyWithWhereWithoutAssigneeInput[];
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutInputsInput = {
    create?: XOR<
      UserCreateWithoutInputsInput,
      UserUncheckedCreateWithoutInputsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutInputsInput;
    connect?: UserWhereUniqueInput;
  };

  export type SolutionCreateNestedManyWithoutInputsInput = {
    create?:
      | XOR<
          SolutionCreateWithoutInputsInput,
          SolutionUncheckedCreateWithoutInputsInput
        >
      | SolutionCreateWithoutInputsInput[]
      | SolutionUncheckedCreateWithoutInputsInput[];
    connectOrCreate?:
      | SolutionCreateOrConnectWithoutInputsInput
      | SolutionCreateOrConnectWithoutInputsInput[];
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[];
  };

  export type CommentCreateNestedManyWithoutInputInput = {
    create?:
      | XOR<
          CommentCreateWithoutInputInput,
          CommentUncheckedCreateWithoutInputInput
        >
      | CommentCreateWithoutInputInput[]
      | CommentUncheckedCreateWithoutInputInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutInputInput
      | CommentCreateOrConnectWithoutInputInput[];
    createMany?: CommentCreateManyInputInputEnvelope;
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
  };

  export type VoteCreateNestedManyWithoutInputInput = {
    create?:
      | XOR<VoteCreateWithoutInputInput, VoteUncheckedCreateWithoutInputInput>
      | VoteCreateWithoutInputInput[]
      | VoteUncheckedCreateWithoutInputInput[];
    connectOrCreate?:
      | VoteCreateOrConnectWithoutInputInput
      | VoteCreateOrConnectWithoutInputInput[];
    createMany?: VoteCreateManyInputInputEnvelope;
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
  };

  export type InputGroupCreateNestedManyWithoutInputsInput = {
    create?:
      | XOR<
          InputGroupCreateWithoutInputsInput,
          InputGroupUncheckedCreateWithoutInputsInput
        >
      | InputGroupCreateWithoutInputsInput[]
      | InputGroupUncheckedCreateWithoutInputsInput[];
    connectOrCreate?:
      | InputGroupCreateOrConnectWithoutInputsInput
      | InputGroupCreateOrConnectWithoutInputsInput[];
    connect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[];
  };

  export type SolutionUncheckedCreateNestedManyWithoutInputsInput = {
    create?:
      | XOR<
          SolutionCreateWithoutInputsInput,
          SolutionUncheckedCreateWithoutInputsInput
        >
      | SolutionCreateWithoutInputsInput[]
      | SolutionUncheckedCreateWithoutInputsInput[];
    connectOrCreate?:
      | SolutionCreateOrConnectWithoutInputsInput
      | SolutionCreateOrConnectWithoutInputsInput[];
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[];
  };

  export type CommentUncheckedCreateNestedManyWithoutInputInput = {
    create?:
      | XOR<
          CommentCreateWithoutInputInput,
          CommentUncheckedCreateWithoutInputInput
        >
      | CommentCreateWithoutInputInput[]
      | CommentUncheckedCreateWithoutInputInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutInputInput
      | CommentCreateOrConnectWithoutInputInput[];
    createMany?: CommentCreateManyInputInputEnvelope;
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
  };

  export type VoteUncheckedCreateNestedManyWithoutInputInput = {
    create?:
      | XOR<VoteCreateWithoutInputInput, VoteUncheckedCreateWithoutInputInput>
      | VoteCreateWithoutInputInput[]
      | VoteUncheckedCreateWithoutInputInput[];
    connectOrCreate?:
      | VoteCreateOrConnectWithoutInputInput
      | VoteCreateOrConnectWithoutInputInput[];
    createMany?: VoteCreateManyInputInputEnvelope;
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
  };

  export type InputGroupUncheckedCreateNestedManyWithoutInputsInput = {
    create?:
      | XOR<
          InputGroupCreateWithoutInputsInput,
          InputGroupUncheckedCreateWithoutInputsInput
        >
      | InputGroupCreateWithoutInputsInput[]
      | InputGroupUncheckedCreateWithoutInputsInput[];
    connectOrCreate?:
      | InputGroupCreateOrConnectWithoutInputsInput
      | InputGroupCreateOrConnectWithoutInputsInput[];
    connect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[];
  };

  export type EnumInputTypeFieldUpdateOperationsInput = {
    set?: $Enums.InputType;
  };

  export type EnumInputStatusFieldUpdateOperationsInput = {
    set?: $Enums.InputStatus;
  };

  export type NullableEnumIssueTypeFieldUpdateOperationsInput = {
    set?: $Enums.IssueType | null;
  };

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type UserUpdateOneRequiredWithoutInputsNestedInput = {
    create?: XOR<
      UserCreateWithoutInputsInput,
      UserUncheckedCreateWithoutInputsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutInputsInput;
    upsert?: UserUpsertWithoutInputsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutInputsInput,
        UserUpdateWithoutInputsInput
      >,
      UserUncheckedUpdateWithoutInputsInput
    >;
  };

  export type SolutionUpdateManyWithoutInputsNestedInput = {
    create?:
      | XOR<
          SolutionCreateWithoutInputsInput,
          SolutionUncheckedCreateWithoutInputsInput
        >
      | SolutionCreateWithoutInputsInput[]
      | SolutionUncheckedCreateWithoutInputsInput[];
    connectOrCreate?:
      | SolutionCreateOrConnectWithoutInputsInput
      | SolutionCreateOrConnectWithoutInputsInput[];
    upsert?:
      | SolutionUpsertWithWhereUniqueWithoutInputsInput
      | SolutionUpsertWithWhereUniqueWithoutInputsInput[];
    set?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[];
    disconnect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[];
    delete?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[];
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[];
    update?:
      | SolutionUpdateWithWhereUniqueWithoutInputsInput
      | SolutionUpdateWithWhereUniqueWithoutInputsInput[];
    updateMany?:
      | SolutionUpdateManyWithWhereWithoutInputsInput
      | SolutionUpdateManyWithWhereWithoutInputsInput[];
    deleteMany?: SolutionScalarWhereInput | SolutionScalarWhereInput[];
  };

  export type CommentUpdateManyWithoutInputNestedInput = {
    create?:
      | XOR<
          CommentCreateWithoutInputInput,
          CommentUncheckedCreateWithoutInputInput
        >
      | CommentCreateWithoutInputInput[]
      | CommentUncheckedCreateWithoutInputInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutInputInput
      | CommentCreateOrConnectWithoutInputInput[];
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutInputInput
      | CommentUpsertWithWhereUniqueWithoutInputInput[];
    createMany?: CommentCreateManyInputInputEnvelope;
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    update?:
      | CommentUpdateWithWhereUniqueWithoutInputInput
      | CommentUpdateWithWhereUniqueWithoutInputInput[];
    updateMany?:
      | CommentUpdateManyWithWhereWithoutInputInput
      | CommentUpdateManyWithWhereWithoutInputInput[];
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[];
  };

  export type VoteUpdateManyWithoutInputNestedInput = {
    create?:
      | XOR<VoteCreateWithoutInputInput, VoteUncheckedCreateWithoutInputInput>
      | VoteCreateWithoutInputInput[]
      | VoteUncheckedCreateWithoutInputInput[];
    connectOrCreate?:
      | VoteCreateOrConnectWithoutInputInput
      | VoteCreateOrConnectWithoutInputInput[];
    upsert?:
      | VoteUpsertWithWhereUniqueWithoutInputInput
      | VoteUpsertWithWhereUniqueWithoutInputInput[];
    createMany?: VoteCreateManyInputInputEnvelope;
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    update?:
      | VoteUpdateWithWhereUniqueWithoutInputInput
      | VoteUpdateWithWhereUniqueWithoutInputInput[];
    updateMany?:
      | VoteUpdateManyWithWhereWithoutInputInput
      | VoteUpdateManyWithWhereWithoutInputInput[];
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[];
  };

  export type InputGroupUpdateManyWithoutInputsNestedInput = {
    create?:
      | XOR<
          InputGroupCreateWithoutInputsInput,
          InputGroupUncheckedCreateWithoutInputsInput
        >
      | InputGroupCreateWithoutInputsInput[]
      | InputGroupUncheckedCreateWithoutInputsInput[];
    connectOrCreate?:
      | InputGroupCreateOrConnectWithoutInputsInput
      | InputGroupCreateOrConnectWithoutInputsInput[];
    upsert?:
      | InputGroupUpsertWithWhereUniqueWithoutInputsInput
      | InputGroupUpsertWithWhereUniqueWithoutInputsInput[];
    set?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[];
    disconnect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[];
    delete?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[];
    connect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[];
    update?:
      | InputGroupUpdateWithWhereUniqueWithoutInputsInput
      | InputGroupUpdateWithWhereUniqueWithoutInputsInput[];
    updateMany?:
      | InputGroupUpdateManyWithWhereWithoutInputsInput
      | InputGroupUpdateManyWithWhereWithoutInputsInput[];
    deleteMany?: InputGroupScalarWhereInput | InputGroupScalarWhereInput[];
  };

  export type SolutionUncheckedUpdateManyWithoutInputsNestedInput = {
    create?:
      | XOR<
          SolutionCreateWithoutInputsInput,
          SolutionUncheckedCreateWithoutInputsInput
        >
      | SolutionCreateWithoutInputsInput[]
      | SolutionUncheckedCreateWithoutInputsInput[];
    connectOrCreate?:
      | SolutionCreateOrConnectWithoutInputsInput
      | SolutionCreateOrConnectWithoutInputsInput[];
    upsert?:
      | SolutionUpsertWithWhereUniqueWithoutInputsInput
      | SolutionUpsertWithWhereUniqueWithoutInputsInput[];
    set?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[];
    disconnect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[];
    delete?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[];
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[];
    update?:
      | SolutionUpdateWithWhereUniqueWithoutInputsInput
      | SolutionUpdateWithWhereUniqueWithoutInputsInput[];
    updateMany?:
      | SolutionUpdateManyWithWhereWithoutInputsInput
      | SolutionUpdateManyWithWhereWithoutInputsInput[];
    deleteMany?: SolutionScalarWhereInput | SolutionScalarWhereInput[];
  };

  export type CommentUncheckedUpdateManyWithoutInputNestedInput = {
    create?:
      | XOR<
          CommentCreateWithoutInputInput,
          CommentUncheckedCreateWithoutInputInput
        >
      | CommentCreateWithoutInputInput[]
      | CommentUncheckedCreateWithoutInputInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutInputInput
      | CommentCreateOrConnectWithoutInputInput[];
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutInputInput
      | CommentUpsertWithWhereUniqueWithoutInputInput[];
    createMany?: CommentCreateManyInputInputEnvelope;
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    update?:
      | CommentUpdateWithWhereUniqueWithoutInputInput
      | CommentUpdateWithWhereUniqueWithoutInputInput[];
    updateMany?:
      | CommentUpdateManyWithWhereWithoutInputInput
      | CommentUpdateManyWithWhereWithoutInputInput[];
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[];
  };

  export type VoteUncheckedUpdateManyWithoutInputNestedInput = {
    create?:
      | XOR<VoteCreateWithoutInputInput, VoteUncheckedCreateWithoutInputInput>
      | VoteCreateWithoutInputInput[]
      | VoteUncheckedCreateWithoutInputInput[];
    connectOrCreate?:
      | VoteCreateOrConnectWithoutInputInput
      | VoteCreateOrConnectWithoutInputInput[];
    upsert?:
      | VoteUpsertWithWhereUniqueWithoutInputInput
      | VoteUpsertWithWhereUniqueWithoutInputInput[];
    createMany?: VoteCreateManyInputInputEnvelope;
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    update?:
      | VoteUpdateWithWhereUniqueWithoutInputInput
      | VoteUpdateWithWhereUniqueWithoutInputInput[];
    updateMany?:
      | VoteUpdateManyWithWhereWithoutInputInput
      | VoteUpdateManyWithWhereWithoutInputInput[];
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[];
  };

  export type InputGroupUncheckedUpdateManyWithoutInputsNestedInput = {
    create?:
      | XOR<
          InputGroupCreateWithoutInputsInput,
          InputGroupUncheckedCreateWithoutInputsInput
        >
      | InputGroupCreateWithoutInputsInput[]
      | InputGroupUncheckedCreateWithoutInputsInput[];
    connectOrCreate?:
      | InputGroupCreateOrConnectWithoutInputsInput
      | InputGroupCreateOrConnectWithoutInputsInput[];
    upsert?:
      | InputGroupUpsertWithWhereUniqueWithoutInputsInput
      | InputGroupUpsertWithWhereUniqueWithoutInputsInput[];
    set?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[];
    disconnect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[];
    delete?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[];
    connect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[];
    update?:
      | InputGroupUpdateWithWhereUniqueWithoutInputsInput
      | InputGroupUpdateWithWhereUniqueWithoutInputsInput[];
    updateMany?:
      | InputGroupUpdateManyWithWhereWithoutInputsInput
      | InputGroupUpdateManyWithWhereWithoutInputsInput[];
    deleteMany?: InputGroupScalarWhereInput | InputGroupScalarWhereInput[];
  };

  export type CommentCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<
          CommentCreateWithoutParentInput,
          CommentUncheckedCreateWithoutParentInput
        >
      | CommentCreateWithoutParentInput[]
      | CommentUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutParentInput
      | CommentCreateOrConnectWithoutParentInput[];
    createMany?: CommentCreateManyParentInputEnvelope;
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
  };

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<
      UserCreateWithoutCommentsInput,
      UserUncheckedCreateWithoutCommentsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput;
    connect?: UserWhereUniqueInput;
  };

  export type InputCreateNestedOneWithoutCommentsInput = {
    create?: XOR<
      InputCreateWithoutCommentsInput,
      InputUncheckedCreateWithoutCommentsInput
    >;
    connectOrCreate?: InputCreateOrConnectWithoutCommentsInput;
    connect?: InputWhereUniqueInput;
  };

  export type SolutionCreateNestedOneWithoutCommentsInput = {
    create?: XOR<
      SolutionCreateWithoutCommentsInput,
      SolutionUncheckedCreateWithoutCommentsInput
    >;
    connectOrCreate?: SolutionCreateOrConnectWithoutCommentsInput;
    connect?: SolutionWhereUniqueInput;
  };

  export type RequirementCreateNestedOneWithoutCommentsInput = {
    create?: XOR<
      RequirementCreateWithoutCommentsInput,
      RequirementUncheckedCreateWithoutCommentsInput
    >;
    connectOrCreate?: RequirementCreateOrConnectWithoutCommentsInput;
    connect?: RequirementWhereUniqueInput;
  };

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<
      CommentCreateWithoutRepliesInput,
      CommentUncheckedCreateWithoutRepliesInput
    >;
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput;
    connect?: CommentWhereUniqueInput;
  };

  export type CommentUncheckedCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<
          CommentCreateWithoutParentInput,
          CommentUncheckedCreateWithoutParentInput
        >
      | CommentCreateWithoutParentInput[]
      | CommentUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutParentInput
      | CommentCreateOrConnectWithoutParentInput[];
    createMany?: CommentCreateManyParentInputEnvelope;
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
  };

  export type CommentUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<
          CommentCreateWithoutParentInput,
          CommentUncheckedCreateWithoutParentInput
        >
      | CommentCreateWithoutParentInput[]
      | CommentUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutParentInput
      | CommentCreateOrConnectWithoutParentInput[];
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutParentInput
      | CommentUpsertWithWhereUniqueWithoutParentInput[];
    createMany?: CommentCreateManyParentInputEnvelope;
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    update?:
      | CommentUpdateWithWhereUniqueWithoutParentInput
      | CommentUpdateWithWhereUniqueWithoutParentInput[];
    updateMany?:
      | CommentUpdateManyWithWhereWithoutParentInput
      | CommentUpdateManyWithWhereWithoutParentInput[];
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[];
  };

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<
      UserCreateWithoutCommentsInput,
      UserUncheckedCreateWithoutCommentsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput;
    upsert?: UserUpsertWithoutCommentsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutCommentsInput,
        UserUpdateWithoutCommentsInput
      >,
      UserUncheckedUpdateWithoutCommentsInput
    >;
  };

  export type InputUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<
      InputCreateWithoutCommentsInput,
      InputUncheckedCreateWithoutCommentsInput
    >;
    connectOrCreate?: InputCreateOrConnectWithoutCommentsInput;
    upsert?: InputUpsertWithoutCommentsInput;
    disconnect?: InputWhereInput | boolean;
    delete?: InputWhereInput | boolean;
    connect?: InputWhereUniqueInput;
    update?: XOR<
      XOR<
        InputUpdateToOneWithWhereWithoutCommentsInput,
        InputUpdateWithoutCommentsInput
      >,
      InputUncheckedUpdateWithoutCommentsInput
    >;
  };

  export type SolutionUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<
      SolutionCreateWithoutCommentsInput,
      SolutionUncheckedCreateWithoutCommentsInput
    >;
    connectOrCreate?: SolutionCreateOrConnectWithoutCommentsInput;
    upsert?: SolutionUpsertWithoutCommentsInput;
    disconnect?: SolutionWhereInput | boolean;
    delete?: SolutionWhereInput | boolean;
    connect?: SolutionWhereUniqueInput;
    update?: XOR<
      XOR<
        SolutionUpdateToOneWithWhereWithoutCommentsInput,
        SolutionUpdateWithoutCommentsInput
      >,
      SolutionUncheckedUpdateWithoutCommentsInput
    >;
  };

  export type RequirementUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<
      RequirementCreateWithoutCommentsInput,
      RequirementUncheckedCreateWithoutCommentsInput
    >;
    connectOrCreate?: RequirementCreateOrConnectWithoutCommentsInput;
    upsert?: RequirementUpsertWithoutCommentsInput;
    disconnect?: RequirementWhereInput | boolean;
    delete?: RequirementWhereInput | boolean;
    connect?: RequirementWhereUniqueInput;
    update?: XOR<
      XOR<
        RequirementUpdateToOneWithWhereWithoutCommentsInput,
        RequirementUpdateWithoutCommentsInput
      >,
      RequirementUncheckedUpdateWithoutCommentsInput
    >;
  };

  export type CommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<
      CommentCreateWithoutRepliesInput,
      CommentUncheckedCreateWithoutRepliesInput
    >;
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput;
    upsert?: CommentUpsertWithoutRepliesInput;
    disconnect?: CommentWhereInput | boolean;
    delete?: CommentWhereInput | boolean;
    connect?: CommentWhereUniqueInput;
    update?: XOR<
      XOR<
        CommentUpdateToOneWithWhereWithoutRepliesInput,
        CommentUpdateWithoutRepliesInput
      >,
      CommentUncheckedUpdateWithoutRepliesInput
    >;
  };

  export type CommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<
          CommentCreateWithoutParentInput,
          CommentUncheckedCreateWithoutParentInput
        >
      | CommentCreateWithoutParentInput[]
      | CommentUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutParentInput
      | CommentCreateOrConnectWithoutParentInput[];
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutParentInput
      | CommentUpsertWithWhereUniqueWithoutParentInput[];
    createMany?: CommentCreateManyParentInputEnvelope;
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    update?:
      | CommentUpdateWithWhereUniqueWithoutParentInput
      | CommentUpdateWithWhereUniqueWithoutParentInput[];
    updateMany?:
      | CommentUpdateManyWithWhereWithoutParentInput
      | CommentUpdateManyWithWhereWithoutParentInput[];
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutVotesInput = {
    create?: XOR<
      UserCreateWithoutVotesInput,
      UserUncheckedCreateWithoutVotesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutVotesInput;
    connect?: UserWhereUniqueInput;
  };

  export type InputCreateNestedOneWithoutVotesInput = {
    create?: XOR<
      InputCreateWithoutVotesInput,
      InputUncheckedCreateWithoutVotesInput
    >;
    connectOrCreate?: InputCreateOrConnectWithoutVotesInput;
    connect?: InputWhereUniqueInput;
  };

  export type SolutionCreateNestedOneWithoutVotesInput = {
    create?: XOR<
      SolutionCreateWithoutVotesInput,
      SolutionUncheckedCreateWithoutVotesInput
    >;
    connectOrCreate?: SolutionCreateOrConnectWithoutVotesInput;
    connect?: SolutionWhereUniqueInput;
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type UserUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<
      UserCreateWithoutVotesInput,
      UserUncheckedCreateWithoutVotesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutVotesInput;
    upsert?: UserUpsertWithoutVotesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutVotesInput,
        UserUpdateWithoutVotesInput
      >,
      UserUncheckedUpdateWithoutVotesInput
    >;
  };

  export type InputUpdateOneWithoutVotesNestedInput = {
    create?: XOR<
      InputCreateWithoutVotesInput,
      InputUncheckedCreateWithoutVotesInput
    >;
    connectOrCreate?: InputCreateOrConnectWithoutVotesInput;
    upsert?: InputUpsertWithoutVotesInput;
    disconnect?: InputWhereInput | boolean;
    delete?: InputWhereInput | boolean;
    connect?: InputWhereUniqueInput;
    update?: XOR<
      XOR<
        InputUpdateToOneWithWhereWithoutVotesInput,
        InputUpdateWithoutVotesInput
      >,
      InputUncheckedUpdateWithoutVotesInput
    >;
  };

  export type SolutionUpdateOneWithoutVotesNestedInput = {
    create?: XOR<
      SolutionCreateWithoutVotesInput,
      SolutionUncheckedCreateWithoutVotesInput
    >;
    connectOrCreate?: SolutionCreateOrConnectWithoutVotesInput;
    upsert?: SolutionUpsertWithoutVotesInput;
    disconnect?: SolutionWhereInput | boolean;
    delete?: SolutionWhereInput | boolean;
    connect?: SolutionWhereUniqueInput;
    update?: XOR<
      XOR<
        SolutionUpdateToOneWithWhereWithoutVotesInput,
        SolutionUpdateWithoutVotesInput
      >,
      SolutionUncheckedUpdateWithoutVotesInput
    >;
  };

  export type UserCreateNestedOneWithoutInputGroupsInput = {
    create?: XOR<
      UserCreateWithoutInputGroupsInput,
      UserUncheckedCreateWithoutInputGroupsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutInputGroupsInput;
    connect?: UserWhereUniqueInput;
  };

  export type InputCreateNestedManyWithoutGroupsInput = {
    create?:
      | XOR<
          InputCreateWithoutGroupsInput,
          InputUncheckedCreateWithoutGroupsInput
        >
      | InputCreateWithoutGroupsInput[]
      | InputUncheckedCreateWithoutGroupsInput[];
    connectOrCreate?:
      | InputCreateOrConnectWithoutGroupsInput
      | InputCreateOrConnectWithoutGroupsInput[];
    connect?: InputWhereUniqueInput | InputWhereUniqueInput[];
  };

  export type InputUncheckedCreateNestedManyWithoutGroupsInput = {
    create?:
      | XOR<
          InputCreateWithoutGroupsInput,
          InputUncheckedCreateWithoutGroupsInput
        >
      | InputCreateWithoutGroupsInput[]
      | InputUncheckedCreateWithoutGroupsInput[];
    connectOrCreate?:
      | InputCreateOrConnectWithoutGroupsInput
      | InputCreateOrConnectWithoutGroupsInput[];
    connect?: InputWhereUniqueInput | InputWhereUniqueInput[];
  };

  export type EnumGroupStatusFieldUpdateOperationsInput = {
    set?: $Enums.GroupStatus;
  };

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type UserUpdateOneRequiredWithoutInputGroupsNestedInput = {
    create?: XOR<
      UserCreateWithoutInputGroupsInput,
      UserUncheckedCreateWithoutInputGroupsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutInputGroupsInput;
    upsert?: UserUpsertWithoutInputGroupsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutInputGroupsInput,
        UserUpdateWithoutInputGroupsInput
      >,
      UserUncheckedUpdateWithoutInputGroupsInput
    >;
  };

  export type InputUpdateManyWithoutGroupsNestedInput = {
    create?:
      | XOR<
          InputCreateWithoutGroupsInput,
          InputUncheckedCreateWithoutGroupsInput
        >
      | InputCreateWithoutGroupsInput[]
      | InputUncheckedCreateWithoutGroupsInput[];
    connectOrCreate?:
      | InputCreateOrConnectWithoutGroupsInput
      | InputCreateOrConnectWithoutGroupsInput[];
    upsert?:
      | InputUpsertWithWhereUniqueWithoutGroupsInput
      | InputUpsertWithWhereUniqueWithoutGroupsInput[];
    set?: InputWhereUniqueInput | InputWhereUniqueInput[];
    disconnect?: InputWhereUniqueInput | InputWhereUniqueInput[];
    delete?: InputWhereUniqueInput | InputWhereUniqueInput[];
    connect?: InputWhereUniqueInput | InputWhereUniqueInput[];
    update?:
      | InputUpdateWithWhereUniqueWithoutGroupsInput
      | InputUpdateWithWhereUniqueWithoutGroupsInput[];
    updateMany?:
      | InputUpdateManyWithWhereWithoutGroupsInput
      | InputUpdateManyWithWhereWithoutGroupsInput[];
    deleteMany?: InputScalarWhereInput | InputScalarWhereInput[];
  };

  export type InputUncheckedUpdateManyWithoutGroupsNestedInput = {
    create?:
      | XOR<
          InputCreateWithoutGroupsInput,
          InputUncheckedCreateWithoutGroupsInput
        >
      | InputCreateWithoutGroupsInput[]
      | InputUncheckedCreateWithoutGroupsInput[];
    connectOrCreate?:
      | InputCreateOrConnectWithoutGroupsInput
      | InputCreateOrConnectWithoutGroupsInput[];
    upsert?:
      | InputUpsertWithWhereUniqueWithoutGroupsInput
      | InputUpsertWithWhereUniqueWithoutGroupsInput[];
    set?: InputWhereUniqueInput | InputWhereUniqueInput[];
    disconnect?: InputWhereUniqueInput | InputWhereUniqueInput[];
    delete?: InputWhereUniqueInput | InputWhereUniqueInput[];
    connect?: InputWhereUniqueInput | InputWhereUniqueInput[];
    update?:
      | InputUpdateWithWhereUniqueWithoutGroupsInput
      | InputUpdateWithWhereUniqueWithoutGroupsInput[];
    updateMany?:
      | InputUpdateManyWithWhereWithoutGroupsInput
      | InputUpdateManyWithWhereWithoutGroupsInput[];
    deleteMany?: InputScalarWhereInput | InputScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutSolutionsInput = {
    create?: XOR<
      UserCreateWithoutSolutionsInput,
      UserUncheckedCreateWithoutSolutionsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSolutionsInput;
    connect?: UserWhereUniqueInput;
  };

  export type InputCreateNestedManyWithoutSolutionsInput = {
    create?:
      | XOR<
          InputCreateWithoutSolutionsInput,
          InputUncheckedCreateWithoutSolutionsInput
        >
      | InputCreateWithoutSolutionsInput[]
      | InputUncheckedCreateWithoutSolutionsInput[];
    connectOrCreate?:
      | InputCreateOrConnectWithoutSolutionsInput
      | InputCreateOrConnectWithoutSolutionsInput[];
    connect?: InputWhereUniqueInput | InputWhereUniqueInput[];
  };

  export type TaskCreateNestedManyWithoutSolutionInput = {
    create?:
      | XOR<
          TaskCreateWithoutSolutionInput,
          TaskUncheckedCreateWithoutSolutionInput
        >
      | TaskCreateWithoutSolutionInput[]
      | TaskUncheckedCreateWithoutSolutionInput[];
    connectOrCreate?:
      | TaskCreateOrConnectWithoutSolutionInput
      | TaskCreateOrConnectWithoutSolutionInput[];
    createMany?: TaskCreateManySolutionInputEnvelope;
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
  };

  export type CommentCreateNestedManyWithoutSolutionInput = {
    create?:
      | XOR<
          CommentCreateWithoutSolutionInput,
          CommentUncheckedCreateWithoutSolutionInput
        >
      | CommentCreateWithoutSolutionInput[]
      | CommentUncheckedCreateWithoutSolutionInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutSolutionInput
      | CommentCreateOrConnectWithoutSolutionInput[];
    createMany?: CommentCreateManySolutionInputEnvelope;
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
  };

  export type VoteCreateNestedManyWithoutSolutionInput = {
    create?:
      | XOR<
          VoteCreateWithoutSolutionInput,
          VoteUncheckedCreateWithoutSolutionInput
        >
      | VoteCreateWithoutSolutionInput[]
      | VoteUncheckedCreateWithoutSolutionInput[];
    connectOrCreate?:
      | VoteCreateOrConnectWithoutSolutionInput
      | VoteCreateOrConnectWithoutSolutionInput[];
    createMany?: VoteCreateManySolutionInputEnvelope;
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
  };

  export type RequirementCreateNestedManyWithoutSolutionInput = {
    create?:
      | XOR<
          RequirementCreateWithoutSolutionInput,
          RequirementUncheckedCreateWithoutSolutionInput
        >
      | RequirementCreateWithoutSolutionInput[]
      | RequirementUncheckedCreateWithoutSolutionInput[];
    connectOrCreate?:
      | RequirementCreateOrConnectWithoutSolutionInput
      | RequirementCreateOrConnectWithoutSolutionInput[];
    createMany?: RequirementCreateManySolutionInputEnvelope;
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[];
  };

  export type FRDDocumentCreateNestedManyWithoutSolutionInput = {
    create?:
      | XOR<
          FRDDocumentCreateWithoutSolutionInput,
          FRDDocumentUncheckedCreateWithoutSolutionInput
        >
      | FRDDocumentCreateWithoutSolutionInput[]
      | FRDDocumentUncheckedCreateWithoutSolutionInput[];
    connectOrCreate?:
      | FRDDocumentCreateOrConnectWithoutSolutionInput
      | FRDDocumentCreateOrConnectWithoutSolutionInput[];
    createMany?: FRDDocumentCreateManySolutionInputEnvelope;
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
  };

  export type InputUncheckedCreateNestedManyWithoutSolutionsInput = {
    create?:
      | XOR<
          InputCreateWithoutSolutionsInput,
          InputUncheckedCreateWithoutSolutionsInput
        >
      | InputCreateWithoutSolutionsInput[]
      | InputUncheckedCreateWithoutSolutionsInput[];
    connectOrCreate?:
      | InputCreateOrConnectWithoutSolutionsInput
      | InputCreateOrConnectWithoutSolutionsInput[];
    connect?: InputWhereUniqueInput | InputWhereUniqueInput[];
  };

  export type TaskUncheckedCreateNestedManyWithoutSolutionInput = {
    create?:
      | XOR<
          TaskCreateWithoutSolutionInput,
          TaskUncheckedCreateWithoutSolutionInput
        >
      | TaskCreateWithoutSolutionInput[]
      | TaskUncheckedCreateWithoutSolutionInput[];
    connectOrCreate?:
      | TaskCreateOrConnectWithoutSolutionInput
      | TaskCreateOrConnectWithoutSolutionInput[];
    createMany?: TaskCreateManySolutionInputEnvelope;
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
  };

  export type CommentUncheckedCreateNestedManyWithoutSolutionInput = {
    create?:
      | XOR<
          CommentCreateWithoutSolutionInput,
          CommentUncheckedCreateWithoutSolutionInput
        >
      | CommentCreateWithoutSolutionInput[]
      | CommentUncheckedCreateWithoutSolutionInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutSolutionInput
      | CommentCreateOrConnectWithoutSolutionInput[];
    createMany?: CommentCreateManySolutionInputEnvelope;
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
  };

  export type VoteUncheckedCreateNestedManyWithoutSolutionInput = {
    create?:
      | XOR<
          VoteCreateWithoutSolutionInput,
          VoteUncheckedCreateWithoutSolutionInput
        >
      | VoteCreateWithoutSolutionInput[]
      | VoteUncheckedCreateWithoutSolutionInput[];
    connectOrCreate?:
      | VoteCreateOrConnectWithoutSolutionInput
      | VoteCreateOrConnectWithoutSolutionInput[];
    createMany?: VoteCreateManySolutionInputEnvelope;
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
  };

  export type RequirementUncheckedCreateNestedManyWithoutSolutionInput = {
    create?:
      | XOR<
          RequirementCreateWithoutSolutionInput,
          RequirementUncheckedCreateWithoutSolutionInput
        >
      | RequirementCreateWithoutSolutionInput[]
      | RequirementUncheckedCreateWithoutSolutionInput[];
    connectOrCreate?:
      | RequirementCreateOrConnectWithoutSolutionInput
      | RequirementCreateOrConnectWithoutSolutionInput[];
    createMany?: RequirementCreateManySolutionInputEnvelope;
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[];
  };

  export type FRDDocumentUncheckedCreateNestedManyWithoutSolutionInput = {
    create?:
      | XOR<
          FRDDocumentCreateWithoutSolutionInput,
          FRDDocumentUncheckedCreateWithoutSolutionInput
        >
      | FRDDocumentCreateWithoutSolutionInput[]
      | FRDDocumentUncheckedCreateWithoutSolutionInput[];
    connectOrCreate?:
      | FRDDocumentCreateOrConnectWithoutSolutionInput
      | FRDDocumentCreateOrConnectWithoutSolutionInput[];
    createMany?: FRDDocumentCreateManySolutionInputEnvelope;
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
  };

  export type EnumSolutionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SolutionStatus;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type UserUpdateOneRequiredWithoutSolutionsNestedInput = {
    create?: XOR<
      UserCreateWithoutSolutionsInput,
      UserUncheckedCreateWithoutSolutionsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSolutionsInput;
    upsert?: UserUpsertWithoutSolutionsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutSolutionsInput,
        UserUpdateWithoutSolutionsInput
      >,
      UserUncheckedUpdateWithoutSolutionsInput
    >;
  };

  export type InputUpdateManyWithoutSolutionsNestedInput = {
    create?:
      | XOR<
          InputCreateWithoutSolutionsInput,
          InputUncheckedCreateWithoutSolutionsInput
        >
      | InputCreateWithoutSolutionsInput[]
      | InputUncheckedCreateWithoutSolutionsInput[];
    connectOrCreate?:
      | InputCreateOrConnectWithoutSolutionsInput
      | InputCreateOrConnectWithoutSolutionsInput[];
    upsert?:
      | InputUpsertWithWhereUniqueWithoutSolutionsInput
      | InputUpsertWithWhereUniqueWithoutSolutionsInput[];
    set?: InputWhereUniqueInput | InputWhereUniqueInput[];
    disconnect?: InputWhereUniqueInput | InputWhereUniqueInput[];
    delete?: InputWhereUniqueInput | InputWhereUniqueInput[];
    connect?: InputWhereUniqueInput | InputWhereUniqueInput[];
    update?:
      | InputUpdateWithWhereUniqueWithoutSolutionsInput
      | InputUpdateWithWhereUniqueWithoutSolutionsInput[];
    updateMany?:
      | InputUpdateManyWithWhereWithoutSolutionsInput
      | InputUpdateManyWithWhereWithoutSolutionsInput[];
    deleteMany?: InputScalarWhereInput | InputScalarWhereInput[];
  };

  export type TaskUpdateManyWithoutSolutionNestedInput = {
    create?:
      | XOR<
          TaskCreateWithoutSolutionInput,
          TaskUncheckedCreateWithoutSolutionInput
        >
      | TaskCreateWithoutSolutionInput[]
      | TaskUncheckedCreateWithoutSolutionInput[];
    connectOrCreate?:
      | TaskCreateOrConnectWithoutSolutionInput
      | TaskCreateOrConnectWithoutSolutionInput[];
    upsert?:
      | TaskUpsertWithWhereUniqueWithoutSolutionInput
      | TaskUpsertWithWhereUniqueWithoutSolutionInput[];
    createMany?: TaskCreateManySolutionInputEnvelope;
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    update?:
      | TaskUpdateWithWhereUniqueWithoutSolutionInput
      | TaskUpdateWithWhereUniqueWithoutSolutionInput[];
    updateMany?:
      | TaskUpdateManyWithWhereWithoutSolutionInput
      | TaskUpdateManyWithWhereWithoutSolutionInput[];
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[];
  };

  export type CommentUpdateManyWithoutSolutionNestedInput = {
    create?:
      | XOR<
          CommentCreateWithoutSolutionInput,
          CommentUncheckedCreateWithoutSolutionInput
        >
      | CommentCreateWithoutSolutionInput[]
      | CommentUncheckedCreateWithoutSolutionInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutSolutionInput
      | CommentCreateOrConnectWithoutSolutionInput[];
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutSolutionInput
      | CommentUpsertWithWhereUniqueWithoutSolutionInput[];
    createMany?: CommentCreateManySolutionInputEnvelope;
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    update?:
      | CommentUpdateWithWhereUniqueWithoutSolutionInput
      | CommentUpdateWithWhereUniqueWithoutSolutionInput[];
    updateMany?:
      | CommentUpdateManyWithWhereWithoutSolutionInput
      | CommentUpdateManyWithWhereWithoutSolutionInput[];
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[];
  };

  export type VoteUpdateManyWithoutSolutionNestedInput = {
    create?:
      | XOR<
          VoteCreateWithoutSolutionInput,
          VoteUncheckedCreateWithoutSolutionInput
        >
      | VoteCreateWithoutSolutionInput[]
      | VoteUncheckedCreateWithoutSolutionInput[];
    connectOrCreate?:
      | VoteCreateOrConnectWithoutSolutionInput
      | VoteCreateOrConnectWithoutSolutionInput[];
    upsert?:
      | VoteUpsertWithWhereUniqueWithoutSolutionInput
      | VoteUpsertWithWhereUniqueWithoutSolutionInput[];
    createMany?: VoteCreateManySolutionInputEnvelope;
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    update?:
      | VoteUpdateWithWhereUniqueWithoutSolutionInput
      | VoteUpdateWithWhereUniqueWithoutSolutionInput[];
    updateMany?:
      | VoteUpdateManyWithWhereWithoutSolutionInput
      | VoteUpdateManyWithWhereWithoutSolutionInput[];
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[];
  };

  export type RequirementUpdateManyWithoutSolutionNestedInput = {
    create?:
      | XOR<
          RequirementCreateWithoutSolutionInput,
          RequirementUncheckedCreateWithoutSolutionInput
        >
      | RequirementCreateWithoutSolutionInput[]
      | RequirementUncheckedCreateWithoutSolutionInput[];
    connectOrCreate?:
      | RequirementCreateOrConnectWithoutSolutionInput
      | RequirementCreateOrConnectWithoutSolutionInput[];
    upsert?:
      | RequirementUpsertWithWhereUniqueWithoutSolutionInput
      | RequirementUpsertWithWhereUniqueWithoutSolutionInput[];
    createMany?: RequirementCreateManySolutionInputEnvelope;
    set?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[];
    disconnect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[];
    delete?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[];
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[];
    update?:
      | RequirementUpdateWithWhereUniqueWithoutSolutionInput
      | RequirementUpdateWithWhereUniqueWithoutSolutionInput[];
    updateMany?:
      | RequirementUpdateManyWithWhereWithoutSolutionInput
      | RequirementUpdateManyWithWhereWithoutSolutionInput[];
    deleteMany?: RequirementScalarWhereInput | RequirementScalarWhereInput[];
  };

  export type FRDDocumentUpdateManyWithoutSolutionNestedInput = {
    create?:
      | XOR<
          FRDDocumentCreateWithoutSolutionInput,
          FRDDocumentUncheckedCreateWithoutSolutionInput
        >
      | FRDDocumentCreateWithoutSolutionInput[]
      | FRDDocumentUncheckedCreateWithoutSolutionInput[];
    connectOrCreate?:
      | FRDDocumentCreateOrConnectWithoutSolutionInput
      | FRDDocumentCreateOrConnectWithoutSolutionInput[];
    upsert?:
      | FRDDocumentUpsertWithWhereUniqueWithoutSolutionInput
      | FRDDocumentUpsertWithWhereUniqueWithoutSolutionInput[];
    createMany?: FRDDocumentCreateManySolutionInputEnvelope;
    set?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    disconnect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    delete?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    update?:
      | FRDDocumentUpdateWithWhereUniqueWithoutSolutionInput
      | FRDDocumentUpdateWithWhereUniqueWithoutSolutionInput[];
    updateMany?:
      | FRDDocumentUpdateManyWithWhereWithoutSolutionInput
      | FRDDocumentUpdateManyWithWhereWithoutSolutionInput[];
    deleteMany?: FRDDocumentScalarWhereInput | FRDDocumentScalarWhereInput[];
  };

  export type InputUncheckedUpdateManyWithoutSolutionsNestedInput = {
    create?:
      | XOR<
          InputCreateWithoutSolutionsInput,
          InputUncheckedCreateWithoutSolutionsInput
        >
      | InputCreateWithoutSolutionsInput[]
      | InputUncheckedCreateWithoutSolutionsInput[];
    connectOrCreate?:
      | InputCreateOrConnectWithoutSolutionsInput
      | InputCreateOrConnectWithoutSolutionsInput[];
    upsert?:
      | InputUpsertWithWhereUniqueWithoutSolutionsInput
      | InputUpsertWithWhereUniqueWithoutSolutionsInput[];
    set?: InputWhereUniqueInput | InputWhereUniqueInput[];
    disconnect?: InputWhereUniqueInput | InputWhereUniqueInput[];
    delete?: InputWhereUniqueInput | InputWhereUniqueInput[];
    connect?: InputWhereUniqueInput | InputWhereUniqueInput[];
    update?:
      | InputUpdateWithWhereUniqueWithoutSolutionsInput
      | InputUpdateWithWhereUniqueWithoutSolutionsInput[];
    updateMany?:
      | InputUpdateManyWithWhereWithoutSolutionsInput
      | InputUpdateManyWithWhereWithoutSolutionsInput[];
    deleteMany?: InputScalarWhereInput | InputScalarWhereInput[];
  };

  export type TaskUncheckedUpdateManyWithoutSolutionNestedInput = {
    create?:
      | XOR<
          TaskCreateWithoutSolutionInput,
          TaskUncheckedCreateWithoutSolutionInput
        >
      | TaskCreateWithoutSolutionInput[]
      | TaskUncheckedCreateWithoutSolutionInput[];
    connectOrCreate?:
      | TaskCreateOrConnectWithoutSolutionInput
      | TaskCreateOrConnectWithoutSolutionInput[];
    upsert?:
      | TaskUpsertWithWhereUniqueWithoutSolutionInput
      | TaskUpsertWithWhereUniqueWithoutSolutionInput[];
    createMany?: TaskCreateManySolutionInputEnvelope;
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[];
    update?:
      | TaskUpdateWithWhereUniqueWithoutSolutionInput
      | TaskUpdateWithWhereUniqueWithoutSolutionInput[];
    updateMany?:
      | TaskUpdateManyWithWhereWithoutSolutionInput
      | TaskUpdateManyWithWhereWithoutSolutionInput[];
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[];
  };

  export type CommentUncheckedUpdateManyWithoutSolutionNestedInput = {
    create?:
      | XOR<
          CommentCreateWithoutSolutionInput,
          CommentUncheckedCreateWithoutSolutionInput
        >
      | CommentCreateWithoutSolutionInput[]
      | CommentUncheckedCreateWithoutSolutionInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutSolutionInput
      | CommentCreateOrConnectWithoutSolutionInput[];
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutSolutionInput
      | CommentUpsertWithWhereUniqueWithoutSolutionInput[];
    createMany?: CommentCreateManySolutionInputEnvelope;
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    update?:
      | CommentUpdateWithWhereUniqueWithoutSolutionInput
      | CommentUpdateWithWhereUniqueWithoutSolutionInput[];
    updateMany?:
      | CommentUpdateManyWithWhereWithoutSolutionInput
      | CommentUpdateManyWithWhereWithoutSolutionInput[];
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[];
  };

  export type VoteUncheckedUpdateManyWithoutSolutionNestedInput = {
    create?:
      | XOR<
          VoteCreateWithoutSolutionInput,
          VoteUncheckedCreateWithoutSolutionInput
        >
      | VoteCreateWithoutSolutionInput[]
      | VoteUncheckedCreateWithoutSolutionInput[];
    connectOrCreate?:
      | VoteCreateOrConnectWithoutSolutionInput
      | VoteCreateOrConnectWithoutSolutionInput[];
    upsert?:
      | VoteUpsertWithWhereUniqueWithoutSolutionInput
      | VoteUpsertWithWhereUniqueWithoutSolutionInput[];
    createMany?: VoteCreateManySolutionInputEnvelope;
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[];
    update?:
      | VoteUpdateWithWhereUniqueWithoutSolutionInput
      | VoteUpdateWithWhereUniqueWithoutSolutionInput[];
    updateMany?:
      | VoteUpdateManyWithWhereWithoutSolutionInput
      | VoteUpdateManyWithWhereWithoutSolutionInput[];
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[];
  };

  export type RequirementUncheckedUpdateManyWithoutSolutionNestedInput = {
    create?:
      | XOR<
          RequirementCreateWithoutSolutionInput,
          RequirementUncheckedCreateWithoutSolutionInput
        >
      | RequirementCreateWithoutSolutionInput[]
      | RequirementUncheckedCreateWithoutSolutionInput[];
    connectOrCreate?:
      | RequirementCreateOrConnectWithoutSolutionInput
      | RequirementCreateOrConnectWithoutSolutionInput[];
    upsert?:
      | RequirementUpsertWithWhereUniqueWithoutSolutionInput
      | RequirementUpsertWithWhereUniqueWithoutSolutionInput[];
    createMany?: RequirementCreateManySolutionInputEnvelope;
    set?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[];
    disconnect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[];
    delete?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[];
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[];
    update?:
      | RequirementUpdateWithWhereUniqueWithoutSolutionInput
      | RequirementUpdateWithWhereUniqueWithoutSolutionInput[];
    updateMany?:
      | RequirementUpdateManyWithWhereWithoutSolutionInput
      | RequirementUpdateManyWithWhereWithoutSolutionInput[];
    deleteMany?: RequirementScalarWhereInput | RequirementScalarWhereInput[];
  };

  export type FRDDocumentUncheckedUpdateManyWithoutSolutionNestedInput = {
    create?:
      | XOR<
          FRDDocumentCreateWithoutSolutionInput,
          FRDDocumentUncheckedCreateWithoutSolutionInput
        >
      | FRDDocumentCreateWithoutSolutionInput[]
      | FRDDocumentUncheckedCreateWithoutSolutionInput[];
    connectOrCreate?:
      | FRDDocumentCreateOrConnectWithoutSolutionInput
      | FRDDocumentCreateOrConnectWithoutSolutionInput[];
    upsert?:
      | FRDDocumentUpsertWithWhereUniqueWithoutSolutionInput
      | FRDDocumentUpsertWithWhereUniqueWithoutSolutionInput[];
    createMany?: FRDDocumentCreateManySolutionInputEnvelope;
    set?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    disconnect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    delete?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[];
    update?:
      | FRDDocumentUpdateWithWhereUniqueWithoutSolutionInput
      | FRDDocumentUpdateWithWhereUniqueWithoutSolutionInput[];
    updateMany?:
      | FRDDocumentUpdateManyWithWhereWithoutSolutionInput
      | FRDDocumentUpdateManyWithWhereWithoutSolutionInput[];
    deleteMany?: FRDDocumentScalarWhereInput | FRDDocumentScalarWhereInput[];
  };

  export type SolutionCreateNestedOneWithoutTasksInput = {
    create?: XOR<
      SolutionCreateWithoutTasksInput,
      SolutionUncheckedCreateWithoutTasksInput
    >;
    connectOrCreate?: SolutionCreateOrConnectWithoutTasksInput;
    connect?: SolutionWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutTasksInput = {
    create?: XOR<
      UserCreateWithoutTasksInput,
      UserUncheckedCreateWithoutTasksInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus;
  };

  export type SolutionUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<
      SolutionCreateWithoutTasksInput,
      SolutionUncheckedCreateWithoutTasksInput
    >;
    connectOrCreate?: SolutionCreateOrConnectWithoutTasksInput;
    upsert?: SolutionUpsertWithoutTasksInput;
    connect?: SolutionWhereUniqueInput;
    update?: XOR<
      XOR<
        SolutionUpdateToOneWithWhereWithoutTasksInput,
        SolutionUpdateWithoutTasksInput
      >,
      SolutionUncheckedUpdateWithoutTasksInput
    >;
  };

  export type UserUpdateOneWithoutTasksNestedInput = {
    create?: XOR<
      UserCreateWithoutTasksInput,
      UserUncheckedCreateWithoutTasksInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput;
    upsert?: UserUpsertWithoutTasksInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutTasksInput,
        UserUpdateWithoutTasksInput
      >,
      UserUncheckedUpdateWithoutTasksInput
    >;
  };

  export type SolutionCreateNestedOneWithoutRequirementsInput = {
    create?: XOR<
      SolutionCreateWithoutRequirementsInput,
      SolutionUncheckedCreateWithoutRequirementsInput
    >;
    connectOrCreate?: SolutionCreateOrConnectWithoutRequirementsInput;
    connect?: SolutionWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutRequirementsInput = {
    create?: XOR<
      UserCreateWithoutRequirementsInput,
      UserUncheckedCreateWithoutRequirementsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutRequirementsInput;
    connect?: UserWhereUniqueInput;
  };

  export type CommentCreateNestedManyWithoutRequirementInput = {
    create?:
      | XOR<
          CommentCreateWithoutRequirementInput,
          CommentUncheckedCreateWithoutRequirementInput
        >
      | CommentCreateWithoutRequirementInput[]
      | CommentUncheckedCreateWithoutRequirementInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutRequirementInput
      | CommentCreateOrConnectWithoutRequirementInput[];
    createMany?: CommentCreateManyRequirementInputEnvelope;
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
  };

  export type CommentUncheckedCreateNestedManyWithoutRequirementInput = {
    create?:
      | XOR<
          CommentCreateWithoutRequirementInput,
          CommentUncheckedCreateWithoutRequirementInput
        >
      | CommentCreateWithoutRequirementInput[]
      | CommentUncheckedCreateWithoutRequirementInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutRequirementInput
      | CommentCreateOrConnectWithoutRequirementInput[];
    createMany?: CommentCreateManyRequirementInputEnvelope;
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
  };

  export type EnumRequirementStatusFieldUpdateOperationsInput = {
    set?: $Enums.RequirementStatus;
  };

  export type SolutionUpdateOneRequiredWithoutRequirementsNestedInput = {
    create?: XOR<
      SolutionCreateWithoutRequirementsInput,
      SolutionUncheckedCreateWithoutRequirementsInput
    >;
    connectOrCreate?: SolutionCreateOrConnectWithoutRequirementsInput;
    upsert?: SolutionUpsertWithoutRequirementsInput;
    connect?: SolutionWhereUniqueInput;
    update?: XOR<
      XOR<
        SolutionUpdateToOneWithWhereWithoutRequirementsInput,
        SolutionUpdateWithoutRequirementsInput
      >,
      SolutionUncheckedUpdateWithoutRequirementsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutRequirementsNestedInput = {
    create?: XOR<
      UserCreateWithoutRequirementsInput,
      UserUncheckedCreateWithoutRequirementsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutRequirementsInput;
    upsert?: UserUpsertWithoutRequirementsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutRequirementsInput,
        UserUpdateWithoutRequirementsInput
      >,
      UserUncheckedUpdateWithoutRequirementsInput
    >;
  };

  export type CommentUpdateManyWithoutRequirementNestedInput = {
    create?:
      | XOR<
          CommentCreateWithoutRequirementInput,
          CommentUncheckedCreateWithoutRequirementInput
        >
      | CommentCreateWithoutRequirementInput[]
      | CommentUncheckedCreateWithoutRequirementInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutRequirementInput
      | CommentCreateOrConnectWithoutRequirementInput[];
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutRequirementInput
      | CommentUpsertWithWhereUniqueWithoutRequirementInput[];
    createMany?: CommentCreateManyRequirementInputEnvelope;
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    update?:
      | CommentUpdateWithWhereUniqueWithoutRequirementInput
      | CommentUpdateWithWhereUniqueWithoutRequirementInput[];
    updateMany?:
      | CommentUpdateManyWithWhereWithoutRequirementInput
      | CommentUpdateManyWithWhereWithoutRequirementInput[];
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[];
  };

  export type CommentUncheckedUpdateManyWithoutRequirementNestedInput = {
    create?:
      | XOR<
          CommentCreateWithoutRequirementInput,
          CommentUncheckedCreateWithoutRequirementInput
        >
      | CommentCreateWithoutRequirementInput[]
      | CommentUncheckedCreateWithoutRequirementInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutRequirementInput
      | CommentCreateOrConnectWithoutRequirementInput[];
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutRequirementInput
      | CommentUpsertWithWhereUniqueWithoutRequirementInput[];
    createMany?: CommentCreateManyRequirementInputEnvelope;
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    update?:
      | CommentUpdateWithWhereUniqueWithoutRequirementInput
      | CommentUpdateWithWhereUniqueWithoutRequirementInput[];
    updateMany?:
      | CommentUpdateManyWithWhereWithoutRequirementInput
      | CommentUpdateManyWithWhereWithoutRequirementInput[];
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[];
  };

  export type SolutionCreateNestedOneWithoutFrdDocumentsInput = {
    create?: XOR<
      SolutionCreateWithoutFrdDocumentsInput,
      SolutionUncheckedCreateWithoutFrdDocumentsInput
    >;
    connectOrCreate?: SolutionCreateOrConnectWithoutFrdDocumentsInput;
    connect?: SolutionWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutFrdDocumentsInput = {
    create?: XOR<
      UserCreateWithoutFrdDocumentsInput,
      UserUncheckedCreateWithoutFrdDocumentsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutFrdDocumentsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutApprovedFRDsInput = {
    create?: XOR<
      UserCreateWithoutApprovedFRDsInput,
      UserUncheckedCreateWithoutApprovedFRDsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutApprovedFRDsInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumFRDStatusFieldUpdateOperationsInput = {
    set?: $Enums.FRDStatus;
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type SolutionUpdateOneRequiredWithoutFrdDocumentsNestedInput = {
    create?: XOR<
      SolutionCreateWithoutFrdDocumentsInput,
      SolutionUncheckedCreateWithoutFrdDocumentsInput
    >;
    connectOrCreate?: SolutionCreateOrConnectWithoutFrdDocumentsInput;
    upsert?: SolutionUpsertWithoutFrdDocumentsInput;
    connect?: SolutionWhereUniqueInput;
    update?: XOR<
      XOR<
        SolutionUpdateToOneWithWhereWithoutFrdDocumentsInput,
        SolutionUpdateWithoutFrdDocumentsInput
      >,
      SolutionUncheckedUpdateWithoutFrdDocumentsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutFrdDocumentsNestedInput = {
    create?: XOR<
      UserCreateWithoutFrdDocumentsInput,
      UserUncheckedCreateWithoutFrdDocumentsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutFrdDocumentsInput;
    upsert?: UserUpsertWithoutFrdDocumentsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutFrdDocumentsInput,
        UserUpdateWithoutFrdDocumentsInput
      >,
      UserUncheckedUpdateWithoutFrdDocumentsInput
    >;
  };

  export type UserUpdateOneWithoutApprovedFRDsNestedInput = {
    create?: XOR<
      UserCreateWithoutApprovedFRDsInput,
      UserUncheckedCreateWithoutApprovedFRDsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutApprovedFRDsInput;
    upsert?: UserUpsertWithoutApprovedFRDsInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutApprovedFRDsInput,
        UserUpdateWithoutApprovedFRDsInput
      >,
      UserUncheckedUpdateWithoutApprovedFRDsInput
    >;
  };

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<
      UserCreateWithoutAuditLogsInput,
      UserUncheckedCreateWithoutAuditLogsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<
      UserCreateWithoutAuditLogsInput,
      UserUncheckedCreateWithoutAuditLogsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput;
    upsert?: UserUpsertWithoutAuditLogsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutAuditLogsInput,
        UserUpdateWithoutAuditLogsInput
      >,
      UserUncheckedUpdateWithoutAuditLogsInput
    >;
  };

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<
      UserCreateWithoutNotificationsInput,
      UserUncheckedCreateWithoutNotificationsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType;
  };

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<
      UserCreateWithoutNotificationsInput,
      UserUncheckedCreateWithoutNotificationsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput;
    upsert?: UserUpsertWithoutNotificationsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutNotificationsInput,
        UserUpdateWithoutNotificationsInput
      >,
      UserUncheckedUpdateWithoutNotificationsInput
    >;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumUserRoleWithAggregatesFilter<$PrismaModel>
      | $Enums.UserRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumUserRoleFilter<$PrismaModel>;
    _max?: NestedEnumUserRoleFilter<$PrismaModel>;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedEnumInputTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InputType | EnumInputTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumInputTypeFilter<$PrismaModel> | $Enums.InputType;
  };

  export type NestedEnumInputStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InputStatus | EnumInputStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.InputStatus[] | ListEnumInputStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.InputStatus[]
      | ListEnumInputStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumInputStatusFilter<$PrismaModel> | $Enums.InputStatus;
  };

  export type NestedEnumIssueTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.IssueType | EnumIssueTypeFieldRefInput<$PrismaModel> | null;
    in?:
      | $Enums.IssueType[]
      | ListEnumIssueTypeFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.IssueType[]
      | ListEnumIssueTypeFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumIssueTypeNullableFilter<$PrismaModel>
      | $Enums.IssueType
      | null;
  };

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>;
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>;
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedEnumInputTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InputType | EnumInputTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumInputTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.InputType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumInputTypeFilter<$PrismaModel>;
    _max?: NestedEnumInputTypeFilter<$PrismaModel>;
  };

  export type NestedEnumInputStatusWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: $Enums.InputStatus | EnumInputStatusFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.InputStatus[]
        | ListEnumInputStatusFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.InputStatus[]
        | ListEnumInputStatusFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumInputStatusWithAggregatesFilter<$PrismaModel>
        | $Enums.InputStatus;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumInputStatusFilter<$PrismaModel>;
      _max?: NestedEnumInputStatusFilter<$PrismaModel>;
    };

  export type NestedEnumIssueTypeNullableWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?: $Enums.IssueType | EnumIssueTypeFieldRefInput<$PrismaModel> | null;
    in?:
      | $Enums.IssueType[]
      | ListEnumIssueTypeFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.IssueType[]
      | ListEnumIssueTypeFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumIssueTypeNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.IssueType
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumIssueTypeNullableFilter<$PrismaModel>;
    _max?: NestedEnumIssueTypeNullableFilter<$PrismaModel>;
  };

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>;
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumPriorityWithAggregatesFilter<$PrismaModel>
      | $Enums.Priority;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumPriorityFilter<$PrismaModel>;
    _max?: NestedEnumPriorityFilter<$PrismaModel>;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonNullableFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>,
            'path'
          >
        >,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>
      >;

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedEnumGroupStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupStatus | EnumGroupStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.GroupStatus[] | ListEnumGroupStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.GroupStatus[]
      | ListEnumGroupStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumGroupStatusFilter<$PrismaModel> | $Enums.GroupStatus;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedEnumGroupStatusWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: $Enums.GroupStatus | EnumGroupStatusFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.GroupStatus[]
        | ListEnumGroupStatusFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.GroupStatus[]
        | ListEnumGroupStatusFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumGroupStatusWithAggregatesFilter<$PrismaModel>
        | $Enums.GroupStatus;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumGroupStatusFilter<$PrismaModel>;
      _max?: NestedEnumGroupStatusFilter<$PrismaModel>;
    };

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type NestedEnumSolutionStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.SolutionStatus
      | EnumSolutionStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.SolutionStatus[]
      | ListEnumSolutionStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.SolutionStatus[]
      | ListEnumSolutionStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumSolutionStatusFilter<$PrismaModel> | $Enums.SolutionStatus;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedEnumSolutionStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.SolutionStatus
      | EnumSolutionStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.SolutionStatus[]
      | ListEnumSolutionStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.SolutionStatus[]
      | ListEnumSolutionStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumSolutionStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.SolutionStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumSolutionStatusFilter<$PrismaModel>;
    _max?: NestedEnumSolutionStatusFilter<$PrismaModel>;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
      notIn?:
        | Date[]
        | string[]
        | ListDateTimeFieldRefInput<$PrismaModel>
        | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?:
        | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
        | Date
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedDateTimeNullableFilter<$PrismaModel>;
      _max?: NestedDateTimeNullableFilter<$PrismaModel>;
    };

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus;
  };

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.TaskStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>;
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>;
  };

  export type NestedEnumRequirementStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.RequirementStatus
      | EnumRequirementStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.RequirementStatus[]
      | ListEnumRequirementStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.RequirementStatus[]
      | ListEnumRequirementStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumRequirementStatusFilter<$PrismaModel>
      | $Enums.RequirementStatus;
  };
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>;

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type NestedEnumRequirementStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.RequirementStatus
      | EnumRequirementStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.RequirementStatus[]
      | ListEnumRequirementStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.RequirementStatus[]
      | ListEnumRequirementStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumRequirementStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.RequirementStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRequirementStatusFilter<$PrismaModel>;
    _max?: NestedEnumRequirementStatusFilter<$PrismaModel>;
  };

  export type NestedEnumFRDStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FRDStatus | EnumFRDStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumFRDStatusFilter<$PrismaModel> | $Enums.FRDStatus;
  };

  export type NestedEnumFRDStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FRDStatus | EnumFRDStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumFRDStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.FRDStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumFRDStatusFilter<$PrismaModel>;
    _max?: NestedEnumFRDStatusFilter<$PrismaModel>;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.NotificationType
      | EnumNotificationTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.NotificationType[]
      | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.NotificationType[]
      | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumNotificationTypeFilter<$PrismaModel>
      | $Enums.NotificationType;
  };

  export type NestedEnumNotificationTypeWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.NotificationType
      | EnumNotificationTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.NotificationType[]
      | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.NotificationType[]
      | ListEnumNotificationTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.NotificationType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>;
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>;
  };

  export type InputCreateWithoutCreatorInput = {
    id?: string;
    title: string;
    description: string;
    type: $Enums.InputType;
    status?: $Enums.InputStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    department?: string | null;
    issueType?: $Enums.IssueType | null;
    rootCause?: string | null;
    priority?: $Enums.Priority;
    aiProcessed?: boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    solutions?: SolutionCreateNestedManyWithoutInputsInput;
    comments?: CommentCreateNestedManyWithoutInputInput;
    votes?: VoteCreateNestedManyWithoutInputInput;
    groups?: InputGroupCreateNestedManyWithoutInputsInput;
  };

  export type InputUncheckedCreateWithoutCreatorInput = {
    id?: string;
    title: string;
    description: string;
    type: $Enums.InputType;
    status?: $Enums.InputStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    department?: string | null;
    issueType?: $Enums.IssueType | null;
    rootCause?: string | null;
    priority?: $Enums.Priority;
    aiProcessed?: boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    solutions?: SolutionUncheckedCreateNestedManyWithoutInputsInput;
    comments?: CommentUncheckedCreateNestedManyWithoutInputInput;
    votes?: VoteUncheckedCreateNestedManyWithoutInputInput;
    groups?: InputGroupUncheckedCreateNestedManyWithoutInputsInput;
  };

  export type InputCreateOrConnectWithoutCreatorInput = {
    where: InputWhereUniqueInput;
    create: XOR<
      InputCreateWithoutCreatorInput,
      InputUncheckedCreateWithoutCreatorInput
    >;
  };

  export type InputCreateManyCreatorInputEnvelope = {
    data: InputCreateManyCreatorInput | InputCreateManyCreatorInput[];
    skipDuplicates?: boolean;
  };

  export type SolutionCreateWithoutOwnerInput = {
    id?: string;
    title: string;
    description: string;
    status?: $Enums.SolutionStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedEffort?: string | null;
    targetCompletion?: Date | string | null;
    actualCompletion?: Date | string | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    inputs?: InputCreateNestedManyWithoutSolutionsInput;
    tasks?: TaskCreateNestedManyWithoutSolutionInput;
    comments?: CommentCreateNestedManyWithoutSolutionInput;
    votes?: VoteCreateNestedManyWithoutSolutionInput;
    requirements?: RequirementCreateNestedManyWithoutSolutionInput;
    frdDocuments?: FRDDocumentCreateNestedManyWithoutSolutionInput;
  };

  export type SolutionUncheckedCreateWithoutOwnerInput = {
    id?: string;
    title: string;
    description: string;
    status?: $Enums.SolutionStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedEffort?: string | null;
    targetCompletion?: Date | string | null;
    actualCompletion?: Date | string | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    inputs?: InputUncheckedCreateNestedManyWithoutSolutionsInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutSolutionInput;
    comments?: CommentUncheckedCreateNestedManyWithoutSolutionInput;
    votes?: VoteUncheckedCreateNestedManyWithoutSolutionInput;
    requirements?: RequirementUncheckedCreateNestedManyWithoutSolutionInput;
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutSolutionInput;
  };

  export type SolutionCreateOrConnectWithoutOwnerInput = {
    where: SolutionWhereUniqueInput;
    create: XOR<
      SolutionCreateWithoutOwnerInput,
      SolutionUncheckedCreateWithoutOwnerInput
    >;
  };

  export type SolutionCreateManyOwnerInputEnvelope = {
    data: SolutionCreateManyOwnerInput | SolutionCreateManyOwnerInput[];
    skipDuplicates?: boolean;
  };

  export type CommentCreateWithoutAuthorInput = {
    id?: string;
    content: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    replies?: CommentCreateNestedManyWithoutParentInput;
    input?: InputCreateNestedOneWithoutCommentsInput;
    solution?: SolutionCreateNestedOneWithoutCommentsInput;
    requirement?: RequirementCreateNestedOneWithoutCommentsInput;
    parent?: CommentCreateNestedOneWithoutRepliesInput;
  };

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: string;
    content: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputId?: string | null;
    solutionId?: string | null;
    requirementId?: string | null;
    parentId?: string | null;
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput;
  };

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput;
    create: XOR<
      CommentCreateWithoutAuthorInput,
      CommentUncheckedCreateWithoutAuthorInput
    >;
  };

  export type CommentCreateManyAuthorInputEnvelope = {
    data: CommentCreateManyAuthorInput | CommentCreateManyAuthorInput[];
    skipDuplicates?: boolean;
  };

  export type VoteCreateWithoutUserInput = {
    id?: string;
    value: number;
    createdAt?: Date | string;
    input?: InputCreateNestedOneWithoutVotesInput;
    solution?: SolutionCreateNestedOneWithoutVotesInput;
  };

  export type VoteUncheckedCreateWithoutUserInput = {
    id?: string;
    value: number;
    createdAt?: Date | string;
    inputId?: string | null;
    solutionId?: string | null;
  };

  export type VoteCreateOrConnectWithoutUserInput = {
    where: VoteWhereUniqueInput;
    create: XOR<
      VoteCreateWithoutUserInput,
      VoteUncheckedCreateWithoutUserInput
    >;
  };

  export type VoteCreateManyUserInputEnvelope = {
    data: VoteCreateManyUserInput | VoteCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type RequirementCreateWithoutCreatorInput = {
    id?: string;
    title: string;
    description: string;
    acceptanceCriteria: JsonNullValueInput | InputJsonValue;
    priority?: $Enums.Priority;
    status?: $Enums.RequirementStatus;
    estimatedEffort?: string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: string | null;
    riskAssessment?: string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: string | null;
    approvedAt?: Date | string | null;
    rejectionReason?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    solution: SolutionCreateNestedOneWithoutRequirementsInput;
    comments?: CommentCreateNestedManyWithoutRequirementInput;
  };

  export type RequirementUncheckedCreateWithoutCreatorInput = {
    id?: string;
    title: string;
    description: string;
    acceptanceCriteria: JsonNullValueInput | InputJsonValue;
    priority?: $Enums.Priority;
    status?: $Enums.RequirementStatus;
    estimatedEffort?: string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: string | null;
    riskAssessment?: string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: string | null;
    approvedAt?: Date | string | null;
    rejectionReason?: string | null;
    solutionId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    comments?: CommentUncheckedCreateNestedManyWithoutRequirementInput;
  };

  export type RequirementCreateOrConnectWithoutCreatorInput = {
    where: RequirementWhereUniqueInput;
    create: XOR<
      RequirementCreateWithoutCreatorInput,
      RequirementUncheckedCreateWithoutCreatorInput
    >;
  };

  export type RequirementCreateManyCreatorInputEnvelope = {
    data:
      | RequirementCreateManyCreatorInput
      | RequirementCreateManyCreatorInput[];
    skipDuplicates?: boolean;
  };

  export type FRDDocumentCreateWithoutCreatorInput = {
    id?: string;
    title: string;
    content: JsonNullValueInput | InputJsonValue;
    aiGenerated?: boolean;
    aiConfidence?: number | null;
    aiPromptUsed?: string | null;
    version?: string;
    status?: $Enums.FRDStatus;
    executiveApproved?: boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: string | null;
    generationTime?: number | null;
    wordCount?: number | null;
    lastExportedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    solution: SolutionCreateNestedOneWithoutFrdDocumentsInput;
    approver?: UserCreateNestedOneWithoutApprovedFRDsInput;
  };

  export type FRDDocumentUncheckedCreateWithoutCreatorInput = {
    id?: string;
    title: string;
    content: JsonNullValueInput | InputJsonValue;
    aiGenerated?: boolean;
    aiConfidence?: number | null;
    aiPromptUsed?: string | null;
    version?: string;
    status?: $Enums.FRDStatus;
    executiveApproved?: boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: string | null;
    generationTime?: number | null;
    wordCount?: number | null;
    lastExportedAt?: Date | string | null;
    solutionId: string;
    approvedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FRDDocumentCreateOrConnectWithoutCreatorInput = {
    where: FRDDocumentWhereUniqueInput;
    create: XOR<
      FRDDocumentCreateWithoutCreatorInput,
      FRDDocumentUncheckedCreateWithoutCreatorInput
    >;
  };

  export type FRDDocumentCreateManyCreatorInputEnvelope = {
    data:
      | FRDDocumentCreateManyCreatorInput
      | FRDDocumentCreateManyCreatorInput[];
    skipDuplicates?: boolean;
  };

  export type FRDDocumentCreateWithoutApproverInput = {
    id?: string;
    title: string;
    content: JsonNullValueInput | InputJsonValue;
    aiGenerated?: boolean;
    aiConfidence?: number | null;
    aiPromptUsed?: string | null;
    version?: string;
    status?: $Enums.FRDStatus;
    executiveApproved?: boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: string | null;
    generationTime?: number | null;
    wordCount?: number | null;
    lastExportedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    solution: SolutionCreateNestedOneWithoutFrdDocumentsInput;
    creator: UserCreateNestedOneWithoutFrdDocumentsInput;
  };

  export type FRDDocumentUncheckedCreateWithoutApproverInput = {
    id?: string;
    title: string;
    content: JsonNullValueInput | InputJsonValue;
    aiGenerated?: boolean;
    aiConfidence?: number | null;
    aiPromptUsed?: string | null;
    version?: string;
    status?: $Enums.FRDStatus;
    executiveApproved?: boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: string | null;
    generationTime?: number | null;
    wordCount?: number | null;
    lastExportedAt?: Date | string | null;
    solutionId: string;
    createdBy: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FRDDocumentCreateOrConnectWithoutApproverInput = {
    where: FRDDocumentWhereUniqueInput;
    create: XOR<
      FRDDocumentCreateWithoutApproverInput,
      FRDDocumentUncheckedCreateWithoutApproverInput
    >;
  };

  export type FRDDocumentCreateManyApproverInputEnvelope = {
    data:
      | FRDDocumentCreateManyApproverInput
      | FRDDocumentCreateManyApproverInput[];
    skipDuplicates?: boolean;
  };

  export type AuditLogCreateWithoutUserInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput;
    create: XOR<
      AuditLogCreateWithoutUserInput,
      AuditLogUncheckedCreateWithoutUserInput
    >;
  };

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type NotificationCreateWithoutUserInput = {
    id?: string;
    type: $Enums.NotificationType;
    title: string;
    message: string;
    readAt?: Date | string | null;
    data?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string;
    type: $Enums.NotificationType;
    title: string;
    message: string;
    readAt?: Date | string | null;
    data?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    create: XOR<
      NotificationCreateWithoutUserInput,
      NotificationUncheckedCreateWithoutUserInput
    >;
  };

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type InputGroupCreateWithoutOwnerInput = {
    id?: string;
    name: string;
    description?: string | null;
    status?: $Enums.GroupStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    aiSuggested?: boolean;
    aiSimilarity?: number | null;
    aiTheme?: string | null;
    inputs?: InputCreateNestedManyWithoutGroupsInput;
  };

  export type InputGroupUncheckedCreateWithoutOwnerInput = {
    id?: string;
    name: string;
    description?: string | null;
    status?: $Enums.GroupStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    aiSuggested?: boolean;
    aiSimilarity?: number | null;
    aiTheme?: string | null;
    inputs?: InputUncheckedCreateNestedManyWithoutGroupsInput;
  };

  export type InputGroupCreateOrConnectWithoutOwnerInput = {
    where: InputGroupWhereUniqueInput;
    create: XOR<
      InputGroupCreateWithoutOwnerInput,
      InputGroupUncheckedCreateWithoutOwnerInput
    >;
  };

  export type InputGroupCreateManyOwnerInputEnvelope = {
    data: InputGroupCreateManyOwnerInput | InputGroupCreateManyOwnerInput[];
    skipDuplicates?: boolean;
  };

  export type TaskCreateWithoutAssigneeInput = {
    id?: string;
    title: string;
    description?: string | null;
    status?: $Enums.TaskStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedHours?: number | null;
    actualHours?: number | null;
    dueDate?: Date | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    solution: SolutionCreateNestedOneWithoutTasksInput;
  };

  export type TaskUncheckedCreateWithoutAssigneeInput = {
    id?: string;
    title: string;
    description?: string | null;
    solutionId: string;
    status?: $Enums.TaskStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedHours?: number | null;
    actualHours?: number | null;
    dueDate?: Date | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type TaskCreateOrConnectWithoutAssigneeInput = {
    where: TaskWhereUniqueInput;
    create: XOR<
      TaskCreateWithoutAssigneeInput,
      TaskUncheckedCreateWithoutAssigneeInput
    >;
  };

  export type TaskCreateManyAssigneeInputEnvelope = {
    data: TaskCreateManyAssigneeInput | TaskCreateManyAssigneeInput[];
    skipDuplicates?: boolean;
  };

  export type InputUpsertWithWhereUniqueWithoutCreatorInput = {
    where: InputWhereUniqueInput;
    update: XOR<
      InputUpdateWithoutCreatorInput,
      InputUncheckedUpdateWithoutCreatorInput
    >;
    create: XOR<
      InputCreateWithoutCreatorInput,
      InputUncheckedCreateWithoutCreatorInput
    >;
  };

  export type InputUpdateWithWhereUniqueWithoutCreatorInput = {
    where: InputWhereUniqueInput;
    data: XOR<
      InputUpdateWithoutCreatorInput,
      InputUncheckedUpdateWithoutCreatorInput
    >;
  };

  export type InputUpdateManyWithWhereWithoutCreatorInput = {
    where: InputScalarWhereInput;
    data: XOR<
      InputUpdateManyMutationInput,
      InputUncheckedUpdateManyWithoutCreatorInput
    >;
  };

  export type InputScalarWhereInput = {
    AND?: InputScalarWhereInput | InputScalarWhereInput[];
    OR?: InputScalarWhereInput[];
    NOT?: InputScalarWhereInput | InputScalarWhereInput[];
    id?: StringFilter<'Input'> | string;
    title?: StringFilter<'Input'> | string;
    description?: StringFilter<'Input'> | string;
    type?: EnumInputTypeFilter<'Input'> | $Enums.InputType;
    status?: EnumInputStatusFilter<'Input'> | $Enums.InputStatus;
    createdBy?: StringFilter<'Input'> | string;
    createdAt?: DateTimeFilter<'Input'> | Date | string;
    updatedAt?: DateTimeFilter<'Input'> | Date | string;
    department?: StringNullableFilter<'Input'> | string | null;
    issueType?: EnumIssueTypeNullableFilter<'Input'> | $Enums.IssueType | null;
    rootCause?: StringNullableFilter<'Input'> | string | null;
    priority?: EnumPriorityFilter<'Input'> | $Enums.Priority;
    aiProcessed?: BoolFilter<'Input'> | boolean;
    aiTags?: JsonNullableFilter<'Input'>;
    aiSuggestions?: JsonNullableFilter<'Input'>;
  };

  export type SolutionUpsertWithWhereUniqueWithoutOwnerInput = {
    where: SolutionWhereUniqueInput;
    update: XOR<
      SolutionUpdateWithoutOwnerInput,
      SolutionUncheckedUpdateWithoutOwnerInput
    >;
    create: XOR<
      SolutionCreateWithoutOwnerInput,
      SolutionUncheckedCreateWithoutOwnerInput
    >;
  };

  export type SolutionUpdateWithWhereUniqueWithoutOwnerInput = {
    where: SolutionWhereUniqueInput;
    data: XOR<
      SolutionUpdateWithoutOwnerInput,
      SolutionUncheckedUpdateWithoutOwnerInput
    >;
  };

  export type SolutionUpdateManyWithWhereWithoutOwnerInput = {
    where: SolutionScalarWhereInput;
    data: XOR<
      SolutionUpdateManyMutationInput,
      SolutionUncheckedUpdateManyWithoutOwnerInput
    >;
  };

  export type SolutionScalarWhereInput = {
    AND?: SolutionScalarWhereInput | SolutionScalarWhereInput[];
    OR?: SolutionScalarWhereInput[];
    NOT?: SolutionScalarWhereInput | SolutionScalarWhereInput[];
    id?: StringFilter<'Solution'> | string;
    title?: StringFilter<'Solution'> | string;
    description?: StringFilter<'Solution'> | string;
    ownerId?: StringFilter<'Solution'> | string;
    status?: EnumSolutionStatusFilter<'Solution'> | $Enums.SolutionStatus;
    priority?: EnumPriorityFilter<'Solution'> | $Enums.Priority;
    createdAt?: DateTimeFilter<'Solution'> | Date | string;
    updatedAt?: DateTimeFilter<'Solution'> | Date | string;
    estimatedEffort?: StringNullableFilter<'Solution'> | string | null;
    targetCompletion?:
      | DateTimeNullableFilter<'Solution'>
      | Date
      | string
      | null;
    actualCompletion?:
      | DateTimeNullableFilter<'Solution'>
      | Date
      | string
      | null;
    successCriteria?: JsonNullableFilter<'Solution'>;
  };

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput;
    update: XOR<
      CommentUpdateWithoutAuthorInput,
      CommentUncheckedUpdateWithoutAuthorInput
    >;
    create: XOR<
      CommentCreateWithoutAuthorInput,
      CommentUncheckedCreateWithoutAuthorInput
    >;
  };

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput;
    data: XOR<
      CommentUpdateWithoutAuthorInput,
      CommentUncheckedUpdateWithoutAuthorInput
    >;
  };

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput;
    data: XOR<
      CommentUpdateManyMutationInput,
      CommentUncheckedUpdateManyWithoutAuthorInput
    >;
  };

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[];
    OR?: CommentScalarWhereInput[];
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[];
    id?: StringFilter<'Comment'> | string;
    content?: StringFilter<'Comment'> | string;
    authorId?: StringFilter<'Comment'> | string;
    createdAt?: DateTimeFilter<'Comment'> | Date | string;
    updatedAt?: DateTimeFilter<'Comment'> | Date | string;
    inputId?: StringNullableFilter<'Comment'> | string | null;
    solutionId?: StringNullableFilter<'Comment'> | string | null;
    requirementId?: StringNullableFilter<'Comment'> | string | null;
    parentId?: StringNullableFilter<'Comment'> | string | null;
  };

  export type VoteUpsertWithWhereUniqueWithoutUserInput = {
    where: VoteWhereUniqueInput;
    update: XOR<
      VoteUpdateWithoutUserInput,
      VoteUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      VoteCreateWithoutUserInput,
      VoteUncheckedCreateWithoutUserInput
    >;
  };

  export type VoteUpdateWithWhereUniqueWithoutUserInput = {
    where: VoteWhereUniqueInput;
    data: XOR<VoteUpdateWithoutUserInput, VoteUncheckedUpdateWithoutUserInput>;
  };

  export type VoteUpdateManyWithWhereWithoutUserInput = {
    where: VoteScalarWhereInput;
    data: XOR<
      VoteUpdateManyMutationInput,
      VoteUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type VoteScalarWhereInput = {
    AND?: VoteScalarWhereInput | VoteScalarWhereInput[];
    OR?: VoteScalarWhereInput[];
    NOT?: VoteScalarWhereInput | VoteScalarWhereInput[];
    id?: StringFilter<'Vote'> | string;
    userId?: StringFilter<'Vote'> | string;
    value?: IntFilter<'Vote'> | number;
    createdAt?: DateTimeFilter<'Vote'> | Date | string;
    inputId?: StringNullableFilter<'Vote'> | string | null;
    solutionId?: StringNullableFilter<'Vote'> | string | null;
  };

  export type RequirementUpsertWithWhereUniqueWithoutCreatorInput = {
    where: RequirementWhereUniqueInput;
    update: XOR<
      RequirementUpdateWithoutCreatorInput,
      RequirementUncheckedUpdateWithoutCreatorInput
    >;
    create: XOR<
      RequirementCreateWithoutCreatorInput,
      RequirementUncheckedCreateWithoutCreatorInput
    >;
  };

  export type RequirementUpdateWithWhereUniqueWithoutCreatorInput = {
    where: RequirementWhereUniqueInput;
    data: XOR<
      RequirementUpdateWithoutCreatorInput,
      RequirementUncheckedUpdateWithoutCreatorInput
    >;
  };

  export type RequirementUpdateManyWithWhereWithoutCreatorInput = {
    where: RequirementScalarWhereInput;
    data: XOR<
      RequirementUpdateManyMutationInput,
      RequirementUncheckedUpdateManyWithoutCreatorInput
    >;
  };

  export type RequirementScalarWhereInput = {
    AND?: RequirementScalarWhereInput | RequirementScalarWhereInput[];
    OR?: RequirementScalarWhereInput[];
    NOT?: RequirementScalarWhereInput | RequirementScalarWhereInput[];
    id?: StringFilter<'Requirement'> | string;
    title?: StringFilter<'Requirement'> | string;
    description?: StringFilter<'Requirement'> | string;
    acceptanceCriteria?: JsonFilter<'Requirement'>;
    priority?: EnumPriorityFilter<'Requirement'> | $Enums.Priority;
    status?:
      | EnumRequirementStatusFilter<'Requirement'>
      | $Enums.RequirementStatus;
    estimatedEffort?: StringNullableFilter<'Requirement'> | string | null;
    dependencies?: JsonNullableFilter<'Requirement'>;
    businessValue?: StringNullableFilter<'Requirement'> | string | null;
    riskAssessment?: StringNullableFilter<'Requirement'> | string | null;
    stakeholders?: JsonNullableFilter<'Requirement'>;
    approvedBy?: StringNullableFilter<'Requirement'> | string | null;
    approvedAt?: DateTimeNullableFilter<'Requirement'> | Date | string | null;
    rejectionReason?: StringNullableFilter<'Requirement'> | string | null;
    solutionId?: StringFilter<'Requirement'> | string;
    createdBy?: StringFilter<'Requirement'> | string;
    createdAt?: DateTimeFilter<'Requirement'> | Date | string;
    updatedAt?: DateTimeFilter<'Requirement'> | Date | string;
  };

  export type FRDDocumentUpsertWithWhereUniqueWithoutCreatorInput = {
    where: FRDDocumentWhereUniqueInput;
    update: XOR<
      FRDDocumentUpdateWithoutCreatorInput,
      FRDDocumentUncheckedUpdateWithoutCreatorInput
    >;
    create: XOR<
      FRDDocumentCreateWithoutCreatorInput,
      FRDDocumentUncheckedCreateWithoutCreatorInput
    >;
  };

  export type FRDDocumentUpdateWithWhereUniqueWithoutCreatorInput = {
    where: FRDDocumentWhereUniqueInput;
    data: XOR<
      FRDDocumentUpdateWithoutCreatorInput,
      FRDDocumentUncheckedUpdateWithoutCreatorInput
    >;
  };

  export type FRDDocumentUpdateManyWithWhereWithoutCreatorInput = {
    where: FRDDocumentScalarWhereInput;
    data: XOR<
      FRDDocumentUpdateManyMutationInput,
      FRDDocumentUncheckedUpdateManyWithoutCreatorInput
    >;
  };

  export type FRDDocumentScalarWhereInput = {
    AND?: FRDDocumentScalarWhereInput | FRDDocumentScalarWhereInput[];
    OR?: FRDDocumentScalarWhereInput[];
    NOT?: FRDDocumentScalarWhereInput | FRDDocumentScalarWhereInput[];
    id?: StringFilter<'FRDDocument'> | string;
    title?: StringFilter<'FRDDocument'> | string;
    content?: JsonFilter<'FRDDocument'>;
    aiGenerated?: BoolFilter<'FRDDocument'> | boolean;
    aiConfidence?: FloatNullableFilter<'FRDDocument'> | number | null;
    aiPromptUsed?: StringNullableFilter<'FRDDocument'> | string | null;
    version?: StringFilter<'FRDDocument'> | string;
    status?: EnumFRDStatusFilter<'FRDDocument'> | $Enums.FRDStatus;
    executiveApproved?: BoolFilter<'FRDDocument'> | boolean;
    exportFormats?: JsonNullableFilter<'FRDDocument'>;
    templateUsed?: StringNullableFilter<'FRDDocument'> | string | null;
    generationTime?: FloatNullableFilter<'FRDDocument'> | number | null;
    wordCount?: IntNullableFilter<'FRDDocument'> | number | null;
    lastExportedAt?:
      | DateTimeNullableFilter<'FRDDocument'>
      | Date
      | string
      | null;
    solutionId?: StringFilter<'FRDDocument'> | string;
    createdBy?: StringFilter<'FRDDocument'> | string;
    approvedBy?: StringNullableFilter<'FRDDocument'> | string | null;
    createdAt?: DateTimeFilter<'FRDDocument'> | Date | string;
    updatedAt?: DateTimeFilter<'FRDDocument'> | Date | string;
  };

  export type FRDDocumentUpsertWithWhereUniqueWithoutApproverInput = {
    where: FRDDocumentWhereUniqueInput;
    update: XOR<
      FRDDocumentUpdateWithoutApproverInput,
      FRDDocumentUncheckedUpdateWithoutApproverInput
    >;
    create: XOR<
      FRDDocumentCreateWithoutApproverInput,
      FRDDocumentUncheckedCreateWithoutApproverInput
    >;
  };

  export type FRDDocumentUpdateWithWhereUniqueWithoutApproverInput = {
    where: FRDDocumentWhereUniqueInput;
    data: XOR<
      FRDDocumentUpdateWithoutApproverInput,
      FRDDocumentUncheckedUpdateWithoutApproverInput
    >;
  };

  export type FRDDocumentUpdateManyWithWhereWithoutApproverInput = {
    where: FRDDocumentScalarWhereInput;
    data: XOR<
      FRDDocumentUpdateManyMutationInput,
      FRDDocumentUncheckedUpdateManyWithoutApproverInput
    >;
  };

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput;
    update: XOR<
      AuditLogUpdateWithoutUserInput,
      AuditLogUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      AuditLogCreateWithoutUserInput,
      AuditLogUncheckedCreateWithoutUserInput
    >;
  };

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput;
    data: XOR<
      AuditLogUpdateWithoutUserInput,
      AuditLogUncheckedUpdateWithoutUserInput
    >;
  };

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput;
    data: XOR<
      AuditLogUpdateManyMutationInput,
      AuditLogUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
    OR?: AuditLogScalarWhereInput[];
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
    id?: StringFilter<'AuditLog'> | string;
    userId?: StringFilter<'AuditLog'> | string;
    action?: StringFilter<'AuditLog'> | string;
    entityType?: StringFilter<'AuditLog'> | string;
    entityId?: StringFilter<'AuditLog'> | string;
    changes?: JsonNullableFilter<'AuditLog'>;
    metadata?: JsonNullableFilter<'AuditLog'>;
    ipAddress?: StringNullableFilter<'AuditLog'> | string | null;
    userAgent?: StringNullableFilter<'AuditLog'> | string | null;
    createdAt?: DateTimeFilter<'AuditLog'> | Date | string;
  };

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    update: XOR<
      NotificationUpdateWithoutUserInput,
      NotificationUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      NotificationCreateWithoutUserInput,
      NotificationUncheckedCreateWithoutUserInput
    >;
  };

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    data: XOR<
      NotificationUpdateWithoutUserInput,
      NotificationUncheckedUpdateWithoutUserInput
    >;
  };

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput;
    data: XOR<
      NotificationUpdateManyMutationInput,
      NotificationUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
    OR?: NotificationScalarWhereInput[];
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
    id?: StringFilter<'Notification'> | string;
    userId?: StringFilter<'Notification'> | string;
    type?: EnumNotificationTypeFilter<'Notification'> | $Enums.NotificationType;
    title?: StringFilter<'Notification'> | string;
    message?: StringFilter<'Notification'> | string;
    readAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
    data?: JsonNullableFilter<'Notification'>;
    createdAt?: DateTimeFilter<'Notification'> | Date | string;
  };

  export type InputGroupUpsertWithWhereUniqueWithoutOwnerInput = {
    where: InputGroupWhereUniqueInput;
    update: XOR<
      InputGroupUpdateWithoutOwnerInput,
      InputGroupUncheckedUpdateWithoutOwnerInput
    >;
    create: XOR<
      InputGroupCreateWithoutOwnerInput,
      InputGroupUncheckedCreateWithoutOwnerInput
    >;
  };

  export type InputGroupUpdateWithWhereUniqueWithoutOwnerInput = {
    where: InputGroupWhereUniqueInput;
    data: XOR<
      InputGroupUpdateWithoutOwnerInput,
      InputGroupUncheckedUpdateWithoutOwnerInput
    >;
  };

  export type InputGroupUpdateManyWithWhereWithoutOwnerInput = {
    where: InputGroupScalarWhereInput;
    data: XOR<
      InputGroupUpdateManyMutationInput,
      InputGroupUncheckedUpdateManyWithoutOwnerInput
    >;
  };

  export type InputGroupScalarWhereInput = {
    AND?: InputGroupScalarWhereInput | InputGroupScalarWhereInput[];
    OR?: InputGroupScalarWhereInput[];
    NOT?: InputGroupScalarWhereInput | InputGroupScalarWhereInput[];
    id?: StringFilter<'InputGroup'> | string;
    name?: StringFilter<'InputGroup'> | string;
    description?: StringNullableFilter<'InputGroup'> | string | null;
    ownerId?: StringFilter<'InputGroup'> | string;
    status?: EnumGroupStatusFilter<'InputGroup'> | $Enums.GroupStatus;
    createdAt?: DateTimeFilter<'InputGroup'> | Date | string;
    updatedAt?: DateTimeFilter<'InputGroup'> | Date | string;
    aiSuggested?: BoolFilter<'InputGroup'> | boolean;
    aiSimilarity?: FloatNullableFilter<'InputGroup'> | number | null;
    aiTheme?: StringNullableFilter<'InputGroup'> | string | null;
  };

  export type TaskUpsertWithWhereUniqueWithoutAssigneeInput = {
    where: TaskWhereUniqueInput;
    update: XOR<
      TaskUpdateWithoutAssigneeInput,
      TaskUncheckedUpdateWithoutAssigneeInput
    >;
    create: XOR<
      TaskCreateWithoutAssigneeInput,
      TaskUncheckedCreateWithoutAssigneeInput
    >;
  };

  export type TaskUpdateWithWhereUniqueWithoutAssigneeInput = {
    where: TaskWhereUniqueInput;
    data: XOR<
      TaskUpdateWithoutAssigneeInput,
      TaskUncheckedUpdateWithoutAssigneeInput
    >;
  };

  export type TaskUpdateManyWithWhereWithoutAssigneeInput = {
    where: TaskScalarWhereInput;
    data: XOR<
      TaskUpdateManyMutationInput,
      TaskUncheckedUpdateManyWithoutAssigneeInput
    >;
  };

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[];
    OR?: TaskScalarWhereInput[];
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[];
    id?: StringFilter<'Task'> | string;
    title?: StringFilter<'Task'> | string;
    description?: StringNullableFilter<'Task'> | string | null;
    solutionId?: StringFilter<'Task'> | string;
    assigneeId?: StringNullableFilter<'Task'> | string | null;
    status?: EnumTaskStatusFilter<'Task'> | $Enums.TaskStatus;
    priority?: EnumPriorityFilter<'Task'> | $Enums.Priority;
    createdAt?: DateTimeFilter<'Task'> | Date | string;
    updatedAt?: DateTimeFilter<'Task'> | Date | string;
    estimatedHours?: FloatNullableFilter<'Task'> | number | null;
    actualHours?: FloatNullableFilter<'Task'> | number | null;
    dueDate?: DateTimeNullableFilter<'Task'> | Date | string | null;
    dependencies?: JsonNullableFilter<'Task'>;
  };

  export type UserCreateWithoutInputsInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    solutions?: SolutionCreateNestedManyWithoutOwnerInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    votes?: VoteCreateNestedManyWithoutUserInput;
    requirements?: RequirementCreateNestedManyWithoutCreatorInput;
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput;
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    inputGroups?: InputGroupCreateNestedManyWithoutOwnerInput;
    tasks?: TaskCreateNestedManyWithoutAssigneeInput;
  };

  export type UserUncheckedCreateWithoutInputsInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    solutions?: SolutionUncheckedCreateNestedManyWithoutOwnerInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput;
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput;
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput;
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutOwnerInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput;
  };

  export type UserCreateOrConnectWithoutInputsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutInputsInput,
      UserUncheckedCreateWithoutInputsInput
    >;
  };

  export type SolutionCreateWithoutInputsInput = {
    id?: string;
    title: string;
    description: string;
    status?: $Enums.SolutionStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedEffort?: string | null;
    targetCompletion?: Date | string | null;
    actualCompletion?: Date | string | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    owner: UserCreateNestedOneWithoutSolutionsInput;
    tasks?: TaskCreateNestedManyWithoutSolutionInput;
    comments?: CommentCreateNestedManyWithoutSolutionInput;
    votes?: VoteCreateNestedManyWithoutSolutionInput;
    requirements?: RequirementCreateNestedManyWithoutSolutionInput;
    frdDocuments?: FRDDocumentCreateNestedManyWithoutSolutionInput;
  };

  export type SolutionUncheckedCreateWithoutInputsInput = {
    id?: string;
    title: string;
    description: string;
    ownerId: string;
    status?: $Enums.SolutionStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedEffort?: string | null;
    targetCompletion?: Date | string | null;
    actualCompletion?: Date | string | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    tasks?: TaskUncheckedCreateNestedManyWithoutSolutionInput;
    comments?: CommentUncheckedCreateNestedManyWithoutSolutionInput;
    votes?: VoteUncheckedCreateNestedManyWithoutSolutionInput;
    requirements?: RequirementUncheckedCreateNestedManyWithoutSolutionInput;
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutSolutionInput;
  };

  export type SolutionCreateOrConnectWithoutInputsInput = {
    where: SolutionWhereUniqueInput;
    create: XOR<
      SolutionCreateWithoutInputsInput,
      SolutionUncheckedCreateWithoutInputsInput
    >;
  };

  export type CommentCreateWithoutInputInput = {
    id?: string;
    content: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    replies?: CommentCreateNestedManyWithoutParentInput;
    author: UserCreateNestedOneWithoutCommentsInput;
    solution?: SolutionCreateNestedOneWithoutCommentsInput;
    requirement?: RequirementCreateNestedOneWithoutCommentsInput;
    parent?: CommentCreateNestedOneWithoutRepliesInput;
  };

  export type CommentUncheckedCreateWithoutInputInput = {
    id?: string;
    content: string;
    authorId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    solutionId?: string | null;
    requirementId?: string | null;
    parentId?: string | null;
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput;
  };

  export type CommentCreateOrConnectWithoutInputInput = {
    where: CommentWhereUniqueInput;
    create: XOR<
      CommentCreateWithoutInputInput,
      CommentUncheckedCreateWithoutInputInput
    >;
  };

  export type CommentCreateManyInputInputEnvelope = {
    data: CommentCreateManyInputInput | CommentCreateManyInputInput[];
    skipDuplicates?: boolean;
  };

  export type VoteCreateWithoutInputInput = {
    id?: string;
    value: number;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutVotesInput;
    solution?: SolutionCreateNestedOneWithoutVotesInput;
  };

  export type VoteUncheckedCreateWithoutInputInput = {
    id?: string;
    userId: string;
    value: number;
    createdAt?: Date | string;
    solutionId?: string | null;
  };

  export type VoteCreateOrConnectWithoutInputInput = {
    where: VoteWhereUniqueInput;
    create: XOR<
      VoteCreateWithoutInputInput,
      VoteUncheckedCreateWithoutInputInput
    >;
  };

  export type VoteCreateManyInputInputEnvelope = {
    data: VoteCreateManyInputInput | VoteCreateManyInputInput[];
    skipDuplicates?: boolean;
  };

  export type InputGroupCreateWithoutInputsInput = {
    id?: string;
    name: string;
    description?: string | null;
    status?: $Enums.GroupStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    aiSuggested?: boolean;
    aiSimilarity?: number | null;
    aiTheme?: string | null;
    owner: UserCreateNestedOneWithoutInputGroupsInput;
  };

  export type InputGroupUncheckedCreateWithoutInputsInput = {
    id?: string;
    name: string;
    description?: string | null;
    ownerId: string;
    status?: $Enums.GroupStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    aiSuggested?: boolean;
    aiSimilarity?: number | null;
    aiTheme?: string | null;
  };

  export type InputGroupCreateOrConnectWithoutInputsInput = {
    where: InputGroupWhereUniqueInput;
    create: XOR<
      InputGroupCreateWithoutInputsInput,
      InputGroupUncheckedCreateWithoutInputsInput
    >;
  };

  export type UserUpsertWithoutInputsInput = {
    update: XOR<
      UserUpdateWithoutInputsInput,
      UserUncheckedUpdateWithoutInputsInput
    >;
    create: XOR<
      UserCreateWithoutInputsInput,
      UserUncheckedCreateWithoutInputsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutInputsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutInputsInput,
      UserUncheckedUpdateWithoutInputsInput
    >;
  };

  export type UserUpdateWithoutInputsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    solutions?: SolutionUpdateManyWithoutOwnerNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    votes?: VoteUpdateManyWithoutUserNestedInput;
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput;
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput;
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    inputGroups?: InputGroupUpdateManyWithoutOwnerNestedInput;
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput;
  };

  export type UserUncheckedUpdateWithoutInputsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    solutions?: SolutionUncheckedUpdateManyWithoutOwnerNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput;
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput;
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput;
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    inputGroups?: InputGroupUncheckedUpdateManyWithoutOwnerNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput;
  };

  export type SolutionUpsertWithWhereUniqueWithoutInputsInput = {
    where: SolutionWhereUniqueInput;
    update: XOR<
      SolutionUpdateWithoutInputsInput,
      SolutionUncheckedUpdateWithoutInputsInput
    >;
    create: XOR<
      SolutionCreateWithoutInputsInput,
      SolutionUncheckedCreateWithoutInputsInput
    >;
  };

  export type SolutionUpdateWithWhereUniqueWithoutInputsInput = {
    where: SolutionWhereUniqueInput;
    data: XOR<
      SolutionUpdateWithoutInputsInput,
      SolutionUncheckedUpdateWithoutInputsInput
    >;
  };

  export type SolutionUpdateManyWithWhereWithoutInputsInput = {
    where: SolutionScalarWhereInput;
    data: XOR<
      SolutionUpdateManyMutationInput,
      SolutionUncheckedUpdateManyWithoutInputsInput
    >;
  };

  export type CommentUpsertWithWhereUniqueWithoutInputInput = {
    where: CommentWhereUniqueInput;
    update: XOR<
      CommentUpdateWithoutInputInput,
      CommentUncheckedUpdateWithoutInputInput
    >;
    create: XOR<
      CommentCreateWithoutInputInput,
      CommentUncheckedCreateWithoutInputInput
    >;
  };

  export type CommentUpdateWithWhereUniqueWithoutInputInput = {
    where: CommentWhereUniqueInput;
    data: XOR<
      CommentUpdateWithoutInputInput,
      CommentUncheckedUpdateWithoutInputInput
    >;
  };

  export type CommentUpdateManyWithWhereWithoutInputInput = {
    where: CommentScalarWhereInput;
    data: XOR<
      CommentUpdateManyMutationInput,
      CommentUncheckedUpdateManyWithoutInputInput
    >;
  };

  export type VoteUpsertWithWhereUniqueWithoutInputInput = {
    where: VoteWhereUniqueInput;
    update: XOR<
      VoteUpdateWithoutInputInput,
      VoteUncheckedUpdateWithoutInputInput
    >;
    create: XOR<
      VoteCreateWithoutInputInput,
      VoteUncheckedCreateWithoutInputInput
    >;
  };

  export type VoteUpdateWithWhereUniqueWithoutInputInput = {
    where: VoteWhereUniqueInput;
    data: XOR<
      VoteUpdateWithoutInputInput,
      VoteUncheckedUpdateWithoutInputInput
    >;
  };

  export type VoteUpdateManyWithWhereWithoutInputInput = {
    where: VoteScalarWhereInput;
    data: XOR<
      VoteUpdateManyMutationInput,
      VoteUncheckedUpdateManyWithoutInputInput
    >;
  };

  export type InputGroupUpsertWithWhereUniqueWithoutInputsInput = {
    where: InputGroupWhereUniqueInput;
    update: XOR<
      InputGroupUpdateWithoutInputsInput,
      InputGroupUncheckedUpdateWithoutInputsInput
    >;
    create: XOR<
      InputGroupCreateWithoutInputsInput,
      InputGroupUncheckedCreateWithoutInputsInput
    >;
  };

  export type InputGroupUpdateWithWhereUniqueWithoutInputsInput = {
    where: InputGroupWhereUniqueInput;
    data: XOR<
      InputGroupUpdateWithoutInputsInput,
      InputGroupUncheckedUpdateWithoutInputsInput
    >;
  };

  export type InputGroupUpdateManyWithWhereWithoutInputsInput = {
    where: InputGroupScalarWhereInput;
    data: XOR<
      InputGroupUpdateManyMutationInput,
      InputGroupUncheckedUpdateManyWithoutInputsInput
    >;
  };

  export type CommentCreateWithoutParentInput = {
    id?: string;
    content: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    replies?: CommentCreateNestedManyWithoutParentInput;
    author: UserCreateNestedOneWithoutCommentsInput;
    input?: InputCreateNestedOneWithoutCommentsInput;
    solution?: SolutionCreateNestedOneWithoutCommentsInput;
    requirement?: RequirementCreateNestedOneWithoutCommentsInput;
  };

  export type CommentUncheckedCreateWithoutParentInput = {
    id?: string;
    content: string;
    authorId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputId?: string | null;
    solutionId?: string | null;
    requirementId?: string | null;
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput;
  };

  export type CommentCreateOrConnectWithoutParentInput = {
    where: CommentWhereUniqueInput;
    create: XOR<
      CommentCreateWithoutParentInput,
      CommentUncheckedCreateWithoutParentInput
    >;
  };

  export type CommentCreateManyParentInputEnvelope = {
    data: CommentCreateManyParentInput | CommentCreateManyParentInput[];
    skipDuplicates?: boolean;
  };

  export type UserCreateWithoutCommentsInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputs?: InputCreateNestedManyWithoutCreatorInput;
    solutions?: SolutionCreateNestedManyWithoutOwnerInput;
    votes?: VoteCreateNestedManyWithoutUserInput;
    requirements?: RequirementCreateNestedManyWithoutCreatorInput;
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput;
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    inputGroups?: InputGroupCreateNestedManyWithoutOwnerInput;
    tasks?: TaskCreateNestedManyWithoutAssigneeInput;
  };

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput;
    solutions?: SolutionUncheckedCreateNestedManyWithoutOwnerInput;
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput;
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput;
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput;
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutOwnerInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput;
  };

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutCommentsInput,
      UserUncheckedCreateWithoutCommentsInput
    >;
  };

  export type InputCreateWithoutCommentsInput = {
    id?: string;
    title: string;
    description: string;
    type: $Enums.InputType;
    status?: $Enums.InputStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    department?: string | null;
    issueType?: $Enums.IssueType | null;
    rootCause?: string | null;
    priority?: $Enums.Priority;
    aiProcessed?: boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    creator: UserCreateNestedOneWithoutInputsInput;
    solutions?: SolutionCreateNestedManyWithoutInputsInput;
    votes?: VoteCreateNestedManyWithoutInputInput;
    groups?: InputGroupCreateNestedManyWithoutInputsInput;
  };

  export type InputUncheckedCreateWithoutCommentsInput = {
    id?: string;
    title: string;
    description: string;
    type: $Enums.InputType;
    status?: $Enums.InputStatus;
    createdBy: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    department?: string | null;
    issueType?: $Enums.IssueType | null;
    rootCause?: string | null;
    priority?: $Enums.Priority;
    aiProcessed?: boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    solutions?: SolutionUncheckedCreateNestedManyWithoutInputsInput;
    votes?: VoteUncheckedCreateNestedManyWithoutInputInput;
    groups?: InputGroupUncheckedCreateNestedManyWithoutInputsInput;
  };

  export type InputCreateOrConnectWithoutCommentsInput = {
    where: InputWhereUniqueInput;
    create: XOR<
      InputCreateWithoutCommentsInput,
      InputUncheckedCreateWithoutCommentsInput
    >;
  };

  export type SolutionCreateWithoutCommentsInput = {
    id?: string;
    title: string;
    description: string;
    status?: $Enums.SolutionStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedEffort?: string | null;
    targetCompletion?: Date | string | null;
    actualCompletion?: Date | string | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    owner: UserCreateNestedOneWithoutSolutionsInput;
    inputs?: InputCreateNestedManyWithoutSolutionsInput;
    tasks?: TaskCreateNestedManyWithoutSolutionInput;
    votes?: VoteCreateNestedManyWithoutSolutionInput;
    requirements?: RequirementCreateNestedManyWithoutSolutionInput;
    frdDocuments?: FRDDocumentCreateNestedManyWithoutSolutionInput;
  };

  export type SolutionUncheckedCreateWithoutCommentsInput = {
    id?: string;
    title: string;
    description: string;
    ownerId: string;
    status?: $Enums.SolutionStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedEffort?: string | null;
    targetCompletion?: Date | string | null;
    actualCompletion?: Date | string | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    inputs?: InputUncheckedCreateNestedManyWithoutSolutionsInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutSolutionInput;
    votes?: VoteUncheckedCreateNestedManyWithoutSolutionInput;
    requirements?: RequirementUncheckedCreateNestedManyWithoutSolutionInput;
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutSolutionInput;
  };

  export type SolutionCreateOrConnectWithoutCommentsInput = {
    where: SolutionWhereUniqueInput;
    create: XOR<
      SolutionCreateWithoutCommentsInput,
      SolutionUncheckedCreateWithoutCommentsInput
    >;
  };

  export type RequirementCreateWithoutCommentsInput = {
    id?: string;
    title: string;
    description: string;
    acceptanceCriteria: JsonNullValueInput | InputJsonValue;
    priority?: $Enums.Priority;
    status?: $Enums.RequirementStatus;
    estimatedEffort?: string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: string | null;
    riskAssessment?: string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: string | null;
    approvedAt?: Date | string | null;
    rejectionReason?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    solution: SolutionCreateNestedOneWithoutRequirementsInput;
    creator: UserCreateNestedOneWithoutRequirementsInput;
  };

  export type RequirementUncheckedCreateWithoutCommentsInput = {
    id?: string;
    title: string;
    description: string;
    acceptanceCriteria: JsonNullValueInput | InputJsonValue;
    priority?: $Enums.Priority;
    status?: $Enums.RequirementStatus;
    estimatedEffort?: string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: string | null;
    riskAssessment?: string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: string | null;
    approvedAt?: Date | string | null;
    rejectionReason?: string | null;
    solutionId: string;
    createdBy: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RequirementCreateOrConnectWithoutCommentsInput = {
    where: RequirementWhereUniqueInput;
    create: XOR<
      RequirementCreateWithoutCommentsInput,
      RequirementUncheckedCreateWithoutCommentsInput
    >;
  };

  export type CommentCreateWithoutRepliesInput = {
    id?: string;
    content: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    author: UserCreateNestedOneWithoutCommentsInput;
    input?: InputCreateNestedOneWithoutCommentsInput;
    solution?: SolutionCreateNestedOneWithoutCommentsInput;
    requirement?: RequirementCreateNestedOneWithoutCommentsInput;
    parent?: CommentCreateNestedOneWithoutRepliesInput;
  };

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: string;
    content: string;
    authorId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputId?: string | null;
    solutionId?: string | null;
    requirementId?: string | null;
    parentId?: string | null;
  };

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput;
    create: XOR<
      CommentCreateWithoutRepliesInput,
      CommentUncheckedCreateWithoutRepliesInput
    >;
  };

  export type CommentUpsertWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput;
    update: XOR<
      CommentUpdateWithoutParentInput,
      CommentUncheckedUpdateWithoutParentInput
    >;
    create: XOR<
      CommentCreateWithoutParentInput,
      CommentUncheckedCreateWithoutParentInput
    >;
  };

  export type CommentUpdateWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput;
    data: XOR<
      CommentUpdateWithoutParentInput,
      CommentUncheckedUpdateWithoutParentInput
    >;
  };

  export type CommentUpdateManyWithWhereWithoutParentInput = {
    where: CommentScalarWhereInput;
    data: XOR<
      CommentUpdateManyMutationInput,
      CommentUncheckedUpdateManyWithoutParentInput
    >;
  };

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<
      UserUpdateWithoutCommentsInput,
      UserUncheckedUpdateWithoutCommentsInput
    >;
    create: XOR<
      UserCreateWithoutCommentsInput,
      UserUncheckedCreateWithoutCommentsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutCommentsInput,
      UserUncheckedUpdateWithoutCommentsInput
    >;
  };

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputs?: InputUpdateManyWithoutCreatorNestedInput;
    solutions?: SolutionUpdateManyWithoutOwnerNestedInput;
    votes?: VoteUpdateManyWithoutUserNestedInput;
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput;
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput;
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    inputGroups?: InputGroupUpdateManyWithoutOwnerNestedInput;
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput;
  };

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput;
    solutions?: SolutionUncheckedUpdateManyWithoutOwnerNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput;
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput;
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput;
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    inputGroups?: InputGroupUncheckedUpdateManyWithoutOwnerNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput;
  };

  export type InputUpsertWithoutCommentsInput = {
    update: XOR<
      InputUpdateWithoutCommentsInput,
      InputUncheckedUpdateWithoutCommentsInput
    >;
    create: XOR<
      InputCreateWithoutCommentsInput,
      InputUncheckedCreateWithoutCommentsInput
    >;
    where?: InputWhereInput;
  };

  export type InputUpdateToOneWithWhereWithoutCommentsInput = {
    where?: InputWhereInput;
    data: XOR<
      InputUpdateWithoutCommentsInput,
      InputUncheckedUpdateWithoutCommentsInput
    >;
  };

  export type InputUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType;
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    issueType?:
      | NullableEnumIssueTypeFieldUpdateOperationsInput
      | $Enums.IssueType
      | null;
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    creator?: UserUpdateOneRequiredWithoutInputsNestedInput;
    solutions?: SolutionUpdateManyWithoutInputsNestedInput;
    votes?: VoteUpdateManyWithoutInputNestedInput;
    groups?: InputGroupUpdateManyWithoutInputsNestedInput;
  };

  export type InputUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType;
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    issueType?:
      | NullableEnumIssueTypeFieldUpdateOperationsInput
      | $Enums.IssueType
      | null;
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    solutions?: SolutionUncheckedUpdateManyWithoutInputsNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutInputNestedInput;
    groups?: InputGroupUncheckedUpdateManyWithoutInputsNestedInput;
  };

  export type SolutionUpsertWithoutCommentsInput = {
    update: XOR<
      SolutionUpdateWithoutCommentsInput,
      SolutionUncheckedUpdateWithoutCommentsInput
    >;
    create: XOR<
      SolutionCreateWithoutCommentsInput,
      SolutionUncheckedCreateWithoutCommentsInput
    >;
    where?: SolutionWhereInput;
  };

  export type SolutionUpdateToOneWithWhereWithoutCommentsInput = {
    where?: SolutionWhereInput;
    data: XOR<
      SolutionUpdateWithoutCommentsInput,
      SolutionUncheckedUpdateWithoutCommentsInput
    >;
  };

  export type SolutionUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSolutionStatusFieldUpdateOperationsInput
      | $Enums.SolutionStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    targetCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    owner?: UserUpdateOneRequiredWithoutSolutionsNestedInput;
    inputs?: InputUpdateManyWithoutSolutionsNestedInput;
    tasks?: TaskUpdateManyWithoutSolutionNestedInput;
    votes?: VoteUpdateManyWithoutSolutionNestedInput;
    requirements?: RequirementUpdateManyWithoutSolutionNestedInput;
    frdDocuments?: FRDDocumentUpdateManyWithoutSolutionNestedInput;
  };

  export type SolutionUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSolutionStatusFieldUpdateOperationsInput
      | $Enums.SolutionStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    targetCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    inputs?: InputUncheckedUpdateManyWithoutSolutionsNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutSolutionNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutSolutionNestedInput;
    requirements?: RequirementUncheckedUpdateManyWithoutSolutionNestedInput;
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutSolutionNestedInput;
  };

  export type RequirementUpsertWithoutCommentsInput = {
    update: XOR<
      RequirementUpdateWithoutCommentsInput,
      RequirementUncheckedUpdateWithoutCommentsInput
    >;
    create: XOR<
      RequirementCreateWithoutCommentsInput,
      RequirementUncheckedCreateWithoutCommentsInput
    >;
    where?: RequirementWhereInput;
  };

  export type RequirementUpdateToOneWithWhereWithoutCommentsInput = {
    where?: RequirementWhereInput;
    data: XOR<
      RequirementUpdateWithoutCommentsInput,
      RequirementUncheckedUpdateWithoutCommentsInput
    >;
  };

  export type RequirementUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    status?:
      | EnumRequirementStatusFieldUpdateOperationsInput
      | $Enums.RequirementStatus;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null;
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    solution?: SolutionUpdateOneRequiredWithoutRequirementsNestedInput;
    creator?: UserUpdateOneRequiredWithoutRequirementsNestedInput;
  };

  export type RequirementUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    status?:
      | EnumRequirementStatusFieldUpdateOperationsInput
      | $Enums.RequirementStatus;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null;
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    solutionId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<
      CommentUpdateWithoutRepliesInput,
      CommentUncheckedUpdateWithoutRepliesInput
    >;
    create: XOR<
      CommentCreateWithoutRepliesInput,
      CommentUncheckedCreateWithoutRepliesInput
    >;
    where?: CommentWhereInput;
  };

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput;
    data: XOR<
      CommentUpdateWithoutRepliesInput,
      CommentUncheckedUpdateWithoutRepliesInput
    >;
  };

  export type CommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput;
    input?: InputUpdateOneWithoutCommentsNestedInput;
    solution?: SolutionUpdateOneWithoutCommentsNestedInput;
    requirement?: RequirementUpdateOneWithoutCommentsNestedInput;
    parent?: CommentUpdateOneWithoutRepliesNestedInput;
  };

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    authorId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputId?: NullableStringFieldUpdateOperationsInput | string | null;
    solutionId?: NullableStringFieldUpdateOperationsInput | string | null;
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type UserCreateWithoutVotesInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputs?: InputCreateNestedManyWithoutCreatorInput;
    solutions?: SolutionCreateNestedManyWithoutOwnerInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    requirements?: RequirementCreateNestedManyWithoutCreatorInput;
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput;
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    inputGroups?: InputGroupCreateNestedManyWithoutOwnerInput;
    tasks?: TaskCreateNestedManyWithoutAssigneeInput;
  };

  export type UserUncheckedCreateWithoutVotesInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput;
    solutions?: SolutionUncheckedCreateNestedManyWithoutOwnerInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput;
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput;
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutOwnerInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput;
  };

  export type UserCreateOrConnectWithoutVotesInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutVotesInput,
      UserUncheckedCreateWithoutVotesInput
    >;
  };

  export type InputCreateWithoutVotesInput = {
    id?: string;
    title: string;
    description: string;
    type: $Enums.InputType;
    status?: $Enums.InputStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    department?: string | null;
    issueType?: $Enums.IssueType | null;
    rootCause?: string | null;
    priority?: $Enums.Priority;
    aiProcessed?: boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    creator: UserCreateNestedOneWithoutInputsInput;
    solutions?: SolutionCreateNestedManyWithoutInputsInput;
    comments?: CommentCreateNestedManyWithoutInputInput;
    groups?: InputGroupCreateNestedManyWithoutInputsInput;
  };

  export type InputUncheckedCreateWithoutVotesInput = {
    id?: string;
    title: string;
    description: string;
    type: $Enums.InputType;
    status?: $Enums.InputStatus;
    createdBy: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    department?: string | null;
    issueType?: $Enums.IssueType | null;
    rootCause?: string | null;
    priority?: $Enums.Priority;
    aiProcessed?: boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    solutions?: SolutionUncheckedCreateNestedManyWithoutInputsInput;
    comments?: CommentUncheckedCreateNestedManyWithoutInputInput;
    groups?: InputGroupUncheckedCreateNestedManyWithoutInputsInput;
  };

  export type InputCreateOrConnectWithoutVotesInput = {
    where: InputWhereUniqueInput;
    create: XOR<
      InputCreateWithoutVotesInput,
      InputUncheckedCreateWithoutVotesInput
    >;
  };

  export type SolutionCreateWithoutVotesInput = {
    id?: string;
    title: string;
    description: string;
    status?: $Enums.SolutionStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedEffort?: string | null;
    targetCompletion?: Date | string | null;
    actualCompletion?: Date | string | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    owner: UserCreateNestedOneWithoutSolutionsInput;
    inputs?: InputCreateNestedManyWithoutSolutionsInput;
    tasks?: TaskCreateNestedManyWithoutSolutionInput;
    comments?: CommentCreateNestedManyWithoutSolutionInput;
    requirements?: RequirementCreateNestedManyWithoutSolutionInput;
    frdDocuments?: FRDDocumentCreateNestedManyWithoutSolutionInput;
  };

  export type SolutionUncheckedCreateWithoutVotesInput = {
    id?: string;
    title: string;
    description: string;
    ownerId: string;
    status?: $Enums.SolutionStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedEffort?: string | null;
    targetCompletion?: Date | string | null;
    actualCompletion?: Date | string | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    inputs?: InputUncheckedCreateNestedManyWithoutSolutionsInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutSolutionInput;
    comments?: CommentUncheckedCreateNestedManyWithoutSolutionInput;
    requirements?: RequirementUncheckedCreateNestedManyWithoutSolutionInput;
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutSolutionInput;
  };

  export type SolutionCreateOrConnectWithoutVotesInput = {
    where: SolutionWhereUniqueInput;
    create: XOR<
      SolutionCreateWithoutVotesInput,
      SolutionUncheckedCreateWithoutVotesInput
    >;
  };

  export type UserUpsertWithoutVotesInput = {
    update: XOR<
      UserUpdateWithoutVotesInput,
      UserUncheckedUpdateWithoutVotesInput
    >;
    create: XOR<
      UserCreateWithoutVotesInput,
      UserUncheckedCreateWithoutVotesInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutVotesInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutVotesInput,
      UserUncheckedUpdateWithoutVotesInput
    >;
  };

  export type UserUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputs?: InputUpdateManyWithoutCreatorNestedInput;
    solutions?: SolutionUpdateManyWithoutOwnerNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput;
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput;
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    inputGroups?: InputGroupUpdateManyWithoutOwnerNestedInput;
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput;
  };

  export type UserUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput;
    solutions?: SolutionUncheckedUpdateManyWithoutOwnerNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput;
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput;
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    inputGroups?: InputGroupUncheckedUpdateManyWithoutOwnerNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput;
  };

  export type InputUpsertWithoutVotesInput = {
    update: XOR<
      InputUpdateWithoutVotesInput,
      InputUncheckedUpdateWithoutVotesInput
    >;
    create: XOR<
      InputCreateWithoutVotesInput,
      InputUncheckedCreateWithoutVotesInput
    >;
    where?: InputWhereInput;
  };

  export type InputUpdateToOneWithWhereWithoutVotesInput = {
    where?: InputWhereInput;
    data: XOR<
      InputUpdateWithoutVotesInput,
      InputUncheckedUpdateWithoutVotesInput
    >;
  };

  export type InputUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType;
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    issueType?:
      | NullableEnumIssueTypeFieldUpdateOperationsInput
      | $Enums.IssueType
      | null;
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    creator?: UserUpdateOneRequiredWithoutInputsNestedInput;
    solutions?: SolutionUpdateManyWithoutInputsNestedInput;
    comments?: CommentUpdateManyWithoutInputNestedInput;
    groups?: InputGroupUpdateManyWithoutInputsNestedInput;
  };

  export type InputUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType;
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    issueType?:
      | NullableEnumIssueTypeFieldUpdateOperationsInput
      | $Enums.IssueType
      | null;
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    solutions?: SolutionUncheckedUpdateManyWithoutInputsNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutInputNestedInput;
    groups?: InputGroupUncheckedUpdateManyWithoutInputsNestedInput;
  };

  export type SolutionUpsertWithoutVotesInput = {
    update: XOR<
      SolutionUpdateWithoutVotesInput,
      SolutionUncheckedUpdateWithoutVotesInput
    >;
    create: XOR<
      SolutionCreateWithoutVotesInput,
      SolutionUncheckedCreateWithoutVotesInput
    >;
    where?: SolutionWhereInput;
  };

  export type SolutionUpdateToOneWithWhereWithoutVotesInput = {
    where?: SolutionWhereInput;
    data: XOR<
      SolutionUpdateWithoutVotesInput,
      SolutionUncheckedUpdateWithoutVotesInput
    >;
  };

  export type SolutionUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSolutionStatusFieldUpdateOperationsInput
      | $Enums.SolutionStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    targetCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    owner?: UserUpdateOneRequiredWithoutSolutionsNestedInput;
    inputs?: InputUpdateManyWithoutSolutionsNestedInput;
    tasks?: TaskUpdateManyWithoutSolutionNestedInput;
    comments?: CommentUpdateManyWithoutSolutionNestedInput;
    requirements?: RequirementUpdateManyWithoutSolutionNestedInput;
    frdDocuments?: FRDDocumentUpdateManyWithoutSolutionNestedInput;
  };

  export type SolutionUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSolutionStatusFieldUpdateOperationsInput
      | $Enums.SolutionStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    targetCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    inputs?: InputUncheckedUpdateManyWithoutSolutionsNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutSolutionNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutSolutionNestedInput;
    requirements?: RequirementUncheckedUpdateManyWithoutSolutionNestedInput;
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutSolutionNestedInput;
  };

  export type UserCreateWithoutInputGroupsInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputs?: InputCreateNestedManyWithoutCreatorInput;
    solutions?: SolutionCreateNestedManyWithoutOwnerInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    votes?: VoteCreateNestedManyWithoutUserInput;
    requirements?: RequirementCreateNestedManyWithoutCreatorInput;
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput;
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    tasks?: TaskCreateNestedManyWithoutAssigneeInput;
  };

  export type UserUncheckedCreateWithoutInputGroupsInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput;
    solutions?: SolutionUncheckedCreateNestedManyWithoutOwnerInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput;
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput;
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput;
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput;
  };

  export type UserCreateOrConnectWithoutInputGroupsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutInputGroupsInput,
      UserUncheckedCreateWithoutInputGroupsInput
    >;
  };

  export type InputCreateWithoutGroupsInput = {
    id?: string;
    title: string;
    description: string;
    type: $Enums.InputType;
    status?: $Enums.InputStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    department?: string | null;
    issueType?: $Enums.IssueType | null;
    rootCause?: string | null;
    priority?: $Enums.Priority;
    aiProcessed?: boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    creator: UserCreateNestedOneWithoutInputsInput;
    solutions?: SolutionCreateNestedManyWithoutInputsInput;
    comments?: CommentCreateNestedManyWithoutInputInput;
    votes?: VoteCreateNestedManyWithoutInputInput;
  };

  export type InputUncheckedCreateWithoutGroupsInput = {
    id?: string;
    title: string;
    description: string;
    type: $Enums.InputType;
    status?: $Enums.InputStatus;
    createdBy: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    department?: string | null;
    issueType?: $Enums.IssueType | null;
    rootCause?: string | null;
    priority?: $Enums.Priority;
    aiProcessed?: boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    solutions?: SolutionUncheckedCreateNestedManyWithoutInputsInput;
    comments?: CommentUncheckedCreateNestedManyWithoutInputInput;
    votes?: VoteUncheckedCreateNestedManyWithoutInputInput;
  };

  export type InputCreateOrConnectWithoutGroupsInput = {
    where: InputWhereUniqueInput;
    create: XOR<
      InputCreateWithoutGroupsInput,
      InputUncheckedCreateWithoutGroupsInput
    >;
  };

  export type UserUpsertWithoutInputGroupsInput = {
    update: XOR<
      UserUpdateWithoutInputGroupsInput,
      UserUncheckedUpdateWithoutInputGroupsInput
    >;
    create: XOR<
      UserCreateWithoutInputGroupsInput,
      UserUncheckedCreateWithoutInputGroupsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutInputGroupsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutInputGroupsInput,
      UserUncheckedUpdateWithoutInputGroupsInput
    >;
  };

  export type UserUpdateWithoutInputGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputs?: InputUpdateManyWithoutCreatorNestedInput;
    solutions?: SolutionUpdateManyWithoutOwnerNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    votes?: VoteUpdateManyWithoutUserNestedInput;
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput;
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput;
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput;
  };

  export type UserUncheckedUpdateWithoutInputGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput;
    solutions?: SolutionUncheckedUpdateManyWithoutOwnerNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput;
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput;
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput;
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput;
  };

  export type InputUpsertWithWhereUniqueWithoutGroupsInput = {
    where: InputWhereUniqueInput;
    update: XOR<
      InputUpdateWithoutGroupsInput,
      InputUncheckedUpdateWithoutGroupsInput
    >;
    create: XOR<
      InputCreateWithoutGroupsInput,
      InputUncheckedCreateWithoutGroupsInput
    >;
  };

  export type InputUpdateWithWhereUniqueWithoutGroupsInput = {
    where: InputWhereUniqueInput;
    data: XOR<
      InputUpdateWithoutGroupsInput,
      InputUncheckedUpdateWithoutGroupsInput
    >;
  };

  export type InputUpdateManyWithWhereWithoutGroupsInput = {
    where: InputScalarWhereInput;
    data: XOR<
      InputUpdateManyMutationInput,
      InputUncheckedUpdateManyWithoutGroupsInput
    >;
  };

  export type UserCreateWithoutSolutionsInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputs?: InputCreateNestedManyWithoutCreatorInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    votes?: VoteCreateNestedManyWithoutUserInput;
    requirements?: RequirementCreateNestedManyWithoutCreatorInput;
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput;
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    inputGroups?: InputGroupCreateNestedManyWithoutOwnerInput;
    tasks?: TaskCreateNestedManyWithoutAssigneeInput;
  };

  export type UserUncheckedCreateWithoutSolutionsInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput;
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput;
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput;
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutOwnerInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput;
  };

  export type UserCreateOrConnectWithoutSolutionsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutSolutionsInput,
      UserUncheckedCreateWithoutSolutionsInput
    >;
  };

  export type InputCreateWithoutSolutionsInput = {
    id?: string;
    title: string;
    description: string;
    type: $Enums.InputType;
    status?: $Enums.InputStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    department?: string | null;
    issueType?: $Enums.IssueType | null;
    rootCause?: string | null;
    priority?: $Enums.Priority;
    aiProcessed?: boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    creator: UserCreateNestedOneWithoutInputsInput;
    comments?: CommentCreateNestedManyWithoutInputInput;
    votes?: VoteCreateNestedManyWithoutInputInput;
    groups?: InputGroupCreateNestedManyWithoutInputsInput;
  };

  export type InputUncheckedCreateWithoutSolutionsInput = {
    id?: string;
    title: string;
    description: string;
    type: $Enums.InputType;
    status?: $Enums.InputStatus;
    createdBy: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    department?: string | null;
    issueType?: $Enums.IssueType | null;
    rootCause?: string | null;
    priority?: $Enums.Priority;
    aiProcessed?: boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    comments?: CommentUncheckedCreateNestedManyWithoutInputInput;
    votes?: VoteUncheckedCreateNestedManyWithoutInputInput;
    groups?: InputGroupUncheckedCreateNestedManyWithoutInputsInput;
  };

  export type InputCreateOrConnectWithoutSolutionsInput = {
    where: InputWhereUniqueInput;
    create: XOR<
      InputCreateWithoutSolutionsInput,
      InputUncheckedCreateWithoutSolutionsInput
    >;
  };

  export type TaskCreateWithoutSolutionInput = {
    id?: string;
    title: string;
    description?: string | null;
    status?: $Enums.TaskStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedHours?: number | null;
    actualHours?: number | null;
    dueDate?: Date | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    assignee?: UserCreateNestedOneWithoutTasksInput;
  };

  export type TaskUncheckedCreateWithoutSolutionInput = {
    id?: string;
    title: string;
    description?: string | null;
    assigneeId?: string | null;
    status?: $Enums.TaskStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedHours?: number | null;
    actualHours?: number | null;
    dueDate?: Date | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type TaskCreateOrConnectWithoutSolutionInput = {
    where: TaskWhereUniqueInput;
    create: XOR<
      TaskCreateWithoutSolutionInput,
      TaskUncheckedCreateWithoutSolutionInput
    >;
  };

  export type TaskCreateManySolutionInputEnvelope = {
    data: TaskCreateManySolutionInput | TaskCreateManySolutionInput[];
    skipDuplicates?: boolean;
  };

  export type CommentCreateWithoutSolutionInput = {
    id?: string;
    content: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    replies?: CommentCreateNestedManyWithoutParentInput;
    author: UserCreateNestedOneWithoutCommentsInput;
    input?: InputCreateNestedOneWithoutCommentsInput;
    requirement?: RequirementCreateNestedOneWithoutCommentsInput;
    parent?: CommentCreateNestedOneWithoutRepliesInput;
  };

  export type CommentUncheckedCreateWithoutSolutionInput = {
    id?: string;
    content: string;
    authorId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputId?: string | null;
    requirementId?: string | null;
    parentId?: string | null;
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput;
  };

  export type CommentCreateOrConnectWithoutSolutionInput = {
    where: CommentWhereUniqueInput;
    create: XOR<
      CommentCreateWithoutSolutionInput,
      CommentUncheckedCreateWithoutSolutionInput
    >;
  };

  export type CommentCreateManySolutionInputEnvelope = {
    data: CommentCreateManySolutionInput | CommentCreateManySolutionInput[];
    skipDuplicates?: boolean;
  };

  export type VoteCreateWithoutSolutionInput = {
    id?: string;
    value: number;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutVotesInput;
    input?: InputCreateNestedOneWithoutVotesInput;
  };

  export type VoteUncheckedCreateWithoutSolutionInput = {
    id?: string;
    userId: string;
    value: number;
    createdAt?: Date | string;
    inputId?: string | null;
  };

  export type VoteCreateOrConnectWithoutSolutionInput = {
    where: VoteWhereUniqueInput;
    create: XOR<
      VoteCreateWithoutSolutionInput,
      VoteUncheckedCreateWithoutSolutionInput
    >;
  };

  export type VoteCreateManySolutionInputEnvelope = {
    data: VoteCreateManySolutionInput | VoteCreateManySolutionInput[];
    skipDuplicates?: boolean;
  };

  export type RequirementCreateWithoutSolutionInput = {
    id?: string;
    title: string;
    description: string;
    acceptanceCriteria: JsonNullValueInput | InputJsonValue;
    priority?: $Enums.Priority;
    status?: $Enums.RequirementStatus;
    estimatedEffort?: string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: string | null;
    riskAssessment?: string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: string | null;
    approvedAt?: Date | string | null;
    rejectionReason?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    creator: UserCreateNestedOneWithoutRequirementsInput;
    comments?: CommentCreateNestedManyWithoutRequirementInput;
  };

  export type RequirementUncheckedCreateWithoutSolutionInput = {
    id?: string;
    title: string;
    description: string;
    acceptanceCriteria: JsonNullValueInput | InputJsonValue;
    priority?: $Enums.Priority;
    status?: $Enums.RequirementStatus;
    estimatedEffort?: string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: string | null;
    riskAssessment?: string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: string | null;
    approvedAt?: Date | string | null;
    rejectionReason?: string | null;
    createdBy: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    comments?: CommentUncheckedCreateNestedManyWithoutRequirementInput;
  };

  export type RequirementCreateOrConnectWithoutSolutionInput = {
    where: RequirementWhereUniqueInput;
    create: XOR<
      RequirementCreateWithoutSolutionInput,
      RequirementUncheckedCreateWithoutSolutionInput
    >;
  };

  export type RequirementCreateManySolutionInputEnvelope = {
    data:
      | RequirementCreateManySolutionInput
      | RequirementCreateManySolutionInput[];
    skipDuplicates?: boolean;
  };

  export type FRDDocumentCreateWithoutSolutionInput = {
    id?: string;
    title: string;
    content: JsonNullValueInput | InputJsonValue;
    aiGenerated?: boolean;
    aiConfidence?: number | null;
    aiPromptUsed?: string | null;
    version?: string;
    status?: $Enums.FRDStatus;
    executiveApproved?: boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: string | null;
    generationTime?: number | null;
    wordCount?: number | null;
    lastExportedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    creator: UserCreateNestedOneWithoutFrdDocumentsInput;
    approver?: UserCreateNestedOneWithoutApprovedFRDsInput;
  };

  export type FRDDocumentUncheckedCreateWithoutSolutionInput = {
    id?: string;
    title: string;
    content: JsonNullValueInput | InputJsonValue;
    aiGenerated?: boolean;
    aiConfidence?: number | null;
    aiPromptUsed?: string | null;
    version?: string;
    status?: $Enums.FRDStatus;
    executiveApproved?: boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: string | null;
    generationTime?: number | null;
    wordCount?: number | null;
    lastExportedAt?: Date | string | null;
    createdBy: string;
    approvedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FRDDocumentCreateOrConnectWithoutSolutionInput = {
    where: FRDDocumentWhereUniqueInput;
    create: XOR<
      FRDDocumentCreateWithoutSolutionInput,
      FRDDocumentUncheckedCreateWithoutSolutionInput
    >;
  };

  export type FRDDocumentCreateManySolutionInputEnvelope = {
    data:
      | FRDDocumentCreateManySolutionInput
      | FRDDocumentCreateManySolutionInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutSolutionsInput = {
    update: XOR<
      UserUpdateWithoutSolutionsInput,
      UserUncheckedUpdateWithoutSolutionsInput
    >;
    create: XOR<
      UserCreateWithoutSolutionsInput,
      UserUncheckedCreateWithoutSolutionsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutSolutionsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutSolutionsInput,
      UserUncheckedUpdateWithoutSolutionsInput
    >;
  };

  export type UserUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputs?: InputUpdateManyWithoutCreatorNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    votes?: VoteUpdateManyWithoutUserNestedInput;
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput;
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput;
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    inputGroups?: InputGroupUpdateManyWithoutOwnerNestedInput;
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput;
  };

  export type UserUncheckedUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput;
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput;
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput;
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    inputGroups?: InputGroupUncheckedUpdateManyWithoutOwnerNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput;
  };

  export type InputUpsertWithWhereUniqueWithoutSolutionsInput = {
    where: InputWhereUniqueInput;
    update: XOR<
      InputUpdateWithoutSolutionsInput,
      InputUncheckedUpdateWithoutSolutionsInput
    >;
    create: XOR<
      InputCreateWithoutSolutionsInput,
      InputUncheckedCreateWithoutSolutionsInput
    >;
  };

  export type InputUpdateWithWhereUniqueWithoutSolutionsInput = {
    where: InputWhereUniqueInput;
    data: XOR<
      InputUpdateWithoutSolutionsInput,
      InputUncheckedUpdateWithoutSolutionsInput
    >;
  };

  export type InputUpdateManyWithWhereWithoutSolutionsInput = {
    where: InputScalarWhereInput;
    data: XOR<
      InputUpdateManyMutationInput,
      InputUncheckedUpdateManyWithoutSolutionsInput
    >;
  };

  export type TaskUpsertWithWhereUniqueWithoutSolutionInput = {
    where: TaskWhereUniqueInput;
    update: XOR<
      TaskUpdateWithoutSolutionInput,
      TaskUncheckedUpdateWithoutSolutionInput
    >;
    create: XOR<
      TaskCreateWithoutSolutionInput,
      TaskUncheckedCreateWithoutSolutionInput
    >;
  };

  export type TaskUpdateWithWhereUniqueWithoutSolutionInput = {
    where: TaskWhereUniqueInput;
    data: XOR<
      TaskUpdateWithoutSolutionInput,
      TaskUncheckedUpdateWithoutSolutionInput
    >;
  };

  export type TaskUpdateManyWithWhereWithoutSolutionInput = {
    where: TaskScalarWhereInput;
    data: XOR<
      TaskUpdateManyMutationInput,
      TaskUncheckedUpdateManyWithoutSolutionInput
    >;
  };

  export type CommentUpsertWithWhereUniqueWithoutSolutionInput = {
    where: CommentWhereUniqueInput;
    update: XOR<
      CommentUpdateWithoutSolutionInput,
      CommentUncheckedUpdateWithoutSolutionInput
    >;
    create: XOR<
      CommentCreateWithoutSolutionInput,
      CommentUncheckedCreateWithoutSolutionInput
    >;
  };

  export type CommentUpdateWithWhereUniqueWithoutSolutionInput = {
    where: CommentWhereUniqueInput;
    data: XOR<
      CommentUpdateWithoutSolutionInput,
      CommentUncheckedUpdateWithoutSolutionInput
    >;
  };

  export type CommentUpdateManyWithWhereWithoutSolutionInput = {
    where: CommentScalarWhereInput;
    data: XOR<
      CommentUpdateManyMutationInput,
      CommentUncheckedUpdateManyWithoutSolutionInput
    >;
  };

  export type VoteUpsertWithWhereUniqueWithoutSolutionInput = {
    where: VoteWhereUniqueInput;
    update: XOR<
      VoteUpdateWithoutSolutionInput,
      VoteUncheckedUpdateWithoutSolutionInput
    >;
    create: XOR<
      VoteCreateWithoutSolutionInput,
      VoteUncheckedCreateWithoutSolutionInput
    >;
  };

  export type VoteUpdateWithWhereUniqueWithoutSolutionInput = {
    where: VoteWhereUniqueInput;
    data: XOR<
      VoteUpdateWithoutSolutionInput,
      VoteUncheckedUpdateWithoutSolutionInput
    >;
  };

  export type VoteUpdateManyWithWhereWithoutSolutionInput = {
    where: VoteScalarWhereInput;
    data: XOR<
      VoteUpdateManyMutationInput,
      VoteUncheckedUpdateManyWithoutSolutionInput
    >;
  };

  export type RequirementUpsertWithWhereUniqueWithoutSolutionInput = {
    where: RequirementWhereUniqueInput;
    update: XOR<
      RequirementUpdateWithoutSolutionInput,
      RequirementUncheckedUpdateWithoutSolutionInput
    >;
    create: XOR<
      RequirementCreateWithoutSolutionInput,
      RequirementUncheckedCreateWithoutSolutionInput
    >;
  };

  export type RequirementUpdateWithWhereUniqueWithoutSolutionInput = {
    where: RequirementWhereUniqueInput;
    data: XOR<
      RequirementUpdateWithoutSolutionInput,
      RequirementUncheckedUpdateWithoutSolutionInput
    >;
  };

  export type RequirementUpdateManyWithWhereWithoutSolutionInput = {
    where: RequirementScalarWhereInput;
    data: XOR<
      RequirementUpdateManyMutationInput,
      RequirementUncheckedUpdateManyWithoutSolutionInput
    >;
  };

  export type FRDDocumentUpsertWithWhereUniqueWithoutSolutionInput = {
    where: FRDDocumentWhereUniqueInput;
    update: XOR<
      FRDDocumentUpdateWithoutSolutionInput,
      FRDDocumentUncheckedUpdateWithoutSolutionInput
    >;
    create: XOR<
      FRDDocumentCreateWithoutSolutionInput,
      FRDDocumentUncheckedCreateWithoutSolutionInput
    >;
  };

  export type FRDDocumentUpdateWithWhereUniqueWithoutSolutionInput = {
    where: FRDDocumentWhereUniqueInput;
    data: XOR<
      FRDDocumentUpdateWithoutSolutionInput,
      FRDDocumentUncheckedUpdateWithoutSolutionInput
    >;
  };

  export type FRDDocumentUpdateManyWithWhereWithoutSolutionInput = {
    where: FRDDocumentScalarWhereInput;
    data: XOR<
      FRDDocumentUpdateManyMutationInput,
      FRDDocumentUncheckedUpdateManyWithoutSolutionInput
    >;
  };

  export type SolutionCreateWithoutTasksInput = {
    id?: string;
    title: string;
    description: string;
    status?: $Enums.SolutionStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedEffort?: string | null;
    targetCompletion?: Date | string | null;
    actualCompletion?: Date | string | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    owner: UserCreateNestedOneWithoutSolutionsInput;
    inputs?: InputCreateNestedManyWithoutSolutionsInput;
    comments?: CommentCreateNestedManyWithoutSolutionInput;
    votes?: VoteCreateNestedManyWithoutSolutionInput;
    requirements?: RequirementCreateNestedManyWithoutSolutionInput;
    frdDocuments?: FRDDocumentCreateNestedManyWithoutSolutionInput;
  };

  export type SolutionUncheckedCreateWithoutTasksInput = {
    id?: string;
    title: string;
    description: string;
    ownerId: string;
    status?: $Enums.SolutionStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedEffort?: string | null;
    targetCompletion?: Date | string | null;
    actualCompletion?: Date | string | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    inputs?: InputUncheckedCreateNestedManyWithoutSolutionsInput;
    comments?: CommentUncheckedCreateNestedManyWithoutSolutionInput;
    votes?: VoteUncheckedCreateNestedManyWithoutSolutionInput;
    requirements?: RequirementUncheckedCreateNestedManyWithoutSolutionInput;
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutSolutionInput;
  };

  export type SolutionCreateOrConnectWithoutTasksInput = {
    where: SolutionWhereUniqueInput;
    create: XOR<
      SolutionCreateWithoutTasksInput,
      SolutionUncheckedCreateWithoutTasksInput
    >;
  };

  export type UserCreateWithoutTasksInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputs?: InputCreateNestedManyWithoutCreatorInput;
    solutions?: SolutionCreateNestedManyWithoutOwnerInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    votes?: VoteCreateNestedManyWithoutUserInput;
    requirements?: RequirementCreateNestedManyWithoutCreatorInput;
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput;
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    inputGroups?: InputGroupCreateNestedManyWithoutOwnerInput;
  };

  export type UserUncheckedCreateWithoutTasksInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput;
    solutions?: SolutionUncheckedCreateNestedManyWithoutOwnerInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput;
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput;
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput;
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutOwnerInput;
  };

  export type UserCreateOrConnectWithoutTasksInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutTasksInput,
      UserUncheckedCreateWithoutTasksInput
    >;
  };

  export type SolutionUpsertWithoutTasksInput = {
    update: XOR<
      SolutionUpdateWithoutTasksInput,
      SolutionUncheckedUpdateWithoutTasksInput
    >;
    create: XOR<
      SolutionCreateWithoutTasksInput,
      SolutionUncheckedCreateWithoutTasksInput
    >;
    where?: SolutionWhereInput;
  };

  export type SolutionUpdateToOneWithWhereWithoutTasksInput = {
    where?: SolutionWhereInput;
    data: XOR<
      SolutionUpdateWithoutTasksInput,
      SolutionUncheckedUpdateWithoutTasksInput
    >;
  };

  export type SolutionUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSolutionStatusFieldUpdateOperationsInput
      | $Enums.SolutionStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    targetCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    owner?: UserUpdateOneRequiredWithoutSolutionsNestedInput;
    inputs?: InputUpdateManyWithoutSolutionsNestedInput;
    comments?: CommentUpdateManyWithoutSolutionNestedInput;
    votes?: VoteUpdateManyWithoutSolutionNestedInput;
    requirements?: RequirementUpdateManyWithoutSolutionNestedInput;
    frdDocuments?: FRDDocumentUpdateManyWithoutSolutionNestedInput;
  };

  export type SolutionUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSolutionStatusFieldUpdateOperationsInput
      | $Enums.SolutionStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    targetCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    inputs?: InputUncheckedUpdateManyWithoutSolutionsNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutSolutionNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutSolutionNestedInput;
    requirements?: RequirementUncheckedUpdateManyWithoutSolutionNestedInput;
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutSolutionNestedInput;
  };

  export type UserUpsertWithoutTasksInput = {
    update: XOR<
      UserUpdateWithoutTasksInput,
      UserUncheckedUpdateWithoutTasksInput
    >;
    create: XOR<
      UserCreateWithoutTasksInput,
      UserUncheckedCreateWithoutTasksInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutTasksInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutTasksInput,
      UserUncheckedUpdateWithoutTasksInput
    >;
  };

  export type UserUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputs?: InputUpdateManyWithoutCreatorNestedInput;
    solutions?: SolutionUpdateManyWithoutOwnerNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    votes?: VoteUpdateManyWithoutUserNestedInput;
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput;
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput;
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    inputGroups?: InputGroupUpdateManyWithoutOwnerNestedInput;
  };

  export type UserUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput;
    solutions?: SolutionUncheckedUpdateManyWithoutOwnerNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput;
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput;
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput;
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    inputGroups?: InputGroupUncheckedUpdateManyWithoutOwnerNestedInput;
  };

  export type SolutionCreateWithoutRequirementsInput = {
    id?: string;
    title: string;
    description: string;
    status?: $Enums.SolutionStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedEffort?: string | null;
    targetCompletion?: Date | string | null;
    actualCompletion?: Date | string | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    owner: UserCreateNestedOneWithoutSolutionsInput;
    inputs?: InputCreateNestedManyWithoutSolutionsInput;
    tasks?: TaskCreateNestedManyWithoutSolutionInput;
    comments?: CommentCreateNestedManyWithoutSolutionInput;
    votes?: VoteCreateNestedManyWithoutSolutionInput;
    frdDocuments?: FRDDocumentCreateNestedManyWithoutSolutionInput;
  };

  export type SolutionUncheckedCreateWithoutRequirementsInput = {
    id?: string;
    title: string;
    description: string;
    ownerId: string;
    status?: $Enums.SolutionStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedEffort?: string | null;
    targetCompletion?: Date | string | null;
    actualCompletion?: Date | string | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    inputs?: InputUncheckedCreateNestedManyWithoutSolutionsInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutSolutionInput;
    comments?: CommentUncheckedCreateNestedManyWithoutSolutionInput;
    votes?: VoteUncheckedCreateNestedManyWithoutSolutionInput;
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutSolutionInput;
  };

  export type SolutionCreateOrConnectWithoutRequirementsInput = {
    where: SolutionWhereUniqueInput;
    create: XOR<
      SolutionCreateWithoutRequirementsInput,
      SolutionUncheckedCreateWithoutRequirementsInput
    >;
  };

  export type UserCreateWithoutRequirementsInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputs?: InputCreateNestedManyWithoutCreatorInput;
    solutions?: SolutionCreateNestedManyWithoutOwnerInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    votes?: VoteCreateNestedManyWithoutUserInput;
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput;
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    inputGroups?: InputGroupCreateNestedManyWithoutOwnerInput;
    tasks?: TaskCreateNestedManyWithoutAssigneeInput;
  };

  export type UserUncheckedCreateWithoutRequirementsInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput;
    solutions?: SolutionUncheckedCreateNestedManyWithoutOwnerInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput;
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput;
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutOwnerInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput;
  };

  export type UserCreateOrConnectWithoutRequirementsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutRequirementsInput,
      UserUncheckedCreateWithoutRequirementsInput
    >;
  };

  export type CommentCreateWithoutRequirementInput = {
    id?: string;
    content: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    replies?: CommentCreateNestedManyWithoutParentInput;
    author: UserCreateNestedOneWithoutCommentsInput;
    input?: InputCreateNestedOneWithoutCommentsInput;
    solution?: SolutionCreateNestedOneWithoutCommentsInput;
    parent?: CommentCreateNestedOneWithoutRepliesInput;
  };

  export type CommentUncheckedCreateWithoutRequirementInput = {
    id?: string;
    content: string;
    authorId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputId?: string | null;
    solutionId?: string | null;
    parentId?: string | null;
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput;
  };

  export type CommentCreateOrConnectWithoutRequirementInput = {
    where: CommentWhereUniqueInput;
    create: XOR<
      CommentCreateWithoutRequirementInput,
      CommentUncheckedCreateWithoutRequirementInput
    >;
  };

  export type CommentCreateManyRequirementInputEnvelope = {
    data:
      | CommentCreateManyRequirementInput
      | CommentCreateManyRequirementInput[];
    skipDuplicates?: boolean;
  };

  export type SolutionUpsertWithoutRequirementsInput = {
    update: XOR<
      SolutionUpdateWithoutRequirementsInput,
      SolutionUncheckedUpdateWithoutRequirementsInput
    >;
    create: XOR<
      SolutionCreateWithoutRequirementsInput,
      SolutionUncheckedCreateWithoutRequirementsInput
    >;
    where?: SolutionWhereInput;
  };

  export type SolutionUpdateToOneWithWhereWithoutRequirementsInput = {
    where?: SolutionWhereInput;
    data: XOR<
      SolutionUpdateWithoutRequirementsInput,
      SolutionUncheckedUpdateWithoutRequirementsInput
    >;
  };

  export type SolutionUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSolutionStatusFieldUpdateOperationsInput
      | $Enums.SolutionStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    targetCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    owner?: UserUpdateOneRequiredWithoutSolutionsNestedInput;
    inputs?: InputUpdateManyWithoutSolutionsNestedInput;
    tasks?: TaskUpdateManyWithoutSolutionNestedInput;
    comments?: CommentUpdateManyWithoutSolutionNestedInput;
    votes?: VoteUpdateManyWithoutSolutionNestedInput;
    frdDocuments?: FRDDocumentUpdateManyWithoutSolutionNestedInput;
  };

  export type SolutionUncheckedUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSolutionStatusFieldUpdateOperationsInput
      | $Enums.SolutionStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    targetCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    inputs?: InputUncheckedUpdateManyWithoutSolutionsNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutSolutionNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutSolutionNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutSolutionNestedInput;
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutSolutionNestedInput;
  };

  export type UserUpsertWithoutRequirementsInput = {
    update: XOR<
      UserUpdateWithoutRequirementsInput,
      UserUncheckedUpdateWithoutRequirementsInput
    >;
    create: XOR<
      UserCreateWithoutRequirementsInput,
      UserUncheckedCreateWithoutRequirementsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutRequirementsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutRequirementsInput,
      UserUncheckedUpdateWithoutRequirementsInput
    >;
  };

  export type UserUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputs?: InputUpdateManyWithoutCreatorNestedInput;
    solutions?: SolutionUpdateManyWithoutOwnerNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    votes?: VoteUpdateManyWithoutUserNestedInput;
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput;
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    inputGroups?: InputGroupUpdateManyWithoutOwnerNestedInput;
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput;
  };

  export type UserUncheckedUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput;
    solutions?: SolutionUncheckedUpdateManyWithoutOwnerNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput;
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput;
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    inputGroups?: InputGroupUncheckedUpdateManyWithoutOwnerNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput;
  };

  export type CommentUpsertWithWhereUniqueWithoutRequirementInput = {
    where: CommentWhereUniqueInput;
    update: XOR<
      CommentUpdateWithoutRequirementInput,
      CommentUncheckedUpdateWithoutRequirementInput
    >;
    create: XOR<
      CommentCreateWithoutRequirementInput,
      CommentUncheckedCreateWithoutRequirementInput
    >;
  };

  export type CommentUpdateWithWhereUniqueWithoutRequirementInput = {
    where: CommentWhereUniqueInput;
    data: XOR<
      CommentUpdateWithoutRequirementInput,
      CommentUncheckedUpdateWithoutRequirementInput
    >;
  };

  export type CommentUpdateManyWithWhereWithoutRequirementInput = {
    where: CommentScalarWhereInput;
    data: XOR<
      CommentUpdateManyMutationInput,
      CommentUncheckedUpdateManyWithoutRequirementInput
    >;
  };

  export type SolutionCreateWithoutFrdDocumentsInput = {
    id?: string;
    title: string;
    description: string;
    status?: $Enums.SolutionStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedEffort?: string | null;
    targetCompletion?: Date | string | null;
    actualCompletion?: Date | string | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    owner: UserCreateNestedOneWithoutSolutionsInput;
    inputs?: InputCreateNestedManyWithoutSolutionsInput;
    tasks?: TaskCreateNestedManyWithoutSolutionInput;
    comments?: CommentCreateNestedManyWithoutSolutionInput;
    votes?: VoteCreateNestedManyWithoutSolutionInput;
    requirements?: RequirementCreateNestedManyWithoutSolutionInput;
  };

  export type SolutionUncheckedCreateWithoutFrdDocumentsInput = {
    id?: string;
    title: string;
    description: string;
    ownerId: string;
    status?: $Enums.SolutionStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedEffort?: string | null;
    targetCompletion?: Date | string | null;
    actualCompletion?: Date | string | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    inputs?: InputUncheckedCreateNestedManyWithoutSolutionsInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutSolutionInput;
    comments?: CommentUncheckedCreateNestedManyWithoutSolutionInput;
    votes?: VoteUncheckedCreateNestedManyWithoutSolutionInput;
    requirements?: RequirementUncheckedCreateNestedManyWithoutSolutionInput;
  };

  export type SolutionCreateOrConnectWithoutFrdDocumentsInput = {
    where: SolutionWhereUniqueInput;
    create: XOR<
      SolutionCreateWithoutFrdDocumentsInput,
      SolutionUncheckedCreateWithoutFrdDocumentsInput
    >;
  };

  export type UserCreateWithoutFrdDocumentsInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputs?: InputCreateNestedManyWithoutCreatorInput;
    solutions?: SolutionCreateNestedManyWithoutOwnerInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    votes?: VoteCreateNestedManyWithoutUserInput;
    requirements?: RequirementCreateNestedManyWithoutCreatorInput;
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    inputGroups?: InputGroupCreateNestedManyWithoutOwnerInput;
    tasks?: TaskCreateNestedManyWithoutAssigneeInput;
  };

  export type UserUncheckedCreateWithoutFrdDocumentsInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput;
    solutions?: SolutionUncheckedCreateNestedManyWithoutOwnerInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput;
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput;
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutOwnerInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput;
  };

  export type UserCreateOrConnectWithoutFrdDocumentsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutFrdDocumentsInput,
      UserUncheckedCreateWithoutFrdDocumentsInput
    >;
  };

  export type UserCreateWithoutApprovedFRDsInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputs?: InputCreateNestedManyWithoutCreatorInput;
    solutions?: SolutionCreateNestedManyWithoutOwnerInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    votes?: VoteCreateNestedManyWithoutUserInput;
    requirements?: RequirementCreateNestedManyWithoutCreatorInput;
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    inputGroups?: InputGroupCreateNestedManyWithoutOwnerInput;
    tasks?: TaskCreateNestedManyWithoutAssigneeInput;
  };

  export type UserUncheckedCreateWithoutApprovedFRDsInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput;
    solutions?: SolutionUncheckedCreateNestedManyWithoutOwnerInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput;
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput;
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutOwnerInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput;
  };

  export type UserCreateOrConnectWithoutApprovedFRDsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutApprovedFRDsInput,
      UserUncheckedCreateWithoutApprovedFRDsInput
    >;
  };

  export type SolutionUpsertWithoutFrdDocumentsInput = {
    update: XOR<
      SolutionUpdateWithoutFrdDocumentsInput,
      SolutionUncheckedUpdateWithoutFrdDocumentsInput
    >;
    create: XOR<
      SolutionCreateWithoutFrdDocumentsInput,
      SolutionUncheckedCreateWithoutFrdDocumentsInput
    >;
    where?: SolutionWhereInput;
  };

  export type SolutionUpdateToOneWithWhereWithoutFrdDocumentsInput = {
    where?: SolutionWhereInput;
    data: XOR<
      SolutionUpdateWithoutFrdDocumentsInput,
      SolutionUncheckedUpdateWithoutFrdDocumentsInput
    >;
  };

  export type SolutionUpdateWithoutFrdDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSolutionStatusFieldUpdateOperationsInput
      | $Enums.SolutionStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    targetCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    owner?: UserUpdateOneRequiredWithoutSolutionsNestedInput;
    inputs?: InputUpdateManyWithoutSolutionsNestedInput;
    tasks?: TaskUpdateManyWithoutSolutionNestedInput;
    comments?: CommentUpdateManyWithoutSolutionNestedInput;
    votes?: VoteUpdateManyWithoutSolutionNestedInput;
    requirements?: RequirementUpdateManyWithoutSolutionNestedInput;
  };

  export type SolutionUncheckedUpdateWithoutFrdDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSolutionStatusFieldUpdateOperationsInput
      | $Enums.SolutionStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    targetCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    inputs?: InputUncheckedUpdateManyWithoutSolutionsNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutSolutionNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutSolutionNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutSolutionNestedInput;
    requirements?: RequirementUncheckedUpdateManyWithoutSolutionNestedInput;
  };

  export type UserUpsertWithoutFrdDocumentsInput = {
    update: XOR<
      UserUpdateWithoutFrdDocumentsInput,
      UserUncheckedUpdateWithoutFrdDocumentsInput
    >;
    create: XOR<
      UserCreateWithoutFrdDocumentsInput,
      UserUncheckedCreateWithoutFrdDocumentsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutFrdDocumentsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutFrdDocumentsInput,
      UserUncheckedUpdateWithoutFrdDocumentsInput
    >;
  };

  export type UserUpdateWithoutFrdDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputs?: InputUpdateManyWithoutCreatorNestedInput;
    solutions?: SolutionUpdateManyWithoutOwnerNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    votes?: VoteUpdateManyWithoutUserNestedInput;
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput;
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    inputGroups?: InputGroupUpdateManyWithoutOwnerNestedInput;
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput;
  };

  export type UserUncheckedUpdateWithoutFrdDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput;
    solutions?: SolutionUncheckedUpdateManyWithoutOwnerNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput;
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput;
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    inputGroups?: InputGroupUncheckedUpdateManyWithoutOwnerNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput;
  };

  export type UserUpsertWithoutApprovedFRDsInput = {
    update: XOR<
      UserUpdateWithoutApprovedFRDsInput,
      UserUncheckedUpdateWithoutApprovedFRDsInput
    >;
    create: XOR<
      UserCreateWithoutApprovedFRDsInput,
      UserUncheckedCreateWithoutApprovedFRDsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutApprovedFRDsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutApprovedFRDsInput,
      UserUncheckedUpdateWithoutApprovedFRDsInput
    >;
  };

  export type UserUpdateWithoutApprovedFRDsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputs?: InputUpdateManyWithoutCreatorNestedInput;
    solutions?: SolutionUpdateManyWithoutOwnerNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    votes?: VoteUpdateManyWithoutUserNestedInput;
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput;
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    inputGroups?: InputGroupUpdateManyWithoutOwnerNestedInput;
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput;
  };

  export type UserUncheckedUpdateWithoutApprovedFRDsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput;
    solutions?: SolutionUncheckedUpdateManyWithoutOwnerNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput;
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput;
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    inputGroups?: InputGroupUncheckedUpdateManyWithoutOwnerNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput;
  };

  export type UserCreateWithoutAuditLogsInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputs?: InputCreateNestedManyWithoutCreatorInput;
    solutions?: SolutionCreateNestedManyWithoutOwnerInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    votes?: VoteCreateNestedManyWithoutUserInput;
    requirements?: RequirementCreateNestedManyWithoutCreatorInput;
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput;
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    inputGroups?: InputGroupCreateNestedManyWithoutOwnerInput;
    tasks?: TaskCreateNestedManyWithoutAssigneeInput;
  };

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput;
    solutions?: SolutionUncheckedCreateNestedManyWithoutOwnerInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput;
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput;
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput;
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutOwnerInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput;
  };

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutAuditLogsInput,
      UserUncheckedCreateWithoutAuditLogsInput
    >;
  };

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<
      UserUpdateWithoutAuditLogsInput,
      UserUncheckedUpdateWithoutAuditLogsInput
    >;
    create: XOR<
      UserCreateWithoutAuditLogsInput,
      UserUncheckedCreateWithoutAuditLogsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutAuditLogsInput,
      UserUncheckedUpdateWithoutAuditLogsInput
    >;
  };

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputs?: InputUpdateManyWithoutCreatorNestedInput;
    solutions?: SolutionUpdateManyWithoutOwnerNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    votes?: VoteUpdateManyWithoutUserNestedInput;
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput;
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput;
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    inputGroups?: InputGroupUpdateManyWithoutOwnerNestedInput;
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput;
  };

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput;
    solutions?: SolutionUncheckedUpdateManyWithoutOwnerNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput;
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput;
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput;
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    inputGroups?: InputGroupUncheckedUpdateManyWithoutOwnerNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput;
  };

  export type UserCreateWithoutNotificationsInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputs?: InputCreateNestedManyWithoutCreatorInput;
    solutions?: SolutionCreateNestedManyWithoutOwnerInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    votes?: VoteCreateNestedManyWithoutUserInput;
    requirements?: RequirementCreateNestedManyWithoutCreatorInput;
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput;
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    inputGroups?: InputGroupCreateNestedManyWithoutOwnerInput;
    tasks?: TaskCreateNestedManyWithoutAssigneeInput;
  };

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string;
    email: string;
    name: string;
    role?: $Enums.UserRole;
    department?: string | null;
    avatar?: string | null;
    passwordHash?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput;
    solutions?: SolutionUncheckedCreateNestedManyWithoutOwnerInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput;
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput;
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput;
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutOwnerInput;
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput;
  };

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutNotificationsInput,
      UserUncheckedCreateWithoutNotificationsInput
    >;
  };

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<
      UserUpdateWithoutNotificationsInput,
      UserUncheckedUpdateWithoutNotificationsInput
    >;
    create: XOR<
      UserCreateWithoutNotificationsInput,
      UserUncheckedCreateWithoutNotificationsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutNotificationsInput,
      UserUncheckedUpdateWithoutNotificationsInput
    >;
  };

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputs?: InputUpdateManyWithoutCreatorNestedInput;
    solutions?: SolutionUpdateManyWithoutOwnerNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    votes?: VoteUpdateManyWithoutUserNestedInput;
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput;
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput;
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    inputGroups?: InputGroupUpdateManyWithoutOwnerNestedInput;
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput;
  };

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput;
    solutions?: SolutionUncheckedUpdateManyWithoutOwnerNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput;
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput;
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput;
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    inputGroups?: InputGroupUncheckedUpdateManyWithoutOwnerNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput;
  };

  export type InputCreateManyCreatorInput = {
    id?: string;
    title: string;
    description: string;
    type: $Enums.InputType;
    status?: $Enums.InputStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    department?: string | null;
    issueType?: $Enums.IssueType | null;
    rootCause?: string | null;
    priority?: $Enums.Priority;
    aiProcessed?: boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type SolutionCreateManyOwnerInput = {
    id?: string;
    title: string;
    description: string;
    status?: $Enums.SolutionStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedEffort?: string | null;
    targetCompletion?: Date | string | null;
    actualCompletion?: Date | string | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type CommentCreateManyAuthorInput = {
    id?: string;
    content: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputId?: string | null;
    solutionId?: string | null;
    requirementId?: string | null;
    parentId?: string | null;
  };

  export type VoteCreateManyUserInput = {
    id?: string;
    value: number;
    createdAt?: Date | string;
    inputId?: string | null;
    solutionId?: string | null;
  };

  export type RequirementCreateManyCreatorInput = {
    id?: string;
    title: string;
    description: string;
    acceptanceCriteria: JsonNullValueInput | InputJsonValue;
    priority?: $Enums.Priority;
    status?: $Enums.RequirementStatus;
    estimatedEffort?: string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: string | null;
    riskAssessment?: string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: string | null;
    approvedAt?: Date | string | null;
    rejectionReason?: string | null;
    solutionId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FRDDocumentCreateManyCreatorInput = {
    id?: string;
    title: string;
    content: JsonNullValueInput | InputJsonValue;
    aiGenerated?: boolean;
    aiConfidence?: number | null;
    aiPromptUsed?: string | null;
    version?: string;
    status?: $Enums.FRDStatus;
    executiveApproved?: boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: string | null;
    generationTime?: number | null;
    wordCount?: number | null;
    lastExportedAt?: Date | string | null;
    solutionId: string;
    approvedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FRDDocumentCreateManyApproverInput = {
    id?: string;
    title: string;
    content: JsonNullValueInput | InputJsonValue;
    aiGenerated?: boolean;
    aiConfidence?: number | null;
    aiPromptUsed?: string | null;
    version?: string;
    status?: $Enums.FRDStatus;
    executiveApproved?: boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: string | null;
    generationTime?: number | null;
    wordCount?: number | null;
    lastExportedAt?: Date | string | null;
    solutionId: string;
    createdBy: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AuditLogCreateManyUserInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId: string;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type NotificationCreateManyUserInput = {
    id?: string;
    type: $Enums.NotificationType;
    title: string;
    message: string;
    readAt?: Date | string | null;
    data?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type InputGroupCreateManyOwnerInput = {
    id?: string;
    name: string;
    description?: string | null;
    status?: $Enums.GroupStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    aiSuggested?: boolean;
    aiSimilarity?: number | null;
    aiTheme?: string | null;
  };

  export type TaskCreateManyAssigneeInput = {
    id?: string;
    title: string;
    description?: string | null;
    solutionId: string;
    status?: $Enums.TaskStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedHours?: number | null;
    actualHours?: number | null;
    dueDate?: Date | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type InputUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType;
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    issueType?:
      | NullableEnumIssueTypeFieldUpdateOperationsInput
      | $Enums.IssueType
      | null;
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    solutions?: SolutionUpdateManyWithoutInputsNestedInput;
    comments?: CommentUpdateManyWithoutInputNestedInput;
    votes?: VoteUpdateManyWithoutInputNestedInput;
    groups?: InputGroupUpdateManyWithoutInputsNestedInput;
  };

  export type InputUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType;
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    issueType?:
      | NullableEnumIssueTypeFieldUpdateOperationsInput
      | $Enums.IssueType
      | null;
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    solutions?: SolutionUncheckedUpdateManyWithoutInputsNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutInputNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutInputNestedInput;
    groups?: InputGroupUncheckedUpdateManyWithoutInputsNestedInput;
  };

  export type InputUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType;
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    issueType?:
      | NullableEnumIssueTypeFieldUpdateOperationsInput
      | $Enums.IssueType
      | null;
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type SolutionUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSolutionStatusFieldUpdateOperationsInput
      | $Enums.SolutionStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    targetCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    inputs?: InputUpdateManyWithoutSolutionsNestedInput;
    tasks?: TaskUpdateManyWithoutSolutionNestedInput;
    comments?: CommentUpdateManyWithoutSolutionNestedInput;
    votes?: VoteUpdateManyWithoutSolutionNestedInput;
    requirements?: RequirementUpdateManyWithoutSolutionNestedInput;
    frdDocuments?: FRDDocumentUpdateManyWithoutSolutionNestedInput;
  };

  export type SolutionUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSolutionStatusFieldUpdateOperationsInput
      | $Enums.SolutionStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    targetCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    inputs?: InputUncheckedUpdateManyWithoutSolutionsNestedInput;
    tasks?: TaskUncheckedUpdateManyWithoutSolutionNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutSolutionNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutSolutionNestedInput;
    requirements?: RequirementUncheckedUpdateManyWithoutSolutionNestedInput;
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutSolutionNestedInput;
  };

  export type SolutionUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSolutionStatusFieldUpdateOperationsInput
      | $Enums.SolutionStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    targetCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type CommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    replies?: CommentUpdateManyWithoutParentNestedInput;
    input?: InputUpdateOneWithoutCommentsNestedInput;
    solution?: SolutionUpdateOneWithoutCommentsNestedInput;
    requirement?: RequirementUpdateOneWithoutCommentsNestedInput;
    parent?: CommentUpdateOneWithoutRepliesNestedInput;
  };

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputId?: NullableStringFieldUpdateOperationsInput | string | null;
    solutionId?: NullableStringFieldUpdateOperationsInput | string | null;
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput;
  };

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputId?: NullableStringFieldUpdateOperationsInput | string | null;
    solutionId?: NullableStringFieldUpdateOperationsInput | string | null;
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type VoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    value?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    input?: InputUpdateOneWithoutVotesNestedInput;
    solution?: SolutionUpdateOneWithoutVotesNestedInput;
  };

  export type VoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    value?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputId?: NullableStringFieldUpdateOperationsInput | string | null;
    solutionId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type VoteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    value?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputId?: NullableStringFieldUpdateOperationsInput | string | null;
    solutionId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type RequirementUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    status?:
      | EnumRequirementStatusFieldUpdateOperationsInput
      | $Enums.RequirementStatus;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null;
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    solution?: SolutionUpdateOneRequiredWithoutRequirementsNestedInput;
    comments?: CommentUpdateManyWithoutRequirementNestedInput;
  };

  export type RequirementUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    status?:
      | EnumRequirementStatusFieldUpdateOperationsInput
      | $Enums.RequirementStatus;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null;
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    solutionId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    comments?: CommentUncheckedUpdateManyWithoutRequirementNestedInput;
  };

  export type RequirementUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    status?:
      | EnumRequirementStatusFieldUpdateOperationsInput
      | $Enums.RequirementStatus;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null;
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    solutionId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FRDDocumentUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    content?: JsonNullValueInput | InputJsonValue;
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean;
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    version?: StringFieldUpdateOperationsInput | string;
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus;
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null;
    lastExportedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    solution?: SolutionUpdateOneRequiredWithoutFrdDocumentsNestedInput;
    approver?: UserUpdateOneWithoutApprovedFRDsNestedInput;
  };

  export type FRDDocumentUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    content?: JsonNullValueInput | InputJsonValue;
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean;
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    version?: StringFieldUpdateOperationsInput | string;
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus;
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null;
    lastExportedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    solutionId?: StringFieldUpdateOperationsInput | string;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FRDDocumentUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    content?: JsonNullValueInput | InputJsonValue;
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean;
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    version?: StringFieldUpdateOperationsInput | string;
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus;
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null;
    lastExportedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    solutionId?: StringFieldUpdateOperationsInput | string;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FRDDocumentUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    content?: JsonNullValueInput | InputJsonValue;
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean;
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    version?: StringFieldUpdateOperationsInput | string;
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus;
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null;
    lastExportedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    solution?: SolutionUpdateOneRequiredWithoutFrdDocumentsNestedInput;
    creator?: UserUpdateOneRequiredWithoutFrdDocumentsNestedInput;
  };

  export type FRDDocumentUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    content?: JsonNullValueInput | InputJsonValue;
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean;
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    version?: StringFieldUpdateOperationsInput | string;
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus;
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null;
    lastExportedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    solutionId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FRDDocumentUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    content?: JsonNullValueInput | InputJsonValue;
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean;
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    version?: StringFieldUpdateOperationsInput | string;
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus;
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null;
    lastExportedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    solutionId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?:
      | EnumNotificationTypeFieldUpdateOperationsInput
      | $Enums.NotificationType;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    data?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?:
      | EnumNotificationTypeFieldUpdateOperationsInput
      | $Enums.NotificationType;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    data?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?:
      | EnumNotificationTypeFieldUpdateOperationsInput
      | $Enums.NotificationType;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    data?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type InputGroupUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumGroupStatusFieldUpdateOperationsInput | $Enums.GroupStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean;
    aiSimilarity?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    inputs?: InputUpdateManyWithoutGroupsNestedInput;
  };

  export type InputGroupUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumGroupStatusFieldUpdateOperationsInput | $Enums.GroupStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean;
    aiSimilarity?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    inputs?: InputUncheckedUpdateManyWithoutGroupsNestedInput;
  };

  export type InputGroupUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumGroupStatusFieldUpdateOperationsInput | $Enums.GroupStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean;
    aiSimilarity?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiTheme?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type TaskUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    solution?: SolutionUpdateOneRequiredWithoutTasksNestedInput;
  };

  export type TaskUncheckedUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    solutionId?: StringFieldUpdateOperationsInput | string;
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type TaskUncheckedUpdateManyWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    solutionId?: StringFieldUpdateOperationsInput | string;
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type CommentCreateManyInputInput = {
    id?: string;
    content: string;
    authorId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    solutionId?: string | null;
    requirementId?: string | null;
    parentId?: string | null;
  };

  export type VoteCreateManyInputInput = {
    id?: string;
    userId: string;
    value: number;
    createdAt?: Date | string;
    solutionId?: string | null;
  };

  export type SolutionUpdateWithoutInputsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSolutionStatusFieldUpdateOperationsInput
      | $Enums.SolutionStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    targetCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    owner?: UserUpdateOneRequiredWithoutSolutionsNestedInput;
    tasks?: TaskUpdateManyWithoutSolutionNestedInput;
    comments?: CommentUpdateManyWithoutSolutionNestedInput;
    votes?: VoteUpdateManyWithoutSolutionNestedInput;
    requirements?: RequirementUpdateManyWithoutSolutionNestedInput;
    frdDocuments?: FRDDocumentUpdateManyWithoutSolutionNestedInput;
  };

  export type SolutionUncheckedUpdateWithoutInputsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSolutionStatusFieldUpdateOperationsInput
      | $Enums.SolutionStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    targetCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
    tasks?: TaskUncheckedUpdateManyWithoutSolutionNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutSolutionNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutSolutionNestedInput;
    requirements?: RequirementUncheckedUpdateManyWithoutSolutionNestedInput;
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutSolutionNestedInput;
  };

  export type SolutionUncheckedUpdateManyWithoutInputsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSolutionStatusFieldUpdateOperationsInput
      | $Enums.SolutionStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    targetCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualCompletion?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    successCriteria?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type CommentUpdateWithoutInputInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    replies?: CommentUpdateManyWithoutParentNestedInput;
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput;
    solution?: SolutionUpdateOneWithoutCommentsNestedInput;
    requirement?: RequirementUpdateOneWithoutCommentsNestedInput;
    parent?: CommentUpdateOneWithoutRepliesNestedInput;
  };

  export type CommentUncheckedUpdateWithoutInputInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    authorId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    solutionId?: NullableStringFieldUpdateOperationsInput | string | null;
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput;
  };

  export type CommentUncheckedUpdateManyWithoutInputInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    authorId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    solutionId?: NullableStringFieldUpdateOperationsInput | string | null;
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type VoteUpdateWithoutInputInput = {
    id?: StringFieldUpdateOperationsInput | string;
    value?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutVotesNestedInput;
    solution?: SolutionUpdateOneWithoutVotesNestedInput;
  };

  export type VoteUncheckedUpdateWithoutInputInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    value?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    solutionId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type VoteUncheckedUpdateManyWithoutInputInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    value?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    solutionId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type InputGroupUpdateWithoutInputsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumGroupStatusFieldUpdateOperationsInput | $Enums.GroupStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean;
    aiSimilarity?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiTheme?: NullableStringFieldUpdateOperationsInput | string | null;
    owner?: UserUpdateOneRequiredWithoutInputGroupsNestedInput;
  };

  export type InputGroupUncheckedUpdateWithoutInputsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    ownerId?: StringFieldUpdateOperationsInput | string;
    status?: EnumGroupStatusFieldUpdateOperationsInput | $Enums.GroupStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean;
    aiSimilarity?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiTheme?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type InputGroupUncheckedUpdateManyWithoutInputsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    ownerId?: StringFieldUpdateOperationsInput | string;
    status?: EnumGroupStatusFieldUpdateOperationsInput | $Enums.GroupStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean;
    aiSimilarity?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiTheme?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CommentCreateManyParentInput = {
    id?: string;
    content: string;
    authorId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputId?: string | null;
    solutionId?: string | null;
    requirementId?: string | null;
  };

  export type CommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    replies?: CommentUpdateManyWithoutParentNestedInput;
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput;
    input?: InputUpdateOneWithoutCommentsNestedInput;
    solution?: SolutionUpdateOneWithoutCommentsNestedInput;
    requirement?: RequirementUpdateOneWithoutCommentsNestedInput;
  };

  export type CommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    authorId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputId?: NullableStringFieldUpdateOperationsInput | string | null;
    solutionId?: NullableStringFieldUpdateOperationsInput | string | null;
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null;
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput;
  };

  export type CommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    authorId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputId?: NullableStringFieldUpdateOperationsInput | string | null;
    solutionId?: NullableStringFieldUpdateOperationsInput | string | null;
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type InputUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType;
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    issueType?:
      | NullableEnumIssueTypeFieldUpdateOperationsInput
      | $Enums.IssueType
      | null;
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    creator?: UserUpdateOneRequiredWithoutInputsNestedInput;
    solutions?: SolutionUpdateManyWithoutInputsNestedInput;
    comments?: CommentUpdateManyWithoutInputNestedInput;
    votes?: VoteUpdateManyWithoutInputNestedInput;
  };

  export type InputUncheckedUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType;
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    issueType?:
      | NullableEnumIssueTypeFieldUpdateOperationsInput
      | $Enums.IssueType
      | null;
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    solutions?: SolutionUncheckedUpdateManyWithoutInputsNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutInputNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutInputNestedInput;
  };

  export type InputUncheckedUpdateManyWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType;
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    issueType?:
      | NullableEnumIssueTypeFieldUpdateOperationsInput
      | $Enums.IssueType
      | null;
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type TaskCreateManySolutionInput = {
    id?: string;
    title: string;
    description?: string | null;
    assigneeId?: string | null;
    status?: $Enums.TaskStatus;
    priority?: $Enums.Priority;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    estimatedHours?: number | null;
    actualHours?: number | null;
    dueDate?: Date | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type CommentCreateManySolutionInput = {
    id?: string;
    content: string;
    authorId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputId?: string | null;
    requirementId?: string | null;
    parentId?: string | null;
  };

  export type VoteCreateManySolutionInput = {
    id?: string;
    userId: string;
    value: number;
    createdAt?: Date | string;
    inputId?: string | null;
  };

  export type RequirementCreateManySolutionInput = {
    id?: string;
    title: string;
    description: string;
    acceptanceCriteria: JsonNullValueInput | InputJsonValue;
    priority?: $Enums.Priority;
    status?: $Enums.RequirementStatus;
    estimatedEffort?: string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: string | null;
    riskAssessment?: string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: string | null;
    approvedAt?: Date | string | null;
    rejectionReason?: string | null;
    createdBy: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FRDDocumentCreateManySolutionInput = {
    id?: string;
    title: string;
    content: JsonNullValueInput | InputJsonValue;
    aiGenerated?: boolean;
    aiConfidence?: number | null;
    aiPromptUsed?: string | null;
    version?: string;
    status?: $Enums.FRDStatus;
    executiveApproved?: boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: string | null;
    generationTime?: number | null;
    wordCount?: number | null;
    lastExportedAt?: Date | string | null;
    createdBy: string;
    approvedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type InputUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType;
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    issueType?:
      | NullableEnumIssueTypeFieldUpdateOperationsInput
      | $Enums.IssueType
      | null;
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    creator?: UserUpdateOneRequiredWithoutInputsNestedInput;
    comments?: CommentUpdateManyWithoutInputNestedInput;
    votes?: VoteUpdateManyWithoutInputNestedInput;
    groups?: InputGroupUpdateManyWithoutInputsNestedInput;
  };

  export type InputUncheckedUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType;
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    issueType?:
      | NullableEnumIssueTypeFieldUpdateOperationsInput
      | $Enums.IssueType
      | null;
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
    comments?: CommentUncheckedUpdateManyWithoutInputNestedInput;
    votes?: VoteUncheckedUpdateManyWithoutInputNestedInput;
    groups?: InputGroupUncheckedUpdateManyWithoutInputsNestedInput;
  };

  export type InputUncheckedUpdateManyWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType;
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    department?: NullableStringFieldUpdateOperationsInput | string | null;
    issueType?:
      | NullableEnumIssueTypeFieldUpdateOperationsInput
      | $Enums.IssueType
      | null;
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean;
    aiTags?: NullableJsonNullValueInput | InputJsonValue;
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type TaskUpdateWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    assignee?: UserUpdateOneWithoutTasksNestedInput;
  };

  export type TaskUncheckedUpdateWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type TaskUncheckedUpdateManyWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    actualHours?: NullableFloatFieldUpdateOperationsInput | number | null;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
  };

  export type CommentUpdateWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    replies?: CommentUpdateManyWithoutParentNestedInput;
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput;
    input?: InputUpdateOneWithoutCommentsNestedInput;
    requirement?: RequirementUpdateOneWithoutCommentsNestedInput;
    parent?: CommentUpdateOneWithoutRepliesNestedInput;
  };

  export type CommentUncheckedUpdateWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    authorId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputId?: NullableStringFieldUpdateOperationsInput | string | null;
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput;
  };

  export type CommentUncheckedUpdateManyWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    authorId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputId?: NullableStringFieldUpdateOperationsInput | string | null;
    requirementId?: NullableStringFieldUpdateOperationsInput | string | null;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type VoteUpdateWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    value?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutVotesNestedInput;
    input?: InputUpdateOneWithoutVotesNestedInput;
  };

  export type VoteUncheckedUpdateWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    value?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type VoteUncheckedUpdateManyWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    value?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type RequirementUpdateWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    status?:
      | EnumRequirementStatusFieldUpdateOperationsInput
      | $Enums.RequirementStatus;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null;
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    creator?: UserUpdateOneRequiredWithoutRequirementsNestedInput;
    comments?: CommentUpdateManyWithoutRequirementNestedInput;
  };

  export type RequirementUncheckedUpdateWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    status?:
      | EnumRequirementStatusFieldUpdateOperationsInput
      | $Enums.RequirementStatus;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null;
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    comments?: CommentUncheckedUpdateManyWithoutRequirementNestedInput;
  };

  export type RequirementUncheckedUpdateManyWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue;
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority;
    status?:
      | EnumRequirementStatusFieldUpdateOperationsInput
      | $Enums.RequirementStatus;
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null;
    dependencies?: NullableJsonNullValueInput | InputJsonValue;
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null;
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null;
    stakeholders?: NullableJsonNullValueInput | InputJsonValue;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FRDDocumentUpdateWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    content?: JsonNullValueInput | InputJsonValue;
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean;
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    version?: StringFieldUpdateOperationsInput | string;
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus;
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null;
    lastExportedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    creator?: UserUpdateOneRequiredWithoutFrdDocumentsNestedInput;
    approver?: UserUpdateOneWithoutApprovedFRDsNestedInput;
  };

  export type FRDDocumentUncheckedUpdateWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    content?: JsonNullValueInput | InputJsonValue;
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean;
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    version?: StringFieldUpdateOperationsInput | string;
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus;
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null;
    lastExportedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdBy?: StringFieldUpdateOperationsInput | string;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FRDDocumentUncheckedUpdateManyWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    content?: JsonNullValueInput | InputJsonValue;
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean;
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null;
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    version?: StringFieldUpdateOperationsInput | string;
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus;
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean;
    exportFormats?: NullableJsonNullValueInput | InputJsonValue;
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null;
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null;
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null;
    lastExportedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdBy?: StringFieldUpdateOperationsInput | string;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommentCreateManyRequirementInput = {
    id?: string;
    content: string;
    authorId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    inputId?: string | null;
    solutionId?: string | null;
    parentId?: string | null;
  };

  export type CommentUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    replies?: CommentUpdateManyWithoutParentNestedInput;
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput;
    input?: InputUpdateOneWithoutCommentsNestedInput;
    solution?: SolutionUpdateOneWithoutCommentsNestedInput;
    parent?: CommentUpdateOneWithoutRepliesNestedInput;
  };

  export type CommentUncheckedUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    authorId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputId?: NullableStringFieldUpdateOperationsInput | string | null;
    solutionId?: NullableStringFieldUpdateOperationsInput | string | null;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput;
  };

  export type CommentUncheckedUpdateManyWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    authorId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    inputId?: NullableStringFieldUpdateOperationsInput | string | null;
    solutionId?: NullableStringFieldUpdateOperationsInput | string | null;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
