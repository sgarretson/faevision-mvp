
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model InputToInputGroup
 * 
 */
export type InputToInputGroup = $Result.DefaultSelection<Prisma.$InputToInputGroupPayload>
/**
 * Model ai_analysis_audit
 * 
 */
export type ai_analysis_audit = $Result.DefaultSelection<Prisma.$ai_analysis_auditPayload>
/**
 * Model ai_insight_overrides
 * 
 */
export type ai_insight_overrides = $Result.DefaultSelection<Prisma.$ai_insight_overridesPayload>
/**
 * Model audit_logs
 * 
 */
export type audit_logs = $Result.DefaultSelection<Prisma.$audit_logsPayload>
/**
 * Model categories
 * 
 */
export type categories = $Result.DefaultSelection<Prisma.$categoriesPayload>
/**
 * Model comments
 * 
 */
export type comments = $Result.DefaultSelection<Prisma.$commentsPayload>
/**
 * Model departments
 * 
 */
export type departments = $Result.DefaultSelection<Prisma.$departmentsPayload>
/**
 * Model frd_documents
 * 
 */
export type frd_documents = $Result.DefaultSelection<Prisma.$frd_documentsPayload>
/**
 * Model hotspot_signals
 * 
 */
export type hotspot_signals = $Result.DefaultSelection<Prisma.$hotspot_signalsPayload>
/**
 * Model hotspots
 * 
 */
export type hotspots = $Result.DefaultSelection<Prisma.$hotspotsPayload>
/**
 * Model ideas
 * 
 */
export type ideas = $Result.DefaultSelection<Prisma.$ideasPayload>
/**
 * Model initiatives
 * 
 */
export type initiatives = $Result.DefaultSelection<Prisma.$initiativesPayload>
/**
 * Model input_groups
 * 
 */
export type input_groups = $Result.DefaultSelection<Prisma.$input_groupsPayload>
/**
 * Model inputs
 * 
 */
export type inputs = $Result.DefaultSelection<Prisma.$inputsPayload>
/**
 * Model notifications
 * 
 */
export type notifications = $Result.DefaultSelection<Prisma.$notificationsPayload>
/**
 * Model requirements
 * 
 */
export type requirements = $Result.DefaultSelection<Prisma.$requirementsPayload>
/**
 * Model signals
 * 
 */
export type signals = $Result.DefaultSelection<Prisma.$signalsPayload>
/**
 * Model solutions
 * 
 */
export type solutions = $Result.DefaultSelection<Prisma.$solutionsPayload>
/**
 * Model teams
 * 
 */
export type teams = $Result.DefaultSelection<Prisma.$teamsPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model votes
 * 
 */
export type votes = $Result.DefaultSelection<Prisma.$votesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const EntityType: {
  INPUT: 'INPUT',
  SIGNAL: 'SIGNAL',
  HOTSPOT: 'HOTSPOT',
  IDEA: 'IDEA',
  SOLUTION: 'SOLUTION',
  REQUIREMENT: 'REQUIREMENT',
  FRD_DOCUMENT: 'FRD_DOCUMENT'
};

export type EntityType = (typeof EntityType)[keyof typeof EntityType]


export const FRDStatus: {
  DRAFT: 'DRAFT',
  REVIEW: 'REVIEW',
  APPROVED: 'APPROVED',
  DELIVERED: 'DELIVERED',
  ARCHIVED: 'ARCHIVED'
};

export type FRDStatus = (typeof FRDStatus)[keyof typeof FRDStatus]


export const HotspotStatus: {
  OPEN: 'OPEN',
  APPROVED: 'APPROVED',
  HANDED_OFF: 'HANDED_OFF',
  MONITORING: 'MONITORING',
  RESOLVED: 'RESOLVED',
  CLOSED_NO_ACTION: 'CLOSED_NO_ACTION'
};

export type HotspotStatus = (typeof HotspotStatus)[keyof typeof HotspotStatus]


export const InputStatus: {
  ACTIVE: 'ACTIVE',
  RESOLVED: 'RESOLVED',
  ARCHIVED: 'ARCHIVED',
  DUPLICATE: 'DUPLICATE'
};

export type InputStatus = (typeof InputStatus)[keyof typeof InputStatus]


export const InputType: {
  PROBLEM: 'PROBLEM',
  OPPORTUNITY: 'OPPORTUNITY',
  GENERAL: 'GENERAL'
};

export type InputType = (typeof InputType)[keyof typeof InputType]


export const NotificationType: {
  MENTION: 'MENTION',
  VOTE: 'VOTE',
  COMMENT: 'COMMENT',
  STATUS_CHANGE: 'STATUS_CHANGE',
  APPROVAL_REQUEST: 'APPROVAL_REQUEST',
  ASSIGNMENT: 'ASSIGNMENT',
  DEADLINE_REMINDER: 'DEADLINE_REMINDER'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const RequirementStatus: {
  DRAFT: 'DRAFT',
  REVIEW: 'REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  IMPLEMENTED: 'IMPLEMENTED',
  OBSOLETE: 'OBSOLETE'
};

export type RequirementStatus = (typeof RequirementStatus)[keyof typeof RequirementStatus]


export const Severity: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type Severity = (typeof Severity)[keyof typeof Severity]


export const SolutionStatus: {
  DRAFT: 'DRAFT',
  IN_PROGRESS: 'IN_PROGRESS',
  REVIEW: 'REVIEW',
  APPROVED: 'APPROVED',
  IMPLEMENTED: 'IMPLEMENTED',
  CANCELLED: 'CANCELLED',
  ON_HOLD: 'ON_HOLD'
};

export type SolutionStatus = (typeof SolutionStatus)[keyof typeof SolutionStatus]


export const UserRole: {
  ADMIN: 'ADMIN',
  EXECUTIVE: 'EXECUTIVE',
  CONTRIBUTOR: 'CONTRIBUTOR'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const VoteValue: {
  UP: 'UP',
  DOWN: 'DOWN'
};

export type VoteValue = (typeof VoteValue)[keyof typeof VoteValue]


export const initiative_status: {
  PLANNING: 'PLANNING',
  ACTIVE: 'ACTIVE',
  ON_HOLD: 'ON_HOLD',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type initiative_status = (typeof initiative_status)[keyof typeof initiative_status]


export const priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT',
  CRITICAL: 'CRITICAL'
};

export type priority = (typeof priority)[keyof typeof priority]


export const risk_level: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type risk_level = (typeof risk_level)[keyof typeof risk_level]

}

export type EntityType = $Enums.EntityType

export const EntityType: typeof $Enums.EntityType

export type FRDStatus = $Enums.FRDStatus

export const FRDStatus: typeof $Enums.FRDStatus

export type HotspotStatus = $Enums.HotspotStatus

export const HotspotStatus: typeof $Enums.HotspotStatus

export type InputStatus = $Enums.InputStatus

export const InputStatus: typeof $Enums.InputStatus

export type InputType = $Enums.InputType

export const InputType: typeof $Enums.InputType

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type RequirementStatus = $Enums.RequirementStatus

export const RequirementStatus: typeof $Enums.RequirementStatus

export type Severity = $Enums.Severity

export const Severity: typeof $Enums.Severity

export type SolutionStatus = $Enums.SolutionStatus

export const SolutionStatus: typeof $Enums.SolutionStatus

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type VoteValue = $Enums.VoteValue

export const VoteValue: typeof $Enums.VoteValue

export type initiative_status = $Enums.initiative_status

export const initiative_status: typeof $Enums.initiative_status

export type priority = $Enums.priority

export const priority: typeof $Enums.priority

export type risk_level = $Enums.risk_level

export const risk_level: typeof $Enums.risk_level

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more InputToInputGroups
 * const inputToInputGroups = await prisma.inputToInputGroup.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more InputToInputGroups
   * const inputToInputGroups = await prisma.inputToInputGroup.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.inputToInputGroup`: Exposes CRUD operations for the **InputToInputGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InputToInputGroups
    * const inputToInputGroups = await prisma.inputToInputGroup.findMany()
    * ```
    */
  get inputToInputGroup(): Prisma.InputToInputGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ai_analysis_audit`: Exposes CRUD operations for the **ai_analysis_audit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ai_analysis_audits
    * const ai_analysis_audits = await prisma.ai_analysis_audit.findMany()
    * ```
    */
  get ai_analysis_audit(): Prisma.ai_analysis_auditDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ai_insight_overrides`: Exposes CRUD operations for the **ai_insight_overrides** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ai_insight_overrides
    * const ai_insight_overrides = await prisma.ai_insight_overrides.findMany()
    * ```
    */
  get ai_insight_overrides(): Prisma.ai_insight_overridesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.audit_logs`: Exposes CRUD operations for the **audit_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Audit_logs
    * const audit_logs = await prisma.audit_logs.findMany()
    * ```
    */
  get audit_logs(): Prisma.audit_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categories`: Exposes CRUD operations for the **categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.categories.findMany()
    * ```
    */
  get categories(): Prisma.categoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comments`: Exposes CRUD operations for the **comments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comments.findMany()
    * ```
    */
  get comments(): Prisma.commentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.departments`: Exposes CRUD operations for the **departments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.departments.findMany()
    * ```
    */
  get departments(): Prisma.departmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.frd_documents`: Exposes CRUD operations for the **frd_documents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Frd_documents
    * const frd_documents = await prisma.frd_documents.findMany()
    * ```
    */
  get frd_documents(): Prisma.frd_documentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotspot_signals`: Exposes CRUD operations for the **hotspot_signals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hotspot_signals
    * const hotspot_signals = await prisma.hotspot_signals.findMany()
    * ```
    */
  get hotspot_signals(): Prisma.hotspot_signalsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotspots`: Exposes CRUD operations for the **hotspots** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hotspots
    * const hotspots = await prisma.hotspots.findMany()
    * ```
    */
  get hotspots(): Prisma.hotspotsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ideas`: Exposes CRUD operations for the **ideas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ideas
    * const ideas = await prisma.ideas.findMany()
    * ```
    */
  get ideas(): Prisma.ideasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.initiatives`: Exposes CRUD operations for the **initiatives** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Initiatives
    * const initiatives = await prisma.initiatives.findMany()
    * ```
    */
  get initiatives(): Prisma.initiativesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.input_groups`: Exposes CRUD operations for the **input_groups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Input_groups
    * const input_groups = await prisma.input_groups.findMany()
    * ```
    */
  get input_groups(): Prisma.input_groupsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inputs`: Exposes CRUD operations for the **inputs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inputs
    * const inputs = await prisma.inputs.findMany()
    * ```
    */
  get inputs(): Prisma.inputsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.notificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requirements`: Exposes CRUD operations for the **requirements** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Requirements
    * const requirements = await prisma.requirements.findMany()
    * ```
    */
  get requirements(): Prisma.requirementsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.signals`: Exposes CRUD operations for the **signals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Signals
    * const signals = await prisma.signals.findMany()
    * ```
    */
  get signals(): Prisma.signalsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.solutions`: Exposes CRUD operations for the **solutions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Solutions
    * const solutions = await prisma.solutions.findMany()
    * ```
    */
  get solutions(): Prisma.solutionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teams`: Exposes CRUD operations for the **teams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.teams.findMany()
    * ```
    */
  get teams(): Prisma.teamsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.votes`: Exposes CRUD operations for the **votes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Votes
    * const votes = await prisma.votes.findMany()
    * ```
    */
  get votes(): Prisma.votesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.1
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    InputToInputGroup: 'InputToInputGroup',
    ai_analysis_audit: 'ai_analysis_audit',
    ai_insight_overrides: 'ai_insight_overrides',
    audit_logs: 'audit_logs',
    categories: 'categories',
    comments: 'comments',
    departments: 'departments',
    frd_documents: 'frd_documents',
    hotspot_signals: 'hotspot_signals',
    hotspots: 'hotspots',
    ideas: 'ideas',
    initiatives: 'initiatives',
    input_groups: 'input_groups',
    inputs: 'inputs',
    notifications: 'notifications',
    requirements: 'requirements',
    signals: 'signals',
    solutions: 'solutions',
    teams: 'teams',
    users: 'users',
    votes: 'votes'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "inputToInputGroup" | "ai_analysis_audit" | "ai_insight_overrides" | "audit_logs" | "categories" | "comments" | "departments" | "frd_documents" | "hotspot_signals" | "hotspots" | "ideas" | "initiatives" | "input_groups" | "inputs" | "notifications" | "requirements" | "signals" | "solutions" | "teams" | "users" | "votes"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      InputToInputGroup: {
        payload: Prisma.$InputToInputGroupPayload<ExtArgs>
        fields: Prisma.InputToInputGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InputToInputGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputToInputGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InputToInputGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputToInputGroupPayload>
          }
          findFirst: {
            args: Prisma.InputToInputGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputToInputGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InputToInputGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputToInputGroupPayload>
          }
          findMany: {
            args: Prisma.InputToInputGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputToInputGroupPayload>[]
          }
          create: {
            args: Prisma.InputToInputGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputToInputGroupPayload>
          }
          createMany: {
            args: Prisma.InputToInputGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InputToInputGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputToInputGroupPayload>[]
          }
          delete: {
            args: Prisma.InputToInputGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputToInputGroupPayload>
          }
          update: {
            args: Prisma.InputToInputGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputToInputGroupPayload>
          }
          deleteMany: {
            args: Prisma.InputToInputGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InputToInputGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InputToInputGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputToInputGroupPayload>[]
          }
          upsert: {
            args: Prisma.InputToInputGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputToInputGroupPayload>
          }
          aggregate: {
            args: Prisma.InputToInputGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInputToInputGroup>
          }
          groupBy: {
            args: Prisma.InputToInputGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<InputToInputGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.InputToInputGroupCountArgs<ExtArgs>
            result: $Utils.Optional<InputToInputGroupCountAggregateOutputType> | number
          }
        }
      }
      ai_analysis_audit: {
        payload: Prisma.$ai_analysis_auditPayload<ExtArgs>
        fields: Prisma.ai_analysis_auditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ai_analysis_auditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_analysis_auditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ai_analysis_auditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_analysis_auditPayload>
          }
          findFirst: {
            args: Prisma.ai_analysis_auditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_analysis_auditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ai_analysis_auditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_analysis_auditPayload>
          }
          findMany: {
            args: Prisma.ai_analysis_auditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_analysis_auditPayload>[]
          }
          create: {
            args: Prisma.ai_analysis_auditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_analysis_auditPayload>
          }
          createMany: {
            args: Prisma.ai_analysis_auditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ai_analysis_auditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_analysis_auditPayload>[]
          }
          delete: {
            args: Prisma.ai_analysis_auditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_analysis_auditPayload>
          }
          update: {
            args: Prisma.ai_analysis_auditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_analysis_auditPayload>
          }
          deleteMany: {
            args: Prisma.ai_analysis_auditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ai_analysis_auditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ai_analysis_auditUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_analysis_auditPayload>[]
          }
          upsert: {
            args: Prisma.ai_analysis_auditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_analysis_auditPayload>
          }
          aggregate: {
            args: Prisma.Ai_analysis_auditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAi_analysis_audit>
          }
          groupBy: {
            args: Prisma.ai_analysis_auditGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ai_analysis_auditGroupByOutputType>[]
          }
          count: {
            args: Prisma.ai_analysis_auditCountArgs<ExtArgs>
            result: $Utils.Optional<Ai_analysis_auditCountAggregateOutputType> | number
          }
        }
      }
      ai_insight_overrides: {
        payload: Prisma.$ai_insight_overridesPayload<ExtArgs>
        fields: Prisma.ai_insight_overridesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ai_insight_overridesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_insight_overridesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ai_insight_overridesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_insight_overridesPayload>
          }
          findFirst: {
            args: Prisma.ai_insight_overridesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_insight_overridesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ai_insight_overridesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_insight_overridesPayload>
          }
          findMany: {
            args: Prisma.ai_insight_overridesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_insight_overridesPayload>[]
          }
          create: {
            args: Prisma.ai_insight_overridesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_insight_overridesPayload>
          }
          createMany: {
            args: Prisma.ai_insight_overridesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ai_insight_overridesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_insight_overridesPayload>[]
          }
          delete: {
            args: Prisma.ai_insight_overridesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_insight_overridesPayload>
          }
          update: {
            args: Prisma.ai_insight_overridesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_insight_overridesPayload>
          }
          deleteMany: {
            args: Prisma.ai_insight_overridesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ai_insight_overridesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ai_insight_overridesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_insight_overridesPayload>[]
          }
          upsert: {
            args: Prisma.ai_insight_overridesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_insight_overridesPayload>
          }
          aggregate: {
            args: Prisma.Ai_insight_overridesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAi_insight_overrides>
          }
          groupBy: {
            args: Prisma.ai_insight_overridesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ai_insight_overridesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ai_insight_overridesCountArgs<ExtArgs>
            result: $Utils.Optional<Ai_insight_overridesCountAggregateOutputType> | number
          }
        }
      }
      audit_logs: {
        payload: Prisma.$audit_logsPayload<ExtArgs>
        fields: Prisma.audit_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.audit_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.audit_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          findFirst: {
            args: Prisma.audit_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.audit_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          findMany: {
            args: Prisma.audit_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>[]
          }
          create: {
            args: Prisma.audit_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          createMany: {
            args: Prisma.audit_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.audit_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>[]
          }
          delete: {
            args: Prisma.audit_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          update: {
            args: Prisma.audit_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          deleteMany: {
            args: Prisma.audit_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.audit_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.audit_logsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>[]
          }
          upsert: {
            args: Prisma.audit_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          aggregate: {
            args: Prisma.Audit_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudit_logs>
          }
          groupBy: {
            args: Prisma.audit_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Audit_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.audit_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Audit_logsCountAggregateOutputType> | number
          }
        }
      }
      categories: {
        payload: Prisma.$categoriesPayload<ExtArgs>
        fields: Prisma.categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          findFirst: {
            args: Prisma.categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          findMany: {
            args: Prisma.categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]
          }
          create: {
            args: Prisma.categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          createMany: {
            args: Prisma.categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.categoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]
          }
          delete: {
            args: Prisma.categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          update: {
            args: Prisma.categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          deleteMany: {
            args: Prisma.categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.categoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]
          }
          upsert: {
            args: Prisma.categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          aggregate: {
            args: Prisma.CategoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategories>
          }
          groupBy: {
            args: Prisma.categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriesCountAggregateOutputType> | number
          }
        }
      }
      comments: {
        payload: Prisma.$commentsPayload<ExtArgs>
        fields: Prisma.commentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.commentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.commentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          findFirst: {
            args: Prisma.commentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.commentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          findMany: {
            args: Prisma.commentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[]
          }
          create: {
            args: Prisma.commentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          createMany: {
            args: Prisma.commentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.commentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[]
          }
          delete: {
            args: Prisma.commentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          update: {
            args: Prisma.commentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          deleteMany: {
            args: Prisma.commentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.commentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.commentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[]
          }
          upsert: {
            args: Prisma.commentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          aggregate: {
            args: Prisma.CommentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComments>
          }
          groupBy: {
            args: Prisma.commentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.commentsCountArgs<ExtArgs>
            result: $Utils.Optional<CommentsCountAggregateOutputType> | number
          }
        }
      }
      departments: {
        payload: Prisma.$departmentsPayload<ExtArgs>
        fields: Prisma.departmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.departmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.departmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          findFirst: {
            args: Prisma.departmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.departmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          findMany: {
            args: Prisma.departmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>[]
          }
          create: {
            args: Prisma.departmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          createMany: {
            args: Prisma.departmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.departmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>[]
          }
          delete: {
            args: Prisma.departmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          update: {
            args: Prisma.departmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          deleteMany: {
            args: Prisma.departmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.departmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.departmentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>[]
          }
          upsert: {
            args: Prisma.departmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          aggregate: {
            args: Prisma.DepartmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartments>
          }
          groupBy: {
            args: Prisma.departmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.departmentsCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentsCountAggregateOutputType> | number
          }
        }
      }
      frd_documents: {
        payload: Prisma.$frd_documentsPayload<ExtArgs>
        fields: Prisma.frd_documentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.frd_documentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$frd_documentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.frd_documentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$frd_documentsPayload>
          }
          findFirst: {
            args: Prisma.frd_documentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$frd_documentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.frd_documentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$frd_documentsPayload>
          }
          findMany: {
            args: Prisma.frd_documentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$frd_documentsPayload>[]
          }
          create: {
            args: Prisma.frd_documentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$frd_documentsPayload>
          }
          createMany: {
            args: Prisma.frd_documentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.frd_documentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$frd_documentsPayload>[]
          }
          delete: {
            args: Prisma.frd_documentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$frd_documentsPayload>
          }
          update: {
            args: Prisma.frd_documentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$frd_documentsPayload>
          }
          deleteMany: {
            args: Prisma.frd_documentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.frd_documentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.frd_documentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$frd_documentsPayload>[]
          }
          upsert: {
            args: Prisma.frd_documentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$frd_documentsPayload>
          }
          aggregate: {
            args: Prisma.Frd_documentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFrd_documents>
          }
          groupBy: {
            args: Prisma.frd_documentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Frd_documentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.frd_documentsCountArgs<ExtArgs>
            result: $Utils.Optional<Frd_documentsCountAggregateOutputType> | number
          }
        }
      }
      hotspot_signals: {
        payload: Prisma.$hotspot_signalsPayload<ExtArgs>
        fields: Prisma.hotspot_signalsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.hotspot_signalsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotspot_signalsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.hotspot_signalsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotspot_signalsPayload>
          }
          findFirst: {
            args: Prisma.hotspot_signalsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotspot_signalsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.hotspot_signalsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotspot_signalsPayload>
          }
          findMany: {
            args: Prisma.hotspot_signalsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotspot_signalsPayload>[]
          }
          create: {
            args: Prisma.hotspot_signalsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotspot_signalsPayload>
          }
          createMany: {
            args: Prisma.hotspot_signalsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.hotspot_signalsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotspot_signalsPayload>[]
          }
          delete: {
            args: Prisma.hotspot_signalsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotspot_signalsPayload>
          }
          update: {
            args: Prisma.hotspot_signalsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotspot_signalsPayload>
          }
          deleteMany: {
            args: Prisma.hotspot_signalsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.hotspot_signalsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.hotspot_signalsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotspot_signalsPayload>[]
          }
          upsert: {
            args: Prisma.hotspot_signalsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotspot_signalsPayload>
          }
          aggregate: {
            args: Prisma.Hotspot_signalsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotspot_signals>
          }
          groupBy: {
            args: Prisma.hotspot_signalsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Hotspot_signalsGroupByOutputType>[]
          }
          count: {
            args: Prisma.hotspot_signalsCountArgs<ExtArgs>
            result: $Utils.Optional<Hotspot_signalsCountAggregateOutputType> | number
          }
        }
      }
      hotspots: {
        payload: Prisma.$hotspotsPayload<ExtArgs>
        fields: Prisma.hotspotsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.hotspotsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotspotsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.hotspotsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotspotsPayload>
          }
          findFirst: {
            args: Prisma.hotspotsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotspotsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.hotspotsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotspotsPayload>
          }
          findMany: {
            args: Prisma.hotspotsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotspotsPayload>[]
          }
          create: {
            args: Prisma.hotspotsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotspotsPayload>
          }
          createMany: {
            args: Prisma.hotspotsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.hotspotsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotspotsPayload>[]
          }
          delete: {
            args: Prisma.hotspotsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotspotsPayload>
          }
          update: {
            args: Prisma.hotspotsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotspotsPayload>
          }
          deleteMany: {
            args: Prisma.hotspotsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.hotspotsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.hotspotsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotspotsPayload>[]
          }
          upsert: {
            args: Prisma.hotspotsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotspotsPayload>
          }
          aggregate: {
            args: Prisma.HotspotsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotspots>
          }
          groupBy: {
            args: Prisma.hotspotsGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotspotsGroupByOutputType>[]
          }
          count: {
            args: Prisma.hotspotsCountArgs<ExtArgs>
            result: $Utils.Optional<HotspotsCountAggregateOutputType> | number
          }
        }
      }
      ideas: {
        payload: Prisma.$ideasPayload<ExtArgs>
        fields: Prisma.ideasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ideasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ideasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ideasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ideasPayload>
          }
          findFirst: {
            args: Prisma.ideasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ideasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ideasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ideasPayload>
          }
          findMany: {
            args: Prisma.ideasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ideasPayload>[]
          }
          create: {
            args: Prisma.ideasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ideasPayload>
          }
          createMany: {
            args: Prisma.ideasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ideasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ideasPayload>[]
          }
          delete: {
            args: Prisma.ideasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ideasPayload>
          }
          update: {
            args: Prisma.ideasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ideasPayload>
          }
          deleteMany: {
            args: Prisma.ideasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ideasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ideasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ideasPayload>[]
          }
          upsert: {
            args: Prisma.ideasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ideasPayload>
          }
          aggregate: {
            args: Prisma.IdeasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIdeas>
          }
          groupBy: {
            args: Prisma.ideasGroupByArgs<ExtArgs>
            result: $Utils.Optional<IdeasGroupByOutputType>[]
          }
          count: {
            args: Prisma.ideasCountArgs<ExtArgs>
            result: $Utils.Optional<IdeasCountAggregateOutputType> | number
          }
        }
      }
      initiatives: {
        payload: Prisma.$initiativesPayload<ExtArgs>
        fields: Prisma.initiativesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.initiativesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$initiativesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.initiativesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$initiativesPayload>
          }
          findFirst: {
            args: Prisma.initiativesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$initiativesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.initiativesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$initiativesPayload>
          }
          findMany: {
            args: Prisma.initiativesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$initiativesPayload>[]
          }
          create: {
            args: Prisma.initiativesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$initiativesPayload>
          }
          createMany: {
            args: Prisma.initiativesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.initiativesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$initiativesPayload>[]
          }
          delete: {
            args: Prisma.initiativesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$initiativesPayload>
          }
          update: {
            args: Prisma.initiativesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$initiativesPayload>
          }
          deleteMany: {
            args: Prisma.initiativesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.initiativesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.initiativesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$initiativesPayload>[]
          }
          upsert: {
            args: Prisma.initiativesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$initiativesPayload>
          }
          aggregate: {
            args: Prisma.InitiativesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInitiatives>
          }
          groupBy: {
            args: Prisma.initiativesGroupByArgs<ExtArgs>
            result: $Utils.Optional<InitiativesGroupByOutputType>[]
          }
          count: {
            args: Prisma.initiativesCountArgs<ExtArgs>
            result: $Utils.Optional<InitiativesCountAggregateOutputType> | number
          }
        }
      }
      input_groups: {
        payload: Prisma.$input_groupsPayload<ExtArgs>
        fields: Prisma.input_groupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.input_groupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$input_groupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.input_groupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$input_groupsPayload>
          }
          findFirst: {
            args: Prisma.input_groupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$input_groupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.input_groupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$input_groupsPayload>
          }
          findMany: {
            args: Prisma.input_groupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$input_groupsPayload>[]
          }
          create: {
            args: Prisma.input_groupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$input_groupsPayload>
          }
          createMany: {
            args: Prisma.input_groupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.input_groupsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$input_groupsPayload>[]
          }
          delete: {
            args: Prisma.input_groupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$input_groupsPayload>
          }
          update: {
            args: Prisma.input_groupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$input_groupsPayload>
          }
          deleteMany: {
            args: Prisma.input_groupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.input_groupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.input_groupsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$input_groupsPayload>[]
          }
          upsert: {
            args: Prisma.input_groupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$input_groupsPayload>
          }
          aggregate: {
            args: Prisma.Input_groupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInput_groups>
          }
          groupBy: {
            args: Prisma.input_groupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Input_groupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.input_groupsCountArgs<ExtArgs>
            result: $Utils.Optional<Input_groupsCountAggregateOutputType> | number
          }
        }
      }
      inputs: {
        payload: Prisma.$inputsPayload<ExtArgs>
        fields: Prisma.inputsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inputsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inputsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inputsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inputsPayload>
          }
          findFirst: {
            args: Prisma.inputsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inputsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inputsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inputsPayload>
          }
          findMany: {
            args: Prisma.inputsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inputsPayload>[]
          }
          create: {
            args: Prisma.inputsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inputsPayload>
          }
          createMany: {
            args: Prisma.inputsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.inputsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inputsPayload>[]
          }
          delete: {
            args: Prisma.inputsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inputsPayload>
          }
          update: {
            args: Prisma.inputsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inputsPayload>
          }
          deleteMany: {
            args: Prisma.inputsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.inputsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.inputsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inputsPayload>[]
          }
          upsert: {
            args: Prisma.inputsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inputsPayload>
          }
          aggregate: {
            args: Prisma.InputsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInputs>
          }
          groupBy: {
            args: Prisma.inputsGroupByArgs<ExtArgs>
            result: $Utils.Optional<InputsGroupByOutputType>[]
          }
          count: {
            args: Prisma.inputsCountArgs<ExtArgs>
            result: $Utils.Optional<InputsCountAggregateOutputType> | number
          }
        }
      }
      notifications: {
        payload: Prisma.$notificationsPayload<ExtArgs>
        fields: Prisma.notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findFirst: {
            args: Prisma.notificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findMany: {
            args: Prisma.notificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          create: {
            args: Prisma.notificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          createMany: {
            args: Prisma.notificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          delete: {
            args: Prisma.notificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          update: {
            args: Prisma.notificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          deleteMany: {
            args: Prisma.notificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notificationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          upsert: {
            args: Prisma.notificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.notificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      requirements: {
        payload: Prisma.$requirementsPayload<ExtArgs>
        fields: Prisma.requirementsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.requirementsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requirementsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.requirementsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requirementsPayload>
          }
          findFirst: {
            args: Prisma.requirementsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requirementsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.requirementsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requirementsPayload>
          }
          findMany: {
            args: Prisma.requirementsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requirementsPayload>[]
          }
          create: {
            args: Prisma.requirementsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requirementsPayload>
          }
          createMany: {
            args: Prisma.requirementsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.requirementsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requirementsPayload>[]
          }
          delete: {
            args: Prisma.requirementsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requirementsPayload>
          }
          update: {
            args: Prisma.requirementsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requirementsPayload>
          }
          deleteMany: {
            args: Prisma.requirementsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.requirementsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.requirementsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requirementsPayload>[]
          }
          upsert: {
            args: Prisma.requirementsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requirementsPayload>
          }
          aggregate: {
            args: Prisma.RequirementsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequirements>
          }
          groupBy: {
            args: Prisma.requirementsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequirementsGroupByOutputType>[]
          }
          count: {
            args: Prisma.requirementsCountArgs<ExtArgs>
            result: $Utils.Optional<RequirementsCountAggregateOutputType> | number
          }
        }
      }
      signals: {
        payload: Prisma.$signalsPayload<ExtArgs>
        fields: Prisma.signalsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.signalsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$signalsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.signalsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$signalsPayload>
          }
          findFirst: {
            args: Prisma.signalsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$signalsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.signalsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$signalsPayload>
          }
          findMany: {
            args: Prisma.signalsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$signalsPayload>[]
          }
          create: {
            args: Prisma.signalsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$signalsPayload>
          }
          createMany: {
            args: Prisma.signalsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.signalsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$signalsPayload>[]
          }
          delete: {
            args: Prisma.signalsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$signalsPayload>
          }
          update: {
            args: Prisma.signalsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$signalsPayload>
          }
          deleteMany: {
            args: Prisma.signalsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.signalsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.signalsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$signalsPayload>[]
          }
          upsert: {
            args: Prisma.signalsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$signalsPayload>
          }
          aggregate: {
            args: Prisma.SignalsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSignals>
          }
          groupBy: {
            args: Prisma.signalsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SignalsGroupByOutputType>[]
          }
          count: {
            args: Prisma.signalsCountArgs<ExtArgs>
            result: $Utils.Optional<SignalsCountAggregateOutputType> | number
          }
        }
      }
      solutions: {
        payload: Prisma.$solutionsPayload<ExtArgs>
        fields: Prisma.solutionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.solutionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$solutionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.solutionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$solutionsPayload>
          }
          findFirst: {
            args: Prisma.solutionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$solutionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.solutionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$solutionsPayload>
          }
          findMany: {
            args: Prisma.solutionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$solutionsPayload>[]
          }
          create: {
            args: Prisma.solutionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$solutionsPayload>
          }
          createMany: {
            args: Prisma.solutionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.solutionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$solutionsPayload>[]
          }
          delete: {
            args: Prisma.solutionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$solutionsPayload>
          }
          update: {
            args: Prisma.solutionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$solutionsPayload>
          }
          deleteMany: {
            args: Prisma.solutionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.solutionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.solutionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$solutionsPayload>[]
          }
          upsert: {
            args: Prisma.solutionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$solutionsPayload>
          }
          aggregate: {
            args: Prisma.SolutionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSolutions>
          }
          groupBy: {
            args: Prisma.solutionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SolutionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.solutionsCountArgs<ExtArgs>
            result: $Utils.Optional<SolutionsCountAggregateOutputType> | number
          }
        }
      }
      teams: {
        payload: Prisma.$teamsPayload<ExtArgs>
        fields: Prisma.teamsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.teamsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.teamsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamsPayload>
          }
          findFirst: {
            args: Prisma.teamsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.teamsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamsPayload>
          }
          findMany: {
            args: Prisma.teamsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamsPayload>[]
          }
          create: {
            args: Prisma.teamsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamsPayload>
          }
          createMany: {
            args: Prisma.teamsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.teamsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamsPayload>[]
          }
          delete: {
            args: Prisma.teamsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamsPayload>
          }
          update: {
            args: Prisma.teamsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamsPayload>
          }
          deleteMany: {
            args: Prisma.teamsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.teamsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.teamsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamsPayload>[]
          }
          upsert: {
            args: Prisma.teamsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamsPayload>
          }
          aggregate: {
            args: Prisma.TeamsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeams>
          }
          groupBy: {
            args: Prisma.teamsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamsGroupByOutputType>[]
          }
          count: {
            args: Prisma.teamsCountArgs<ExtArgs>
            result: $Utils.Optional<TeamsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      votes: {
        payload: Prisma.$votesPayload<ExtArgs>
        fields: Prisma.votesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.votesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$votesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.votesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$votesPayload>
          }
          findFirst: {
            args: Prisma.votesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$votesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.votesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$votesPayload>
          }
          findMany: {
            args: Prisma.votesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$votesPayload>[]
          }
          create: {
            args: Prisma.votesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$votesPayload>
          }
          createMany: {
            args: Prisma.votesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.votesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$votesPayload>[]
          }
          delete: {
            args: Prisma.votesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$votesPayload>
          }
          update: {
            args: Prisma.votesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$votesPayload>
          }
          deleteMany: {
            args: Prisma.votesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.votesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.votesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$votesPayload>[]
          }
          upsert: {
            args: Prisma.votesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$votesPayload>
          }
          aggregate: {
            args: Prisma.VotesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVotes>
          }
          groupBy: {
            args: Prisma.votesGroupByArgs<ExtArgs>
            result: $Utils.Optional<VotesGroupByOutputType>[]
          }
          count: {
            args: Prisma.votesCountArgs<ExtArgs>
            result: $Utils.Optional<VotesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    inputToInputGroup?: InputToInputGroupOmit
    ai_analysis_audit?: ai_analysis_auditOmit
    ai_insight_overrides?: ai_insight_overridesOmit
    audit_logs?: audit_logsOmit
    categories?: categoriesOmit
    comments?: commentsOmit
    departments?: departmentsOmit
    frd_documents?: frd_documentsOmit
    hotspot_signals?: hotspot_signalsOmit
    hotspots?: hotspotsOmit
    ideas?: ideasOmit
    initiatives?: initiativesOmit
    input_groups?: input_groupsOmit
    inputs?: inputsOmit
    notifications?: notificationsOmit
    requirements?: requirementsOmit
    signals?: signalsOmit
    solutions?: solutionsOmit
    teams?: teamsOmit
    users?: usersOmit
    votes?: votesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CategoriesCountOutputType
   */

  export type CategoriesCountOutputType = {
    other_categories: number
    signals: number
  }

  export type CategoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    other_categories?: boolean | CategoriesCountOutputTypeCountOther_categoriesArgs
    signals?: boolean | CategoriesCountOutputTypeCountSignalsArgs
  }

  // Custom InputTypes
  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesCountOutputType
     */
    select?: CategoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountOther_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriesWhereInput
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountSignalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: signalsWhereInput
  }


  /**
   * Count Type CommentsCountOutputType
   */

  export type CommentsCountOutputType = {
    other_comments: number
  }

  export type CommentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    other_comments?: boolean | CommentsCountOutputTypeCountOther_commentsArgs
  }

  // Custom InputTypes
  /**
   * CommentsCountOutputType without action
   */
  export type CommentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentsCountOutputType
     */
    select?: CommentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentsCountOutputType without action
   */
  export type CommentsCountOutputTypeCountOther_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
  }


  /**
   * Count Type DepartmentsCountOutputType
   */

  export type DepartmentsCountOutputType = {
    signals: number
    teams: number
    users_users_departmentObjIdTodepartments: number
  }

  export type DepartmentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    signals?: boolean | DepartmentsCountOutputTypeCountSignalsArgs
    teams?: boolean | DepartmentsCountOutputTypeCountTeamsArgs
    users_users_departmentObjIdTodepartments?: boolean | DepartmentsCountOutputTypeCountUsers_users_departmentObjIdTodepartmentsArgs
  }

  // Custom InputTypes
  /**
   * DepartmentsCountOutputType without action
   */
  export type DepartmentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentsCountOutputType
     */
    select?: DepartmentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentsCountOutputType without action
   */
  export type DepartmentsCountOutputTypeCountSignalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: signalsWhereInput
  }

  /**
   * DepartmentsCountOutputType without action
   */
  export type DepartmentsCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamsWhereInput
  }

  /**
   * DepartmentsCountOutputType without action
   */
  export type DepartmentsCountOutputTypeCountUsers_users_departmentObjIdTodepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type HotspotsCountOutputType
   */

  export type HotspotsCountOutputType = {
    hotspot_signals: number
    ideas: number
    solutions: number
  }

  export type HotspotsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotspot_signals?: boolean | HotspotsCountOutputTypeCountHotspot_signalsArgs
    ideas?: boolean | HotspotsCountOutputTypeCountIdeasArgs
    solutions?: boolean | HotspotsCountOutputTypeCountSolutionsArgs
  }

  // Custom InputTypes
  /**
   * HotspotsCountOutputType without action
   */
  export type HotspotsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotspotsCountOutputType
     */
    select?: HotspotsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotspotsCountOutputType without action
   */
  export type HotspotsCountOutputTypeCountHotspot_signalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hotspot_signalsWhereInput
  }

  /**
   * HotspotsCountOutputType without action
   */
  export type HotspotsCountOutputTypeCountIdeasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ideasWhereInput
  }

  /**
   * HotspotsCountOutputType without action
   */
  export type HotspotsCountOutputTypeCountSolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: solutionsWhereInput
  }


  /**
   * Count Type InitiativesCountOutputType
   */

  export type InitiativesCountOutputType = {
    ideas: number
    solutions: number
  }

  export type InitiativesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ideas?: boolean | InitiativesCountOutputTypeCountIdeasArgs
    solutions?: boolean | InitiativesCountOutputTypeCountSolutionsArgs
  }

  // Custom InputTypes
  /**
   * InitiativesCountOutputType without action
   */
  export type InitiativesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InitiativesCountOutputType
     */
    select?: InitiativesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InitiativesCountOutputType without action
   */
  export type InitiativesCountOutputTypeCountIdeasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ideasWhereInput
  }

  /**
   * InitiativesCountOutputType without action
   */
  export type InitiativesCountOutputTypeCountSolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: solutionsWhereInput
  }


  /**
   * Count Type Input_groupsCountOutputType
   */

  export type Input_groupsCountOutputType = {
    InputToInputGroup: number
  }

  export type Input_groupsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    InputToInputGroup?: boolean | Input_groupsCountOutputTypeCountInputToInputGroupArgs
  }

  // Custom InputTypes
  /**
   * Input_groupsCountOutputType without action
   */
  export type Input_groupsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Input_groupsCountOutputType
     */
    select?: Input_groupsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Input_groupsCountOutputType without action
   */
  export type Input_groupsCountOutputTypeCountInputToInputGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InputToInputGroupWhereInput
  }


  /**
   * Count Type InputsCountOutputType
   */

  export type InputsCountOutputType = {
    InputToInputGroup: number
    solutions: number
  }

  export type InputsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    InputToInputGroup?: boolean | InputsCountOutputTypeCountInputToInputGroupArgs
    solutions?: boolean | InputsCountOutputTypeCountSolutionsArgs
  }

  // Custom InputTypes
  /**
   * InputsCountOutputType without action
   */
  export type InputsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputsCountOutputType
     */
    select?: InputsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InputsCountOutputType without action
   */
  export type InputsCountOutputTypeCountInputToInputGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InputToInputGroupWhereInput
  }

  /**
   * InputsCountOutputType without action
   */
  export type InputsCountOutputTypeCountSolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: solutionsWhereInput
  }


  /**
   * Count Type SignalsCountOutputType
   */

  export type SignalsCountOutputType = {
    ai_insight_overrides: number
    hotspot_signals: number
  }

  export type SignalsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ai_insight_overrides?: boolean | SignalsCountOutputTypeCountAi_insight_overridesArgs
    hotspot_signals?: boolean | SignalsCountOutputTypeCountHotspot_signalsArgs
  }

  // Custom InputTypes
  /**
   * SignalsCountOutputType without action
   */
  export type SignalsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalsCountOutputType
     */
    select?: SignalsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SignalsCountOutputType without action
   */
  export type SignalsCountOutputTypeCountAi_insight_overridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_insight_overridesWhereInput
  }

  /**
   * SignalsCountOutputType without action
   */
  export type SignalsCountOutputTypeCountHotspot_signalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hotspot_signalsWhereInput
  }


  /**
   * Count Type SolutionsCountOutputType
   */

  export type SolutionsCountOutputType = {
    frd_documents: number
    requirements: number
  }

  export type SolutionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    frd_documents?: boolean | SolutionsCountOutputTypeCountFrd_documentsArgs
    requirements?: boolean | SolutionsCountOutputTypeCountRequirementsArgs
  }

  // Custom InputTypes
  /**
   * SolutionsCountOutputType without action
   */
  export type SolutionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolutionsCountOutputType
     */
    select?: SolutionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SolutionsCountOutputType without action
   */
  export type SolutionsCountOutputTypeCountFrd_documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: frd_documentsWhereInput
  }

  /**
   * SolutionsCountOutputType without action
   */
  export type SolutionsCountOutputTypeCountRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: requirementsWhereInput
  }


  /**
   * Count Type TeamsCountOutputType
   */

  export type TeamsCountOutputType = {
    signals: number
    users_TeamMembers: number
  }

  export type TeamsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    signals?: boolean | TeamsCountOutputTypeCountSignalsArgs
    users_TeamMembers?: boolean | TeamsCountOutputTypeCountUsers_TeamMembersArgs
  }

  // Custom InputTypes
  /**
   * TeamsCountOutputType without action
   */
  export type TeamsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsCountOutputType
     */
    select?: TeamsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamsCountOutputType without action
   */
  export type TeamsCountOutputTypeCountSignalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: signalsWhereInput
  }

  /**
   * TeamsCountOutputType without action
   */
  export type TeamsCountOutputTypeCountUsers_TeamMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    ai_analysis_audit: number
    ai_insight_overrides: number
    audit_logs: number
    comments: number
    departments_departments_managerIdTousers: number
    frd_documents_frd_documents_approvedByTousers: number
    frd_documents_frd_documents_createdByTousers: number
    ideas: number
    initiatives: number
    input_groups: number
    inputs: number
    requirements: number
    signals: number
    solutions: number
    teams_teams_leaderIdTousers: number
    other_users: number
    votes: number
    teams_TeamMembers: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ai_analysis_audit?: boolean | UsersCountOutputTypeCountAi_analysis_auditArgs
    ai_insight_overrides?: boolean | UsersCountOutputTypeCountAi_insight_overridesArgs
    audit_logs?: boolean | UsersCountOutputTypeCountAudit_logsArgs
    comments?: boolean | UsersCountOutputTypeCountCommentsArgs
    departments_departments_managerIdTousers?: boolean | UsersCountOutputTypeCountDepartments_departments_managerIdTousersArgs
    frd_documents_frd_documents_approvedByTousers?: boolean | UsersCountOutputTypeCountFrd_documents_frd_documents_approvedByTousersArgs
    frd_documents_frd_documents_createdByTousers?: boolean | UsersCountOutputTypeCountFrd_documents_frd_documents_createdByTousersArgs
    ideas?: boolean | UsersCountOutputTypeCountIdeasArgs
    initiatives?: boolean | UsersCountOutputTypeCountInitiativesArgs
    input_groups?: boolean | UsersCountOutputTypeCountInput_groupsArgs
    inputs?: boolean | UsersCountOutputTypeCountInputsArgs
    requirements?: boolean | UsersCountOutputTypeCountRequirementsArgs
    signals?: boolean | UsersCountOutputTypeCountSignalsArgs
    solutions?: boolean | UsersCountOutputTypeCountSolutionsArgs
    teams_teams_leaderIdTousers?: boolean | UsersCountOutputTypeCountTeams_teams_leaderIdTousersArgs
    other_users?: boolean | UsersCountOutputTypeCountOther_usersArgs
    votes?: boolean | UsersCountOutputTypeCountVotesArgs
    teams_TeamMembers?: boolean | UsersCountOutputTypeCountTeams_TeamMembersArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAi_analysis_auditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_analysis_auditWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAi_insight_overridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_insight_overridesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAudit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: audit_logsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountDepartments_departments_managerIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: departmentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFrd_documents_frd_documents_approvedByTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: frd_documentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFrd_documents_frd_documents_createdByTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: frd_documentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountIdeasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ideasWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountInitiativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: initiativesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountInput_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: input_groupsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountInputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inputsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: requirementsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSignalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: signalsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: solutionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTeams_teams_leaderIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountOther_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: votesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTeams_TeamMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model InputToInputGroup
   */

  export type AggregateInputToInputGroup = {
    _count: InputToInputGroupCountAggregateOutputType | null
    _min: InputToInputGroupMinAggregateOutputType | null
    _max: InputToInputGroupMaxAggregateOutputType | null
  }

  export type InputToInputGroupMinAggregateOutputType = {
    A: string | null
    B: string | null
  }

  export type InputToInputGroupMaxAggregateOutputType = {
    A: string | null
    B: string | null
  }

  export type InputToInputGroupCountAggregateOutputType = {
    A: number
    B: number
    _all: number
  }


  export type InputToInputGroupMinAggregateInputType = {
    A?: true
    B?: true
  }

  export type InputToInputGroupMaxAggregateInputType = {
    A?: true
    B?: true
  }

  export type InputToInputGroupCountAggregateInputType = {
    A?: true
    B?: true
    _all?: true
  }

  export type InputToInputGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InputToInputGroup to aggregate.
     */
    where?: InputToInputGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InputToInputGroups to fetch.
     */
    orderBy?: InputToInputGroupOrderByWithRelationInput | InputToInputGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InputToInputGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InputToInputGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InputToInputGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InputToInputGroups
    **/
    _count?: true | InputToInputGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InputToInputGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InputToInputGroupMaxAggregateInputType
  }

  export type GetInputToInputGroupAggregateType<T extends InputToInputGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateInputToInputGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInputToInputGroup[P]>
      : GetScalarType<T[P], AggregateInputToInputGroup[P]>
  }




  export type InputToInputGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InputToInputGroupWhereInput
    orderBy?: InputToInputGroupOrderByWithAggregationInput | InputToInputGroupOrderByWithAggregationInput[]
    by: InputToInputGroupScalarFieldEnum[] | InputToInputGroupScalarFieldEnum
    having?: InputToInputGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InputToInputGroupCountAggregateInputType | true
    _min?: InputToInputGroupMinAggregateInputType
    _max?: InputToInputGroupMaxAggregateInputType
  }

  export type InputToInputGroupGroupByOutputType = {
    A: string
    B: string
    _count: InputToInputGroupCountAggregateOutputType | null
    _min: InputToInputGroupMinAggregateOutputType | null
    _max: InputToInputGroupMaxAggregateOutputType | null
  }

  type GetInputToInputGroupGroupByPayload<T extends InputToInputGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InputToInputGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InputToInputGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InputToInputGroupGroupByOutputType[P]>
            : GetScalarType<T[P], InputToInputGroupGroupByOutputType[P]>
        }
      >
    >


  export type InputToInputGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    A?: boolean
    B?: boolean
    inputs?: boolean | inputsDefaultArgs<ExtArgs>
    input_groups?: boolean | input_groupsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inputToInputGroup"]>

  export type InputToInputGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    A?: boolean
    B?: boolean
    inputs?: boolean | inputsDefaultArgs<ExtArgs>
    input_groups?: boolean | input_groupsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inputToInputGroup"]>

  export type InputToInputGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    A?: boolean
    B?: boolean
    inputs?: boolean | inputsDefaultArgs<ExtArgs>
    input_groups?: boolean | input_groupsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inputToInputGroup"]>

  export type InputToInputGroupSelectScalar = {
    A?: boolean
    B?: boolean
  }

  export type InputToInputGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"A" | "B", ExtArgs["result"]["inputToInputGroup"]>
  export type InputToInputGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inputs?: boolean | inputsDefaultArgs<ExtArgs>
    input_groups?: boolean | input_groupsDefaultArgs<ExtArgs>
  }
  export type InputToInputGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inputs?: boolean | inputsDefaultArgs<ExtArgs>
    input_groups?: boolean | input_groupsDefaultArgs<ExtArgs>
  }
  export type InputToInputGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inputs?: boolean | inputsDefaultArgs<ExtArgs>
    input_groups?: boolean | input_groupsDefaultArgs<ExtArgs>
  }

  export type $InputToInputGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InputToInputGroup"
    objects: {
      inputs: Prisma.$inputsPayload<ExtArgs>
      input_groups: Prisma.$input_groupsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      A: string
      B: string
    }, ExtArgs["result"]["inputToInputGroup"]>
    composites: {}
  }

  type InputToInputGroupGetPayload<S extends boolean | null | undefined | InputToInputGroupDefaultArgs> = $Result.GetResult<Prisma.$InputToInputGroupPayload, S>

  type InputToInputGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InputToInputGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InputToInputGroupCountAggregateInputType | true
    }

  export interface InputToInputGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InputToInputGroup'], meta: { name: 'InputToInputGroup' } }
    /**
     * Find zero or one InputToInputGroup that matches the filter.
     * @param {InputToInputGroupFindUniqueArgs} args - Arguments to find a InputToInputGroup
     * @example
     * // Get one InputToInputGroup
     * const inputToInputGroup = await prisma.inputToInputGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InputToInputGroupFindUniqueArgs>(args: SelectSubset<T, InputToInputGroupFindUniqueArgs<ExtArgs>>): Prisma__InputToInputGroupClient<$Result.GetResult<Prisma.$InputToInputGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InputToInputGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InputToInputGroupFindUniqueOrThrowArgs} args - Arguments to find a InputToInputGroup
     * @example
     * // Get one InputToInputGroup
     * const inputToInputGroup = await prisma.inputToInputGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InputToInputGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, InputToInputGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InputToInputGroupClient<$Result.GetResult<Prisma.$InputToInputGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InputToInputGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputToInputGroupFindFirstArgs} args - Arguments to find a InputToInputGroup
     * @example
     * // Get one InputToInputGroup
     * const inputToInputGroup = await prisma.inputToInputGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InputToInputGroupFindFirstArgs>(args?: SelectSubset<T, InputToInputGroupFindFirstArgs<ExtArgs>>): Prisma__InputToInputGroupClient<$Result.GetResult<Prisma.$InputToInputGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InputToInputGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputToInputGroupFindFirstOrThrowArgs} args - Arguments to find a InputToInputGroup
     * @example
     * // Get one InputToInputGroup
     * const inputToInputGroup = await prisma.inputToInputGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InputToInputGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, InputToInputGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__InputToInputGroupClient<$Result.GetResult<Prisma.$InputToInputGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InputToInputGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputToInputGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InputToInputGroups
     * const inputToInputGroups = await prisma.inputToInputGroup.findMany()
     * 
     * // Get first 10 InputToInputGroups
     * const inputToInputGroups = await prisma.inputToInputGroup.findMany({ take: 10 })
     * 
     * // Only select the `A`
     * const inputToInputGroupWithAOnly = await prisma.inputToInputGroup.findMany({ select: { A: true } })
     * 
     */
    findMany<T extends InputToInputGroupFindManyArgs>(args?: SelectSubset<T, InputToInputGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InputToInputGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InputToInputGroup.
     * @param {InputToInputGroupCreateArgs} args - Arguments to create a InputToInputGroup.
     * @example
     * // Create one InputToInputGroup
     * const InputToInputGroup = await prisma.inputToInputGroup.create({
     *   data: {
     *     // ... data to create a InputToInputGroup
     *   }
     * })
     * 
     */
    create<T extends InputToInputGroupCreateArgs>(args: SelectSubset<T, InputToInputGroupCreateArgs<ExtArgs>>): Prisma__InputToInputGroupClient<$Result.GetResult<Prisma.$InputToInputGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InputToInputGroups.
     * @param {InputToInputGroupCreateManyArgs} args - Arguments to create many InputToInputGroups.
     * @example
     * // Create many InputToInputGroups
     * const inputToInputGroup = await prisma.inputToInputGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InputToInputGroupCreateManyArgs>(args?: SelectSubset<T, InputToInputGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InputToInputGroups and returns the data saved in the database.
     * @param {InputToInputGroupCreateManyAndReturnArgs} args - Arguments to create many InputToInputGroups.
     * @example
     * // Create many InputToInputGroups
     * const inputToInputGroup = await prisma.inputToInputGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InputToInputGroups and only return the `A`
     * const inputToInputGroupWithAOnly = await prisma.inputToInputGroup.createManyAndReturn({
     *   select: { A: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InputToInputGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, InputToInputGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InputToInputGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InputToInputGroup.
     * @param {InputToInputGroupDeleteArgs} args - Arguments to delete one InputToInputGroup.
     * @example
     * // Delete one InputToInputGroup
     * const InputToInputGroup = await prisma.inputToInputGroup.delete({
     *   where: {
     *     // ... filter to delete one InputToInputGroup
     *   }
     * })
     * 
     */
    delete<T extends InputToInputGroupDeleteArgs>(args: SelectSubset<T, InputToInputGroupDeleteArgs<ExtArgs>>): Prisma__InputToInputGroupClient<$Result.GetResult<Prisma.$InputToInputGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InputToInputGroup.
     * @param {InputToInputGroupUpdateArgs} args - Arguments to update one InputToInputGroup.
     * @example
     * // Update one InputToInputGroup
     * const inputToInputGroup = await prisma.inputToInputGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InputToInputGroupUpdateArgs>(args: SelectSubset<T, InputToInputGroupUpdateArgs<ExtArgs>>): Prisma__InputToInputGroupClient<$Result.GetResult<Prisma.$InputToInputGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InputToInputGroups.
     * @param {InputToInputGroupDeleteManyArgs} args - Arguments to filter InputToInputGroups to delete.
     * @example
     * // Delete a few InputToInputGroups
     * const { count } = await prisma.inputToInputGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InputToInputGroupDeleteManyArgs>(args?: SelectSubset<T, InputToInputGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InputToInputGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputToInputGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InputToInputGroups
     * const inputToInputGroup = await prisma.inputToInputGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InputToInputGroupUpdateManyArgs>(args: SelectSubset<T, InputToInputGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InputToInputGroups and returns the data updated in the database.
     * @param {InputToInputGroupUpdateManyAndReturnArgs} args - Arguments to update many InputToInputGroups.
     * @example
     * // Update many InputToInputGroups
     * const inputToInputGroup = await prisma.inputToInputGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InputToInputGroups and only return the `A`
     * const inputToInputGroupWithAOnly = await prisma.inputToInputGroup.updateManyAndReturn({
     *   select: { A: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InputToInputGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, InputToInputGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InputToInputGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InputToInputGroup.
     * @param {InputToInputGroupUpsertArgs} args - Arguments to update or create a InputToInputGroup.
     * @example
     * // Update or create a InputToInputGroup
     * const inputToInputGroup = await prisma.inputToInputGroup.upsert({
     *   create: {
     *     // ... data to create a InputToInputGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InputToInputGroup we want to update
     *   }
     * })
     */
    upsert<T extends InputToInputGroupUpsertArgs>(args: SelectSubset<T, InputToInputGroupUpsertArgs<ExtArgs>>): Prisma__InputToInputGroupClient<$Result.GetResult<Prisma.$InputToInputGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InputToInputGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputToInputGroupCountArgs} args - Arguments to filter InputToInputGroups to count.
     * @example
     * // Count the number of InputToInputGroups
     * const count = await prisma.inputToInputGroup.count({
     *   where: {
     *     // ... the filter for the InputToInputGroups we want to count
     *   }
     * })
    **/
    count<T extends InputToInputGroupCountArgs>(
      args?: Subset<T, InputToInputGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InputToInputGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InputToInputGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputToInputGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InputToInputGroupAggregateArgs>(args: Subset<T, InputToInputGroupAggregateArgs>): Prisma.PrismaPromise<GetInputToInputGroupAggregateType<T>>

    /**
     * Group by InputToInputGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputToInputGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InputToInputGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InputToInputGroupGroupByArgs['orderBy'] }
        : { orderBy?: InputToInputGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InputToInputGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInputToInputGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InputToInputGroup model
   */
  readonly fields: InputToInputGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InputToInputGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InputToInputGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inputs<T extends inputsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, inputsDefaultArgs<ExtArgs>>): Prisma__inputsClient<$Result.GetResult<Prisma.$inputsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    input_groups<T extends input_groupsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, input_groupsDefaultArgs<ExtArgs>>): Prisma__input_groupsClient<$Result.GetResult<Prisma.$input_groupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InputToInputGroup model
   */
  interface InputToInputGroupFieldRefs {
    readonly A: FieldRef<"InputToInputGroup", 'String'>
    readonly B: FieldRef<"InputToInputGroup", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InputToInputGroup findUnique
   */
  export type InputToInputGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputToInputGroup
     */
    select?: InputToInputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputToInputGroup
     */
    omit?: InputToInputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputToInputGroupInclude<ExtArgs> | null
    /**
     * Filter, which InputToInputGroup to fetch.
     */
    where: InputToInputGroupWhereUniqueInput
  }

  /**
   * InputToInputGroup findUniqueOrThrow
   */
  export type InputToInputGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputToInputGroup
     */
    select?: InputToInputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputToInputGroup
     */
    omit?: InputToInputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputToInputGroupInclude<ExtArgs> | null
    /**
     * Filter, which InputToInputGroup to fetch.
     */
    where: InputToInputGroupWhereUniqueInput
  }

  /**
   * InputToInputGroup findFirst
   */
  export type InputToInputGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputToInputGroup
     */
    select?: InputToInputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputToInputGroup
     */
    omit?: InputToInputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputToInputGroupInclude<ExtArgs> | null
    /**
     * Filter, which InputToInputGroup to fetch.
     */
    where?: InputToInputGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InputToInputGroups to fetch.
     */
    orderBy?: InputToInputGroupOrderByWithRelationInput | InputToInputGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InputToInputGroups.
     */
    cursor?: InputToInputGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InputToInputGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InputToInputGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InputToInputGroups.
     */
    distinct?: InputToInputGroupScalarFieldEnum | InputToInputGroupScalarFieldEnum[]
  }

  /**
   * InputToInputGroup findFirstOrThrow
   */
  export type InputToInputGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputToInputGroup
     */
    select?: InputToInputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputToInputGroup
     */
    omit?: InputToInputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputToInputGroupInclude<ExtArgs> | null
    /**
     * Filter, which InputToInputGroup to fetch.
     */
    where?: InputToInputGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InputToInputGroups to fetch.
     */
    orderBy?: InputToInputGroupOrderByWithRelationInput | InputToInputGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InputToInputGroups.
     */
    cursor?: InputToInputGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InputToInputGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InputToInputGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InputToInputGroups.
     */
    distinct?: InputToInputGroupScalarFieldEnum | InputToInputGroupScalarFieldEnum[]
  }

  /**
   * InputToInputGroup findMany
   */
  export type InputToInputGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputToInputGroup
     */
    select?: InputToInputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputToInputGroup
     */
    omit?: InputToInputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputToInputGroupInclude<ExtArgs> | null
    /**
     * Filter, which InputToInputGroups to fetch.
     */
    where?: InputToInputGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InputToInputGroups to fetch.
     */
    orderBy?: InputToInputGroupOrderByWithRelationInput | InputToInputGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InputToInputGroups.
     */
    cursor?: InputToInputGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InputToInputGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InputToInputGroups.
     */
    skip?: number
    distinct?: InputToInputGroupScalarFieldEnum | InputToInputGroupScalarFieldEnum[]
  }

  /**
   * InputToInputGroup create
   */
  export type InputToInputGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputToInputGroup
     */
    select?: InputToInputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputToInputGroup
     */
    omit?: InputToInputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputToInputGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a InputToInputGroup.
     */
    data: XOR<InputToInputGroupCreateInput, InputToInputGroupUncheckedCreateInput>
  }

  /**
   * InputToInputGroup createMany
   */
  export type InputToInputGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InputToInputGroups.
     */
    data: InputToInputGroupCreateManyInput | InputToInputGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InputToInputGroup createManyAndReturn
   */
  export type InputToInputGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputToInputGroup
     */
    select?: InputToInputGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InputToInputGroup
     */
    omit?: InputToInputGroupOmit<ExtArgs> | null
    /**
     * The data used to create many InputToInputGroups.
     */
    data: InputToInputGroupCreateManyInput | InputToInputGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputToInputGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InputToInputGroup update
   */
  export type InputToInputGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputToInputGroup
     */
    select?: InputToInputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputToInputGroup
     */
    omit?: InputToInputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputToInputGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a InputToInputGroup.
     */
    data: XOR<InputToInputGroupUpdateInput, InputToInputGroupUncheckedUpdateInput>
    /**
     * Choose, which InputToInputGroup to update.
     */
    where: InputToInputGroupWhereUniqueInput
  }

  /**
   * InputToInputGroup updateMany
   */
  export type InputToInputGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InputToInputGroups.
     */
    data: XOR<InputToInputGroupUpdateManyMutationInput, InputToInputGroupUncheckedUpdateManyInput>
    /**
     * Filter which InputToInputGroups to update
     */
    where?: InputToInputGroupWhereInput
    /**
     * Limit how many InputToInputGroups to update.
     */
    limit?: number
  }

  /**
   * InputToInputGroup updateManyAndReturn
   */
  export type InputToInputGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputToInputGroup
     */
    select?: InputToInputGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InputToInputGroup
     */
    omit?: InputToInputGroupOmit<ExtArgs> | null
    /**
     * The data used to update InputToInputGroups.
     */
    data: XOR<InputToInputGroupUpdateManyMutationInput, InputToInputGroupUncheckedUpdateManyInput>
    /**
     * Filter which InputToInputGroups to update
     */
    where?: InputToInputGroupWhereInput
    /**
     * Limit how many InputToInputGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputToInputGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InputToInputGroup upsert
   */
  export type InputToInputGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputToInputGroup
     */
    select?: InputToInputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputToInputGroup
     */
    omit?: InputToInputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputToInputGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the InputToInputGroup to update in case it exists.
     */
    where: InputToInputGroupWhereUniqueInput
    /**
     * In case the InputToInputGroup found by the `where` argument doesn't exist, create a new InputToInputGroup with this data.
     */
    create: XOR<InputToInputGroupCreateInput, InputToInputGroupUncheckedCreateInput>
    /**
     * In case the InputToInputGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InputToInputGroupUpdateInput, InputToInputGroupUncheckedUpdateInput>
  }

  /**
   * InputToInputGroup delete
   */
  export type InputToInputGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputToInputGroup
     */
    select?: InputToInputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputToInputGroup
     */
    omit?: InputToInputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputToInputGroupInclude<ExtArgs> | null
    /**
     * Filter which InputToInputGroup to delete.
     */
    where: InputToInputGroupWhereUniqueInput
  }

  /**
   * InputToInputGroup deleteMany
   */
  export type InputToInputGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InputToInputGroups to delete
     */
    where?: InputToInputGroupWhereInput
    /**
     * Limit how many InputToInputGroups to delete.
     */
    limit?: number
  }

  /**
   * InputToInputGroup without action
   */
  export type InputToInputGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputToInputGroup
     */
    select?: InputToInputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputToInputGroup
     */
    omit?: InputToInputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputToInputGroupInclude<ExtArgs> | null
  }


  /**
   * Model ai_analysis_audit
   */

  export type AggregateAi_analysis_audit = {
    _count: Ai_analysis_auditCountAggregateOutputType | null
    _avg: Ai_analysis_auditAvgAggregateOutputType | null
    _sum: Ai_analysis_auditSumAggregateOutputType | null
    _min: Ai_analysis_auditMinAggregateOutputType | null
    _max: Ai_analysis_auditMaxAggregateOutputType | null
  }

  export type Ai_analysis_auditAvgAggregateOutputType = {
    processingTime: number | null
    confidence: number | null
  }

  export type Ai_analysis_auditSumAggregateOutputType = {
    processingTime: number | null
    confidence: number | null
  }

  export type Ai_analysis_auditMinAggregateOutputType = {
    id: string | null
    hotspotId: string | null
    analysisType: string | null
    userId: string | null
    processingTime: number | null
    confidence: number | null
    status: string | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type Ai_analysis_auditMaxAggregateOutputType = {
    id: string | null
    hotspotId: string | null
    analysisType: string | null
    userId: string | null
    processingTime: number | null
    confidence: number | null
    status: string | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type Ai_analysis_auditCountAggregateOutputType = {
    id: number
    hotspotId: number
    analysisType: number
    userId: number
    requestData: number
    responseData: number
    processingTime: number
    confidence: number
    status: number
    errorMessage: number
    createdAt: number
    _all: number
  }


  export type Ai_analysis_auditAvgAggregateInputType = {
    processingTime?: true
    confidence?: true
  }

  export type Ai_analysis_auditSumAggregateInputType = {
    processingTime?: true
    confidence?: true
  }

  export type Ai_analysis_auditMinAggregateInputType = {
    id?: true
    hotspotId?: true
    analysisType?: true
    userId?: true
    processingTime?: true
    confidence?: true
    status?: true
    errorMessage?: true
    createdAt?: true
  }

  export type Ai_analysis_auditMaxAggregateInputType = {
    id?: true
    hotspotId?: true
    analysisType?: true
    userId?: true
    processingTime?: true
    confidence?: true
    status?: true
    errorMessage?: true
    createdAt?: true
  }

  export type Ai_analysis_auditCountAggregateInputType = {
    id?: true
    hotspotId?: true
    analysisType?: true
    userId?: true
    requestData?: true
    responseData?: true
    processingTime?: true
    confidence?: true
    status?: true
    errorMessage?: true
    createdAt?: true
    _all?: true
  }

  export type Ai_analysis_auditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_analysis_audit to aggregate.
     */
    where?: ai_analysis_auditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_analysis_audits to fetch.
     */
    orderBy?: ai_analysis_auditOrderByWithRelationInput | ai_analysis_auditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ai_analysis_auditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_analysis_audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_analysis_audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ai_analysis_audits
    **/
    _count?: true | Ai_analysis_auditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ai_analysis_auditAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ai_analysis_auditSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ai_analysis_auditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ai_analysis_auditMaxAggregateInputType
  }

  export type GetAi_analysis_auditAggregateType<T extends Ai_analysis_auditAggregateArgs> = {
        [P in keyof T & keyof AggregateAi_analysis_audit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAi_analysis_audit[P]>
      : GetScalarType<T[P], AggregateAi_analysis_audit[P]>
  }




  export type ai_analysis_auditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_analysis_auditWhereInput
    orderBy?: ai_analysis_auditOrderByWithAggregationInput | ai_analysis_auditOrderByWithAggregationInput[]
    by: Ai_analysis_auditScalarFieldEnum[] | Ai_analysis_auditScalarFieldEnum
    having?: ai_analysis_auditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ai_analysis_auditCountAggregateInputType | true
    _avg?: Ai_analysis_auditAvgAggregateInputType
    _sum?: Ai_analysis_auditSumAggregateInputType
    _min?: Ai_analysis_auditMinAggregateInputType
    _max?: Ai_analysis_auditMaxAggregateInputType
  }

  export type Ai_analysis_auditGroupByOutputType = {
    id: string
    hotspotId: string
    analysisType: string
    userId: string
    requestData: JsonValue | null
    responseData: JsonValue | null
    processingTime: number | null
    confidence: number | null
    status: string
    errorMessage: string | null
    createdAt: Date
    _count: Ai_analysis_auditCountAggregateOutputType | null
    _avg: Ai_analysis_auditAvgAggregateOutputType | null
    _sum: Ai_analysis_auditSumAggregateOutputType | null
    _min: Ai_analysis_auditMinAggregateOutputType | null
    _max: Ai_analysis_auditMaxAggregateOutputType | null
  }

  type GetAi_analysis_auditGroupByPayload<T extends ai_analysis_auditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ai_analysis_auditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ai_analysis_auditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ai_analysis_auditGroupByOutputType[P]>
            : GetScalarType<T[P], Ai_analysis_auditGroupByOutputType[P]>
        }
      >
    >


  export type ai_analysis_auditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotspotId?: boolean
    analysisType?: boolean
    userId?: boolean
    requestData?: boolean
    responseData?: boolean
    processingTime?: boolean
    confidence?: boolean
    status?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ai_analysis_audit"]>

  export type ai_analysis_auditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotspotId?: boolean
    analysisType?: boolean
    userId?: boolean
    requestData?: boolean
    responseData?: boolean
    processingTime?: boolean
    confidence?: boolean
    status?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ai_analysis_audit"]>

  export type ai_analysis_auditSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotspotId?: boolean
    analysisType?: boolean
    userId?: boolean
    requestData?: boolean
    responseData?: boolean
    processingTime?: boolean
    confidence?: boolean
    status?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ai_analysis_audit"]>

  export type ai_analysis_auditSelectScalar = {
    id?: boolean
    hotspotId?: boolean
    analysisType?: boolean
    userId?: boolean
    requestData?: boolean
    responseData?: boolean
    processingTime?: boolean
    confidence?: boolean
    status?: boolean
    errorMessage?: boolean
    createdAt?: boolean
  }

  export type ai_analysis_auditOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hotspotId" | "analysisType" | "userId" | "requestData" | "responseData" | "processingTime" | "confidence" | "status" | "errorMessage" | "createdAt", ExtArgs["result"]["ai_analysis_audit"]>
  export type ai_analysis_auditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type ai_analysis_auditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type ai_analysis_auditIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $ai_analysis_auditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ai_analysis_audit"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hotspotId: string
      analysisType: string
      userId: string
      requestData: Prisma.JsonValue | null
      responseData: Prisma.JsonValue | null
      processingTime: number | null
      confidence: number | null
      status: string
      errorMessage: string | null
      createdAt: Date
    }, ExtArgs["result"]["ai_analysis_audit"]>
    composites: {}
  }

  type ai_analysis_auditGetPayload<S extends boolean | null | undefined | ai_analysis_auditDefaultArgs> = $Result.GetResult<Prisma.$ai_analysis_auditPayload, S>

  type ai_analysis_auditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ai_analysis_auditFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ai_analysis_auditCountAggregateInputType | true
    }

  export interface ai_analysis_auditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ai_analysis_audit'], meta: { name: 'ai_analysis_audit' } }
    /**
     * Find zero or one Ai_analysis_audit that matches the filter.
     * @param {ai_analysis_auditFindUniqueArgs} args - Arguments to find a Ai_analysis_audit
     * @example
     * // Get one Ai_analysis_audit
     * const ai_analysis_audit = await prisma.ai_analysis_audit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ai_analysis_auditFindUniqueArgs>(args: SelectSubset<T, ai_analysis_auditFindUniqueArgs<ExtArgs>>): Prisma__ai_analysis_auditClient<$Result.GetResult<Prisma.$ai_analysis_auditPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ai_analysis_audit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ai_analysis_auditFindUniqueOrThrowArgs} args - Arguments to find a Ai_analysis_audit
     * @example
     * // Get one Ai_analysis_audit
     * const ai_analysis_audit = await prisma.ai_analysis_audit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ai_analysis_auditFindUniqueOrThrowArgs>(args: SelectSubset<T, ai_analysis_auditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ai_analysis_auditClient<$Result.GetResult<Prisma.$ai_analysis_auditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_analysis_audit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_analysis_auditFindFirstArgs} args - Arguments to find a Ai_analysis_audit
     * @example
     * // Get one Ai_analysis_audit
     * const ai_analysis_audit = await prisma.ai_analysis_audit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ai_analysis_auditFindFirstArgs>(args?: SelectSubset<T, ai_analysis_auditFindFirstArgs<ExtArgs>>): Prisma__ai_analysis_auditClient<$Result.GetResult<Prisma.$ai_analysis_auditPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_analysis_audit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_analysis_auditFindFirstOrThrowArgs} args - Arguments to find a Ai_analysis_audit
     * @example
     * // Get one Ai_analysis_audit
     * const ai_analysis_audit = await prisma.ai_analysis_audit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ai_analysis_auditFindFirstOrThrowArgs>(args?: SelectSubset<T, ai_analysis_auditFindFirstOrThrowArgs<ExtArgs>>): Prisma__ai_analysis_auditClient<$Result.GetResult<Prisma.$ai_analysis_auditPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ai_analysis_audits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_analysis_auditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ai_analysis_audits
     * const ai_analysis_audits = await prisma.ai_analysis_audit.findMany()
     * 
     * // Get first 10 Ai_analysis_audits
     * const ai_analysis_audits = await prisma.ai_analysis_audit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ai_analysis_auditWithIdOnly = await prisma.ai_analysis_audit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ai_analysis_auditFindManyArgs>(args?: SelectSubset<T, ai_analysis_auditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_analysis_auditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ai_analysis_audit.
     * @param {ai_analysis_auditCreateArgs} args - Arguments to create a Ai_analysis_audit.
     * @example
     * // Create one Ai_analysis_audit
     * const Ai_analysis_audit = await prisma.ai_analysis_audit.create({
     *   data: {
     *     // ... data to create a Ai_analysis_audit
     *   }
     * })
     * 
     */
    create<T extends ai_analysis_auditCreateArgs>(args: SelectSubset<T, ai_analysis_auditCreateArgs<ExtArgs>>): Prisma__ai_analysis_auditClient<$Result.GetResult<Prisma.$ai_analysis_auditPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ai_analysis_audits.
     * @param {ai_analysis_auditCreateManyArgs} args - Arguments to create many Ai_analysis_audits.
     * @example
     * // Create many Ai_analysis_audits
     * const ai_analysis_audit = await prisma.ai_analysis_audit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ai_analysis_auditCreateManyArgs>(args?: SelectSubset<T, ai_analysis_auditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ai_analysis_audits and returns the data saved in the database.
     * @param {ai_analysis_auditCreateManyAndReturnArgs} args - Arguments to create many Ai_analysis_audits.
     * @example
     * // Create many Ai_analysis_audits
     * const ai_analysis_audit = await prisma.ai_analysis_audit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ai_analysis_audits and only return the `id`
     * const ai_analysis_auditWithIdOnly = await prisma.ai_analysis_audit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ai_analysis_auditCreateManyAndReturnArgs>(args?: SelectSubset<T, ai_analysis_auditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_analysis_auditPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ai_analysis_audit.
     * @param {ai_analysis_auditDeleteArgs} args - Arguments to delete one Ai_analysis_audit.
     * @example
     * // Delete one Ai_analysis_audit
     * const Ai_analysis_audit = await prisma.ai_analysis_audit.delete({
     *   where: {
     *     // ... filter to delete one Ai_analysis_audit
     *   }
     * })
     * 
     */
    delete<T extends ai_analysis_auditDeleteArgs>(args: SelectSubset<T, ai_analysis_auditDeleteArgs<ExtArgs>>): Prisma__ai_analysis_auditClient<$Result.GetResult<Prisma.$ai_analysis_auditPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ai_analysis_audit.
     * @param {ai_analysis_auditUpdateArgs} args - Arguments to update one Ai_analysis_audit.
     * @example
     * // Update one Ai_analysis_audit
     * const ai_analysis_audit = await prisma.ai_analysis_audit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ai_analysis_auditUpdateArgs>(args: SelectSubset<T, ai_analysis_auditUpdateArgs<ExtArgs>>): Prisma__ai_analysis_auditClient<$Result.GetResult<Prisma.$ai_analysis_auditPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ai_analysis_audits.
     * @param {ai_analysis_auditDeleteManyArgs} args - Arguments to filter Ai_analysis_audits to delete.
     * @example
     * // Delete a few Ai_analysis_audits
     * const { count } = await prisma.ai_analysis_audit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ai_analysis_auditDeleteManyArgs>(args?: SelectSubset<T, ai_analysis_auditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_analysis_audits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_analysis_auditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ai_analysis_audits
     * const ai_analysis_audit = await prisma.ai_analysis_audit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ai_analysis_auditUpdateManyArgs>(args: SelectSubset<T, ai_analysis_auditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_analysis_audits and returns the data updated in the database.
     * @param {ai_analysis_auditUpdateManyAndReturnArgs} args - Arguments to update many Ai_analysis_audits.
     * @example
     * // Update many Ai_analysis_audits
     * const ai_analysis_audit = await prisma.ai_analysis_audit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ai_analysis_audits and only return the `id`
     * const ai_analysis_auditWithIdOnly = await prisma.ai_analysis_audit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ai_analysis_auditUpdateManyAndReturnArgs>(args: SelectSubset<T, ai_analysis_auditUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_analysis_auditPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ai_analysis_audit.
     * @param {ai_analysis_auditUpsertArgs} args - Arguments to update or create a Ai_analysis_audit.
     * @example
     * // Update or create a Ai_analysis_audit
     * const ai_analysis_audit = await prisma.ai_analysis_audit.upsert({
     *   create: {
     *     // ... data to create a Ai_analysis_audit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ai_analysis_audit we want to update
     *   }
     * })
     */
    upsert<T extends ai_analysis_auditUpsertArgs>(args: SelectSubset<T, ai_analysis_auditUpsertArgs<ExtArgs>>): Prisma__ai_analysis_auditClient<$Result.GetResult<Prisma.$ai_analysis_auditPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ai_analysis_audits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_analysis_auditCountArgs} args - Arguments to filter Ai_analysis_audits to count.
     * @example
     * // Count the number of Ai_analysis_audits
     * const count = await prisma.ai_analysis_audit.count({
     *   where: {
     *     // ... the filter for the Ai_analysis_audits we want to count
     *   }
     * })
    **/
    count<T extends ai_analysis_auditCountArgs>(
      args?: Subset<T, ai_analysis_auditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ai_analysis_auditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ai_analysis_audit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ai_analysis_auditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ai_analysis_auditAggregateArgs>(args: Subset<T, Ai_analysis_auditAggregateArgs>): Prisma.PrismaPromise<GetAi_analysis_auditAggregateType<T>>

    /**
     * Group by Ai_analysis_audit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_analysis_auditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ai_analysis_auditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ai_analysis_auditGroupByArgs['orderBy'] }
        : { orderBy?: ai_analysis_auditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ai_analysis_auditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAi_analysis_auditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ai_analysis_audit model
   */
  readonly fields: ai_analysis_auditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ai_analysis_audit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ai_analysis_auditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ai_analysis_audit model
   */
  interface ai_analysis_auditFieldRefs {
    readonly id: FieldRef<"ai_analysis_audit", 'String'>
    readonly hotspotId: FieldRef<"ai_analysis_audit", 'String'>
    readonly analysisType: FieldRef<"ai_analysis_audit", 'String'>
    readonly userId: FieldRef<"ai_analysis_audit", 'String'>
    readonly requestData: FieldRef<"ai_analysis_audit", 'Json'>
    readonly responseData: FieldRef<"ai_analysis_audit", 'Json'>
    readonly processingTime: FieldRef<"ai_analysis_audit", 'Int'>
    readonly confidence: FieldRef<"ai_analysis_audit", 'Float'>
    readonly status: FieldRef<"ai_analysis_audit", 'String'>
    readonly errorMessage: FieldRef<"ai_analysis_audit", 'String'>
    readonly createdAt: FieldRef<"ai_analysis_audit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ai_analysis_audit findUnique
   */
  export type ai_analysis_auditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_analysis_audit
     */
    select?: ai_analysis_auditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_analysis_audit
     */
    omit?: ai_analysis_auditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_analysis_auditInclude<ExtArgs> | null
    /**
     * Filter, which ai_analysis_audit to fetch.
     */
    where: ai_analysis_auditWhereUniqueInput
  }

  /**
   * ai_analysis_audit findUniqueOrThrow
   */
  export type ai_analysis_auditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_analysis_audit
     */
    select?: ai_analysis_auditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_analysis_audit
     */
    omit?: ai_analysis_auditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_analysis_auditInclude<ExtArgs> | null
    /**
     * Filter, which ai_analysis_audit to fetch.
     */
    where: ai_analysis_auditWhereUniqueInput
  }

  /**
   * ai_analysis_audit findFirst
   */
  export type ai_analysis_auditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_analysis_audit
     */
    select?: ai_analysis_auditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_analysis_audit
     */
    omit?: ai_analysis_auditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_analysis_auditInclude<ExtArgs> | null
    /**
     * Filter, which ai_analysis_audit to fetch.
     */
    where?: ai_analysis_auditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_analysis_audits to fetch.
     */
    orderBy?: ai_analysis_auditOrderByWithRelationInput | ai_analysis_auditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_analysis_audits.
     */
    cursor?: ai_analysis_auditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_analysis_audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_analysis_audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_analysis_audits.
     */
    distinct?: Ai_analysis_auditScalarFieldEnum | Ai_analysis_auditScalarFieldEnum[]
  }

  /**
   * ai_analysis_audit findFirstOrThrow
   */
  export type ai_analysis_auditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_analysis_audit
     */
    select?: ai_analysis_auditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_analysis_audit
     */
    omit?: ai_analysis_auditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_analysis_auditInclude<ExtArgs> | null
    /**
     * Filter, which ai_analysis_audit to fetch.
     */
    where?: ai_analysis_auditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_analysis_audits to fetch.
     */
    orderBy?: ai_analysis_auditOrderByWithRelationInput | ai_analysis_auditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_analysis_audits.
     */
    cursor?: ai_analysis_auditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_analysis_audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_analysis_audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_analysis_audits.
     */
    distinct?: Ai_analysis_auditScalarFieldEnum | Ai_analysis_auditScalarFieldEnum[]
  }

  /**
   * ai_analysis_audit findMany
   */
  export type ai_analysis_auditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_analysis_audit
     */
    select?: ai_analysis_auditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_analysis_audit
     */
    omit?: ai_analysis_auditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_analysis_auditInclude<ExtArgs> | null
    /**
     * Filter, which ai_analysis_audits to fetch.
     */
    where?: ai_analysis_auditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_analysis_audits to fetch.
     */
    orderBy?: ai_analysis_auditOrderByWithRelationInput | ai_analysis_auditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ai_analysis_audits.
     */
    cursor?: ai_analysis_auditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_analysis_audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_analysis_audits.
     */
    skip?: number
    distinct?: Ai_analysis_auditScalarFieldEnum | Ai_analysis_auditScalarFieldEnum[]
  }

  /**
   * ai_analysis_audit create
   */
  export type ai_analysis_auditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_analysis_audit
     */
    select?: ai_analysis_auditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_analysis_audit
     */
    omit?: ai_analysis_auditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_analysis_auditInclude<ExtArgs> | null
    /**
     * The data needed to create a ai_analysis_audit.
     */
    data: XOR<ai_analysis_auditCreateInput, ai_analysis_auditUncheckedCreateInput>
  }

  /**
   * ai_analysis_audit createMany
   */
  export type ai_analysis_auditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ai_analysis_audits.
     */
    data: ai_analysis_auditCreateManyInput | ai_analysis_auditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_analysis_audit createManyAndReturn
   */
  export type ai_analysis_auditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_analysis_audit
     */
    select?: ai_analysis_auditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ai_analysis_audit
     */
    omit?: ai_analysis_auditOmit<ExtArgs> | null
    /**
     * The data used to create many ai_analysis_audits.
     */
    data: ai_analysis_auditCreateManyInput | ai_analysis_auditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_analysis_auditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ai_analysis_audit update
   */
  export type ai_analysis_auditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_analysis_audit
     */
    select?: ai_analysis_auditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_analysis_audit
     */
    omit?: ai_analysis_auditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_analysis_auditInclude<ExtArgs> | null
    /**
     * The data needed to update a ai_analysis_audit.
     */
    data: XOR<ai_analysis_auditUpdateInput, ai_analysis_auditUncheckedUpdateInput>
    /**
     * Choose, which ai_analysis_audit to update.
     */
    where: ai_analysis_auditWhereUniqueInput
  }

  /**
   * ai_analysis_audit updateMany
   */
  export type ai_analysis_auditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ai_analysis_audits.
     */
    data: XOR<ai_analysis_auditUpdateManyMutationInput, ai_analysis_auditUncheckedUpdateManyInput>
    /**
     * Filter which ai_analysis_audits to update
     */
    where?: ai_analysis_auditWhereInput
    /**
     * Limit how many ai_analysis_audits to update.
     */
    limit?: number
  }

  /**
   * ai_analysis_audit updateManyAndReturn
   */
  export type ai_analysis_auditUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_analysis_audit
     */
    select?: ai_analysis_auditSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ai_analysis_audit
     */
    omit?: ai_analysis_auditOmit<ExtArgs> | null
    /**
     * The data used to update ai_analysis_audits.
     */
    data: XOR<ai_analysis_auditUpdateManyMutationInput, ai_analysis_auditUncheckedUpdateManyInput>
    /**
     * Filter which ai_analysis_audits to update
     */
    where?: ai_analysis_auditWhereInput
    /**
     * Limit how many ai_analysis_audits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_analysis_auditIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ai_analysis_audit upsert
   */
  export type ai_analysis_auditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_analysis_audit
     */
    select?: ai_analysis_auditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_analysis_audit
     */
    omit?: ai_analysis_auditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_analysis_auditInclude<ExtArgs> | null
    /**
     * The filter to search for the ai_analysis_audit to update in case it exists.
     */
    where: ai_analysis_auditWhereUniqueInput
    /**
     * In case the ai_analysis_audit found by the `where` argument doesn't exist, create a new ai_analysis_audit with this data.
     */
    create: XOR<ai_analysis_auditCreateInput, ai_analysis_auditUncheckedCreateInput>
    /**
     * In case the ai_analysis_audit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ai_analysis_auditUpdateInput, ai_analysis_auditUncheckedUpdateInput>
  }

  /**
   * ai_analysis_audit delete
   */
  export type ai_analysis_auditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_analysis_audit
     */
    select?: ai_analysis_auditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_analysis_audit
     */
    omit?: ai_analysis_auditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_analysis_auditInclude<ExtArgs> | null
    /**
     * Filter which ai_analysis_audit to delete.
     */
    where: ai_analysis_auditWhereUniqueInput
  }

  /**
   * ai_analysis_audit deleteMany
   */
  export type ai_analysis_auditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_analysis_audits to delete
     */
    where?: ai_analysis_auditWhereInput
    /**
     * Limit how many ai_analysis_audits to delete.
     */
    limit?: number
  }

  /**
   * ai_analysis_audit without action
   */
  export type ai_analysis_auditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_analysis_audit
     */
    select?: ai_analysis_auditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_analysis_audit
     */
    omit?: ai_analysis_auditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_analysis_auditInclude<ExtArgs> | null
  }


  /**
   * Model ai_insight_overrides
   */

  export type AggregateAi_insight_overrides = {
    _count: Ai_insight_overridesCountAggregateOutputType | null
    _min: Ai_insight_overridesMinAggregateOutputType | null
    _max: Ai_insight_overridesMaxAggregateOutputType | null
  }

  export type Ai_insight_overridesMinAggregateOutputType = {
    id: string | null
    signalId: string | null
    insightId: string | null
    insightType: string | null
    overrideReason: string | null
    executiveJustification: string | null
    executiveId: string | null
    executiveName: string | null
    executiveEmail: string | null
    overriddenAt: Date | null
    createdAt: Date | null
  }

  export type Ai_insight_overridesMaxAggregateOutputType = {
    id: string | null
    signalId: string | null
    insightId: string | null
    insightType: string | null
    overrideReason: string | null
    executiveJustification: string | null
    executiveId: string | null
    executiveName: string | null
    executiveEmail: string | null
    overriddenAt: Date | null
    createdAt: Date | null
  }

  export type Ai_insight_overridesCountAggregateOutputType = {
    id: number
    signalId: number
    insightId: number
    insightType: number
    originalRecommendation: number
    overrideReason: number
    executiveJustification: number
    newValue: number
    executiveId: number
    executiveName: number
    executiveEmail: number
    overriddenAt: number
    createdAt: number
    _all: number
  }


  export type Ai_insight_overridesMinAggregateInputType = {
    id?: true
    signalId?: true
    insightId?: true
    insightType?: true
    overrideReason?: true
    executiveJustification?: true
    executiveId?: true
    executiveName?: true
    executiveEmail?: true
    overriddenAt?: true
    createdAt?: true
  }

  export type Ai_insight_overridesMaxAggregateInputType = {
    id?: true
    signalId?: true
    insightId?: true
    insightType?: true
    overrideReason?: true
    executiveJustification?: true
    executiveId?: true
    executiveName?: true
    executiveEmail?: true
    overriddenAt?: true
    createdAt?: true
  }

  export type Ai_insight_overridesCountAggregateInputType = {
    id?: true
    signalId?: true
    insightId?: true
    insightType?: true
    originalRecommendation?: true
    overrideReason?: true
    executiveJustification?: true
    newValue?: true
    executiveId?: true
    executiveName?: true
    executiveEmail?: true
    overriddenAt?: true
    createdAt?: true
    _all?: true
  }

  export type Ai_insight_overridesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_insight_overrides to aggregate.
     */
    where?: ai_insight_overridesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_insight_overrides to fetch.
     */
    orderBy?: ai_insight_overridesOrderByWithRelationInput | ai_insight_overridesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ai_insight_overridesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_insight_overrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_insight_overrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ai_insight_overrides
    **/
    _count?: true | Ai_insight_overridesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ai_insight_overridesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ai_insight_overridesMaxAggregateInputType
  }

  export type GetAi_insight_overridesAggregateType<T extends Ai_insight_overridesAggregateArgs> = {
        [P in keyof T & keyof AggregateAi_insight_overrides]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAi_insight_overrides[P]>
      : GetScalarType<T[P], AggregateAi_insight_overrides[P]>
  }




  export type ai_insight_overridesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_insight_overridesWhereInput
    orderBy?: ai_insight_overridesOrderByWithAggregationInput | ai_insight_overridesOrderByWithAggregationInput[]
    by: Ai_insight_overridesScalarFieldEnum[] | Ai_insight_overridesScalarFieldEnum
    having?: ai_insight_overridesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ai_insight_overridesCountAggregateInputType | true
    _min?: Ai_insight_overridesMinAggregateInputType
    _max?: Ai_insight_overridesMaxAggregateInputType
  }

  export type Ai_insight_overridesGroupByOutputType = {
    id: string
    signalId: string
    insightId: string
    insightType: string
    originalRecommendation: JsonValue | null
    overrideReason: string
    executiveJustification: string | null
    newValue: JsonValue | null
    executiveId: string
    executiveName: string
    executiveEmail: string
    overriddenAt: Date
    createdAt: Date
    _count: Ai_insight_overridesCountAggregateOutputType | null
    _min: Ai_insight_overridesMinAggregateOutputType | null
    _max: Ai_insight_overridesMaxAggregateOutputType | null
  }

  type GetAi_insight_overridesGroupByPayload<T extends ai_insight_overridesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ai_insight_overridesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ai_insight_overridesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ai_insight_overridesGroupByOutputType[P]>
            : GetScalarType<T[P], Ai_insight_overridesGroupByOutputType[P]>
        }
      >
    >


  export type ai_insight_overridesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    signalId?: boolean
    insightId?: boolean
    insightType?: boolean
    originalRecommendation?: boolean
    overrideReason?: boolean
    executiveJustification?: boolean
    newValue?: boolean
    executiveId?: boolean
    executiveName?: boolean
    executiveEmail?: boolean
    overriddenAt?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    signals?: boolean | signalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ai_insight_overrides"]>

  export type ai_insight_overridesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    signalId?: boolean
    insightId?: boolean
    insightType?: boolean
    originalRecommendation?: boolean
    overrideReason?: boolean
    executiveJustification?: boolean
    newValue?: boolean
    executiveId?: boolean
    executiveName?: boolean
    executiveEmail?: boolean
    overriddenAt?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    signals?: boolean | signalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ai_insight_overrides"]>

  export type ai_insight_overridesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    signalId?: boolean
    insightId?: boolean
    insightType?: boolean
    originalRecommendation?: boolean
    overrideReason?: boolean
    executiveJustification?: boolean
    newValue?: boolean
    executiveId?: boolean
    executiveName?: boolean
    executiveEmail?: boolean
    overriddenAt?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    signals?: boolean | signalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ai_insight_overrides"]>

  export type ai_insight_overridesSelectScalar = {
    id?: boolean
    signalId?: boolean
    insightId?: boolean
    insightType?: boolean
    originalRecommendation?: boolean
    overrideReason?: boolean
    executiveJustification?: boolean
    newValue?: boolean
    executiveId?: boolean
    executiveName?: boolean
    executiveEmail?: boolean
    overriddenAt?: boolean
    createdAt?: boolean
  }

  export type ai_insight_overridesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "signalId" | "insightId" | "insightType" | "originalRecommendation" | "overrideReason" | "executiveJustification" | "newValue" | "executiveId" | "executiveName" | "executiveEmail" | "overriddenAt" | "createdAt", ExtArgs["result"]["ai_insight_overrides"]>
  export type ai_insight_overridesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    signals?: boolean | signalsDefaultArgs<ExtArgs>
  }
  export type ai_insight_overridesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    signals?: boolean | signalsDefaultArgs<ExtArgs>
  }
  export type ai_insight_overridesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    signals?: boolean | signalsDefaultArgs<ExtArgs>
  }

  export type $ai_insight_overridesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ai_insight_overrides"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      signals: Prisma.$signalsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      signalId: string
      insightId: string
      insightType: string
      originalRecommendation: Prisma.JsonValue | null
      overrideReason: string
      executiveJustification: string | null
      newValue: Prisma.JsonValue | null
      executiveId: string
      executiveName: string
      executiveEmail: string
      overriddenAt: Date
      createdAt: Date
    }, ExtArgs["result"]["ai_insight_overrides"]>
    composites: {}
  }

  type ai_insight_overridesGetPayload<S extends boolean | null | undefined | ai_insight_overridesDefaultArgs> = $Result.GetResult<Prisma.$ai_insight_overridesPayload, S>

  type ai_insight_overridesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ai_insight_overridesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ai_insight_overridesCountAggregateInputType | true
    }

  export interface ai_insight_overridesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ai_insight_overrides'], meta: { name: 'ai_insight_overrides' } }
    /**
     * Find zero or one Ai_insight_overrides that matches the filter.
     * @param {ai_insight_overridesFindUniqueArgs} args - Arguments to find a Ai_insight_overrides
     * @example
     * // Get one Ai_insight_overrides
     * const ai_insight_overrides = await prisma.ai_insight_overrides.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ai_insight_overridesFindUniqueArgs>(args: SelectSubset<T, ai_insight_overridesFindUniqueArgs<ExtArgs>>): Prisma__ai_insight_overridesClient<$Result.GetResult<Prisma.$ai_insight_overridesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ai_insight_overrides that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ai_insight_overridesFindUniqueOrThrowArgs} args - Arguments to find a Ai_insight_overrides
     * @example
     * // Get one Ai_insight_overrides
     * const ai_insight_overrides = await prisma.ai_insight_overrides.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ai_insight_overridesFindUniqueOrThrowArgs>(args: SelectSubset<T, ai_insight_overridesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ai_insight_overridesClient<$Result.GetResult<Prisma.$ai_insight_overridesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_insight_overrides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_insight_overridesFindFirstArgs} args - Arguments to find a Ai_insight_overrides
     * @example
     * // Get one Ai_insight_overrides
     * const ai_insight_overrides = await prisma.ai_insight_overrides.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ai_insight_overridesFindFirstArgs>(args?: SelectSubset<T, ai_insight_overridesFindFirstArgs<ExtArgs>>): Prisma__ai_insight_overridesClient<$Result.GetResult<Prisma.$ai_insight_overridesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ai_insight_overrides that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_insight_overridesFindFirstOrThrowArgs} args - Arguments to find a Ai_insight_overrides
     * @example
     * // Get one Ai_insight_overrides
     * const ai_insight_overrides = await prisma.ai_insight_overrides.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ai_insight_overridesFindFirstOrThrowArgs>(args?: SelectSubset<T, ai_insight_overridesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ai_insight_overridesClient<$Result.GetResult<Prisma.$ai_insight_overridesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ai_insight_overrides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_insight_overridesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ai_insight_overrides
     * const ai_insight_overrides = await prisma.ai_insight_overrides.findMany()
     * 
     * // Get first 10 Ai_insight_overrides
     * const ai_insight_overrides = await prisma.ai_insight_overrides.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ai_insight_overridesWithIdOnly = await prisma.ai_insight_overrides.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ai_insight_overridesFindManyArgs>(args?: SelectSubset<T, ai_insight_overridesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_insight_overridesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ai_insight_overrides.
     * @param {ai_insight_overridesCreateArgs} args - Arguments to create a Ai_insight_overrides.
     * @example
     * // Create one Ai_insight_overrides
     * const Ai_insight_overrides = await prisma.ai_insight_overrides.create({
     *   data: {
     *     // ... data to create a Ai_insight_overrides
     *   }
     * })
     * 
     */
    create<T extends ai_insight_overridesCreateArgs>(args: SelectSubset<T, ai_insight_overridesCreateArgs<ExtArgs>>): Prisma__ai_insight_overridesClient<$Result.GetResult<Prisma.$ai_insight_overridesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ai_insight_overrides.
     * @param {ai_insight_overridesCreateManyArgs} args - Arguments to create many Ai_insight_overrides.
     * @example
     * // Create many Ai_insight_overrides
     * const ai_insight_overrides = await prisma.ai_insight_overrides.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ai_insight_overridesCreateManyArgs>(args?: SelectSubset<T, ai_insight_overridesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ai_insight_overrides and returns the data saved in the database.
     * @param {ai_insight_overridesCreateManyAndReturnArgs} args - Arguments to create many Ai_insight_overrides.
     * @example
     * // Create many Ai_insight_overrides
     * const ai_insight_overrides = await prisma.ai_insight_overrides.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ai_insight_overrides and only return the `id`
     * const ai_insight_overridesWithIdOnly = await prisma.ai_insight_overrides.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ai_insight_overridesCreateManyAndReturnArgs>(args?: SelectSubset<T, ai_insight_overridesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_insight_overridesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ai_insight_overrides.
     * @param {ai_insight_overridesDeleteArgs} args - Arguments to delete one Ai_insight_overrides.
     * @example
     * // Delete one Ai_insight_overrides
     * const Ai_insight_overrides = await prisma.ai_insight_overrides.delete({
     *   where: {
     *     // ... filter to delete one Ai_insight_overrides
     *   }
     * })
     * 
     */
    delete<T extends ai_insight_overridesDeleteArgs>(args: SelectSubset<T, ai_insight_overridesDeleteArgs<ExtArgs>>): Prisma__ai_insight_overridesClient<$Result.GetResult<Prisma.$ai_insight_overridesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ai_insight_overrides.
     * @param {ai_insight_overridesUpdateArgs} args - Arguments to update one Ai_insight_overrides.
     * @example
     * // Update one Ai_insight_overrides
     * const ai_insight_overrides = await prisma.ai_insight_overrides.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ai_insight_overridesUpdateArgs>(args: SelectSubset<T, ai_insight_overridesUpdateArgs<ExtArgs>>): Prisma__ai_insight_overridesClient<$Result.GetResult<Prisma.$ai_insight_overridesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ai_insight_overrides.
     * @param {ai_insight_overridesDeleteManyArgs} args - Arguments to filter Ai_insight_overrides to delete.
     * @example
     * // Delete a few Ai_insight_overrides
     * const { count } = await prisma.ai_insight_overrides.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ai_insight_overridesDeleteManyArgs>(args?: SelectSubset<T, ai_insight_overridesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_insight_overrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_insight_overridesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ai_insight_overrides
     * const ai_insight_overrides = await prisma.ai_insight_overrides.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ai_insight_overridesUpdateManyArgs>(args: SelectSubset<T, ai_insight_overridesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_insight_overrides and returns the data updated in the database.
     * @param {ai_insight_overridesUpdateManyAndReturnArgs} args - Arguments to update many Ai_insight_overrides.
     * @example
     * // Update many Ai_insight_overrides
     * const ai_insight_overrides = await prisma.ai_insight_overrides.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ai_insight_overrides and only return the `id`
     * const ai_insight_overridesWithIdOnly = await prisma.ai_insight_overrides.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ai_insight_overridesUpdateManyAndReturnArgs>(args: SelectSubset<T, ai_insight_overridesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_insight_overridesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ai_insight_overrides.
     * @param {ai_insight_overridesUpsertArgs} args - Arguments to update or create a Ai_insight_overrides.
     * @example
     * // Update or create a Ai_insight_overrides
     * const ai_insight_overrides = await prisma.ai_insight_overrides.upsert({
     *   create: {
     *     // ... data to create a Ai_insight_overrides
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ai_insight_overrides we want to update
     *   }
     * })
     */
    upsert<T extends ai_insight_overridesUpsertArgs>(args: SelectSubset<T, ai_insight_overridesUpsertArgs<ExtArgs>>): Prisma__ai_insight_overridesClient<$Result.GetResult<Prisma.$ai_insight_overridesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ai_insight_overrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_insight_overridesCountArgs} args - Arguments to filter Ai_insight_overrides to count.
     * @example
     * // Count the number of Ai_insight_overrides
     * const count = await prisma.ai_insight_overrides.count({
     *   where: {
     *     // ... the filter for the Ai_insight_overrides we want to count
     *   }
     * })
    **/
    count<T extends ai_insight_overridesCountArgs>(
      args?: Subset<T, ai_insight_overridesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ai_insight_overridesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ai_insight_overrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ai_insight_overridesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ai_insight_overridesAggregateArgs>(args: Subset<T, Ai_insight_overridesAggregateArgs>): Prisma.PrismaPromise<GetAi_insight_overridesAggregateType<T>>

    /**
     * Group by Ai_insight_overrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_insight_overridesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ai_insight_overridesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ai_insight_overridesGroupByArgs['orderBy'] }
        : { orderBy?: ai_insight_overridesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ai_insight_overridesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAi_insight_overridesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ai_insight_overrides model
   */
  readonly fields: ai_insight_overridesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ai_insight_overrides.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ai_insight_overridesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    signals<T extends signalsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, signalsDefaultArgs<ExtArgs>>): Prisma__signalsClient<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ai_insight_overrides model
   */
  interface ai_insight_overridesFieldRefs {
    readonly id: FieldRef<"ai_insight_overrides", 'String'>
    readonly signalId: FieldRef<"ai_insight_overrides", 'String'>
    readonly insightId: FieldRef<"ai_insight_overrides", 'String'>
    readonly insightType: FieldRef<"ai_insight_overrides", 'String'>
    readonly originalRecommendation: FieldRef<"ai_insight_overrides", 'Json'>
    readonly overrideReason: FieldRef<"ai_insight_overrides", 'String'>
    readonly executiveJustification: FieldRef<"ai_insight_overrides", 'String'>
    readonly newValue: FieldRef<"ai_insight_overrides", 'Json'>
    readonly executiveId: FieldRef<"ai_insight_overrides", 'String'>
    readonly executiveName: FieldRef<"ai_insight_overrides", 'String'>
    readonly executiveEmail: FieldRef<"ai_insight_overrides", 'String'>
    readonly overriddenAt: FieldRef<"ai_insight_overrides", 'DateTime'>
    readonly createdAt: FieldRef<"ai_insight_overrides", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ai_insight_overrides findUnique
   */
  export type ai_insight_overridesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insight_overrides
     */
    select?: ai_insight_overridesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insight_overrides
     */
    omit?: ai_insight_overridesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insight_overridesInclude<ExtArgs> | null
    /**
     * Filter, which ai_insight_overrides to fetch.
     */
    where: ai_insight_overridesWhereUniqueInput
  }

  /**
   * ai_insight_overrides findUniqueOrThrow
   */
  export type ai_insight_overridesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insight_overrides
     */
    select?: ai_insight_overridesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insight_overrides
     */
    omit?: ai_insight_overridesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insight_overridesInclude<ExtArgs> | null
    /**
     * Filter, which ai_insight_overrides to fetch.
     */
    where: ai_insight_overridesWhereUniqueInput
  }

  /**
   * ai_insight_overrides findFirst
   */
  export type ai_insight_overridesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insight_overrides
     */
    select?: ai_insight_overridesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insight_overrides
     */
    omit?: ai_insight_overridesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insight_overridesInclude<ExtArgs> | null
    /**
     * Filter, which ai_insight_overrides to fetch.
     */
    where?: ai_insight_overridesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_insight_overrides to fetch.
     */
    orderBy?: ai_insight_overridesOrderByWithRelationInput | ai_insight_overridesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_insight_overrides.
     */
    cursor?: ai_insight_overridesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_insight_overrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_insight_overrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_insight_overrides.
     */
    distinct?: Ai_insight_overridesScalarFieldEnum | Ai_insight_overridesScalarFieldEnum[]
  }

  /**
   * ai_insight_overrides findFirstOrThrow
   */
  export type ai_insight_overridesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insight_overrides
     */
    select?: ai_insight_overridesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insight_overrides
     */
    omit?: ai_insight_overridesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insight_overridesInclude<ExtArgs> | null
    /**
     * Filter, which ai_insight_overrides to fetch.
     */
    where?: ai_insight_overridesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_insight_overrides to fetch.
     */
    orderBy?: ai_insight_overridesOrderByWithRelationInput | ai_insight_overridesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_insight_overrides.
     */
    cursor?: ai_insight_overridesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_insight_overrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_insight_overrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_insight_overrides.
     */
    distinct?: Ai_insight_overridesScalarFieldEnum | Ai_insight_overridesScalarFieldEnum[]
  }

  /**
   * ai_insight_overrides findMany
   */
  export type ai_insight_overridesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insight_overrides
     */
    select?: ai_insight_overridesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insight_overrides
     */
    omit?: ai_insight_overridesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insight_overridesInclude<ExtArgs> | null
    /**
     * Filter, which ai_insight_overrides to fetch.
     */
    where?: ai_insight_overridesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_insight_overrides to fetch.
     */
    orderBy?: ai_insight_overridesOrderByWithRelationInput | ai_insight_overridesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ai_insight_overrides.
     */
    cursor?: ai_insight_overridesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_insight_overrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_insight_overrides.
     */
    skip?: number
    distinct?: Ai_insight_overridesScalarFieldEnum | Ai_insight_overridesScalarFieldEnum[]
  }

  /**
   * ai_insight_overrides create
   */
  export type ai_insight_overridesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insight_overrides
     */
    select?: ai_insight_overridesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insight_overrides
     */
    omit?: ai_insight_overridesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insight_overridesInclude<ExtArgs> | null
    /**
     * The data needed to create a ai_insight_overrides.
     */
    data: XOR<ai_insight_overridesCreateInput, ai_insight_overridesUncheckedCreateInput>
  }

  /**
   * ai_insight_overrides createMany
   */
  export type ai_insight_overridesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ai_insight_overrides.
     */
    data: ai_insight_overridesCreateManyInput | ai_insight_overridesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_insight_overrides createManyAndReturn
   */
  export type ai_insight_overridesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insight_overrides
     */
    select?: ai_insight_overridesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insight_overrides
     */
    omit?: ai_insight_overridesOmit<ExtArgs> | null
    /**
     * The data used to create many ai_insight_overrides.
     */
    data: ai_insight_overridesCreateManyInput | ai_insight_overridesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insight_overridesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ai_insight_overrides update
   */
  export type ai_insight_overridesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insight_overrides
     */
    select?: ai_insight_overridesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insight_overrides
     */
    omit?: ai_insight_overridesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insight_overridesInclude<ExtArgs> | null
    /**
     * The data needed to update a ai_insight_overrides.
     */
    data: XOR<ai_insight_overridesUpdateInput, ai_insight_overridesUncheckedUpdateInput>
    /**
     * Choose, which ai_insight_overrides to update.
     */
    where: ai_insight_overridesWhereUniqueInput
  }

  /**
   * ai_insight_overrides updateMany
   */
  export type ai_insight_overridesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ai_insight_overrides.
     */
    data: XOR<ai_insight_overridesUpdateManyMutationInput, ai_insight_overridesUncheckedUpdateManyInput>
    /**
     * Filter which ai_insight_overrides to update
     */
    where?: ai_insight_overridesWhereInput
    /**
     * Limit how many ai_insight_overrides to update.
     */
    limit?: number
  }

  /**
   * ai_insight_overrides updateManyAndReturn
   */
  export type ai_insight_overridesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insight_overrides
     */
    select?: ai_insight_overridesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insight_overrides
     */
    omit?: ai_insight_overridesOmit<ExtArgs> | null
    /**
     * The data used to update ai_insight_overrides.
     */
    data: XOR<ai_insight_overridesUpdateManyMutationInput, ai_insight_overridesUncheckedUpdateManyInput>
    /**
     * Filter which ai_insight_overrides to update
     */
    where?: ai_insight_overridesWhereInput
    /**
     * Limit how many ai_insight_overrides to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insight_overridesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ai_insight_overrides upsert
   */
  export type ai_insight_overridesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insight_overrides
     */
    select?: ai_insight_overridesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insight_overrides
     */
    omit?: ai_insight_overridesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insight_overridesInclude<ExtArgs> | null
    /**
     * The filter to search for the ai_insight_overrides to update in case it exists.
     */
    where: ai_insight_overridesWhereUniqueInput
    /**
     * In case the ai_insight_overrides found by the `where` argument doesn't exist, create a new ai_insight_overrides with this data.
     */
    create: XOR<ai_insight_overridesCreateInput, ai_insight_overridesUncheckedCreateInput>
    /**
     * In case the ai_insight_overrides was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ai_insight_overridesUpdateInput, ai_insight_overridesUncheckedUpdateInput>
  }

  /**
   * ai_insight_overrides delete
   */
  export type ai_insight_overridesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insight_overrides
     */
    select?: ai_insight_overridesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insight_overrides
     */
    omit?: ai_insight_overridesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insight_overridesInclude<ExtArgs> | null
    /**
     * Filter which ai_insight_overrides to delete.
     */
    where: ai_insight_overridesWhereUniqueInput
  }

  /**
   * ai_insight_overrides deleteMany
   */
  export type ai_insight_overridesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_insight_overrides to delete
     */
    where?: ai_insight_overridesWhereInput
    /**
     * Limit how many ai_insight_overrides to delete.
     */
    limit?: number
  }

  /**
   * ai_insight_overrides without action
   */
  export type ai_insight_overridesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insight_overrides
     */
    select?: ai_insight_overridesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insight_overrides
     */
    omit?: ai_insight_overridesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insight_overridesInclude<ExtArgs> | null
  }


  /**
   * Model audit_logs
   */

  export type AggregateAudit_logs = {
    _count: Audit_logsCountAggregateOutputType | null
    _min: Audit_logsMinAggregateOutputType | null
    _max: Audit_logsMaxAggregateOutputType | null
  }

  export type Audit_logsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    sessionId: string | null
  }

  export type Audit_logsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    sessionId: string | null
  }

  export type Audit_logsCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entityType: number
    entityId: number
    changes: number
    ipAddress: number
    userAgent: number
    createdAt: number
    sessionId: number
    _all: number
  }


  export type Audit_logsMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    sessionId?: true
  }

  export type Audit_logsMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    sessionId?: true
  }

  export type Audit_logsCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    changes?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    sessionId?: true
    _all?: true
  }

  export type Audit_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which audit_logs to aggregate.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned audit_logs
    **/
    _count?: true | Audit_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Audit_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Audit_logsMaxAggregateInputType
  }

  export type GetAudit_logsAggregateType<T extends Audit_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateAudit_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudit_logs[P]>
      : GetScalarType<T[P], AggregateAudit_logs[P]>
  }




  export type audit_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: audit_logsWhereInput
    orderBy?: audit_logsOrderByWithAggregationInput | audit_logsOrderByWithAggregationInput[]
    by: Audit_logsScalarFieldEnum[] | Audit_logsScalarFieldEnum
    having?: audit_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Audit_logsCountAggregateInputType | true
    _min?: Audit_logsMinAggregateInputType
    _max?: Audit_logsMaxAggregateInputType
  }

  export type Audit_logsGroupByOutputType = {
    id: string
    userId: string
    action: string
    entityType: string
    entityId: string
    changes: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    sessionId: string | null
    _count: Audit_logsCountAggregateOutputType | null
    _min: Audit_logsMinAggregateOutputType | null
    _max: Audit_logsMaxAggregateOutputType | null
  }

  type GetAudit_logsGroupByPayload<T extends audit_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Audit_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Audit_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Audit_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Audit_logsGroupByOutputType[P]>
        }
      >
    >


  export type audit_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    sessionId?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audit_logs"]>

  export type audit_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    sessionId?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audit_logs"]>

  export type audit_logsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    sessionId?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audit_logs"]>

  export type audit_logsSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    sessionId?: boolean
  }

  export type audit_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entityType" | "entityId" | "changes" | "ipAddress" | "userAgent" | "createdAt" | "sessionId", ExtArgs["result"]["audit_logs"]>
  export type audit_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type audit_logsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type audit_logsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $audit_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "audit_logs"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      entityType: string
      entityId: string
      changes: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      sessionId: string | null
    }, ExtArgs["result"]["audit_logs"]>
    composites: {}
  }

  type audit_logsGetPayload<S extends boolean | null | undefined | audit_logsDefaultArgs> = $Result.GetResult<Prisma.$audit_logsPayload, S>

  type audit_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<audit_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Audit_logsCountAggregateInputType | true
    }

  export interface audit_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['audit_logs'], meta: { name: 'audit_logs' } }
    /**
     * Find zero or one Audit_logs that matches the filter.
     * @param {audit_logsFindUniqueArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends audit_logsFindUniqueArgs>(args: SelectSubset<T, audit_logsFindUniqueArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Audit_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {audit_logsFindUniqueOrThrowArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends audit_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, audit_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsFindFirstArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends audit_logsFindFirstArgs>(args?: SelectSubset<T, audit_logsFindFirstArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsFindFirstOrThrowArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends audit_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, audit_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Audit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Audit_logs
     * const audit_logs = await prisma.audit_logs.findMany()
     * 
     * // Get first 10 Audit_logs
     * const audit_logs = await prisma.audit_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audit_logsWithIdOnly = await prisma.audit_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends audit_logsFindManyArgs>(args?: SelectSubset<T, audit_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Audit_logs.
     * @param {audit_logsCreateArgs} args - Arguments to create a Audit_logs.
     * @example
     * // Create one Audit_logs
     * const Audit_logs = await prisma.audit_logs.create({
     *   data: {
     *     // ... data to create a Audit_logs
     *   }
     * })
     * 
     */
    create<T extends audit_logsCreateArgs>(args: SelectSubset<T, audit_logsCreateArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Audit_logs.
     * @param {audit_logsCreateManyArgs} args - Arguments to create many Audit_logs.
     * @example
     * // Create many Audit_logs
     * const audit_logs = await prisma.audit_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends audit_logsCreateManyArgs>(args?: SelectSubset<T, audit_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Audit_logs and returns the data saved in the database.
     * @param {audit_logsCreateManyAndReturnArgs} args - Arguments to create many Audit_logs.
     * @example
     * // Create many Audit_logs
     * const audit_logs = await prisma.audit_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Audit_logs and only return the `id`
     * const audit_logsWithIdOnly = await prisma.audit_logs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends audit_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, audit_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Audit_logs.
     * @param {audit_logsDeleteArgs} args - Arguments to delete one Audit_logs.
     * @example
     * // Delete one Audit_logs
     * const Audit_logs = await prisma.audit_logs.delete({
     *   where: {
     *     // ... filter to delete one Audit_logs
     *   }
     * })
     * 
     */
    delete<T extends audit_logsDeleteArgs>(args: SelectSubset<T, audit_logsDeleteArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Audit_logs.
     * @param {audit_logsUpdateArgs} args - Arguments to update one Audit_logs.
     * @example
     * // Update one Audit_logs
     * const audit_logs = await prisma.audit_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends audit_logsUpdateArgs>(args: SelectSubset<T, audit_logsUpdateArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Audit_logs.
     * @param {audit_logsDeleteManyArgs} args - Arguments to filter Audit_logs to delete.
     * @example
     * // Delete a few Audit_logs
     * const { count } = await prisma.audit_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends audit_logsDeleteManyArgs>(args?: SelectSubset<T, audit_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Audit_logs
     * const audit_logs = await prisma.audit_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends audit_logsUpdateManyArgs>(args: SelectSubset<T, audit_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audit_logs and returns the data updated in the database.
     * @param {audit_logsUpdateManyAndReturnArgs} args - Arguments to update many Audit_logs.
     * @example
     * // Update many Audit_logs
     * const audit_logs = await prisma.audit_logs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Audit_logs and only return the `id`
     * const audit_logsWithIdOnly = await prisma.audit_logs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends audit_logsUpdateManyAndReturnArgs>(args: SelectSubset<T, audit_logsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Audit_logs.
     * @param {audit_logsUpsertArgs} args - Arguments to update or create a Audit_logs.
     * @example
     * // Update or create a Audit_logs
     * const audit_logs = await prisma.audit_logs.upsert({
     *   create: {
     *     // ... data to create a Audit_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Audit_logs we want to update
     *   }
     * })
     */
    upsert<T extends audit_logsUpsertArgs>(args: SelectSubset<T, audit_logsUpsertArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsCountArgs} args - Arguments to filter Audit_logs to count.
     * @example
     * // Count the number of Audit_logs
     * const count = await prisma.audit_logs.count({
     *   where: {
     *     // ... the filter for the Audit_logs we want to count
     *   }
     * })
    **/
    count<T extends audit_logsCountArgs>(
      args?: Subset<T, audit_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Audit_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Audit_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Audit_logsAggregateArgs>(args: Subset<T, Audit_logsAggregateArgs>): Prisma.PrismaPromise<GetAudit_logsAggregateType<T>>

    /**
     * Group by Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends audit_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: audit_logsGroupByArgs['orderBy'] }
        : { orderBy?: audit_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, audit_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudit_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the audit_logs model
   */
  readonly fields: audit_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for audit_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__audit_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the audit_logs model
   */
  interface audit_logsFieldRefs {
    readonly id: FieldRef<"audit_logs", 'String'>
    readonly userId: FieldRef<"audit_logs", 'String'>
    readonly action: FieldRef<"audit_logs", 'String'>
    readonly entityType: FieldRef<"audit_logs", 'String'>
    readonly entityId: FieldRef<"audit_logs", 'String'>
    readonly changes: FieldRef<"audit_logs", 'Json'>
    readonly ipAddress: FieldRef<"audit_logs", 'String'>
    readonly userAgent: FieldRef<"audit_logs", 'String'>
    readonly createdAt: FieldRef<"audit_logs", 'DateTime'>
    readonly sessionId: FieldRef<"audit_logs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * audit_logs findUnique
   */
  export type audit_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs findUniqueOrThrow
   */
  export type audit_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs findFirst
   */
  export type audit_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audit_logs.
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audit_logs.
     */
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }

  /**
   * audit_logs findFirstOrThrow
   */
  export type audit_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audit_logs.
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audit_logs.
     */
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }

  /**
   * audit_logs findMany
   */
  export type audit_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing audit_logs.
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }

  /**
   * audit_logs create
   */
  export type audit_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a audit_logs.
     */
    data: XOR<audit_logsCreateInput, audit_logsUncheckedCreateInput>
  }

  /**
   * audit_logs createMany
   */
  export type audit_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many audit_logs.
     */
    data: audit_logsCreateManyInput | audit_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * audit_logs createManyAndReturn
   */
  export type audit_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * The data used to create many audit_logs.
     */
    data: audit_logsCreateManyInput | audit_logsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * audit_logs update
   */
  export type audit_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a audit_logs.
     */
    data: XOR<audit_logsUpdateInput, audit_logsUncheckedUpdateInput>
    /**
     * Choose, which audit_logs to update.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs updateMany
   */
  export type audit_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update audit_logs.
     */
    data: XOR<audit_logsUpdateManyMutationInput, audit_logsUncheckedUpdateManyInput>
    /**
     * Filter which audit_logs to update
     */
    where?: audit_logsWhereInput
    /**
     * Limit how many audit_logs to update.
     */
    limit?: number
  }

  /**
   * audit_logs updateManyAndReturn
   */
  export type audit_logsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * The data used to update audit_logs.
     */
    data: XOR<audit_logsUpdateManyMutationInput, audit_logsUncheckedUpdateManyInput>
    /**
     * Filter which audit_logs to update
     */
    where?: audit_logsWhereInput
    /**
     * Limit how many audit_logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * audit_logs upsert
   */
  export type audit_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the audit_logs to update in case it exists.
     */
    where: audit_logsWhereUniqueInput
    /**
     * In case the audit_logs found by the `where` argument doesn't exist, create a new audit_logs with this data.
     */
    create: XOR<audit_logsCreateInput, audit_logsUncheckedCreateInput>
    /**
     * In case the audit_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<audit_logsUpdateInput, audit_logsUncheckedUpdateInput>
  }

  /**
   * audit_logs delete
   */
  export type audit_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter which audit_logs to delete.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs deleteMany
   */
  export type audit_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which audit_logs to delete
     */
    where?: audit_logsWhereInput
    /**
     * Limit how many audit_logs to delete.
     */
    limit?: number
  }

  /**
   * audit_logs without action
   */
  export type audit_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
  }


  /**
   * Model categories
   */

  export type AggregateCategories = {
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  export type CategoriesAvgAggregateOutputType = {
    sortOrder: number | null
    usageCount: number | null
  }

  export type CategoriesSumAggregateOutputType = {
    sortOrder: number | null
    usageCount: number | null
  }

  export type CategoriesMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    color: string | null
    icon: string | null
    parentId: string | null
    isActive: boolean | null
    sortOrder: number | null
    usageCount: number | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoriesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    color: string | null
    icon: string | null
    parentId: string | null
    isActive: boolean | null
    sortOrder: number | null
    usageCount: number | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoriesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    color: number
    icon: number
    parentId: number
    isActive: number
    sortOrder: number
    usageCount: number
    isSystem: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoriesAvgAggregateInputType = {
    sortOrder?: true
    usageCount?: true
  }

  export type CategoriesSumAggregateInputType = {
    sortOrder?: true
    usageCount?: true
  }

  export type CategoriesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    icon?: true
    parentId?: true
    isActive?: true
    sortOrder?: true
    usageCount?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoriesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    icon?: true
    parentId?: true
    isActive?: true
    sortOrder?: true
    usageCount?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoriesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    icon?: true
    parentId?: true
    isActive?: true
    sortOrder?: true
    usageCount?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to aggregate.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    _count?: true | CategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriesMaxAggregateInputType
  }

  export type GetCategoriesAggregateType<T extends CategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategories[P]>
      : GetScalarType<T[P], AggregateCategories[P]>
  }




  export type categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriesWhereInput
    orderBy?: categoriesOrderByWithAggregationInput | categoriesOrderByWithAggregationInput[]
    by: CategoriesScalarFieldEnum[] | CategoriesScalarFieldEnum
    having?: categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriesCountAggregateInputType | true
    _avg?: CategoriesAvgAggregateInputType
    _sum?: CategoriesSumAggregateInputType
    _min?: CategoriesMinAggregateInputType
    _max?: CategoriesMaxAggregateInputType
  }

  export type CategoriesGroupByOutputType = {
    id: string
    name: string
    description: string | null
    color: string | null
    icon: string | null
    parentId: string | null
    isActive: boolean
    sortOrder: number
    usageCount: number
    isSystem: boolean
    createdAt: Date
    updatedAt: Date
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  type GetCategoriesGroupByPayload<T extends categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
        }
      >
    >


  export type categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    parentId?: boolean
    isActive?: boolean
    sortOrder?: boolean
    usageCount?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categories?: boolean | categories$categoriesArgs<ExtArgs>
    other_categories?: boolean | categories$other_categoriesArgs<ExtArgs>
    signals?: boolean | categories$signalsArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>

  export type categoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    parentId?: boolean
    isActive?: boolean
    sortOrder?: boolean
    usageCount?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categories?: boolean | categories$categoriesArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>

  export type categoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    parentId?: boolean
    isActive?: boolean
    sortOrder?: boolean
    usageCount?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categories?: boolean | categories$categoriesArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>

  export type categoriesSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    parentId?: boolean
    isActive?: boolean
    sortOrder?: boolean
    usageCount?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "color" | "icon" | "parentId" | "isActive" | "sortOrder" | "usageCount" | "isSystem" | "createdAt" | "updatedAt", ExtArgs["result"]["categories"]>
  export type categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | categories$categoriesArgs<ExtArgs>
    other_categories?: boolean | categories$other_categoriesArgs<ExtArgs>
    signals?: boolean | categories$signalsArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type categoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | categories$categoriesArgs<ExtArgs>
  }
  export type categoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | categories$categoriesArgs<ExtArgs>
  }

  export type $categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "categories"
    objects: {
      categories: Prisma.$categoriesPayload<ExtArgs> | null
      other_categories: Prisma.$categoriesPayload<ExtArgs>[]
      signals: Prisma.$signalsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      color: string | null
      icon: string | null
      parentId: string | null
      isActive: boolean
      sortOrder: number
      usageCount: number
      isSystem: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["categories"]>
    composites: {}
  }

  type categoriesGetPayload<S extends boolean | null | undefined | categoriesDefaultArgs> = $Result.GetResult<Prisma.$categoriesPayload, S>

  type categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriesCountAggregateInputType | true
    }

  export interface categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['categories'], meta: { name: 'categories' } }
    /**
     * Find zero or one Categories that matches the filter.
     * @param {categoriesFindUniqueArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoriesFindUniqueArgs>(args: SelectSubset<T, categoriesFindUniqueArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {categoriesFindUniqueOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindFirstArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoriesFindFirstArgs>(args?: SelectSubset<T, categoriesFindFirstArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindFirstOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.categories.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriesWithIdOnly = await prisma.categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends categoriesFindManyArgs>(args?: SelectSubset<T, categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Categories.
     * @param {categoriesCreateArgs} args - Arguments to create a Categories.
     * @example
     * // Create one Categories
     * const Categories = await prisma.categories.create({
     *   data: {
     *     // ... data to create a Categories
     *   }
     * })
     * 
     */
    create<T extends categoriesCreateArgs>(args: SelectSubset<T, categoriesCreateArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {categoriesCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoriesCreateManyArgs>(args?: SelectSubset<T, categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {categoriesCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoriesWithIdOnly = await prisma.categories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends categoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, categoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Categories.
     * @param {categoriesDeleteArgs} args - Arguments to delete one Categories.
     * @example
     * // Delete one Categories
     * const Categories = await prisma.categories.delete({
     *   where: {
     *     // ... filter to delete one Categories
     *   }
     * })
     * 
     */
    delete<T extends categoriesDeleteArgs>(args: SelectSubset<T, categoriesDeleteArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Categories.
     * @param {categoriesUpdateArgs} args - Arguments to update one Categories.
     * @example
     * // Update one Categories
     * const categories = await prisma.categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoriesUpdateArgs>(args: SelectSubset<T, categoriesUpdateArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {categoriesDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoriesDeleteManyArgs>(args?: SelectSubset<T, categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoriesUpdateManyArgs>(args: SelectSubset<T, categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {categoriesUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoriesWithIdOnly = await prisma.categories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends categoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, categoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Categories.
     * @param {categoriesUpsertArgs} args - Arguments to update or create a Categories.
     * @example
     * // Update or create a Categories
     * const categories = await prisma.categories.upsert({
     *   create: {
     *     // ... data to create a Categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categories we want to update
     *   }
     * })
     */
    upsert<T extends categoriesUpsertArgs>(args: SelectSubset<T, categoriesUpsertArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.categories.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoriesCountArgs>(
      args?: Subset<T, categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriesAggregateArgs>(args: Subset<T, CategoriesAggregateArgs>): Prisma.PrismaPromise<GetCategoriesAggregateType<T>>

    /**
     * Group by Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoriesGroupByArgs['orderBy'] }
        : { orderBy?: categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the categories model
   */
  readonly fields: categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends categories$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, categories$categoriesArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_categories<T extends categories$other_categoriesArgs<ExtArgs> = {}>(args?: Subset<T, categories$other_categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    signals<T extends categories$signalsArgs<ExtArgs> = {}>(args?: Subset<T, categories$signalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the categories model
   */
  interface categoriesFieldRefs {
    readonly id: FieldRef<"categories", 'String'>
    readonly name: FieldRef<"categories", 'String'>
    readonly description: FieldRef<"categories", 'String'>
    readonly color: FieldRef<"categories", 'String'>
    readonly icon: FieldRef<"categories", 'String'>
    readonly parentId: FieldRef<"categories", 'String'>
    readonly isActive: FieldRef<"categories", 'Boolean'>
    readonly sortOrder: FieldRef<"categories", 'Int'>
    readonly usageCount: FieldRef<"categories", 'Int'>
    readonly isSystem: FieldRef<"categories", 'Boolean'>
    readonly createdAt: FieldRef<"categories", 'DateTime'>
    readonly updatedAt: FieldRef<"categories", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * categories findUnique
   */
  export type categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories findUniqueOrThrow
   */
  export type categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories findFirst
   */
  export type categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories findFirstOrThrow
   */
  export type categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories findMany
   */
  export type categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories create
   */
  export type categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a categories.
     */
    data: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>
  }

  /**
   * categories createMany
   */
  export type categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categories.
     */
    data: categoriesCreateManyInput | categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categories createManyAndReturn
   */
  export type categoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * The data used to create many categories.
     */
    data: categoriesCreateManyInput | categoriesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * categories update
   */
  export type categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a categories.
     */
    data: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>
    /**
     * Choose, which categories to update.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories updateMany
   */
  export type categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categories.
     */
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoriesWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
  }

  /**
   * categories updateManyAndReturn
   */
  export type categoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * The data used to update categories.
     */
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoriesWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * categories upsert
   */
  export type categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the categories to update in case it exists.
     */
    where: categoriesWhereUniqueInput
    /**
     * In case the categories found by the `where` argument doesn't exist, create a new categories with this data.
     */
    create: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>
    /**
     * In case the categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>
  }

  /**
   * categories delete
   */
  export type categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter which categories to delete.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories deleteMany
   */
  export type categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to delete
     */
    where?: categoriesWhereInput
    /**
     * Limit how many categories to delete.
     */
    limit?: number
  }

  /**
   * categories.categories
   */
  export type categories$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    where?: categoriesWhereInput
  }

  /**
   * categories.other_categories
   */
  export type categories$other_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    where?: categoriesWhereInput
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    cursor?: categoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories.signals
   */
  export type categories$signalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: signalsInclude<ExtArgs> | null
    where?: signalsWhereInput
    orderBy?: signalsOrderByWithRelationInput | signalsOrderByWithRelationInput[]
    cursor?: signalsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SignalsScalarFieldEnum | SignalsScalarFieldEnum[]
  }

  /**
   * categories without action
   */
  export type categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
  }


  /**
   * Model comments
   */

  export type AggregateComments = {
    _count: CommentsCountAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  export type CommentsMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    parentId: string | null
    createdBy: string | null
    edited: boolean | null
    editedAt: Date | null
    entityId: string | null
    entityType: $Enums.EntityType | null
  }

  export type CommentsMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    parentId: string | null
    createdBy: string | null
    edited: boolean | null
    editedAt: Date | null
    entityId: string | null
    entityType: $Enums.EntityType | null
  }

  export type CommentsCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    updatedAt: number
    parentId: number
    createdBy: number
    edited: number
    editedAt: number
    entityId: number
    entityType: number
    mentions: number
    _all: number
  }


  export type CommentsMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    createdBy?: true
    edited?: true
    editedAt?: true
    entityId?: true
    entityType?: true
  }

  export type CommentsMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    createdBy?: true
    edited?: true
    editedAt?: true
    entityId?: true
    entityType?: true
  }

  export type CommentsCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    createdBy?: true
    edited?: true
    editedAt?: true
    entityId?: true
    entityType?: true
    mentions?: true
    _all?: true
  }

  export type CommentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comments to aggregate.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comments
    **/
    _count?: true | CommentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentsMaxAggregateInputType
  }

  export type GetCommentsAggregateType<T extends CommentsAggregateArgs> = {
        [P in keyof T & keyof AggregateComments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComments[P]>
      : GetScalarType<T[P], AggregateComments[P]>
  }




  export type commentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
    orderBy?: commentsOrderByWithAggregationInput | commentsOrderByWithAggregationInput[]
    by: CommentsScalarFieldEnum[] | CommentsScalarFieldEnum
    having?: commentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentsCountAggregateInputType | true
    _min?: CommentsMinAggregateInputType
    _max?: CommentsMaxAggregateInputType
  }

  export type CommentsGroupByOutputType = {
    id: string
    content: string
    createdAt: Date
    updatedAt: Date
    parentId: string | null
    createdBy: string
    edited: boolean
    editedAt: Date | null
    entityId: string
    entityType: $Enums.EntityType
    mentions: JsonValue | null
    _count: CommentsCountAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  type GetCommentsGroupByPayload<T extends commentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentsGroupByOutputType[P]>
            : GetScalarType<T[P], CommentsGroupByOutputType[P]>
        }
      >
    >


  export type commentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    createdBy?: boolean
    edited?: boolean
    editedAt?: boolean
    entityId?: boolean
    entityType?: boolean
    mentions?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    comments?: boolean | comments$commentsArgs<ExtArgs>
    other_comments?: boolean | comments$other_commentsArgs<ExtArgs>
    _count?: boolean | CommentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>

  export type commentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    createdBy?: boolean
    edited?: boolean
    editedAt?: boolean
    entityId?: boolean
    entityType?: boolean
    mentions?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    comments?: boolean | comments$commentsArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>

  export type commentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    createdBy?: boolean
    edited?: boolean
    editedAt?: boolean
    entityId?: boolean
    entityType?: boolean
    mentions?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    comments?: boolean | comments$commentsArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>

  export type commentsSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    createdBy?: boolean
    edited?: boolean
    editedAt?: boolean
    entityId?: boolean
    entityType?: boolean
    mentions?: boolean
  }

  export type commentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "createdAt" | "updatedAt" | "parentId" | "createdBy" | "edited" | "editedAt" | "entityId" | "entityType" | "mentions", ExtArgs["result"]["comments"]>
  export type commentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    comments?: boolean | comments$commentsArgs<ExtArgs>
    other_comments?: boolean | comments$other_commentsArgs<ExtArgs>
    _count?: boolean | CommentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type commentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    comments?: boolean | comments$commentsArgs<ExtArgs>
  }
  export type commentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    comments?: boolean | comments$commentsArgs<ExtArgs>
  }

  export type $commentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "comments"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      comments: Prisma.$commentsPayload<ExtArgs> | null
      other_comments: Prisma.$commentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: Date
      updatedAt: Date
      parentId: string | null
      createdBy: string
      edited: boolean
      editedAt: Date | null
      entityId: string
      entityType: $Enums.EntityType
      mentions: Prisma.JsonValue | null
    }, ExtArgs["result"]["comments"]>
    composites: {}
  }

  type commentsGetPayload<S extends boolean | null | undefined | commentsDefaultArgs> = $Result.GetResult<Prisma.$commentsPayload, S>

  type commentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<commentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentsCountAggregateInputType | true
    }

  export interface commentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comments'], meta: { name: 'comments' } }
    /**
     * Find zero or one Comments that matches the filter.
     * @param {commentsFindUniqueArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends commentsFindUniqueArgs>(args: SelectSubset<T, commentsFindUniqueArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {commentsFindUniqueOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends commentsFindUniqueOrThrowArgs>(args: SelectSubset<T, commentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindFirstArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends commentsFindFirstArgs>(args?: SelectSubset<T, commentsFindFirstArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindFirstOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends commentsFindFirstOrThrowArgs>(args?: SelectSubset<T, commentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comments.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentsWithIdOnly = await prisma.comments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends commentsFindManyArgs>(args?: SelectSubset<T, commentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comments.
     * @param {commentsCreateArgs} args - Arguments to create a Comments.
     * @example
     * // Create one Comments
     * const Comments = await prisma.comments.create({
     *   data: {
     *     // ... data to create a Comments
     *   }
     * })
     * 
     */
    create<T extends commentsCreateArgs>(args: SelectSubset<T, commentsCreateArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {commentsCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comments = await prisma.comments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends commentsCreateManyArgs>(args?: SelectSubset<T, commentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {commentsCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comments = await prisma.comments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentsWithIdOnly = await prisma.comments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends commentsCreateManyAndReturnArgs>(args?: SelectSubset<T, commentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comments.
     * @param {commentsDeleteArgs} args - Arguments to delete one Comments.
     * @example
     * // Delete one Comments
     * const Comments = await prisma.comments.delete({
     *   where: {
     *     // ... filter to delete one Comments
     *   }
     * })
     * 
     */
    delete<T extends commentsDeleteArgs>(args: SelectSubset<T, commentsDeleteArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comments.
     * @param {commentsUpdateArgs} args - Arguments to update one Comments.
     * @example
     * // Update one Comments
     * const comments = await prisma.comments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends commentsUpdateArgs>(args: SelectSubset<T, commentsUpdateArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {commentsDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends commentsDeleteManyArgs>(args?: SelectSubset<T, commentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comments = await prisma.comments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends commentsUpdateManyArgs>(args: SelectSubset<T, commentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {commentsUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comments = await prisma.comments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentsWithIdOnly = await prisma.comments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends commentsUpdateManyAndReturnArgs>(args: SelectSubset<T, commentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comments.
     * @param {commentsUpsertArgs} args - Arguments to update or create a Comments.
     * @example
     * // Update or create a Comments
     * const comments = await prisma.comments.upsert({
     *   create: {
     *     // ... data to create a Comments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comments we want to update
     *   }
     * })
     */
    upsert<T extends commentsUpsertArgs>(args: SelectSubset<T, commentsUpsertArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comments.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends commentsCountArgs>(
      args?: Subset<T, commentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentsAggregateArgs>(args: Subset<T, CommentsAggregateArgs>): Prisma.PrismaPromise<GetCommentsAggregateType<T>>

    /**
     * Group by Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends commentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: commentsGroupByArgs['orderBy'] }
        : { orderBy?: commentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, commentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the comments model
   */
  readonly fields: commentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for comments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__commentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    comments<T extends comments$commentsArgs<ExtArgs> = {}>(args?: Subset<T, comments$commentsArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_comments<T extends comments$other_commentsArgs<ExtArgs> = {}>(args?: Subset<T, comments$other_commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the comments model
   */
  interface commentsFieldRefs {
    readonly id: FieldRef<"comments", 'String'>
    readonly content: FieldRef<"comments", 'String'>
    readonly createdAt: FieldRef<"comments", 'DateTime'>
    readonly updatedAt: FieldRef<"comments", 'DateTime'>
    readonly parentId: FieldRef<"comments", 'String'>
    readonly createdBy: FieldRef<"comments", 'String'>
    readonly edited: FieldRef<"comments", 'Boolean'>
    readonly editedAt: FieldRef<"comments", 'DateTime'>
    readonly entityId: FieldRef<"comments", 'String'>
    readonly entityType: FieldRef<"comments", 'EntityType'>
    readonly mentions: FieldRef<"comments", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * comments findUnique
   */
  export type commentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where: commentsWhereUniqueInput
  }

  /**
   * comments findUniqueOrThrow
   */
  export type commentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where: commentsWhereUniqueInput
  }

  /**
   * comments findFirst
   */
  export type commentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comments.
     */
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * comments findFirstOrThrow
   */
  export type commentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comments.
     */
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * comments findMany
   */
  export type commentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * comments create
   */
  export type commentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * The data needed to create a comments.
     */
    data: XOR<commentsCreateInput, commentsUncheckedCreateInput>
  }

  /**
   * comments createMany
   */
  export type commentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comments.
     */
    data: commentsCreateManyInput | commentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * comments createManyAndReturn
   */
  export type commentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * The data used to create many comments.
     */
    data: commentsCreateManyInput | commentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * comments update
   */
  export type commentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * The data needed to update a comments.
     */
    data: XOR<commentsUpdateInput, commentsUncheckedUpdateInput>
    /**
     * Choose, which comments to update.
     */
    where: commentsWhereUniqueInput
  }

  /**
   * comments updateMany
   */
  export type commentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comments.
     */
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyInput>
    /**
     * Filter which comments to update
     */
    where?: commentsWhereInput
    /**
     * Limit how many comments to update.
     */
    limit?: number
  }

  /**
   * comments updateManyAndReturn
   */
  export type commentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * The data used to update comments.
     */
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyInput>
    /**
     * Filter which comments to update
     */
    where?: commentsWhereInput
    /**
     * Limit how many comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * comments upsert
   */
  export type commentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * The filter to search for the comments to update in case it exists.
     */
    where: commentsWhereUniqueInput
    /**
     * In case the comments found by the `where` argument doesn't exist, create a new comments with this data.
     */
    create: XOR<commentsCreateInput, commentsUncheckedCreateInput>
    /**
     * In case the comments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<commentsUpdateInput, commentsUncheckedUpdateInput>
  }

  /**
   * comments delete
   */
  export type commentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter which comments to delete.
     */
    where: commentsWhereUniqueInput
  }

  /**
   * comments deleteMany
   */
  export type commentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comments to delete
     */
    where?: commentsWhereInput
    /**
     * Limit how many comments to delete.
     */
    limit?: number
  }

  /**
   * comments.comments
   */
  export type comments$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    where?: commentsWhereInput
  }

  /**
   * comments.other_comments
   */
  export type comments$other_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    where?: commentsWhereInput
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    cursor?: commentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * comments without action
   */
  export type commentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
  }


  /**
   * Model departments
   */

  export type AggregateDepartments = {
    _count: DepartmentsCountAggregateOutputType | null
    _avg: DepartmentsAvgAggregateOutputType | null
    _sum: DepartmentsSumAggregateOutputType | null
    _min: DepartmentsMinAggregateOutputType | null
    _max: DepartmentsMaxAggregateOutputType | null
  }

  export type DepartmentsAvgAggregateOutputType = {
    headCount: number | null
    budgetAllocation: number | null
    utilizationTarget: number | null
    actualUtilization: number | null
  }

  export type DepartmentsSumAggregateOutputType = {
    headCount: number | null
    budgetAllocation: number | null
    utilizationTarget: number | null
    actualUtilization: number | null
  }

  export type DepartmentsMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    headCount: number | null
    budgetAllocation: number | null
    managerId: string | null
    costCenter: string | null
    location: string | null
    isActive: boolean | null
    utilizationTarget: number | null
    actualUtilization: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    headCount: number | null
    budgetAllocation: number | null
    managerId: string | null
    costCenter: string | null
    location: string | null
    isActive: boolean | null
    utilizationTarget: number | null
    actualUtilization: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    headCount: number
    budgetAllocation: number
    managerId: number
    costCenter: number
    location: number
    isActive: number
    utilizationTarget: number
    actualUtilization: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentsAvgAggregateInputType = {
    headCount?: true
    budgetAllocation?: true
    utilizationTarget?: true
    actualUtilization?: true
  }

  export type DepartmentsSumAggregateInputType = {
    headCount?: true
    budgetAllocation?: true
    utilizationTarget?: true
    actualUtilization?: true
  }

  export type DepartmentsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    headCount?: true
    budgetAllocation?: true
    managerId?: true
    costCenter?: true
    location?: true
    isActive?: true
    utilizationTarget?: true
    actualUtilization?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    headCount?: true
    budgetAllocation?: true
    managerId?: true
    costCenter?: true
    location?: true
    isActive?: true
    utilizationTarget?: true
    actualUtilization?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    headCount?: true
    budgetAllocation?: true
    managerId?: true
    costCenter?: true
    location?: true
    isActive?: true
    utilizationTarget?: true
    actualUtilization?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which departments to aggregate.
     */
    where?: departmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentsOrderByWithRelationInput | departmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: departmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned departments
    **/
    _count?: true | DepartmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentsMaxAggregateInputType
  }

  export type GetDepartmentsAggregateType<T extends DepartmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartments[P]>
      : GetScalarType<T[P], AggregateDepartments[P]>
  }




  export type departmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: departmentsWhereInput
    orderBy?: departmentsOrderByWithAggregationInput | departmentsOrderByWithAggregationInput[]
    by: DepartmentsScalarFieldEnum[] | DepartmentsScalarFieldEnum
    having?: departmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentsCountAggregateInputType | true
    _avg?: DepartmentsAvgAggregateInputType
    _sum?: DepartmentsSumAggregateInputType
    _min?: DepartmentsMinAggregateInputType
    _max?: DepartmentsMaxAggregateInputType
  }

  export type DepartmentsGroupByOutputType = {
    id: string
    name: string
    description: string | null
    headCount: number
    budgetAllocation: number
    managerId: string | null
    costCenter: string | null
    location: string | null
    isActive: boolean
    utilizationTarget: number | null
    actualUtilization: number | null
    createdAt: Date
    updatedAt: Date
    _count: DepartmentsCountAggregateOutputType | null
    _avg: DepartmentsAvgAggregateOutputType | null
    _sum: DepartmentsSumAggregateOutputType | null
    _min: DepartmentsMinAggregateOutputType | null
    _max: DepartmentsMaxAggregateOutputType | null
  }

  type GetDepartmentsGroupByPayload<T extends departmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentsGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentsGroupByOutputType[P]>
        }
      >
    >


  export type departmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    headCount?: boolean
    budgetAllocation?: boolean
    managerId?: boolean
    costCenter?: boolean
    location?: boolean
    isActive?: boolean
    utilizationTarget?: boolean
    actualUtilization?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_departments_managerIdTousers?: boolean | departments$users_departments_managerIdTousersArgs<ExtArgs>
    signals?: boolean | departments$signalsArgs<ExtArgs>
    teams?: boolean | departments$teamsArgs<ExtArgs>
    users_users_departmentObjIdTodepartments?: boolean | departments$users_users_departmentObjIdTodepartmentsArgs<ExtArgs>
    _count?: boolean | DepartmentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departments"]>

  export type departmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    headCount?: boolean
    budgetAllocation?: boolean
    managerId?: boolean
    costCenter?: boolean
    location?: boolean
    isActive?: boolean
    utilizationTarget?: boolean
    actualUtilization?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_departments_managerIdTousers?: boolean | departments$users_departments_managerIdTousersArgs<ExtArgs>
  }, ExtArgs["result"]["departments"]>

  export type departmentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    headCount?: boolean
    budgetAllocation?: boolean
    managerId?: boolean
    costCenter?: boolean
    location?: boolean
    isActive?: boolean
    utilizationTarget?: boolean
    actualUtilization?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_departments_managerIdTousers?: boolean | departments$users_departments_managerIdTousersArgs<ExtArgs>
  }, ExtArgs["result"]["departments"]>

  export type departmentsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    headCount?: boolean
    budgetAllocation?: boolean
    managerId?: boolean
    costCenter?: boolean
    location?: boolean
    isActive?: boolean
    utilizationTarget?: boolean
    actualUtilization?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type departmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "headCount" | "budgetAllocation" | "managerId" | "costCenter" | "location" | "isActive" | "utilizationTarget" | "actualUtilization" | "createdAt" | "updatedAt", ExtArgs["result"]["departments"]>
  export type departmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_departments_managerIdTousers?: boolean | departments$users_departments_managerIdTousersArgs<ExtArgs>
    signals?: boolean | departments$signalsArgs<ExtArgs>
    teams?: boolean | departments$teamsArgs<ExtArgs>
    users_users_departmentObjIdTodepartments?: boolean | departments$users_users_departmentObjIdTodepartmentsArgs<ExtArgs>
    _count?: boolean | DepartmentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type departmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_departments_managerIdTousers?: boolean | departments$users_departments_managerIdTousersArgs<ExtArgs>
  }
  export type departmentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_departments_managerIdTousers?: boolean | departments$users_departments_managerIdTousersArgs<ExtArgs>
  }

  export type $departmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "departments"
    objects: {
      users_departments_managerIdTousers: Prisma.$usersPayload<ExtArgs> | null
      signals: Prisma.$signalsPayload<ExtArgs>[]
      teams: Prisma.$teamsPayload<ExtArgs>[]
      users_users_departmentObjIdTodepartments: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      headCount: number
      budgetAllocation: number
      managerId: string | null
      costCenter: string | null
      location: string | null
      isActive: boolean
      utilizationTarget: number | null
      actualUtilization: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["departments"]>
    composites: {}
  }

  type departmentsGetPayload<S extends boolean | null | undefined | departmentsDefaultArgs> = $Result.GetResult<Prisma.$departmentsPayload, S>

  type departmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<departmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentsCountAggregateInputType | true
    }

  export interface departmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['departments'], meta: { name: 'departments' } }
    /**
     * Find zero or one Departments that matches the filter.
     * @param {departmentsFindUniqueArgs} args - Arguments to find a Departments
     * @example
     * // Get one Departments
     * const departments = await prisma.departments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends departmentsFindUniqueArgs>(args: SelectSubset<T, departmentsFindUniqueArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Departments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {departmentsFindUniqueOrThrowArgs} args - Arguments to find a Departments
     * @example
     * // Get one Departments
     * const departments = await prisma.departments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends departmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, departmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsFindFirstArgs} args - Arguments to find a Departments
     * @example
     * // Get one Departments
     * const departments = await prisma.departments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends departmentsFindFirstArgs>(args?: SelectSubset<T, departmentsFindFirstArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Departments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsFindFirstOrThrowArgs} args - Arguments to find a Departments
     * @example
     * // Get one Departments
     * const departments = await prisma.departments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends departmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, departmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.departments.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.departments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentsWithIdOnly = await prisma.departments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends departmentsFindManyArgs>(args?: SelectSubset<T, departmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Departments.
     * @param {departmentsCreateArgs} args - Arguments to create a Departments.
     * @example
     * // Create one Departments
     * const Departments = await prisma.departments.create({
     *   data: {
     *     // ... data to create a Departments
     *   }
     * })
     * 
     */
    create<T extends departmentsCreateArgs>(args: SelectSubset<T, departmentsCreateArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {departmentsCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const departments = await prisma.departments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends departmentsCreateManyArgs>(args?: SelectSubset<T, departmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {departmentsCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const departments = await prisma.departments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentsWithIdOnly = await prisma.departments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends departmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, departmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Departments.
     * @param {departmentsDeleteArgs} args - Arguments to delete one Departments.
     * @example
     * // Delete one Departments
     * const Departments = await prisma.departments.delete({
     *   where: {
     *     // ... filter to delete one Departments
     *   }
     * })
     * 
     */
    delete<T extends departmentsDeleteArgs>(args: SelectSubset<T, departmentsDeleteArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Departments.
     * @param {departmentsUpdateArgs} args - Arguments to update one Departments.
     * @example
     * // Update one Departments
     * const departments = await prisma.departments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends departmentsUpdateArgs>(args: SelectSubset<T, departmentsUpdateArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {departmentsDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.departments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends departmentsDeleteManyArgs>(args?: SelectSubset<T, departmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const departments = await prisma.departments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends departmentsUpdateManyArgs>(args: SelectSubset<T, departmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {departmentsUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const departments = await prisma.departments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentsWithIdOnly = await prisma.departments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends departmentsUpdateManyAndReturnArgs>(args: SelectSubset<T, departmentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Departments.
     * @param {departmentsUpsertArgs} args - Arguments to update or create a Departments.
     * @example
     * // Update or create a Departments
     * const departments = await prisma.departments.upsert({
     *   create: {
     *     // ... data to create a Departments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Departments we want to update
     *   }
     * })
     */
    upsert<T extends departmentsUpsertArgs>(args: SelectSubset<T, departmentsUpsertArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.departments.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends departmentsCountArgs>(
      args?: Subset<T, departmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentsAggregateArgs>(args: Subset<T, DepartmentsAggregateArgs>): Prisma.PrismaPromise<GetDepartmentsAggregateType<T>>

    /**
     * Group by Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends departmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: departmentsGroupByArgs['orderBy'] }
        : { orderBy?: departmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, departmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the departments model
   */
  readonly fields: departmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for departments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__departmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_departments_managerIdTousers<T extends departments$users_departments_managerIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, departments$users_departments_managerIdTousersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    signals<T extends departments$signalsArgs<ExtArgs> = {}>(args?: Subset<T, departments$signalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teams<T extends departments$teamsArgs<ExtArgs> = {}>(args?: Subset<T, departments$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users_users_departmentObjIdTodepartments<T extends departments$users_users_departmentObjIdTodepartmentsArgs<ExtArgs> = {}>(args?: Subset<T, departments$users_users_departmentObjIdTodepartmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the departments model
   */
  interface departmentsFieldRefs {
    readonly id: FieldRef<"departments", 'String'>
    readonly name: FieldRef<"departments", 'String'>
    readonly description: FieldRef<"departments", 'String'>
    readonly headCount: FieldRef<"departments", 'Int'>
    readonly budgetAllocation: FieldRef<"departments", 'Float'>
    readonly managerId: FieldRef<"departments", 'String'>
    readonly costCenter: FieldRef<"departments", 'String'>
    readonly location: FieldRef<"departments", 'String'>
    readonly isActive: FieldRef<"departments", 'Boolean'>
    readonly utilizationTarget: FieldRef<"departments", 'Float'>
    readonly actualUtilization: FieldRef<"departments", 'Float'>
    readonly createdAt: FieldRef<"departments", 'DateTime'>
    readonly updatedAt: FieldRef<"departments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * departments findUnique
   */
  export type departmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where: departmentsWhereUniqueInput
  }

  /**
   * departments findUniqueOrThrow
   */
  export type departmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where: departmentsWhereUniqueInput
  }

  /**
   * departments findFirst
   */
  export type departmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where?: departmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentsOrderByWithRelationInput | departmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for departments.
     */
    cursor?: departmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of departments.
     */
    distinct?: DepartmentsScalarFieldEnum | DepartmentsScalarFieldEnum[]
  }

  /**
   * departments findFirstOrThrow
   */
  export type departmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where?: departmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentsOrderByWithRelationInput | departmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for departments.
     */
    cursor?: departmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of departments.
     */
    distinct?: DepartmentsScalarFieldEnum | DepartmentsScalarFieldEnum[]
  }

  /**
   * departments findMany
   */
  export type departmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where?: departmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentsOrderByWithRelationInput | departmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing departments.
     */
    cursor?: departmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    distinct?: DepartmentsScalarFieldEnum | DepartmentsScalarFieldEnum[]
  }

  /**
   * departments create
   */
  export type departmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a departments.
     */
    data: XOR<departmentsCreateInput, departmentsUncheckedCreateInput>
  }

  /**
   * departments createMany
   */
  export type departmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many departments.
     */
    data: departmentsCreateManyInput | departmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * departments createManyAndReturn
   */
  export type departmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * The data used to create many departments.
     */
    data: departmentsCreateManyInput | departmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * departments update
   */
  export type departmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a departments.
     */
    data: XOR<departmentsUpdateInput, departmentsUncheckedUpdateInput>
    /**
     * Choose, which departments to update.
     */
    where: departmentsWhereUniqueInput
  }

  /**
   * departments updateMany
   */
  export type departmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update departments.
     */
    data: XOR<departmentsUpdateManyMutationInput, departmentsUncheckedUpdateManyInput>
    /**
     * Filter which departments to update
     */
    where?: departmentsWhereInput
    /**
     * Limit how many departments to update.
     */
    limit?: number
  }

  /**
   * departments updateManyAndReturn
   */
  export type departmentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * The data used to update departments.
     */
    data: XOR<departmentsUpdateManyMutationInput, departmentsUncheckedUpdateManyInput>
    /**
     * Filter which departments to update
     */
    where?: departmentsWhereInput
    /**
     * Limit how many departments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * departments upsert
   */
  export type departmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the departments to update in case it exists.
     */
    where: departmentsWhereUniqueInput
    /**
     * In case the departments found by the `where` argument doesn't exist, create a new departments with this data.
     */
    create: XOR<departmentsCreateInput, departmentsUncheckedCreateInput>
    /**
     * In case the departments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<departmentsUpdateInput, departmentsUncheckedUpdateInput>
  }

  /**
   * departments delete
   */
  export type departmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * Filter which departments to delete.
     */
    where: departmentsWhereUniqueInput
  }

  /**
   * departments deleteMany
   */
  export type departmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which departments to delete
     */
    where?: departmentsWhereInput
    /**
     * Limit how many departments to delete.
     */
    limit?: number
  }

  /**
   * departments.users_departments_managerIdTousers
   */
  export type departments$users_departments_managerIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * departments.signals
   */
  export type departments$signalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: signalsInclude<ExtArgs> | null
    where?: signalsWhereInput
    orderBy?: signalsOrderByWithRelationInput | signalsOrderByWithRelationInput[]
    cursor?: signalsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SignalsScalarFieldEnum | SignalsScalarFieldEnum[]
  }

  /**
   * departments.teams
   */
  export type departments$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teams
     */
    select?: teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teams
     */
    omit?: teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamsInclude<ExtArgs> | null
    where?: teamsWhereInput
    orderBy?: teamsOrderByWithRelationInput | teamsOrderByWithRelationInput[]
    cursor?: teamsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamsScalarFieldEnum | TeamsScalarFieldEnum[]
  }

  /**
   * departments.users_users_departmentObjIdTodepartments
   */
  export type departments$users_users_departmentObjIdTodepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * departments without action
   */
  export type departmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
  }


  /**
   * Model frd_documents
   */

  export type AggregateFrd_documents = {
    _count: Frd_documentsCountAggregateOutputType | null
    _avg: Frd_documentsAvgAggregateOutputType | null
    _sum: Frd_documentsSumAggregateOutputType | null
    _min: Frd_documentsMinAggregateOutputType | null
    _max: Frd_documentsMaxAggregateOutputType | null
  }

  export type Frd_documentsAvgAggregateOutputType = {
    aiConfidence: number | null
    generationTime: number | null
    wordCount: number | null
  }

  export type Frd_documentsSumAggregateOutputType = {
    aiConfidence: number | null
    generationTime: number | null
    wordCount: number | null
  }

  export type Frd_documentsMinAggregateOutputType = {
    id: string | null
    title: string | null
    aiGenerated: boolean | null
    aiConfidence: number | null
    aiPromptUsed: string | null
    version: string | null
    status: $Enums.FRDStatus | null
    executiveApproved: boolean | null
    templateUsed: string | null
    generationTime: number | null
    wordCount: number | null
    lastExportedAt: Date | null
    solutionId: string | null
    createdBy: string | null
    approvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Frd_documentsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    aiGenerated: boolean | null
    aiConfidence: number | null
    aiPromptUsed: string | null
    version: string | null
    status: $Enums.FRDStatus | null
    executiveApproved: boolean | null
    templateUsed: string | null
    generationTime: number | null
    wordCount: number | null
    lastExportedAt: Date | null
    solutionId: string | null
    createdBy: string | null
    approvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Frd_documentsCountAggregateOutputType = {
    id: number
    title: number
    content: number
    aiGenerated: number
    aiConfidence: number
    aiPromptUsed: number
    version: number
    status: number
    executiveApproved: number
    exportFormats: number
    templateUsed: number
    generationTime: number
    wordCount: number
    lastExportedAt: number
    solutionId: number
    createdBy: number
    approvedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Frd_documentsAvgAggregateInputType = {
    aiConfidence?: true
    generationTime?: true
    wordCount?: true
  }

  export type Frd_documentsSumAggregateInputType = {
    aiConfidence?: true
    generationTime?: true
    wordCount?: true
  }

  export type Frd_documentsMinAggregateInputType = {
    id?: true
    title?: true
    aiGenerated?: true
    aiConfidence?: true
    aiPromptUsed?: true
    version?: true
    status?: true
    executiveApproved?: true
    templateUsed?: true
    generationTime?: true
    wordCount?: true
    lastExportedAt?: true
    solutionId?: true
    createdBy?: true
    approvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Frd_documentsMaxAggregateInputType = {
    id?: true
    title?: true
    aiGenerated?: true
    aiConfidence?: true
    aiPromptUsed?: true
    version?: true
    status?: true
    executiveApproved?: true
    templateUsed?: true
    generationTime?: true
    wordCount?: true
    lastExportedAt?: true
    solutionId?: true
    createdBy?: true
    approvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Frd_documentsCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    aiGenerated?: true
    aiConfidence?: true
    aiPromptUsed?: true
    version?: true
    status?: true
    executiveApproved?: true
    exportFormats?: true
    templateUsed?: true
    generationTime?: true
    wordCount?: true
    lastExportedAt?: true
    solutionId?: true
    createdBy?: true
    approvedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Frd_documentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which frd_documents to aggregate.
     */
    where?: frd_documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of frd_documents to fetch.
     */
    orderBy?: frd_documentsOrderByWithRelationInput | frd_documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: frd_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` frd_documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` frd_documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned frd_documents
    **/
    _count?: true | Frd_documentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Frd_documentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Frd_documentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Frd_documentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Frd_documentsMaxAggregateInputType
  }

  export type GetFrd_documentsAggregateType<T extends Frd_documentsAggregateArgs> = {
        [P in keyof T & keyof AggregateFrd_documents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFrd_documents[P]>
      : GetScalarType<T[P], AggregateFrd_documents[P]>
  }




  export type frd_documentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: frd_documentsWhereInput
    orderBy?: frd_documentsOrderByWithAggregationInput | frd_documentsOrderByWithAggregationInput[]
    by: Frd_documentsScalarFieldEnum[] | Frd_documentsScalarFieldEnum
    having?: frd_documentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Frd_documentsCountAggregateInputType | true
    _avg?: Frd_documentsAvgAggregateInputType
    _sum?: Frd_documentsSumAggregateInputType
    _min?: Frd_documentsMinAggregateInputType
    _max?: Frd_documentsMaxAggregateInputType
  }

  export type Frd_documentsGroupByOutputType = {
    id: string
    title: string
    content: JsonValue
    aiGenerated: boolean
    aiConfidence: number | null
    aiPromptUsed: string | null
    version: string
    status: $Enums.FRDStatus
    executiveApproved: boolean
    exportFormats: JsonValue | null
    templateUsed: string | null
    generationTime: number | null
    wordCount: number | null
    lastExportedAt: Date | null
    solutionId: string
    createdBy: string
    approvedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: Frd_documentsCountAggregateOutputType | null
    _avg: Frd_documentsAvgAggregateOutputType | null
    _sum: Frd_documentsSumAggregateOutputType | null
    _min: Frd_documentsMinAggregateOutputType | null
    _max: Frd_documentsMaxAggregateOutputType | null
  }

  type GetFrd_documentsGroupByPayload<T extends frd_documentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Frd_documentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Frd_documentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Frd_documentsGroupByOutputType[P]>
            : GetScalarType<T[P], Frd_documentsGroupByOutputType[P]>
        }
      >
    >


  export type frd_documentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    aiGenerated?: boolean
    aiConfidence?: boolean
    aiPromptUsed?: boolean
    version?: boolean
    status?: boolean
    executiveApproved?: boolean
    exportFormats?: boolean
    templateUsed?: boolean
    generationTime?: boolean
    wordCount?: boolean
    lastExportedAt?: boolean
    solutionId?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_frd_documents_approvedByTousers?: boolean | frd_documents$users_frd_documents_approvedByTousersArgs<ExtArgs>
    users_frd_documents_createdByTousers?: boolean | usersDefaultArgs<ExtArgs>
    solutions?: boolean | solutionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["frd_documents"]>

  export type frd_documentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    aiGenerated?: boolean
    aiConfidence?: boolean
    aiPromptUsed?: boolean
    version?: boolean
    status?: boolean
    executiveApproved?: boolean
    exportFormats?: boolean
    templateUsed?: boolean
    generationTime?: boolean
    wordCount?: boolean
    lastExportedAt?: boolean
    solutionId?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_frd_documents_approvedByTousers?: boolean | frd_documents$users_frd_documents_approvedByTousersArgs<ExtArgs>
    users_frd_documents_createdByTousers?: boolean | usersDefaultArgs<ExtArgs>
    solutions?: boolean | solutionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["frd_documents"]>

  export type frd_documentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    aiGenerated?: boolean
    aiConfidence?: boolean
    aiPromptUsed?: boolean
    version?: boolean
    status?: boolean
    executiveApproved?: boolean
    exportFormats?: boolean
    templateUsed?: boolean
    generationTime?: boolean
    wordCount?: boolean
    lastExportedAt?: boolean
    solutionId?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_frd_documents_approvedByTousers?: boolean | frd_documents$users_frd_documents_approvedByTousersArgs<ExtArgs>
    users_frd_documents_createdByTousers?: boolean | usersDefaultArgs<ExtArgs>
    solutions?: boolean | solutionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["frd_documents"]>

  export type frd_documentsSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    aiGenerated?: boolean
    aiConfidence?: boolean
    aiPromptUsed?: boolean
    version?: boolean
    status?: boolean
    executiveApproved?: boolean
    exportFormats?: boolean
    templateUsed?: boolean
    generationTime?: boolean
    wordCount?: boolean
    lastExportedAt?: boolean
    solutionId?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type frd_documentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "aiGenerated" | "aiConfidence" | "aiPromptUsed" | "version" | "status" | "executiveApproved" | "exportFormats" | "templateUsed" | "generationTime" | "wordCount" | "lastExportedAt" | "solutionId" | "createdBy" | "approvedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["frd_documents"]>
  export type frd_documentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_frd_documents_approvedByTousers?: boolean | frd_documents$users_frd_documents_approvedByTousersArgs<ExtArgs>
    users_frd_documents_createdByTousers?: boolean | usersDefaultArgs<ExtArgs>
    solutions?: boolean | solutionsDefaultArgs<ExtArgs>
  }
  export type frd_documentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_frd_documents_approvedByTousers?: boolean | frd_documents$users_frd_documents_approvedByTousersArgs<ExtArgs>
    users_frd_documents_createdByTousers?: boolean | usersDefaultArgs<ExtArgs>
    solutions?: boolean | solutionsDefaultArgs<ExtArgs>
  }
  export type frd_documentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_frd_documents_approvedByTousers?: boolean | frd_documents$users_frd_documents_approvedByTousersArgs<ExtArgs>
    users_frd_documents_createdByTousers?: boolean | usersDefaultArgs<ExtArgs>
    solutions?: boolean | solutionsDefaultArgs<ExtArgs>
  }

  export type $frd_documentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "frd_documents"
    objects: {
      users_frd_documents_approvedByTousers: Prisma.$usersPayload<ExtArgs> | null
      users_frd_documents_createdByTousers: Prisma.$usersPayload<ExtArgs>
      solutions: Prisma.$solutionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: Prisma.JsonValue
      aiGenerated: boolean
      aiConfidence: number | null
      aiPromptUsed: string | null
      version: string
      status: $Enums.FRDStatus
      executiveApproved: boolean
      exportFormats: Prisma.JsonValue | null
      templateUsed: string | null
      generationTime: number | null
      wordCount: number | null
      lastExportedAt: Date | null
      solutionId: string
      createdBy: string
      approvedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["frd_documents"]>
    composites: {}
  }

  type frd_documentsGetPayload<S extends boolean | null | undefined | frd_documentsDefaultArgs> = $Result.GetResult<Prisma.$frd_documentsPayload, S>

  type frd_documentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<frd_documentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Frd_documentsCountAggregateInputType | true
    }

  export interface frd_documentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['frd_documents'], meta: { name: 'frd_documents' } }
    /**
     * Find zero or one Frd_documents that matches the filter.
     * @param {frd_documentsFindUniqueArgs} args - Arguments to find a Frd_documents
     * @example
     * // Get one Frd_documents
     * const frd_documents = await prisma.frd_documents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends frd_documentsFindUniqueArgs>(args: SelectSubset<T, frd_documentsFindUniqueArgs<ExtArgs>>): Prisma__frd_documentsClient<$Result.GetResult<Prisma.$frd_documentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Frd_documents that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {frd_documentsFindUniqueOrThrowArgs} args - Arguments to find a Frd_documents
     * @example
     * // Get one Frd_documents
     * const frd_documents = await prisma.frd_documents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends frd_documentsFindUniqueOrThrowArgs>(args: SelectSubset<T, frd_documentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__frd_documentsClient<$Result.GetResult<Prisma.$frd_documentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Frd_documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {frd_documentsFindFirstArgs} args - Arguments to find a Frd_documents
     * @example
     * // Get one Frd_documents
     * const frd_documents = await prisma.frd_documents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends frd_documentsFindFirstArgs>(args?: SelectSubset<T, frd_documentsFindFirstArgs<ExtArgs>>): Prisma__frd_documentsClient<$Result.GetResult<Prisma.$frd_documentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Frd_documents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {frd_documentsFindFirstOrThrowArgs} args - Arguments to find a Frd_documents
     * @example
     * // Get one Frd_documents
     * const frd_documents = await prisma.frd_documents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends frd_documentsFindFirstOrThrowArgs>(args?: SelectSubset<T, frd_documentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__frd_documentsClient<$Result.GetResult<Prisma.$frd_documentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Frd_documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {frd_documentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Frd_documents
     * const frd_documents = await prisma.frd_documents.findMany()
     * 
     * // Get first 10 Frd_documents
     * const frd_documents = await prisma.frd_documents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const frd_documentsWithIdOnly = await prisma.frd_documents.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends frd_documentsFindManyArgs>(args?: SelectSubset<T, frd_documentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$frd_documentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Frd_documents.
     * @param {frd_documentsCreateArgs} args - Arguments to create a Frd_documents.
     * @example
     * // Create one Frd_documents
     * const Frd_documents = await prisma.frd_documents.create({
     *   data: {
     *     // ... data to create a Frd_documents
     *   }
     * })
     * 
     */
    create<T extends frd_documentsCreateArgs>(args: SelectSubset<T, frd_documentsCreateArgs<ExtArgs>>): Prisma__frd_documentsClient<$Result.GetResult<Prisma.$frd_documentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Frd_documents.
     * @param {frd_documentsCreateManyArgs} args - Arguments to create many Frd_documents.
     * @example
     * // Create many Frd_documents
     * const frd_documents = await prisma.frd_documents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends frd_documentsCreateManyArgs>(args?: SelectSubset<T, frd_documentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Frd_documents and returns the data saved in the database.
     * @param {frd_documentsCreateManyAndReturnArgs} args - Arguments to create many Frd_documents.
     * @example
     * // Create many Frd_documents
     * const frd_documents = await prisma.frd_documents.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Frd_documents and only return the `id`
     * const frd_documentsWithIdOnly = await prisma.frd_documents.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends frd_documentsCreateManyAndReturnArgs>(args?: SelectSubset<T, frd_documentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$frd_documentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Frd_documents.
     * @param {frd_documentsDeleteArgs} args - Arguments to delete one Frd_documents.
     * @example
     * // Delete one Frd_documents
     * const Frd_documents = await prisma.frd_documents.delete({
     *   where: {
     *     // ... filter to delete one Frd_documents
     *   }
     * })
     * 
     */
    delete<T extends frd_documentsDeleteArgs>(args: SelectSubset<T, frd_documentsDeleteArgs<ExtArgs>>): Prisma__frd_documentsClient<$Result.GetResult<Prisma.$frd_documentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Frd_documents.
     * @param {frd_documentsUpdateArgs} args - Arguments to update one Frd_documents.
     * @example
     * // Update one Frd_documents
     * const frd_documents = await prisma.frd_documents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends frd_documentsUpdateArgs>(args: SelectSubset<T, frd_documentsUpdateArgs<ExtArgs>>): Prisma__frd_documentsClient<$Result.GetResult<Prisma.$frd_documentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Frd_documents.
     * @param {frd_documentsDeleteManyArgs} args - Arguments to filter Frd_documents to delete.
     * @example
     * // Delete a few Frd_documents
     * const { count } = await prisma.frd_documents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends frd_documentsDeleteManyArgs>(args?: SelectSubset<T, frd_documentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Frd_documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {frd_documentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Frd_documents
     * const frd_documents = await prisma.frd_documents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends frd_documentsUpdateManyArgs>(args: SelectSubset<T, frd_documentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Frd_documents and returns the data updated in the database.
     * @param {frd_documentsUpdateManyAndReturnArgs} args - Arguments to update many Frd_documents.
     * @example
     * // Update many Frd_documents
     * const frd_documents = await prisma.frd_documents.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Frd_documents and only return the `id`
     * const frd_documentsWithIdOnly = await prisma.frd_documents.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends frd_documentsUpdateManyAndReturnArgs>(args: SelectSubset<T, frd_documentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$frd_documentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Frd_documents.
     * @param {frd_documentsUpsertArgs} args - Arguments to update or create a Frd_documents.
     * @example
     * // Update or create a Frd_documents
     * const frd_documents = await prisma.frd_documents.upsert({
     *   create: {
     *     // ... data to create a Frd_documents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Frd_documents we want to update
     *   }
     * })
     */
    upsert<T extends frd_documentsUpsertArgs>(args: SelectSubset<T, frd_documentsUpsertArgs<ExtArgs>>): Prisma__frd_documentsClient<$Result.GetResult<Prisma.$frd_documentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Frd_documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {frd_documentsCountArgs} args - Arguments to filter Frd_documents to count.
     * @example
     * // Count the number of Frd_documents
     * const count = await prisma.frd_documents.count({
     *   where: {
     *     // ... the filter for the Frd_documents we want to count
     *   }
     * })
    **/
    count<T extends frd_documentsCountArgs>(
      args?: Subset<T, frd_documentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Frd_documentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Frd_documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Frd_documentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Frd_documentsAggregateArgs>(args: Subset<T, Frd_documentsAggregateArgs>): Prisma.PrismaPromise<GetFrd_documentsAggregateType<T>>

    /**
     * Group by Frd_documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {frd_documentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends frd_documentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: frd_documentsGroupByArgs['orderBy'] }
        : { orderBy?: frd_documentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, frd_documentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFrd_documentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the frd_documents model
   */
  readonly fields: frd_documentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for frd_documents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__frd_documentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_frd_documents_approvedByTousers<T extends frd_documents$users_frd_documents_approvedByTousersArgs<ExtArgs> = {}>(args?: Subset<T, frd_documents$users_frd_documents_approvedByTousersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users_frd_documents_createdByTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    solutions<T extends solutionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, solutionsDefaultArgs<ExtArgs>>): Prisma__solutionsClient<$Result.GetResult<Prisma.$solutionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the frd_documents model
   */
  interface frd_documentsFieldRefs {
    readonly id: FieldRef<"frd_documents", 'String'>
    readonly title: FieldRef<"frd_documents", 'String'>
    readonly content: FieldRef<"frd_documents", 'Json'>
    readonly aiGenerated: FieldRef<"frd_documents", 'Boolean'>
    readonly aiConfidence: FieldRef<"frd_documents", 'Float'>
    readonly aiPromptUsed: FieldRef<"frd_documents", 'String'>
    readonly version: FieldRef<"frd_documents", 'String'>
    readonly status: FieldRef<"frd_documents", 'FRDStatus'>
    readonly executiveApproved: FieldRef<"frd_documents", 'Boolean'>
    readonly exportFormats: FieldRef<"frd_documents", 'Json'>
    readonly templateUsed: FieldRef<"frd_documents", 'String'>
    readonly generationTime: FieldRef<"frd_documents", 'Float'>
    readonly wordCount: FieldRef<"frd_documents", 'Int'>
    readonly lastExportedAt: FieldRef<"frd_documents", 'DateTime'>
    readonly solutionId: FieldRef<"frd_documents", 'String'>
    readonly createdBy: FieldRef<"frd_documents", 'String'>
    readonly approvedBy: FieldRef<"frd_documents", 'String'>
    readonly createdAt: FieldRef<"frd_documents", 'DateTime'>
    readonly updatedAt: FieldRef<"frd_documents", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * frd_documents findUnique
   */
  export type frd_documentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frd_documents
     */
    select?: frd_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the frd_documents
     */
    omit?: frd_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frd_documentsInclude<ExtArgs> | null
    /**
     * Filter, which frd_documents to fetch.
     */
    where: frd_documentsWhereUniqueInput
  }

  /**
   * frd_documents findUniqueOrThrow
   */
  export type frd_documentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frd_documents
     */
    select?: frd_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the frd_documents
     */
    omit?: frd_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frd_documentsInclude<ExtArgs> | null
    /**
     * Filter, which frd_documents to fetch.
     */
    where: frd_documentsWhereUniqueInput
  }

  /**
   * frd_documents findFirst
   */
  export type frd_documentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frd_documents
     */
    select?: frd_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the frd_documents
     */
    omit?: frd_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frd_documentsInclude<ExtArgs> | null
    /**
     * Filter, which frd_documents to fetch.
     */
    where?: frd_documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of frd_documents to fetch.
     */
    orderBy?: frd_documentsOrderByWithRelationInput | frd_documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for frd_documents.
     */
    cursor?: frd_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` frd_documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` frd_documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of frd_documents.
     */
    distinct?: Frd_documentsScalarFieldEnum | Frd_documentsScalarFieldEnum[]
  }

  /**
   * frd_documents findFirstOrThrow
   */
  export type frd_documentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frd_documents
     */
    select?: frd_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the frd_documents
     */
    omit?: frd_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frd_documentsInclude<ExtArgs> | null
    /**
     * Filter, which frd_documents to fetch.
     */
    where?: frd_documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of frd_documents to fetch.
     */
    orderBy?: frd_documentsOrderByWithRelationInput | frd_documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for frd_documents.
     */
    cursor?: frd_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` frd_documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` frd_documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of frd_documents.
     */
    distinct?: Frd_documentsScalarFieldEnum | Frd_documentsScalarFieldEnum[]
  }

  /**
   * frd_documents findMany
   */
  export type frd_documentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frd_documents
     */
    select?: frd_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the frd_documents
     */
    omit?: frd_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frd_documentsInclude<ExtArgs> | null
    /**
     * Filter, which frd_documents to fetch.
     */
    where?: frd_documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of frd_documents to fetch.
     */
    orderBy?: frd_documentsOrderByWithRelationInput | frd_documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing frd_documents.
     */
    cursor?: frd_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` frd_documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` frd_documents.
     */
    skip?: number
    distinct?: Frd_documentsScalarFieldEnum | Frd_documentsScalarFieldEnum[]
  }

  /**
   * frd_documents create
   */
  export type frd_documentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frd_documents
     */
    select?: frd_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the frd_documents
     */
    omit?: frd_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frd_documentsInclude<ExtArgs> | null
    /**
     * The data needed to create a frd_documents.
     */
    data: XOR<frd_documentsCreateInput, frd_documentsUncheckedCreateInput>
  }

  /**
   * frd_documents createMany
   */
  export type frd_documentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many frd_documents.
     */
    data: frd_documentsCreateManyInput | frd_documentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * frd_documents createManyAndReturn
   */
  export type frd_documentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frd_documents
     */
    select?: frd_documentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the frd_documents
     */
    omit?: frd_documentsOmit<ExtArgs> | null
    /**
     * The data used to create many frd_documents.
     */
    data: frd_documentsCreateManyInput | frd_documentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frd_documentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * frd_documents update
   */
  export type frd_documentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frd_documents
     */
    select?: frd_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the frd_documents
     */
    omit?: frd_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frd_documentsInclude<ExtArgs> | null
    /**
     * The data needed to update a frd_documents.
     */
    data: XOR<frd_documentsUpdateInput, frd_documentsUncheckedUpdateInput>
    /**
     * Choose, which frd_documents to update.
     */
    where: frd_documentsWhereUniqueInput
  }

  /**
   * frd_documents updateMany
   */
  export type frd_documentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update frd_documents.
     */
    data: XOR<frd_documentsUpdateManyMutationInput, frd_documentsUncheckedUpdateManyInput>
    /**
     * Filter which frd_documents to update
     */
    where?: frd_documentsWhereInput
    /**
     * Limit how many frd_documents to update.
     */
    limit?: number
  }

  /**
   * frd_documents updateManyAndReturn
   */
  export type frd_documentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frd_documents
     */
    select?: frd_documentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the frd_documents
     */
    omit?: frd_documentsOmit<ExtArgs> | null
    /**
     * The data used to update frd_documents.
     */
    data: XOR<frd_documentsUpdateManyMutationInput, frd_documentsUncheckedUpdateManyInput>
    /**
     * Filter which frd_documents to update
     */
    where?: frd_documentsWhereInput
    /**
     * Limit how many frd_documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frd_documentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * frd_documents upsert
   */
  export type frd_documentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frd_documents
     */
    select?: frd_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the frd_documents
     */
    omit?: frd_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frd_documentsInclude<ExtArgs> | null
    /**
     * The filter to search for the frd_documents to update in case it exists.
     */
    where: frd_documentsWhereUniqueInput
    /**
     * In case the frd_documents found by the `where` argument doesn't exist, create a new frd_documents with this data.
     */
    create: XOR<frd_documentsCreateInput, frd_documentsUncheckedCreateInput>
    /**
     * In case the frd_documents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<frd_documentsUpdateInput, frd_documentsUncheckedUpdateInput>
  }

  /**
   * frd_documents delete
   */
  export type frd_documentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frd_documents
     */
    select?: frd_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the frd_documents
     */
    omit?: frd_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frd_documentsInclude<ExtArgs> | null
    /**
     * Filter which frd_documents to delete.
     */
    where: frd_documentsWhereUniqueInput
  }

  /**
   * frd_documents deleteMany
   */
  export type frd_documentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which frd_documents to delete
     */
    where?: frd_documentsWhereInput
    /**
     * Limit how many frd_documents to delete.
     */
    limit?: number
  }

  /**
   * frd_documents.users_frd_documents_approvedByTousers
   */
  export type frd_documents$users_frd_documents_approvedByTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * frd_documents without action
   */
  export type frd_documentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frd_documents
     */
    select?: frd_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the frd_documents
     */
    omit?: frd_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frd_documentsInclude<ExtArgs> | null
  }


  /**
   * Model hotspot_signals
   */

  export type AggregateHotspot_signals = {
    _count: Hotspot_signalsCountAggregateOutputType | null
    _avg: Hotspot_signalsAvgAggregateOutputType | null
    _sum: Hotspot_signalsSumAggregateOutputType | null
    _min: Hotspot_signalsMinAggregateOutputType | null
    _max: Hotspot_signalsMaxAggregateOutputType | null
  }

  export type Hotspot_signalsAvgAggregateOutputType = {
    membershipStrength: number | null
  }

  export type Hotspot_signalsSumAggregateOutputType = {
    membershipStrength: number | null
  }

  export type Hotspot_signalsMinAggregateOutputType = {
    hotspotId: string | null
    signalId: string | null
    membershipStrength: number | null
    isOutlier: boolean | null
    addedAt: Date | null
  }

  export type Hotspot_signalsMaxAggregateOutputType = {
    hotspotId: string | null
    signalId: string | null
    membershipStrength: number | null
    isOutlier: boolean | null
    addedAt: Date | null
  }

  export type Hotspot_signalsCountAggregateOutputType = {
    hotspotId: number
    signalId: number
    membershipStrength: number
    isOutlier: number
    addedAt: number
    _all: number
  }


  export type Hotspot_signalsAvgAggregateInputType = {
    membershipStrength?: true
  }

  export type Hotspot_signalsSumAggregateInputType = {
    membershipStrength?: true
  }

  export type Hotspot_signalsMinAggregateInputType = {
    hotspotId?: true
    signalId?: true
    membershipStrength?: true
    isOutlier?: true
    addedAt?: true
  }

  export type Hotspot_signalsMaxAggregateInputType = {
    hotspotId?: true
    signalId?: true
    membershipStrength?: true
    isOutlier?: true
    addedAt?: true
  }

  export type Hotspot_signalsCountAggregateInputType = {
    hotspotId?: true
    signalId?: true
    membershipStrength?: true
    isOutlier?: true
    addedAt?: true
    _all?: true
  }

  export type Hotspot_signalsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hotspot_signals to aggregate.
     */
    where?: hotspot_signalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hotspot_signals to fetch.
     */
    orderBy?: hotspot_signalsOrderByWithRelationInput | hotspot_signalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hotspot_signalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hotspot_signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hotspot_signals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hotspot_signals
    **/
    _count?: true | Hotspot_signalsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Hotspot_signalsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Hotspot_signalsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Hotspot_signalsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Hotspot_signalsMaxAggregateInputType
  }

  export type GetHotspot_signalsAggregateType<T extends Hotspot_signalsAggregateArgs> = {
        [P in keyof T & keyof AggregateHotspot_signals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotspot_signals[P]>
      : GetScalarType<T[P], AggregateHotspot_signals[P]>
  }




  export type hotspot_signalsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hotspot_signalsWhereInput
    orderBy?: hotspot_signalsOrderByWithAggregationInput | hotspot_signalsOrderByWithAggregationInput[]
    by: Hotspot_signalsScalarFieldEnum[] | Hotspot_signalsScalarFieldEnum
    having?: hotspot_signalsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Hotspot_signalsCountAggregateInputType | true
    _avg?: Hotspot_signalsAvgAggregateInputType
    _sum?: Hotspot_signalsSumAggregateInputType
    _min?: Hotspot_signalsMinAggregateInputType
    _max?: Hotspot_signalsMaxAggregateInputType
  }

  export type Hotspot_signalsGroupByOutputType = {
    hotspotId: string
    signalId: string
    membershipStrength: number
    isOutlier: boolean
    addedAt: Date
    _count: Hotspot_signalsCountAggregateOutputType | null
    _avg: Hotspot_signalsAvgAggregateOutputType | null
    _sum: Hotspot_signalsSumAggregateOutputType | null
    _min: Hotspot_signalsMinAggregateOutputType | null
    _max: Hotspot_signalsMaxAggregateOutputType | null
  }

  type GetHotspot_signalsGroupByPayload<T extends hotspot_signalsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Hotspot_signalsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Hotspot_signalsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Hotspot_signalsGroupByOutputType[P]>
            : GetScalarType<T[P], Hotspot_signalsGroupByOutputType[P]>
        }
      >
    >


  export type hotspot_signalsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotspotId?: boolean
    signalId?: boolean
    membershipStrength?: boolean
    isOutlier?: boolean
    addedAt?: boolean
    hotspots?: boolean | hotspotsDefaultArgs<ExtArgs>
    signals?: boolean | signalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotspot_signals"]>

  export type hotspot_signalsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotspotId?: boolean
    signalId?: boolean
    membershipStrength?: boolean
    isOutlier?: boolean
    addedAt?: boolean
    hotspots?: boolean | hotspotsDefaultArgs<ExtArgs>
    signals?: boolean | signalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotspot_signals"]>

  export type hotspot_signalsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotspotId?: boolean
    signalId?: boolean
    membershipStrength?: boolean
    isOutlier?: boolean
    addedAt?: boolean
    hotspots?: boolean | hotspotsDefaultArgs<ExtArgs>
    signals?: boolean | signalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotspot_signals"]>

  export type hotspot_signalsSelectScalar = {
    hotspotId?: boolean
    signalId?: boolean
    membershipStrength?: boolean
    isOutlier?: boolean
    addedAt?: boolean
  }

  export type hotspot_signalsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"hotspotId" | "signalId" | "membershipStrength" | "isOutlier" | "addedAt", ExtArgs["result"]["hotspot_signals"]>
  export type hotspot_signalsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotspots?: boolean | hotspotsDefaultArgs<ExtArgs>
    signals?: boolean | signalsDefaultArgs<ExtArgs>
  }
  export type hotspot_signalsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotspots?: boolean | hotspotsDefaultArgs<ExtArgs>
    signals?: boolean | signalsDefaultArgs<ExtArgs>
  }
  export type hotspot_signalsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotspots?: boolean | hotspotsDefaultArgs<ExtArgs>
    signals?: boolean | signalsDefaultArgs<ExtArgs>
  }

  export type $hotspot_signalsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "hotspot_signals"
    objects: {
      hotspots: Prisma.$hotspotsPayload<ExtArgs>
      signals: Prisma.$signalsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      hotspotId: string
      signalId: string
      membershipStrength: number
      isOutlier: boolean
      addedAt: Date
    }, ExtArgs["result"]["hotspot_signals"]>
    composites: {}
  }

  type hotspot_signalsGetPayload<S extends boolean | null | undefined | hotspot_signalsDefaultArgs> = $Result.GetResult<Prisma.$hotspot_signalsPayload, S>

  type hotspot_signalsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<hotspot_signalsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Hotspot_signalsCountAggregateInputType | true
    }

  export interface hotspot_signalsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['hotspot_signals'], meta: { name: 'hotspot_signals' } }
    /**
     * Find zero or one Hotspot_signals that matches the filter.
     * @param {hotspot_signalsFindUniqueArgs} args - Arguments to find a Hotspot_signals
     * @example
     * // Get one Hotspot_signals
     * const hotspot_signals = await prisma.hotspot_signals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends hotspot_signalsFindUniqueArgs>(args: SelectSubset<T, hotspot_signalsFindUniqueArgs<ExtArgs>>): Prisma__hotspot_signalsClient<$Result.GetResult<Prisma.$hotspot_signalsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hotspot_signals that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {hotspot_signalsFindUniqueOrThrowArgs} args - Arguments to find a Hotspot_signals
     * @example
     * // Get one Hotspot_signals
     * const hotspot_signals = await prisma.hotspot_signals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends hotspot_signalsFindUniqueOrThrowArgs>(args: SelectSubset<T, hotspot_signalsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__hotspot_signalsClient<$Result.GetResult<Prisma.$hotspot_signalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hotspot_signals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotspot_signalsFindFirstArgs} args - Arguments to find a Hotspot_signals
     * @example
     * // Get one Hotspot_signals
     * const hotspot_signals = await prisma.hotspot_signals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends hotspot_signalsFindFirstArgs>(args?: SelectSubset<T, hotspot_signalsFindFirstArgs<ExtArgs>>): Prisma__hotspot_signalsClient<$Result.GetResult<Prisma.$hotspot_signalsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hotspot_signals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotspot_signalsFindFirstOrThrowArgs} args - Arguments to find a Hotspot_signals
     * @example
     * // Get one Hotspot_signals
     * const hotspot_signals = await prisma.hotspot_signals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends hotspot_signalsFindFirstOrThrowArgs>(args?: SelectSubset<T, hotspot_signalsFindFirstOrThrowArgs<ExtArgs>>): Prisma__hotspot_signalsClient<$Result.GetResult<Prisma.$hotspot_signalsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hotspot_signals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotspot_signalsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hotspot_signals
     * const hotspot_signals = await prisma.hotspot_signals.findMany()
     * 
     * // Get first 10 Hotspot_signals
     * const hotspot_signals = await prisma.hotspot_signals.findMany({ take: 10 })
     * 
     * // Only select the `hotspotId`
     * const hotspot_signalsWithHotspotIdOnly = await prisma.hotspot_signals.findMany({ select: { hotspotId: true } })
     * 
     */
    findMany<T extends hotspot_signalsFindManyArgs>(args?: SelectSubset<T, hotspot_signalsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hotspot_signalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hotspot_signals.
     * @param {hotspot_signalsCreateArgs} args - Arguments to create a Hotspot_signals.
     * @example
     * // Create one Hotspot_signals
     * const Hotspot_signals = await prisma.hotspot_signals.create({
     *   data: {
     *     // ... data to create a Hotspot_signals
     *   }
     * })
     * 
     */
    create<T extends hotspot_signalsCreateArgs>(args: SelectSubset<T, hotspot_signalsCreateArgs<ExtArgs>>): Prisma__hotspot_signalsClient<$Result.GetResult<Prisma.$hotspot_signalsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hotspot_signals.
     * @param {hotspot_signalsCreateManyArgs} args - Arguments to create many Hotspot_signals.
     * @example
     * // Create many Hotspot_signals
     * const hotspot_signals = await prisma.hotspot_signals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends hotspot_signalsCreateManyArgs>(args?: SelectSubset<T, hotspot_signalsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hotspot_signals and returns the data saved in the database.
     * @param {hotspot_signalsCreateManyAndReturnArgs} args - Arguments to create many Hotspot_signals.
     * @example
     * // Create many Hotspot_signals
     * const hotspot_signals = await prisma.hotspot_signals.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hotspot_signals and only return the `hotspotId`
     * const hotspot_signalsWithHotspotIdOnly = await prisma.hotspot_signals.createManyAndReturn({
     *   select: { hotspotId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends hotspot_signalsCreateManyAndReturnArgs>(args?: SelectSubset<T, hotspot_signalsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hotspot_signalsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Hotspot_signals.
     * @param {hotspot_signalsDeleteArgs} args - Arguments to delete one Hotspot_signals.
     * @example
     * // Delete one Hotspot_signals
     * const Hotspot_signals = await prisma.hotspot_signals.delete({
     *   where: {
     *     // ... filter to delete one Hotspot_signals
     *   }
     * })
     * 
     */
    delete<T extends hotspot_signalsDeleteArgs>(args: SelectSubset<T, hotspot_signalsDeleteArgs<ExtArgs>>): Prisma__hotspot_signalsClient<$Result.GetResult<Prisma.$hotspot_signalsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hotspot_signals.
     * @param {hotspot_signalsUpdateArgs} args - Arguments to update one Hotspot_signals.
     * @example
     * // Update one Hotspot_signals
     * const hotspot_signals = await prisma.hotspot_signals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends hotspot_signalsUpdateArgs>(args: SelectSubset<T, hotspot_signalsUpdateArgs<ExtArgs>>): Prisma__hotspot_signalsClient<$Result.GetResult<Prisma.$hotspot_signalsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hotspot_signals.
     * @param {hotspot_signalsDeleteManyArgs} args - Arguments to filter Hotspot_signals to delete.
     * @example
     * // Delete a few Hotspot_signals
     * const { count } = await prisma.hotspot_signals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends hotspot_signalsDeleteManyArgs>(args?: SelectSubset<T, hotspot_signalsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hotspot_signals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotspot_signalsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hotspot_signals
     * const hotspot_signals = await prisma.hotspot_signals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends hotspot_signalsUpdateManyArgs>(args: SelectSubset<T, hotspot_signalsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hotspot_signals and returns the data updated in the database.
     * @param {hotspot_signalsUpdateManyAndReturnArgs} args - Arguments to update many Hotspot_signals.
     * @example
     * // Update many Hotspot_signals
     * const hotspot_signals = await prisma.hotspot_signals.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Hotspot_signals and only return the `hotspotId`
     * const hotspot_signalsWithHotspotIdOnly = await prisma.hotspot_signals.updateManyAndReturn({
     *   select: { hotspotId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends hotspot_signalsUpdateManyAndReturnArgs>(args: SelectSubset<T, hotspot_signalsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hotspot_signalsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Hotspot_signals.
     * @param {hotspot_signalsUpsertArgs} args - Arguments to update or create a Hotspot_signals.
     * @example
     * // Update or create a Hotspot_signals
     * const hotspot_signals = await prisma.hotspot_signals.upsert({
     *   create: {
     *     // ... data to create a Hotspot_signals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hotspot_signals we want to update
     *   }
     * })
     */
    upsert<T extends hotspot_signalsUpsertArgs>(args: SelectSubset<T, hotspot_signalsUpsertArgs<ExtArgs>>): Prisma__hotspot_signalsClient<$Result.GetResult<Prisma.$hotspot_signalsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hotspot_signals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotspot_signalsCountArgs} args - Arguments to filter Hotspot_signals to count.
     * @example
     * // Count the number of Hotspot_signals
     * const count = await prisma.hotspot_signals.count({
     *   where: {
     *     // ... the filter for the Hotspot_signals we want to count
     *   }
     * })
    **/
    count<T extends hotspot_signalsCountArgs>(
      args?: Subset<T, hotspot_signalsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Hotspot_signalsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hotspot_signals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hotspot_signalsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Hotspot_signalsAggregateArgs>(args: Subset<T, Hotspot_signalsAggregateArgs>): Prisma.PrismaPromise<GetHotspot_signalsAggregateType<T>>

    /**
     * Group by Hotspot_signals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotspot_signalsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends hotspot_signalsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: hotspot_signalsGroupByArgs['orderBy'] }
        : { orderBy?: hotspot_signalsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, hotspot_signalsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotspot_signalsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the hotspot_signals model
   */
  readonly fields: hotspot_signalsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for hotspot_signals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__hotspot_signalsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotspots<T extends hotspotsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, hotspotsDefaultArgs<ExtArgs>>): Prisma__hotspotsClient<$Result.GetResult<Prisma.$hotspotsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    signals<T extends signalsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, signalsDefaultArgs<ExtArgs>>): Prisma__signalsClient<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the hotspot_signals model
   */
  interface hotspot_signalsFieldRefs {
    readonly hotspotId: FieldRef<"hotspot_signals", 'String'>
    readonly signalId: FieldRef<"hotspot_signals", 'String'>
    readonly membershipStrength: FieldRef<"hotspot_signals", 'Float'>
    readonly isOutlier: FieldRef<"hotspot_signals", 'Boolean'>
    readonly addedAt: FieldRef<"hotspot_signals", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * hotspot_signals findUnique
   */
  export type hotspot_signalsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspot_signals
     */
    select?: hotspot_signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspot_signals
     */
    omit?: hotspot_signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspot_signalsInclude<ExtArgs> | null
    /**
     * Filter, which hotspot_signals to fetch.
     */
    where: hotspot_signalsWhereUniqueInput
  }

  /**
   * hotspot_signals findUniqueOrThrow
   */
  export type hotspot_signalsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspot_signals
     */
    select?: hotspot_signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspot_signals
     */
    omit?: hotspot_signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspot_signalsInclude<ExtArgs> | null
    /**
     * Filter, which hotspot_signals to fetch.
     */
    where: hotspot_signalsWhereUniqueInput
  }

  /**
   * hotspot_signals findFirst
   */
  export type hotspot_signalsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspot_signals
     */
    select?: hotspot_signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspot_signals
     */
    omit?: hotspot_signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspot_signalsInclude<ExtArgs> | null
    /**
     * Filter, which hotspot_signals to fetch.
     */
    where?: hotspot_signalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hotspot_signals to fetch.
     */
    orderBy?: hotspot_signalsOrderByWithRelationInput | hotspot_signalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hotspot_signals.
     */
    cursor?: hotspot_signalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hotspot_signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hotspot_signals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hotspot_signals.
     */
    distinct?: Hotspot_signalsScalarFieldEnum | Hotspot_signalsScalarFieldEnum[]
  }

  /**
   * hotspot_signals findFirstOrThrow
   */
  export type hotspot_signalsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspot_signals
     */
    select?: hotspot_signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspot_signals
     */
    omit?: hotspot_signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspot_signalsInclude<ExtArgs> | null
    /**
     * Filter, which hotspot_signals to fetch.
     */
    where?: hotspot_signalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hotspot_signals to fetch.
     */
    orderBy?: hotspot_signalsOrderByWithRelationInput | hotspot_signalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hotspot_signals.
     */
    cursor?: hotspot_signalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hotspot_signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hotspot_signals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hotspot_signals.
     */
    distinct?: Hotspot_signalsScalarFieldEnum | Hotspot_signalsScalarFieldEnum[]
  }

  /**
   * hotspot_signals findMany
   */
  export type hotspot_signalsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspot_signals
     */
    select?: hotspot_signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspot_signals
     */
    omit?: hotspot_signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspot_signalsInclude<ExtArgs> | null
    /**
     * Filter, which hotspot_signals to fetch.
     */
    where?: hotspot_signalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hotspot_signals to fetch.
     */
    orderBy?: hotspot_signalsOrderByWithRelationInput | hotspot_signalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hotspot_signals.
     */
    cursor?: hotspot_signalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hotspot_signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hotspot_signals.
     */
    skip?: number
    distinct?: Hotspot_signalsScalarFieldEnum | Hotspot_signalsScalarFieldEnum[]
  }

  /**
   * hotspot_signals create
   */
  export type hotspot_signalsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspot_signals
     */
    select?: hotspot_signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspot_signals
     */
    omit?: hotspot_signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspot_signalsInclude<ExtArgs> | null
    /**
     * The data needed to create a hotspot_signals.
     */
    data: XOR<hotspot_signalsCreateInput, hotspot_signalsUncheckedCreateInput>
  }

  /**
   * hotspot_signals createMany
   */
  export type hotspot_signalsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many hotspot_signals.
     */
    data: hotspot_signalsCreateManyInput | hotspot_signalsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * hotspot_signals createManyAndReturn
   */
  export type hotspot_signalsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspot_signals
     */
    select?: hotspot_signalsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the hotspot_signals
     */
    omit?: hotspot_signalsOmit<ExtArgs> | null
    /**
     * The data used to create many hotspot_signals.
     */
    data: hotspot_signalsCreateManyInput | hotspot_signalsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspot_signalsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * hotspot_signals update
   */
  export type hotspot_signalsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspot_signals
     */
    select?: hotspot_signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspot_signals
     */
    omit?: hotspot_signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspot_signalsInclude<ExtArgs> | null
    /**
     * The data needed to update a hotspot_signals.
     */
    data: XOR<hotspot_signalsUpdateInput, hotspot_signalsUncheckedUpdateInput>
    /**
     * Choose, which hotspot_signals to update.
     */
    where: hotspot_signalsWhereUniqueInput
  }

  /**
   * hotspot_signals updateMany
   */
  export type hotspot_signalsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update hotspot_signals.
     */
    data: XOR<hotspot_signalsUpdateManyMutationInput, hotspot_signalsUncheckedUpdateManyInput>
    /**
     * Filter which hotspot_signals to update
     */
    where?: hotspot_signalsWhereInput
    /**
     * Limit how many hotspot_signals to update.
     */
    limit?: number
  }

  /**
   * hotspot_signals updateManyAndReturn
   */
  export type hotspot_signalsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspot_signals
     */
    select?: hotspot_signalsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the hotspot_signals
     */
    omit?: hotspot_signalsOmit<ExtArgs> | null
    /**
     * The data used to update hotspot_signals.
     */
    data: XOR<hotspot_signalsUpdateManyMutationInput, hotspot_signalsUncheckedUpdateManyInput>
    /**
     * Filter which hotspot_signals to update
     */
    where?: hotspot_signalsWhereInput
    /**
     * Limit how many hotspot_signals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspot_signalsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * hotspot_signals upsert
   */
  export type hotspot_signalsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspot_signals
     */
    select?: hotspot_signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspot_signals
     */
    omit?: hotspot_signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspot_signalsInclude<ExtArgs> | null
    /**
     * The filter to search for the hotspot_signals to update in case it exists.
     */
    where: hotspot_signalsWhereUniqueInput
    /**
     * In case the hotspot_signals found by the `where` argument doesn't exist, create a new hotspot_signals with this data.
     */
    create: XOR<hotspot_signalsCreateInput, hotspot_signalsUncheckedCreateInput>
    /**
     * In case the hotspot_signals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hotspot_signalsUpdateInput, hotspot_signalsUncheckedUpdateInput>
  }

  /**
   * hotspot_signals delete
   */
  export type hotspot_signalsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspot_signals
     */
    select?: hotspot_signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspot_signals
     */
    omit?: hotspot_signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspot_signalsInclude<ExtArgs> | null
    /**
     * Filter which hotspot_signals to delete.
     */
    where: hotspot_signalsWhereUniqueInput
  }

  /**
   * hotspot_signals deleteMany
   */
  export type hotspot_signalsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hotspot_signals to delete
     */
    where?: hotspot_signalsWhereInput
    /**
     * Limit how many hotspot_signals to delete.
     */
    limit?: number
  }

  /**
   * hotspot_signals without action
   */
  export type hotspot_signalsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspot_signals
     */
    select?: hotspot_signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspot_signals
     */
    omit?: hotspot_signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspot_signalsInclude<ExtArgs> | null
  }


  /**
   * Model hotspots
   */

  export type AggregateHotspots = {
    _count: HotspotsCountAggregateOutputType | null
    _avg: HotspotsAvgAggregateOutputType | null
    _sum: HotspotsSumAggregateOutputType | null
    _min: HotspotsMinAggregateOutputType | null
    _max: HotspotsMaxAggregateOutputType | null
  }

  export type HotspotsAvgAggregateOutputType = {
    rankScore: number | null
    confidence: number | null
    similarityThreshold: number | null
    clusteringQualityScore: number | null
  }

  export type HotspotsSumAggregateOutputType = {
    rankScore: number | null
    confidence: number | null
    similarityThreshold: number | null
    clusteringQualityScore: number | null
  }

  export type HotspotsMinAggregateOutputType = {
    id: string | null
    title: string | null
    summary: string | null
    status: $Enums.HotspotStatus | null
    rankScore: number | null
    confidence: number | null
    primaryCategoryId: string | null
    clusteringMethod: string | null
    similarityThreshold: number | null
    lastAnalysisAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    clusteringQualityScore: number | null
    clusteringVersion: string | null
    lastClusteredAt: Date | null
  }

  export type HotspotsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    summary: string | null
    status: $Enums.HotspotStatus | null
    rankScore: number | null
    confidence: number | null
    primaryCategoryId: string | null
    clusteringMethod: string | null
    similarityThreshold: number | null
    lastAnalysisAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    clusteringQualityScore: number | null
    clusteringVersion: string | null
    lastClusteredAt: Date | null
  }

  export type HotspotsCountAggregateOutputType = {
    id: number
    title: number
    summary: number
    status: number
    rankScore: number
    confidence: number
    primaryCategoryId: number
    linkedEntitiesJson: number
    clusteringMethod: number
    similarityThreshold: number
    rcaBreakdownJson: number
    solutionSuggestionsJson: number
    decisionMatrixJson: number
    crossFunctionalImpactJson: number
    lastAnalysisAt: number
    createdAt: number
    updatedAt: number
    clusteringQualityScore: number
    clusteringResults: number
    clusteringVersion: number
    lastClusteredAt: number
    _all: number
  }


  export type HotspotsAvgAggregateInputType = {
    rankScore?: true
    confidence?: true
    similarityThreshold?: true
    clusteringQualityScore?: true
  }

  export type HotspotsSumAggregateInputType = {
    rankScore?: true
    confidence?: true
    similarityThreshold?: true
    clusteringQualityScore?: true
  }

  export type HotspotsMinAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    status?: true
    rankScore?: true
    confidence?: true
    primaryCategoryId?: true
    clusteringMethod?: true
    similarityThreshold?: true
    lastAnalysisAt?: true
    createdAt?: true
    updatedAt?: true
    clusteringQualityScore?: true
    clusteringVersion?: true
    lastClusteredAt?: true
  }

  export type HotspotsMaxAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    status?: true
    rankScore?: true
    confidence?: true
    primaryCategoryId?: true
    clusteringMethod?: true
    similarityThreshold?: true
    lastAnalysisAt?: true
    createdAt?: true
    updatedAt?: true
    clusteringQualityScore?: true
    clusteringVersion?: true
    lastClusteredAt?: true
  }

  export type HotspotsCountAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    status?: true
    rankScore?: true
    confidence?: true
    primaryCategoryId?: true
    linkedEntitiesJson?: true
    clusteringMethod?: true
    similarityThreshold?: true
    rcaBreakdownJson?: true
    solutionSuggestionsJson?: true
    decisionMatrixJson?: true
    crossFunctionalImpactJson?: true
    lastAnalysisAt?: true
    createdAt?: true
    updatedAt?: true
    clusteringQualityScore?: true
    clusteringResults?: true
    clusteringVersion?: true
    lastClusteredAt?: true
    _all?: true
  }

  export type HotspotsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hotspots to aggregate.
     */
    where?: hotspotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hotspots to fetch.
     */
    orderBy?: hotspotsOrderByWithRelationInput | hotspotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hotspotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hotspots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hotspots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hotspots
    **/
    _count?: true | HotspotsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotspotsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotspotsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotspotsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotspotsMaxAggregateInputType
  }

  export type GetHotspotsAggregateType<T extends HotspotsAggregateArgs> = {
        [P in keyof T & keyof AggregateHotspots]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotspots[P]>
      : GetScalarType<T[P], AggregateHotspots[P]>
  }




  export type hotspotsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hotspotsWhereInput
    orderBy?: hotspotsOrderByWithAggregationInput | hotspotsOrderByWithAggregationInput[]
    by: HotspotsScalarFieldEnum[] | HotspotsScalarFieldEnum
    having?: hotspotsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotspotsCountAggregateInputType | true
    _avg?: HotspotsAvgAggregateInputType
    _sum?: HotspotsSumAggregateInputType
    _min?: HotspotsMinAggregateInputType
    _max?: HotspotsMaxAggregateInputType
  }

  export type HotspotsGroupByOutputType = {
    id: string
    title: string
    summary: string
    status: $Enums.HotspotStatus
    rankScore: number
    confidence: number
    primaryCategoryId: string | null
    linkedEntitiesJson: JsonValue | null
    clusteringMethod: string | null
    similarityThreshold: number | null
    rcaBreakdownJson: JsonValue | null
    solutionSuggestionsJson: JsonValue | null
    decisionMatrixJson: JsonValue | null
    crossFunctionalImpactJson: JsonValue | null
    lastAnalysisAt: Date | null
    createdAt: Date
    updatedAt: Date
    clusteringQualityScore: number | null
    clusteringResults: JsonValue | null
    clusteringVersion: string | null
    lastClusteredAt: Date | null
    _count: HotspotsCountAggregateOutputType | null
    _avg: HotspotsAvgAggregateOutputType | null
    _sum: HotspotsSumAggregateOutputType | null
    _min: HotspotsMinAggregateOutputType | null
    _max: HotspotsMaxAggregateOutputType | null
  }

  type GetHotspotsGroupByPayload<T extends hotspotsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotspotsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotspotsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotspotsGroupByOutputType[P]>
            : GetScalarType<T[P], HotspotsGroupByOutputType[P]>
        }
      >
    >


  export type hotspotsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    summary?: boolean
    status?: boolean
    rankScore?: boolean
    confidence?: boolean
    primaryCategoryId?: boolean
    linkedEntitiesJson?: boolean
    clusteringMethod?: boolean
    similarityThreshold?: boolean
    rcaBreakdownJson?: boolean
    solutionSuggestionsJson?: boolean
    decisionMatrixJson?: boolean
    crossFunctionalImpactJson?: boolean
    lastAnalysisAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clusteringQualityScore?: boolean
    clusteringResults?: boolean
    clusteringVersion?: boolean
    lastClusteredAt?: boolean
    hotspot_signals?: boolean | hotspots$hotspot_signalsArgs<ExtArgs>
    ideas?: boolean | hotspots$ideasArgs<ExtArgs>
    solutions?: boolean | hotspots$solutionsArgs<ExtArgs>
    _count?: boolean | HotspotsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotspots"]>

  export type hotspotsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    summary?: boolean
    status?: boolean
    rankScore?: boolean
    confidence?: boolean
    primaryCategoryId?: boolean
    linkedEntitiesJson?: boolean
    clusteringMethod?: boolean
    similarityThreshold?: boolean
    rcaBreakdownJson?: boolean
    solutionSuggestionsJson?: boolean
    decisionMatrixJson?: boolean
    crossFunctionalImpactJson?: boolean
    lastAnalysisAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clusteringQualityScore?: boolean
    clusteringResults?: boolean
    clusteringVersion?: boolean
    lastClusteredAt?: boolean
  }, ExtArgs["result"]["hotspots"]>

  export type hotspotsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    summary?: boolean
    status?: boolean
    rankScore?: boolean
    confidence?: boolean
    primaryCategoryId?: boolean
    linkedEntitiesJson?: boolean
    clusteringMethod?: boolean
    similarityThreshold?: boolean
    rcaBreakdownJson?: boolean
    solutionSuggestionsJson?: boolean
    decisionMatrixJson?: boolean
    crossFunctionalImpactJson?: boolean
    lastAnalysisAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clusteringQualityScore?: boolean
    clusteringResults?: boolean
    clusteringVersion?: boolean
    lastClusteredAt?: boolean
  }, ExtArgs["result"]["hotspots"]>

  export type hotspotsSelectScalar = {
    id?: boolean
    title?: boolean
    summary?: boolean
    status?: boolean
    rankScore?: boolean
    confidence?: boolean
    primaryCategoryId?: boolean
    linkedEntitiesJson?: boolean
    clusteringMethod?: boolean
    similarityThreshold?: boolean
    rcaBreakdownJson?: boolean
    solutionSuggestionsJson?: boolean
    decisionMatrixJson?: boolean
    crossFunctionalImpactJson?: boolean
    lastAnalysisAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clusteringQualityScore?: boolean
    clusteringResults?: boolean
    clusteringVersion?: boolean
    lastClusteredAt?: boolean
  }

  export type hotspotsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "summary" | "status" | "rankScore" | "confidence" | "primaryCategoryId" | "linkedEntitiesJson" | "clusteringMethod" | "similarityThreshold" | "rcaBreakdownJson" | "solutionSuggestionsJson" | "decisionMatrixJson" | "crossFunctionalImpactJson" | "lastAnalysisAt" | "createdAt" | "updatedAt" | "clusteringQualityScore" | "clusteringResults" | "clusteringVersion" | "lastClusteredAt", ExtArgs["result"]["hotspots"]>
  export type hotspotsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotspot_signals?: boolean | hotspots$hotspot_signalsArgs<ExtArgs>
    ideas?: boolean | hotspots$ideasArgs<ExtArgs>
    solutions?: boolean | hotspots$solutionsArgs<ExtArgs>
    _count?: boolean | HotspotsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type hotspotsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type hotspotsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $hotspotsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "hotspots"
    objects: {
      hotspot_signals: Prisma.$hotspot_signalsPayload<ExtArgs>[]
      ideas: Prisma.$ideasPayload<ExtArgs>[]
      solutions: Prisma.$solutionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      summary: string
      status: $Enums.HotspotStatus
      rankScore: number
      confidence: number
      primaryCategoryId: string | null
      linkedEntitiesJson: Prisma.JsonValue | null
      clusteringMethod: string | null
      similarityThreshold: number | null
      rcaBreakdownJson: Prisma.JsonValue | null
      solutionSuggestionsJson: Prisma.JsonValue | null
      decisionMatrixJson: Prisma.JsonValue | null
      crossFunctionalImpactJson: Prisma.JsonValue | null
      lastAnalysisAt: Date | null
      createdAt: Date
      updatedAt: Date
      clusteringQualityScore: number | null
      clusteringResults: Prisma.JsonValue | null
      clusteringVersion: string | null
      lastClusteredAt: Date | null
    }, ExtArgs["result"]["hotspots"]>
    composites: {}
  }

  type hotspotsGetPayload<S extends boolean | null | undefined | hotspotsDefaultArgs> = $Result.GetResult<Prisma.$hotspotsPayload, S>

  type hotspotsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<hotspotsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotspotsCountAggregateInputType | true
    }

  export interface hotspotsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['hotspots'], meta: { name: 'hotspots' } }
    /**
     * Find zero or one Hotspots that matches the filter.
     * @param {hotspotsFindUniqueArgs} args - Arguments to find a Hotspots
     * @example
     * // Get one Hotspots
     * const hotspots = await prisma.hotspots.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends hotspotsFindUniqueArgs>(args: SelectSubset<T, hotspotsFindUniqueArgs<ExtArgs>>): Prisma__hotspotsClient<$Result.GetResult<Prisma.$hotspotsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hotspots that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {hotspotsFindUniqueOrThrowArgs} args - Arguments to find a Hotspots
     * @example
     * // Get one Hotspots
     * const hotspots = await prisma.hotspots.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends hotspotsFindUniqueOrThrowArgs>(args: SelectSubset<T, hotspotsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__hotspotsClient<$Result.GetResult<Prisma.$hotspotsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hotspots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotspotsFindFirstArgs} args - Arguments to find a Hotspots
     * @example
     * // Get one Hotspots
     * const hotspots = await prisma.hotspots.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends hotspotsFindFirstArgs>(args?: SelectSubset<T, hotspotsFindFirstArgs<ExtArgs>>): Prisma__hotspotsClient<$Result.GetResult<Prisma.$hotspotsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hotspots that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotspotsFindFirstOrThrowArgs} args - Arguments to find a Hotspots
     * @example
     * // Get one Hotspots
     * const hotspots = await prisma.hotspots.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends hotspotsFindFirstOrThrowArgs>(args?: SelectSubset<T, hotspotsFindFirstOrThrowArgs<ExtArgs>>): Prisma__hotspotsClient<$Result.GetResult<Prisma.$hotspotsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hotspots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotspotsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hotspots
     * const hotspots = await prisma.hotspots.findMany()
     * 
     * // Get first 10 Hotspots
     * const hotspots = await prisma.hotspots.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotspotsWithIdOnly = await prisma.hotspots.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends hotspotsFindManyArgs>(args?: SelectSubset<T, hotspotsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hotspotsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hotspots.
     * @param {hotspotsCreateArgs} args - Arguments to create a Hotspots.
     * @example
     * // Create one Hotspots
     * const Hotspots = await prisma.hotspots.create({
     *   data: {
     *     // ... data to create a Hotspots
     *   }
     * })
     * 
     */
    create<T extends hotspotsCreateArgs>(args: SelectSubset<T, hotspotsCreateArgs<ExtArgs>>): Prisma__hotspotsClient<$Result.GetResult<Prisma.$hotspotsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hotspots.
     * @param {hotspotsCreateManyArgs} args - Arguments to create many Hotspots.
     * @example
     * // Create many Hotspots
     * const hotspots = await prisma.hotspots.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends hotspotsCreateManyArgs>(args?: SelectSubset<T, hotspotsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hotspots and returns the data saved in the database.
     * @param {hotspotsCreateManyAndReturnArgs} args - Arguments to create many Hotspots.
     * @example
     * // Create many Hotspots
     * const hotspots = await prisma.hotspots.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hotspots and only return the `id`
     * const hotspotsWithIdOnly = await prisma.hotspots.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends hotspotsCreateManyAndReturnArgs>(args?: SelectSubset<T, hotspotsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hotspotsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Hotspots.
     * @param {hotspotsDeleteArgs} args - Arguments to delete one Hotspots.
     * @example
     * // Delete one Hotspots
     * const Hotspots = await prisma.hotspots.delete({
     *   where: {
     *     // ... filter to delete one Hotspots
     *   }
     * })
     * 
     */
    delete<T extends hotspotsDeleteArgs>(args: SelectSubset<T, hotspotsDeleteArgs<ExtArgs>>): Prisma__hotspotsClient<$Result.GetResult<Prisma.$hotspotsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hotspots.
     * @param {hotspotsUpdateArgs} args - Arguments to update one Hotspots.
     * @example
     * // Update one Hotspots
     * const hotspots = await prisma.hotspots.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends hotspotsUpdateArgs>(args: SelectSubset<T, hotspotsUpdateArgs<ExtArgs>>): Prisma__hotspotsClient<$Result.GetResult<Prisma.$hotspotsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hotspots.
     * @param {hotspotsDeleteManyArgs} args - Arguments to filter Hotspots to delete.
     * @example
     * // Delete a few Hotspots
     * const { count } = await prisma.hotspots.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends hotspotsDeleteManyArgs>(args?: SelectSubset<T, hotspotsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hotspots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotspotsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hotspots
     * const hotspots = await prisma.hotspots.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends hotspotsUpdateManyArgs>(args: SelectSubset<T, hotspotsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hotspots and returns the data updated in the database.
     * @param {hotspotsUpdateManyAndReturnArgs} args - Arguments to update many Hotspots.
     * @example
     * // Update many Hotspots
     * const hotspots = await prisma.hotspots.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Hotspots and only return the `id`
     * const hotspotsWithIdOnly = await prisma.hotspots.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends hotspotsUpdateManyAndReturnArgs>(args: SelectSubset<T, hotspotsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hotspotsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Hotspots.
     * @param {hotspotsUpsertArgs} args - Arguments to update or create a Hotspots.
     * @example
     * // Update or create a Hotspots
     * const hotspots = await prisma.hotspots.upsert({
     *   create: {
     *     // ... data to create a Hotspots
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hotspots we want to update
     *   }
     * })
     */
    upsert<T extends hotspotsUpsertArgs>(args: SelectSubset<T, hotspotsUpsertArgs<ExtArgs>>): Prisma__hotspotsClient<$Result.GetResult<Prisma.$hotspotsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hotspots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotspotsCountArgs} args - Arguments to filter Hotspots to count.
     * @example
     * // Count the number of Hotspots
     * const count = await prisma.hotspots.count({
     *   where: {
     *     // ... the filter for the Hotspots we want to count
     *   }
     * })
    **/
    count<T extends hotspotsCountArgs>(
      args?: Subset<T, hotspotsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotspotsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hotspots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotspotsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotspotsAggregateArgs>(args: Subset<T, HotspotsAggregateArgs>): Prisma.PrismaPromise<GetHotspotsAggregateType<T>>

    /**
     * Group by Hotspots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotspotsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends hotspotsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: hotspotsGroupByArgs['orderBy'] }
        : { orderBy?: hotspotsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, hotspotsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotspotsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the hotspots model
   */
  readonly fields: hotspotsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for hotspots.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__hotspotsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotspot_signals<T extends hotspots$hotspot_signalsArgs<ExtArgs> = {}>(args?: Subset<T, hotspots$hotspot_signalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hotspot_signalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ideas<T extends hotspots$ideasArgs<ExtArgs> = {}>(args?: Subset<T, hotspots$ideasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ideasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    solutions<T extends hotspots$solutionsArgs<ExtArgs> = {}>(args?: Subset<T, hotspots$solutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$solutionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the hotspots model
   */
  interface hotspotsFieldRefs {
    readonly id: FieldRef<"hotspots", 'String'>
    readonly title: FieldRef<"hotspots", 'String'>
    readonly summary: FieldRef<"hotspots", 'String'>
    readonly status: FieldRef<"hotspots", 'HotspotStatus'>
    readonly rankScore: FieldRef<"hotspots", 'Float'>
    readonly confidence: FieldRef<"hotspots", 'Float'>
    readonly primaryCategoryId: FieldRef<"hotspots", 'String'>
    readonly linkedEntitiesJson: FieldRef<"hotspots", 'Json'>
    readonly clusteringMethod: FieldRef<"hotspots", 'String'>
    readonly similarityThreshold: FieldRef<"hotspots", 'Float'>
    readonly rcaBreakdownJson: FieldRef<"hotspots", 'Json'>
    readonly solutionSuggestionsJson: FieldRef<"hotspots", 'Json'>
    readonly decisionMatrixJson: FieldRef<"hotspots", 'Json'>
    readonly crossFunctionalImpactJson: FieldRef<"hotspots", 'Json'>
    readonly lastAnalysisAt: FieldRef<"hotspots", 'DateTime'>
    readonly createdAt: FieldRef<"hotspots", 'DateTime'>
    readonly updatedAt: FieldRef<"hotspots", 'DateTime'>
    readonly clusteringQualityScore: FieldRef<"hotspots", 'Float'>
    readonly clusteringResults: FieldRef<"hotspots", 'Json'>
    readonly clusteringVersion: FieldRef<"hotspots", 'String'>
    readonly lastClusteredAt: FieldRef<"hotspots", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * hotspots findUnique
   */
  export type hotspotsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspots
     */
    select?: hotspotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspots
     */
    omit?: hotspotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspotsInclude<ExtArgs> | null
    /**
     * Filter, which hotspots to fetch.
     */
    where: hotspotsWhereUniqueInput
  }

  /**
   * hotspots findUniqueOrThrow
   */
  export type hotspotsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspots
     */
    select?: hotspotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspots
     */
    omit?: hotspotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspotsInclude<ExtArgs> | null
    /**
     * Filter, which hotspots to fetch.
     */
    where: hotspotsWhereUniqueInput
  }

  /**
   * hotspots findFirst
   */
  export type hotspotsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspots
     */
    select?: hotspotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspots
     */
    omit?: hotspotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspotsInclude<ExtArgs> | null
    /**
     * Filter, which hotspots to fetch.
     */
    where?: hotspotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hotspots to fetch.
     */
    orderBy?: hotspotsOrderByWithRelationInput | hotspotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hotspots.
     */
    cursor?: hotspotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hotspots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hotspots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hotspots.
     */
    distinct?: HotspotsScalarFieldEnum | HotspotsScalarFieldEnum[]
  }

  /**
   * hotspots findFirstOrThrow
   */
  export type hotspotsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspots
     */
    select?: hotspotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspots
     */
    omit?: hotspotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspotsInclude<ExtArgs> | null
    /**
     * Filter, which hotspots to fetch.
     */
    where?: hotspotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hotspots to fetch.
     */
    orderBy?: hotspotsOrderByWithRelationInput | hotspotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hotspots.
     */
    cursor?: hotspotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hotspots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hotspots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hotspots.
     */
    distinct?: HotspotsScalarFieldEnum | HotspotsScalarFieldEnum[]
  }

  /**
   * hotspots findMany
   */
  export type hotspotsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspots
     */
    select?: hotspotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspots
     */
    omit?: hotspotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspotsInclude<ExtArgs> | null
    /**
     * Filter, which hotspots to fetch.
     */
    where?: hotspotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hotspots to fetch.
     */
    orderBy?: hotspotsOrderByWithRelationInput | hotspotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hotspots.
     */
    cursor?: hotspotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hotspots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hotspots.
     */
    skip?: number
    distinct?: HotspotsScalarFieldEnum | HotspotsScalarFieldEnum[]
  }

  /**
   * hotspots create
   */
  export type hotspotsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspots
     */
    select?: hotspotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspots
     */
    omit?: hotspotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspotsInclude<ExtArgs> | null
    /**
     * The data needed to create a hotspots.
     */
    data: XOR<hotspotsCreateInput, hotspotsUncheckedCreateInput>
  }

  /**
   * hotspots createMany
   */
  export type hotspotsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many hotspots.
     */
    data: hotspotsCreateManyInput | hotspotsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * hotspots createManyAndReturn
   */
  export type hotspotsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspots
     */
    select?: hotspotsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the hotspots
     */
    omit?: hotspotsOmit<ExtArgs> | null
    /**
     * The data used to create many hotspots.
     */
    data: hotspotsCreateManyInput | hotspotsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * hotspots update
   */
  export type hotspotsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspots
     */
    select?: hotspotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspots
     */
    omit?: hotspotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspotsInclude<ExtArgs> | null
    /**
     * The data needed to update a hotspots.
     */
    data: XOR<hotspotsUpdateInput, hotspotsUncheckedUpdateInput>
    /**
     * Choose, which hotspots to update.
     */
    where: hotspotsWhereUniqueInput
  }

  /**
   * hotspots updateMany
   */
  export type hotspotsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update hotspots.
     */
    data: XOR<hotspotsUpdateManyMutationInput, hotspotsUncheckedUpdateManyInput>
    /**
     * Filter which hotspots to update
     */
    where?: hotspotsWhereInput
    /**
     * Limit how many hotspots to update.
     */
    limit?: number
  }

  /**
   * hotspots updateManyAndReturn
   */
  export type hotspotsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspots
     */
    select?: hotspotsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the hotspots
     */
    omit?: hotspotsOmit<ExtArgs> | null
    /**
     * The data used to update hotspots.
     */
    data: XOR<hotspotsUpdateManyMutationInput, hotspotsUncheckedUpdateManyInput>
    /**
     * Filter which hotspots to update
     */
    where?: hotspotsWhereInput
    /**
     * Limit how many hotspots to update.
     */
    limit?: number
  }

  /**
   * hotspots upsert
   */
  export type hotspotsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspots
     */
    select?: hotspotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspots
     */
    omit?: hotspotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspotsInclude<ExtArgs> | null
    /**
     * The filter to search for the hotspots to update in case it exists.
     */
    where: hotspotsWhereUniqueInput
    /**
     * In case the hotspots found by the `where` argument doesn't exist, create a new hotspots with this data.
     */
    create: XOR<hotspotsCreateInput, hotspotsUncheckedCreateInput>
    /**
     * In case the hotspots was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hotspotsUpdateInput, hotspotsUncheckedUpdateInput>
  }

  /**
   * hotspots delete
   */
  export type hotspotsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspots
     */
    select?: hotspotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspots
     */
    omit?: hotspotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspotsInclude<ExtArgs> | null
    /**
     * Filter which hotspots to delete.
     */
    where: hotspotsWhereUniqueInput
  }

  /**
   * hotspots deleteMany
   */
  export type hotspotsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hotspots to delete
     */
    where?: hotspotsWhereInput
    /**
     * Limit how many hotspots to delete.
     */
    limit?: number
  }

  /**
   * hotspots.hotspot_signals
   */
  export type hotspots$hotspot_signalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspot_signals
     */
    select?: hotspot_signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspot_signals
     */
    omit?: hotspot_signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspot_signalsInclude<ExtArgs> | null
    where?: hotspot_signalsWhereInput
    orderBy?: hotspot_signalsOrderByWithRelationInput | hotspot_signalsOrderByWithRelationInput[]
    cursor?: hotspot_signalsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Hotspot_signalsScalarFieldEnum | Hotspot_signalsScalarFieldEnum[]
  }

  /**
   * hotspots.ideas
   */
  export type hotspots$ideasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ideas
     */
    select?: ideasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ideas
     */
    omit?: ideasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ideasInclude<ExtArgs> | null
    where?: ideasWhereInput
    orderBy?: ideasOrderByWithRelationInput | ideasOrderByWithRelationInput[]
    cursor?: ideasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IdeasScalarFieldEnum | IdeasScalarFieldEnum[]
  }

  /**
   * hotspots.solutions
   */
  export type hotspots$solutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the solutions
     */
    select?: solutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the solutions
     */
    omit?: solutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: solutionsInclude<ExtArgs> | null
    where?: solutionsWhereInput
    orderBy?: solutionsOrderByWithRelationInput | solutionsOrderByWithRelationInput[]
    cursor?: solutionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SolutionsScalarFieldEnum | SolutionsScalarFieldEnum[]
  }

  /**
   * hotspots without action
   */
  export type hotspotsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspots
     */
    select?: hotspotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspots
     */
    omit?: hotspotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspotsInclude<ExtArgs> | null
  }


  /**
   * Model ideas
   */

  export type AggregateIdeas = {
    _count: IdeasCountAggregateOutputType | null
    _avg: IdeasAvgAggregateOutputType | null
    _sum: IdeasSumAggregateOutputType | null
    _min: IdeasMinAggregateOutputType | null
    _max: IdeasMaxAggregateOutputType | null
  }

  export type IdeasAvgAggregateOutputType = {
    votes: number | null
    confidence: number | null
  }

  export type IdeasSumAggregateOutputType = {
    votes: number | null
    confidence: number | null
  }

  export type IdeasMinAggregateOutputType = {
    id: string | null
    hotspotId: string | null
    title: string | null
    description: string | null
    origin: string | null
    votes: number | null
    status: string | null
    confidence: number | null
    createdById: string | null
    initiativeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IdeasMaxAggregateOutputType = {
    id: string | null
    hotspotId: string | null
    title: string | null
    description: string | null
    origin: string | null
    votes: number | null
    status: string | null
    confidence: number | null
    createdById: string | null
    initiativeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IdeasCountAggregateOutputType = {
    id: number
    hotspotId: number
    title: number
    description: number
    origin: number
    votes: number
    status: number
    evidenceJson: number
    tagsJson: number
    confidence: number
    createdById: number
    initiativeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IdeasAvgAggregateInputType = {
    votes?: true
    confidence?: true
  }

  export type IdeasSumAggregateInputType = {
    votes?: true
    confidence?: true
  }

  export type IdeasMinAggregateInputType = {
    id?: true
    hotspotId?: true
    title?: true
    description?: true
    origin?: true
    votes?: true
    status?: true
    confidence?: true
    createdById?: true
    initiativeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IdeasMaxAggregateInputType = {
    id?: true
    hotspotId?: true
    title?: true
    description?: true
    origin?: true
    votes?: true
    status?: true
    confidence?: true
    createdById?: true
    initiativeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IdeasCountAggregateInputType = {
    id?: true
    hotspotId?: true
    title?: true
    description?: true
    origin?: true
    votes?: true
    status?: true
    evidenceJson?: true
    tagsJson?: true
    confidence?: true
    createdById?: true
    initiativeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IdeasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ideas to aggregate.
     */
    where?: ideasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ideas to fetch.
     */
    orderBy?: ideasOrderByWithRelationInput | ideasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ideasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ideas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ideas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ideas
    **/
    _count?: true | IdeasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IdeasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IdeasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IdeasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IdeasMaxAggregateInputType
  }

  export type GetIdeasAggregateType<T extends IdeasAggregateArgs> = {
        [P in keyof T & keyof AggregateIdeas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIdeas[P]>
      : GetScalarType<T[P], AggregateIdeas[P]>
  }




  export type ideasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ideasWhereInput
    orderBy?: ideasOrderByWithAggregationInput | ideasOrderByWithAggregationInput[]
    by: IdeasScalarFieldEnum[] | IdeasScalarFieldEnum
    having?: ideasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IdeasCountAggregateInputType | true
    _avg?: IdeasAvgAggregateInputType
    _sum?: IdeasSumAggregateInputType
    _min?: IdeasMinAggregateInputType
    _max?: IdeasMaxAggregateInputType
  }

  export type IdeasGroupByOutputType = {
    id: string
    hotspotId: string
    title: string | null
    description: string
    origin: string
    votes: number
    status: string
    evidenceJson: JsonValue | null
    tagsJson: JsonValue | null
    confidence: number | null
    createdById: string | null
    initiativeId: string | null
    createdAt: Date
    updatedAt: Date
    _count: IdeasCountAggregateOutputType | null
    _avg: IdeasAvgAggregateOutputType | null
    _sum: IdeasSumAggregateOutputType | null
    _min: IdeasMinAggregateOutputType | null
    _max: IdeasMaxAggregateOutputType | null
  }

  type GetIdeasGroupByPayload<T extends ideasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IdeasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IdeasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IdeasGroupByOutputType[P]>
            : GetScalarType<T[P], IdeasGroupByOutputType[P]>
        }
      >
    >


  export type ideasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotspotId?: boolean
    title?: boolean
    description?: boolean
    origin?: boolean
    votes?: boolean
    status?: boolean
    evidenceJson?: boolean
    tagsJson?: boolean
    confidence?: boolean
    createdById?: boolean
    initiativeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | ideas$usersArgs<ExtArgs>
    hotspots?: boolean | hotspotsDefaultArgs<ExtArgs>
    initiatives?: boolean | ideas$initiativesArgs<ExtArgs>
    solutions?: boolean | ideas$solutionsArgs<ExtArgs>
  }, ExtArgs["result"]["ideas"]>

  export type ideasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotspotId?: boolean
    title?: boolean
    description?: boolean
    origin?: boolean
    votes?: boolean
    status?: boolean
    evidenceJson?: boolean
    tagsJson?: boolean
    confidence?: boolean
    createdById?: boolean
    initiativeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | ideas$usersArgs<ExtArgs>
    hotspots?: boolean | hotspotsDefaultArgs<ExtArgs>
    initiatives?: boolean | ideas$initiativesArgs<ExtArgs>
  }, ExtArgs["result"]["ideas"]>

  export type ideasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotspotId?: boolean
    title?: boolean
    description?: boolean
    origin?: boolean
    votes?: boolean
    status?: boolean
    evidenceJson?: boolean
    tagsJson?: boolean
    confidence?: boolean
    createdById?: boolean
    initiativeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | ideas$usersArgs<ExtArgs>
    hotspots?: boolean | hotspotsDefaultArgs<ExtArgs>
    initiatives?: boolean | ideas$initiativesArgs<ExtArgs>
  }, ExtArgs["result"]["ideas"]>

  export type ideasSelectScalar = {
    id?: boolean
    hotspotId?: boolean
    title?: boolean
    description?: boolean
    origin?: boolean
    votes?: boolean
    status?: boolean
    evidenceJson?: boolean
    tagsJson?: boolean
    confidence?: boolean
    createdById?: boolean
    initiativeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ideasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hotspotId" | "title" | "description" | "origin" | "votes" | "status" | "evidenceJson" | "tagsJson" | "confidence" | "createdById" | "initiativeId" | "createdAt" | "updatedAt", ExtArgs["result"]["ideas"]>
  export type ideasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ideas$usersArgs<ExtArgs>
    hotspots?: boolean | hotspotsDefaultArgs<ExtArgs>
    initiatives?: boolean | ideas$initiativesArgs<ExtArgs>
    solutions?: boolean | ideas$solutionsArgs<ExtArgs>
  }
  export type ideasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ideas$usersArgs<ExtArgs>
    hotspots?: boolean | hotspotsDefaultArgs<ExtArgs>
    initiatives?: boolean | ideas$initiativesArgs<ExtArgs>
  }
  export type ideasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ideas$usersArgs<ExtArgs>
    hotspots?: boolean | hotspotsDefaultArgs<ExtArgs>
    initiatives?: boolean | ideas$initiativesArgs<ExtArgs>
  }

  export type $ideasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ideas"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
      hotspots: Prisma.$hotspotsPayload<ExtArgs>
      initiatives: Prisma.$initiativesPayload<ExtArgs> | null
      solutions: Prisma.$solutionsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hotspotId: string
      title: string | null
      description: string
      origin: string
      votes: number
      status: string
      evidenceJson: Prisma.JsonValue | null
      tagsJson: Prisma.JsonValue | null
      confidence: number | null
      createdById: string | null
      initiativeId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ideas"]>
    composites: {}
  }

  type ideasGetPayload<S extends boolean | null | undefined | ideasDefaultArgs> = $Result.GetResult<Prisma.$ideasPayload, S>

  type ideasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ideasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IdeasCountAggregateInputType | true
    }

  export interface ideasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ideas'], meta: { name: 'ideas' } }
    /**
     * Find zero or one Ideas that matches the filter.
     * @param {ideasFindUniqueArgs} args - Arguments to find a Ideas
     * @example
     * // Get one Ideas
     * const ideas = await prisma.ideas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ideasFindUniqueArgs>(args: SelectSubset<T, ideasFindUniqueArgs<ExtArgs>>): Prisma__ideasClient<$Result.GetResult<Prisma.$ideasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ideas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ideasFindUniqueOrThrowArgs} args - Arguments to find a Ideas
     * @example
     * // Get one Ideas
     * const ideas = await prisma.ideas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ideasFindUniqueOrThrowArgs>(args: SelectSubset<T, ideasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ideasClient<$Result.GetResult<Prisma.$ideasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ideas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ideasFindFirstArgs} args - Arguments to find a Ideas
     * @example
     * // Get one Ideas
     * const ideas = await prisma.ideas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ideasFindFirstArgs>(args?: SelectSubset<T, ideasFindFirstArgs<ExtArgs>>): Prisma__ideasClient<$Result.GetResult<Prisma.$ideasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ideas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ideasFindFirstOrThrowArgs} args - Arguments to find a Ideas
     * @example
     * // Get one Ideas
     * const ideas = await prisma.ideas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ideasFindFirstOrThrowArgs>(args?: SelectSubset<T, ideasFindFirstOrThrowArgs<ExtArgs>>): Prisma__ideasClient<$Result.GetResult<Prisma.$ideasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ideas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ideasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ideas
     * const ideas = await prisma.ideas.findMany()
     * 
     * // Get first 10 Ideas
     * const ideas = await prisma.ideas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ideasWithIdOnly = await prisma.ideas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ideasFindManyArgs>(args?: SelectSubset<T, ideasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ideasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ideas.
     * @param {ideasCreateArgs} args - Arguments to create a Ideas.
     * @example
     * // Create one Ideas
     * const Ideas = await prisma.ideas.create({
     *   data: {
     *     // ... data to create a Ideas
     *   }
     * })
     * 
     */
    create<T extends ideasCreateArgs>(args: SelectSubset<T, ideasCreateArgs<ExtArgs>>): Prisma__ideasClient<$Result.GetResult<Prisma.$ideasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ideas.
     * @param {ideasCreateManyArgs} args - Arguments to create many Ideas.
     * @example
     * // Create many Ideas
     * const ideas = await prisma.ideas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ideasCreateManyArgs>(args?: SelectSubset<T, ideasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ideas and returns the data saved in the database.
     * @param {ideasCreateManyAndReturnArgs} args - Arguments to create many Ideas.
     * @example
     * // Create many Ideas
     * const ideas = await prisma.ideas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ideas and only return the `id`
     * const ideasWithIdOnly = await prisma.ideas.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ideasCreateManyAndReturnArgs>(args?: SelectSubset<T, ideasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ideasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ideas.
     * @param {ideasDeleteArgs} args - Arguments to delete one Ideas.
     * @example
     * // Delete one Ideas
     * const Ideas = await prisma.ideas.delete({
     *   where: {
     *     // ... filter to delete one Ideas
     *   }
     * })
     * 
     */
    delete<T extends ideasDeleteArgs>(args: SelectSubset<T, ideasDeleteArgs<ExtArgs>>): Prisma__ideasClient<$Result.GetResult<Prisma.$ideasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ideas.
     * @param {ideasUpdateArgs} args - Arguments to update one Ideas.
     * @example
     * // Update one Ideas
     * const ideas = await prisma.ideas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ideasUpdateArgs>(args: SelectSubset<T, ideasUpdateArgs<ExtArgs>>): Prisma__ideasClient<$Result.GetResult<Prisma.$ideasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ideas.
     * @param {ideasDeleteManyArgs} args - Arguments to filter Ideas to delete.
     * @example
     * // Delete a few Ideas
     * const { count } = await prisma.ideas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ideasDeleteManyArgs>(args?: SelectSubset<T, ideasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ideas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ideasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ideas
     * const ideas = await prisma.ideas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ideasUpdateManyArgs>(args: SelectSubset<T, ideasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ideas and returns the data updated in the database.
     * @param {ideasUpdateManyAndReturnArgs} args - Arguments to update many Ideas.
     * @example
     * // Update many Ideas
     * const ideas = await prisma.ideas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ideas and only return the `id`
     * const ideasWithIdOnly = await prisma.ideas.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ideasUpdateManyAndReturnArgs>(args: SelectSubset<T, ideasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ideasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ideas.
     * @param {ideasUpsertArgs} args - Arguments to update or create a Ideas.
     * @example
     * // Update or create a Ideas
     * const ideas = await prisma.ideas.upsert({
     *   create: {
     *     // ... data to create a Ideas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ideas we want to update
     *   }
     * })
     */
    upsert<T extends ideasUpsertArgs>(args: SelectSubset<T, ideasUpsertArgs<ExtArgs>>): Prisma__ideasClient<$Result.GetResult<Prisma.$ideasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ideas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ideasCountArgs} args - Arguments to filter Ideas to count.
     * @example
     * // Count the number of Ideas
     * const count = await prisma.ideas.count({
     *   where: {
     *     // ... the filter for the Ideas we want to count
     *   }
     * })
    **/
    count<T extends ideasCountArgs>(
      args?: Subset<T, ideasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IdeasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ideas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IdeasAggregateArgs>(args: Subset<T, IdeasAggregateArgs>): Prisma.PrismaPromise<GetIdeasAggregateType<T>>

    /**
     * Group by Ideas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ideasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ideasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ideasGroupByArgs['orderBy'] }
        : { orderBy?: ideasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ideasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIdeasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ideas model
   */
  readonly fields: ideasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ideas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ideasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends ideas$usersArgs<ExtArgs> = {}>(args?: Subset<T, ideas$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    hotspots<T extends hotspotsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, hotspotsDefaultArgs<ExtArgs>>): Prisma__hotspotsClient<$Result.GetResult<Prisma.$hotspotsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    initiatives<T extends ideas$initiativesArgs<ExtArgs> = {}>(args?: Subset<T, ideas$initiativesArgs<ExtArgs>>): Prisma__initiativesClient<$Result.GetResult<Prisma.$initiativesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    solutions<T extends ideas$solutionsArgs<ExtArgs> = {}>(args?: Subset<T, ideas$solutionsArgs<ExtArgs>>): Prisma__solutionsClient<$Result.GetResult<Prisma.$solutionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ideas model
   */
  interface ideasFieldRefs {
    readonly id: FieldRef<"ideas", 'String'>
    readonly hotspotId: FieldRef<"ideas", 'String'>
    readonly title: FieldRef<"ideas", 'String'>
    readonly description: FieldRef<"ideas", 'String'>
    readonly origin: FieldRef<"ideas", 'String'>
    readonly votes: FieldRef<"ideas", 'Int'>
    readonly status: FieldRef<"ideas", 'String'>
    readonly evidenceJson: FieldRef<"ideas", 'Json'>
    readonly tagsJson: FieldRef<"ideas", 'Json'>
    readonly confidence: FieldRef<"ideas", 'Float'>
    readonly createdById: FieldRef<"ideas", 'String'>
    readonly initiativeId: FieldRef<"ideas", 'String'>
    readonly createdAt: FieldRef<"ideas", 'DateTime'>
    readonly updatedAt: FieldRef<"ideas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ideas findUnique
   */
  export type ideasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ideas
     */
    select?: ideasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ideas
     */
    omit?: ideasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ideasInclude<ExtArgs> | null
    /**
     * Filter, which ideas to fetch.
     */
    where: ideasWhereUniqueInput
  }

  /**
   * ideas findUniqueOrThrow
   */
  export type ideasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ideas
     */
    select?: ideasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ideas
     */
    omit?: ideasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ideasInclude<ExtArgs> | null
    /**
     * Filter, which ideas to fetch.
     */
    where: ideasWhereUniqueInput
  }

  /**
   * ideas findFirst
   */
  export type ideasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ideas
     */
    select?: ideasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ideas
     */
    omit?: ideasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ideasInclude<ExtArgs> | null
    /**
     * Filter, which ideas to fetch.
     */
    where?: ideasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ideas to fetch.
     */
    orderBy?: ideasOrderByWithRelationInput | ideasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ideas.
     */
    cursor?: ideasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ideas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ideas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ideas.
     */
    distinct?: IdeasScalarFieldEnum | IdeasScalarFieldEnum[]
  }

  /**
   * ideas findFirstOrThrow
   */
  export type ideasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ideas
     */
    select?: ideasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ideas
     */
    omit?: ideasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ideasInclude<ExtArgs> | null
    /**
     * Filter, which ideas to fetch.
     */
    where?: ideasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ideas to fetch.
     */
    orderBy?: ideasOrderByWithRelationInput | ideasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ideas.
     */
    cursor?: ideasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ideas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ideas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ideas.
     */
    distinct?: IdeasScalarFieldEnum | IdeasScalarFieldEnum[]
  }

  /**
   * ideas findMany
   */
  export type ideasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ideas
     */
    select?: ideasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ideas
     */
    omit?: ideasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ideasInclude<ExtArgs> | null
    /**
     * Filter, which ideas to fetch.
     */
    where?: ideasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ideas to fetch.
     */
    orderBy?: ideasOrderByWithRelationInput | ideasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ideas.
     */
    cursor?: ideasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ideas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ideas.
     */
    skip?: number
    distinct?: IdeasScalarFieldEnum | IdeasScalarFieldEnum[]
  }

  /**
   * ideas create
   */
  export type ideasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ideas
     */
    select?: ideasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ideas
     */
    omit?: ideasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ideasInclude<ExtArgs> | null
    /**
     * The data needed to create a ideas.
     */
    data: XOR<ideasCreateInput, ideasUncheckedCreateInput>
  }

  /**
   * ideas createMany
   */
  export type ideasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ideas.
     */
    data: ideasCreateManyInput | ideasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ideas createManyAndReturn
   */
  export type ideasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ideas
     */
    select?: ideasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ideas
     */
    omit?: ideasOmit<ExtArgs> | null
    /**
     * The data used to create many ideas.
     */
    data: ideasCreateManyInput | ideasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ideasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ideas update
   */
  export type ideasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ideas
     */
    select?: ideasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ideas
     */
    omit?: ideasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ideasInclude<ExtArgs> | null
    /**
     * The data needed to update a ideas.
     */
    data: XOR<ideasUpdateInput, ideasUncheckedUpdateInput>
    /**
     * Choose, which ideas to update.
     */
    where: ideasWhereUniqueInput
  }

  /**
   * ideas updateMany
   */
  export type ideasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ideas.
     */
    data: XOR<ideasUpdateManyMutationInput, ideasUncheckedUpdateManyInput>
    /**
     * Filter which ideas to update
     */
    where?: ideasWhereInput
    /**
     * Limit how many ideas to update.
     */
    limit?: number
  }

  /**
   * ideas updateManyAndReturn
   */
  export type ideasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ideas
     */
    select?: ideasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ideas
     */
    omit?: ideasOmit<ExtArgs> | null
    /**
     * The data used to update ideas.
     */
    data: XOR<ideasUpdateManyMutationInput, ideasUncheckedUpdateManyInput>
    /**
     * Filter which ideas to update
     */
    where?: ideasWhereInput
    /**
     * Limit how many ideas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ideasIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ideas upsert
   */
  export type ideasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ideas
     */
    select?: ideasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ideas
     */
    omit?: ideasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ideasInclude<ExtArgs> | null
    /**
     * The filter to search for the ideas to update in case it exists.
     */
    where: ideasWhereUniqueInput
    /**
     * In case the ideas found by the `where` argument doesn't exist, create a new ideas with this data.
     */
    create: XOR<ideasCreateInput, ideasUncheckedCreateInput>
    /**
     * In case the ideas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ideasUpdateInput, ideasUncheckedUpdateInput>
  }

  /**
   * ideas delete
   */
  export type ideasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ideas
     */
    select?: ideasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ideas
     */
    omit?: ideasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ideasInclude<ExtArgs> | null
    /**
     * Filter which ideas to delete.
     */
    where: ideasWhereUniqueInput
  }

  /**
   * ideas deleteMany
   */
  export type ideasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ideas to delete
     */
    where?: ideasWhereInput
    /**
     * Limit how many ideas to delete.
     */
    limit?: number
  }

  /**
   * ideas.users
   */
  export type ideas$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * ideas.initiatives
   */
  export type ideas$initiativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the initiatives
     */
    select?: initiativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the initiatives
     */
    omit?: initiativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: initiativesInclude<ExtArgs> | null
    where?: initiativesWhereInput
  }

  /**
   * ideas.solutions
   */
  export type ideas$solutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the solutions
     */
    select?: solutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the solutions
     */
    omit?: solutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: solutionsInclude<ExtArgs> | null
    where?: solutionsWhereInput
  }

  /**
   * ideas without action
   */
  export type ideasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ideas
     */
    select?: ideasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ideas
     */
    omit?: ideasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ideasInclude<ExtArgs> | null
  }


  /**
   * Model initiatives
   */

  export type AggregateInitiatives = {
    _count: InitiativesCountAggregateOutputType | null
    _avg: InitiativesAvgAggregateOutputType | null
    _sum: InitiativesSumAggregateOutputType | null
    _min: InitiativesMinAggregateOutputType | null
    _max: InitiativesMaxAggregateOutputType | null
  }

  export type InitiativesAvgAggregateOutputType = {
    budget: number | null
    actualSpend: number | null
    expectedROI: number | null
    actualROI: number | null
  }

  export type InitiativesSumAggregateOutputType = {
    budget: number | null
    actualSpend: number | null
    expectedROI: number | null
    actualROI: number | null
  }

  export type InitiativesMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.initiative_status | null
    priority: $Enums.priority | null
    ownerId: string | null
    budget: number | null
    actualSpend: number | null
    startDate: Date | null
    targetDate: Date | null
    completionDate: Date | null
    expectedROI: number | null
    actualROI: number | null
    riskLevel: $Enums.risk_level | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InitiativesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.initiative_status | null
    priority: $Enums.priority | null
    ownerId: string | null
    budget: number | null
    actualSpend: number | null
    startDate: Date | null
    targetDate: Date | null
    completionDate: Date | null
    expectedROI: number | null
    actualROI: number | null
    riskLevel: $Enums.risk_level | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InitiativesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    priority: number
    ownerId: number
    budget: number
    actualSpend: number
    startDate: number
    targetDate: number
    completionDate: number
    expectedROI: number
    actualROI: number
    riskLevel: number
    goalJson: number
    roiJson: number
    milestonesJson: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InitiativesAvgAggregateInputType = {
    budget?: true
    actualSpend?: true
    expectedROI?: true
    actualROI?: true
  }

  export type InitiativesSumAggregateInputType = {
    budget?: true
    actualSpend?: true
    expectedROI?: true
    actualROI?: true
  }

  export type InitiativesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    priority?: true
    ownerId?: true
    budget?: true
    actualSpend?: true
    startDate?: true
    targetDate?: true
    completionDate?: true
    expectedROI?: true
    actualROI?: true
    riskLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InitiativesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    priority?: true
    ownerId?: true
    budget?: true
    actualSpend?: true
    startDate?: true
    targetDate?: true
    completionDate?: true
    expectedROI?: true
    actualROI?: true
    riskLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InitiativesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    priority?: true
    ownerId?: true
    budget?: true
    actualSpend?: true
    startDate?: true
    targetDate?: true
    completionDate?: true
    expectedROI?: true
    actualROI?: true
    riskLevel?: true
    goalJson?: true
    roiJson?: true
    milestonesJson?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InitiativesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which initiatives to aggregate.
     */
    where?: initiativesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of initiatives to fetch.
     */
    orderBy?: initiativesOrderByWithRelationInput | initiativesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: initiativesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` initiatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` initiatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned initiatives
    **/
    _count?: true | InitiativesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InitiativesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InitiativesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InitiativesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InitiativesMaxAggregateInputType
  }

  export type GetInitiativesAggregateType<T extends InitiativesAggregateArgs> = {
        [P in keyof T & keyof AggregateInitiatives]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInitiatives[P]>
      : GetScalarType<T[P], AggregateInitiatives[P]>
  }




  export type initiativesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: initiativesWhereInput
    orderBy?: initiativesOrderByWithAggregationInput | initiativesOrderByWithAggregationInput[]
    by: InitiativesScalarFieldEnum[] | InitiativesScalarFieldEnum
    having?: initiativesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InitiativesCountAggregateInputType | true
    _avg?: InitiativesAvgAggregateInputType
    _sum?: InitiativesSumAggregateInputType
    _min?: InitiativesMinAggregateInputType
    _max?: InitiativesMaxAggregateInputType
  }

  export type InitiativesGroupByOutputType = {
    id: string
    name: string
    description: string | null
    status: $Enums.initiative_status
    priority: $Enums.priority
    ownerId: string | null
    budget: number
    actualSpend: number
    startDate: Date | null
    targetDate: Date | null
    completionDate: Date | null
    expectedROI: number | null
    actualROI: number | null
    riskLevel: $Enums.risk_level
    goalJson: JsonValue | null
    roiJson: JsonValue | null
    milestonesJson: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: InitiativesCountAggregateOutputType | null
    _avg: InitiativesAvgAggregateOutputType | null
    _sum: InitiativesSumAggregateOutputType | null
    _min: InitiativesMinAggregateOutputType | null
    _max: InitiativesMaxAggregateOutputType | null
  }

  type GetInitiativesGroupByPayload<T extends initiativesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InitiativesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InitiativesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InitiativesGroupByOutputType[P]>
            : GetScalarType<T[P], InitiativesGroupByOutputType[P]>
        }
      >
    >


  export type initiativesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    ownerId?: boolean
    budget?: boolean
    actualSpend?: boolean
    startDate?: boolean
    targetDate?: boolean
    completionDate?: boolean
    expectedROI?: boolean
    actualROI?: boolean
    riskLevel?: boolean
    goalJson?: boolean
    roiJson?: boolean
    milestonesJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ideas?: boolean | initiatives$ideasArgs<ExtArgs>
    users?: boolean | initiatives$usersArgs<ExtArgs>
    solutions?: boolean | initiatives$solutionsArgs<ExtArgs>
    _count?: boolean | InitiativesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["initiatives"]>

  export type initiativesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    ownerId?: boolean
    budget?: boolean
    actualSpend?: boolean
    startDate?: boolean
    targetDate?: boolean
    completionDate?: boolean
    expectedROI?: boolean
    actualROI?: boolean
    riskLevel?: boolean
    goalJson?: boolean
    roiJson?: boolean
    milestonesJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | initiatives$usersArgs<ExtArgs>
  }, ExtArgs["result"]["initiatives"]>

  export type initiativesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    ownerId?: boolean
    budget?: boolean
    actualSpend?: boolean
    startDate?: boolean
    targetDate?: boolean
    completionDate?: boolean
    expectedROI?: boolean
    actualROI?: boolean
    riskLevel?: boolean
    goalJson?: boolean
    roiJson?: boolean
    milestonesJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | initiatives$usersArgs<ExtArgs>
  }, ExtArgs["result"]["initiatives"]>

  export type initiativesSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    ownerId?: boolean
    budget?: boolean
    actualSpend?: boolean
    startDate?: boolean
    targetDate?: boolean
    completionDate?: boolean
    expectedROI?: boolean
    actualROI?: boolean
    riskLevel?: boolean
    goalJson?: boolean
    roiJson?: boolean
    milestonesJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type initiativesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "status" | "priority" | "ownerId" | "budget" | "actualSpend" | "startDate" | "targetDate" | "completionDate" | "expectedROI" | "actualROI" | "riskLevel" | "goalJson" | "roiJson" | "milestonesJson" | "createdAt" | "updatedAt", ExtArgs["result"]["initiatives"]>
  export type initiativesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ideas?: boolean | initiatives$ideasArgs<ExtArgs>
    users?: boolean | initiatives$usersArgs<ExtArgs>
    solutions?: boolean | initiatives$solutionsArgs<ExtArgs>
    _count?: boolean | InitiativesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type initiativesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | initiatives$usersArgs<ExtArgs>
  }
  export type initiativesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | initiatives$usersArgs<ExtArgs>
  }

  export type $initiativesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "initiatives"
    objects: {
      ideas: Prisma.$ideasPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs> | null
      solutions: Prisma.$solutionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      status: $Enums.initiative_status
      priority: $Enums.priority
      ownerId: string | null
      budget: number
      actualSpend: number
      startDate: Date | null
      targetDate: Date | null
      completionDate: Date | null
      expectedROI: number | null
      actualROI: number | null
      riskLevel: $Enums.risk_level
      goalJson: Prisma.JsonValue | null
      roiJson: Prisma.JsonValue | null
      milestonesJson: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["initiatives"]>
    composites: {}
  }

  type initiativesGetPayload<S extends boolean | null | undefined | initiativesDefaultArgs> = $Result.GetResult<Prisma.$initiativesPayload, S>

  type initiativesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<initiativesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InitiativesCountAggregateInputType | true
    }

  export interface initiativesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['initiatives'], meta: { name: 'initiatives' } }
    /**
     * Find zero or one Initiatives that matches the filter.
     * @param {initiativesFindUniqueArgs} args - Arguments to find a Initiatives
     * @example
     * // Get one Initiatives
     * const initiatives = await prisma.initiatives.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends initiativesFindUniqueArgs>(args: SelectSubset<T, initiativesFindUniqueArgs<ExtArgs>>): Prisma__initiativesClient<$Result.GetResult<Prisma.$initiativesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Initiatives that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {initiativesFindUniqueOrThrowArgs} args - Arguments to find a Initiatives
     * @example
     * // Get one Initiatives
     * const initiatives = await prisma.initiatives.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends initiativesFindUniqueOrThrowArgs>(args: SelectSubset<T, initiativesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__initiativesClient<$Result.GetResult<Prisma.$initiativesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Initiatives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {initiativesFindFirstArgs} args - Arguments to find a Initiatives
     * @example
     * // Get one Initiatives
     * const initiatives = await prisma.initiatives.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends initiativesFindFirstArgs>(args?: SelectSubset<T, initiativesFindFirstArgs<ExtArgs>>): Prisma__initiativesClient<$Result.GetResult<Prisma.$initiativesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Initiatives that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {initiativesFindFirstOrThrowArgs} args - Arguments to find a Initiatives
     * @example
     * // Get one Initiatives
     * const initiatives = await prisma.initiatives.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends initiativesFindFirstOrThrowArgs>(args?: SelectSubset<T, initiativesFindFirstOrThrowArgs<ExtArgs>>): Prisma__initiativesClient<$Result.GetResult<Prisma.$initiativesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Initiatives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {initiativesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Initiatives
     * const initiatives = await prisma.initiatives.findMany()
     * 
     * // Get first 10 Initiatives
     * const initiatives = await prisma.initiatives.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const initiativesWithIdOnly = await prisma.initiatives.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends initiativesFindManyArgs>(args?: SelectSubset<T, initiativesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$initiativesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Initiatives.
     * @param {initiativesCreateArgs} args - Arguments to create a Initiatives.
     * @example
     * // Create one Initiatives
     * const Initiatives = await prisma.initiatives.create({
     *   data: {
     *     // ... data to create a Initiatives
     *   }
     * })
     * 
     */
    create<T extends initiativesCreateArgs>(args: SelectSubset<T, initiativesCreateArgs<ExtArgs>>): Prisma__initiativesClient<$Result.GetResult<Prisma.$initiativesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Initiatives.
     * @param {initiativesCreateManyArgs} args - Arguments to create many Initiatives.
     * @example
     * // Create many Initiatives
     * const initiatives = await prisma.initiatives.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends initiativesCreateManyArgs>(args?: SelectSubset<T, initiativesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Initiatives and returns the data saved in the database.
     * @param {initiativesCreateManyAndReturnArgs} args - Arguments to create many Initiatives.
     * @example
     * // Create many Initiatives
     * const initiatives = await prisma.initiatives.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Initiatives and only return the `id`
     * const initiativesWithIdOnly = await prisma.initiatives.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends initiativesCreateManyAndReturnArgs>(args?: SelectSubset<T, initiativesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$initiativesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Initiatives.
     * @param {initiativesDeleteArgs} args - Arguments to delete one Initiatives.
     * @example
     * // Delete one Initiatives
     * const Initiatives = await prisma.initiatives.delete({
     *   where: {
     *     // ... filter to delete one Initiatives
     *   }
     * })
     * 
     */
    delete<T extends initiativesDeleteArgs>(args: SelectSubset<T, initiativesDeleteArgs<ExtArgs>>): Prisma__initiativesClient<$Result.GetResult<Prisma.$initiativesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Initiatives.
     * @param {initiativesUpdateArgs} args - Arguments to update one Initiatives.
     * @example
     * // Update one Initiatives
     * const initiatives = await prisma.initiatives.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends initiativesUpdateArgs>(args: SelectSubset<T, initiativesUpdateArgs<ExtArgs>>): Prisma__initiativesClient<$Result.GetResult<Prisma.$initiativesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Initiatives.
     * @param {initiativesDeleteManyArgs} args - Arguments to filter Initiatives to delete.
     * @example
     * // Delete a few Initiatives
     * const { count } = await prisma.initiatives.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends initiativesDeleteManyArgs>(args?: SelectSubset<T, initiativesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Initiatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {initiativesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Initiatives
     * const initiatives = await prisma.initiatives.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends initiativesUpdateManyArgs>(args: SelectSubset<T, initiativesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Initiatives and returns the data updated in the database.
     * @param {initiativesUpdateManyAndReturnArgs} args - Arguments to update many Initiatives.
     * @example
     * // Update many Initiatives
     * const initiatives = await prisma.initiatives.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Initiatives and only return the `id`
     * const initiativesWithIdOnly = await prisma.initiatives.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends initiativesUpdateManyAndReturnArgs>(args: SelectSubset<T, initiativesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$initiativesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Initiatives.
     * @param {initiativesUpsertArgs} args - Arguments to update or create a Initiatives.
     * @example
     * // Update or create a Initiatives
     * const initiatives = await prisma.initiatives.upsert({
     *   create: {
     *     // ... data to create a Initiatives
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Initiatives we want to update
     *   }
     * })
     */
    upsert<T extends initiativesUpsertArgs>(args: SelectSubset<T, initiativesUpsertArgs<ExtArgs>>): Prisma__initiativesClient<$Result.GetResult<Prisma.$initiativesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Initiatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {initiativesCountArgs} args - Arguments to filter Initiatives to count.
     * @example
     * // Count the number of Initiatives
     * const count = await prisma.initiatives.count({
     *   where: {
     *     // ... the filter for the Initiatives we want to count
     *   }
     * })
    **/
    count<T extends initiativesCountArgs>(
      args?: Subset<T, initiativesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InitiativesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Initiatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InitiativesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InitiativesAggregateArgs>(args: Subset<T, InitiativesAggregateArgs>): Prisma.PrismaPromise<GetInitiativesAggregateType<T>>

    /**
     * Group by Initiatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {initiativesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends initiativesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: initiativesGroupByArgs['orderBy'] }
        : { orderBy?: initiativesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, initiativesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInitiativesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the initiatives model
   */
  readonly fields: initiativesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for initiatives.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__initiativesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ideas<T extends initiatives$ideasArgs<ExtArgs> = {}>(args?: Subset<T, initiatives$ideasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ideasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends initiatives$usersArgs<ExtArgs> = {}>(args?: Subset<T, initiatives$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    solutions<T extends initiatives$solutionsArgs<ExtArgs> = {}>(args?: Subset<T, initiatives$solutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$solutionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the initiatives model
   */
  interface initiativesFieldRefs {
    readonly id: FieldRef<"initiatives", 'String'>
    readonly name: FieldRef<"initiatives", 'String'>
    readonly description: FieldRef<"initiatives", 'String'>
    readonly status: FieldRef<"initiatives", 'initiative_status'>
    readonly priority: FieldRef<"initiatives", 'priority'>
    readonly ownerId: FieldRef<"initiatives", 'String'>
    readonly budget: FieldRef<"initiatives", 'Float'>
    readonly actualSpend: FieldRef<"initiatives", 'Float'>
    readonly startDate: FieldRef<"initiatives", 'DateTime'>
    readonly targetDate: FieldRef<"initiatives", 'DateTime'>
    readonly completionDate: FieldRef<"initiatives", 'DateTime'>
    readonly expectedROI: FieldRef<"initiatives", 'Float'>
    readonly actualROI: FieldRef<"initiatives", 'Float'>
    readonly riskLevel: FieldRef<"initiatives", 'risk_level'>
    readonly goalJson: FieldRef<"initiatives", 'Json'>
    readonly roiJson: FieldRef<"initiatives", 'Json'>
    readonly milestonesJson: FieldRef<"initiatives", 'Json'>
    readonly createdAt: FieldRef<"initiatives", 'DateTime'>
    readonly updatedAt: FieldRef<"initiatives", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * initiatives findUnique
   */
  export type initiativesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the initiatives
     */
    select?: initiativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the initiatives
     */
    omit?: initiativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: initiativesInclude<ExtArgs> | null
    /**
     * Filter, which initiatives to fetch.
     */
    where: initiativesWhereUniqueInput
  }

  /**
   * initiatives findUniqueOrThrow
   */
  export type initiativesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the initiatives
     */
    select?: initiativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the initiatives
     */
    omit?: initiativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: initiativesInclude<ExtArgs> | null
    /**
     * Filter, which initiatives to fetch.
     */
    where: initiativesWhereUniqueInput
  }

  /**
   * initiatives findFirst
   */
  export type initiativesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the initiatives
     */
    select?: initiativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the initiatives
     */
    omit?: initiativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: initiativesInclude<ExtArgs> | null
    /**
     * Filter, which initiatives to fetch.
     */
    where?: initiativesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of initiatives to fetch.
     */
    orderBy?: initiativesOrderByWithRelationInput | initiativesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for initiatives.
     */
    cursor?: initiativesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` initiatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` initiatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of initiatives.
     */
    distinct?: InitiativesScalarFieldEnum | InitiativesScalarFieldEnum[]
  }

  /**
   * initiatives findFirstOrThrow
   */
  export type initiativesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the initiatives
     */
    select?: initiativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the initiatives
     */
    omit?: initiativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: initiativesInclude<ExtArgs> | null
    /**
     * Filter, which initiatives to fetch.
     */
    where?: initiativesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of initiatives to fetch.
     */
    orderBy?: initiativesOrderByWithRelationInput | initiativesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for initiatives.
     */
    cursor?: initiativesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` initiatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` initiatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of initiatives.
     */
    distinct?: InitiativesScalarFieldEnum | InitiativesScalarFieldEnum[]
  }

  /**
   * initiatives findMany
   */
  export type initiativesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the initiatives
     */
    select?: initiativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the initiatives
     */
    omit?: initiativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: initiativesInclude<ExtArgs> | null
    /**
     * Filter, which initiatives to fetch.
     */
    where?: initiativesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of initiatives to fetch.
     */
    orderBy?: initiativesOrderByWithRelationInput | initiativesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing initiatives.
     */
    cursor?: initiativesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` initiatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` initiatives.
     */
    skip?: number
    distinct?: InitiativesScalarFieldEnum | InitiativesScalarFieldEnum[]
  }

  /**
   * initiatives create
   */
  export type initiativesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the initiatives
     */
    select?: initiativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the initiatives
     */
    omit?: initiativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: initiativesInclude<ExtArgs> | null
    /**
     * The data needed to create a initiatives.
     */
    data: XOR<initiativesCreateInput, initiativesUncheckedCreateInput>
  }

  /**
   * initiatives createMany
   */
  export type initiativesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many initiatives.
     */
    data: initiativesCreateManyInput | initiativesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * initiatives createManyAndReturn
   */
  export type initiativesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the initiatives
     */
    select?: initiativesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the initiatives
     */
    omit?: initiativesOmit<ExtArgs> | null
    /**
     * The data used to create many initiatives.
     */
    data: initiativesCreateManyInput | initiativesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: initiativesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * initiatives update
   */
  export type initiativesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the initiatives
     */
    select?: initiativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the initiatives
     */
    omit?: initiativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: initiativesInclude<ExtArgs> | null
    /**
     * The data needed to update a initiatives.
     */
    data: XOR<initiativesUpdateInput, initiativesUncheckedUpdateInput>
    /**
     * Choose, which initiatives to update.
     */
    where: initiativesWhereUniqueInput
  }

  /**
   * initiatives updateMany
   */
  export type initiativesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update initiatives.
     */
    data: XOR<initiativesUpdateManyMutationInput, initiativesUncheckedUpdateManyInput>
    /**
     * Filter which initiatives to update
     */
    where?: initiativesWhereInput
    /**
     * Limit how many initiatives to update.
     */
    limit?: number
  }

  /**
   * initiatives updateManyAndReturn
   */
  export type initiativesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the initiatives
     */
    select?: initiativesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the initiatives
     */
    omit?: initiativesOmit<ExtArgs> | null
    /**
     * The data used to update initiatives.
     */
    data: XOR<initiativesUpdateManyMutationInput, initiativesUncheckedUpdateManyInput>
    /**
     * Filter which initiatives to update
     */
    where?: initiativesWhereInput
    /**
     * Limit how many initiatives to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: initiativesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * initiatives upsert
   */
  export type initiativesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the initiatives
     */
    select?: initiativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the initiatives
     */
    omit?: initiativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: initiativesInclude<ExtArgs> | null
    /**
     * The filter to search for the initiatives to update in case it exists.
     */
    where: initiativesWhereUniqueInput
    /**
     * In case the initiatives found by the `where` argument doesn't exist, create a new initiatives with this data.
     */
    create: XOR<initiativesCreateInput, initiativesUncheckedCreateInput>
    /**
     * In case the initiatives was found with the provided `where` argument, update it with this data.
     */
    update: XOR<initiativesUpdateInput, initiativesUncheckedUpdateInput>
  }

  /**
   * initiatives delete
   */
  export type initiativesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the initiatives
     */
    select?: initiativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the initiatives
     */
    omit?: initiativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: initiativesInclude<ExtArgs> | null
    /**
     * Filter which initiatives to delete.
     */
    where: initiativesWhereUniqueInput
  }

  /**
   * initiatives deleteMany
   */
  export type initiativesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which initiatives to delete
     */
    where?: initiativesWhereInput
    /**
     * Limit how many initiatives to delete.
     */
    limit?: number
  }

  /**
   * initiatives.ideas
   */
  export type initiatives$ideasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ideas
     */
    select?: ideasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ideas
     */
    omit?: ideasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ideasInclude<ExtArgs> | null
    where?: ideasWhereInput
    orderBy?: ideasOrderByWithRelationInput | ideasOrderByWithRelationInput[]
    cursor?: ideasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IdeasScalarFieldEnum | IdeasScalarFieldEnum[]
  }

  /**
   * initiatives.users
   */
  export type initiatives$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * initiatives.solutions
   */
  export type initiatives$solutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the solutions
     */
    select?: solutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the solutions
     */
    omit?: solutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: solutionsInclude<ExtArgs> | null
    where?: solutionsWhereInput
    orderBy?: solutionsOrderByWithRelationInput | solutionsOrderByWithRelationInput[]
    cursor?: solutionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SolutionsScalarFieldEnum | SolutionsScalarFieldEnum[]
  }

  /**
   * initiatives without action
   */
  export type initiativesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the initiatives
     */
    select?: initiativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the initiatives
     */
    omit?: initiativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: initiativesInclude<ExtArgs> | null
  }


  /**
   * Model input_groups
   */

  export type AggregateInput_groups = {
    _count: Input_groupsCountAggregateOutputType | null
    _avg: Input_groupsAvgAggregateOutputType | null
    _sum: Input_groupsSumAggregateOutputType | null
    _min: Input_groupsMinAggregateOutputType | null
    _max: Input_groupsMaxAggregateOutputType | null
  }

  export type Input_groupsAvgAggregateOutputType = {
    aiConfidence: number | null
    avgPriority: number | null
    inputCount: number | null
  }

  export type Input_groupsSumAggregateOutputType = {
    aiConfidence: number | null
    avgPriority: number | null
    inputCount: number | null
  }

  export type Input_groupsMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    aiSuggested: boolean | null
    aiConfidence: number | null
    aiReasoning: string | null
    avgPriority: number | null
    color: string | null
    createdBy: string | null
    inputCount: number | null
    lastActivity: Date | null
  }

  export type Input_groupsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    aiSuggested: boolean | null
    aiConfidence: number | null
    aiReasoning: string | null
    avgPriority: number | null
    color: string | null
    createdBy: string | null
    inputCount: number | null
    lastActivity: Date | null
  }

  export type Input_groupsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    aiSuggested: number
    aiConfidence: number
    aiReasoning: number
    avgPriority: number
    color: number
    createdBy: number
    inputCount: number
    lastActivity: number
    _all: number
  }


  export type Input_groupsAvgAggregateInputType = {
    aiConfidence?: true
    avgPriority?: true
    inputCount?: true
  }

  export type Input_groupsSumAggregateInputType = {
    aiConfidence?: true
    avgPriority?: true
    inputCount?: true
  }

  export type Input_groupsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    aiSuggested?: true
    aiConfidence?: true
    aiReasoning?: true
    avgPriority?: true
    color?: true
    createdBy?: true
    inputCount?: true
    lastActivity?: true
  }

  export type Input_groupsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    aiSuggested?: true
    aiConfidence?: true
    aiReasoning?: true
    avgPriority?: true
    color?: true
    createdBy?: true
    inputCount?: true
    lastActivity?: true
  }

  export type Input_groupsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    aiSuggested?: true
    aiConfidence?: true
    aiReasoning?: true
    avgPriority?: true
    color?: true
    createdBy?: true
    inputCount?: true
    lastActivity?: true
    _all?: true
  }

  export type Input_groupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which input_groups to aggregate.
     */
    where?: input_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of input_groups to fetch.
     */
    orderBy?: input_groupsOrderByWithRelationInput | input_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: input_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` input_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` input_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned input_groups
    **/
    _count?: true | Input_groupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Input_groupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Input_groupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Input_groupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Input_groupsMaxAggregateInputType
  }

  export type GetInput_groupsAggregateType<T extends Input_groupsAggregateArgs> = {
        [P in keyof T & keyof AggregateInput_groups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInput_groups[P]>
      : GetScalarType<T[P], AggregateInput_groups[P]>
  }




  export type input_groupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: input_groupsWhereInput
    orderBy?: input_groupsOrderByWithAggregationInput | input_groupsOrderByWithAggregationInput[]
    by: Input_groupsScalarFieldEnum[] | Input_groupsScalarFieldEnum
    having?: input_groupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Input_groupsCountAggregateInputType | true
    _avg?: Input_groupsAvgAggregateInputType
    _sum?: Input_groupsSumAggregateInputType
    _min?: Input_groupsMinAggregateInputType
    _max?: Input_groupsMaxAggregateInputType
  }

  export type Input_groupsGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    aiSuggested: boolean
    aiConfidence: number | null
    aiReasoning: string | null
    avgPriority: number | null
    color: string | null
    createdBy: string
    inputCount: number
    lastActivity: Date | null
    _count: Input_groupsCountAggregateOutputType | null
    _avg: Input_groupsAvgAggregateOutputType | null
    _sum: Input_groupsSumAggregateOutputType | null
    _min: Input_groupsMinAggregateOutputType | null
    _max: Input_groupsMaxAggregateOutputType | null
  }

  type GetInput_groupsGroupByPayload<T extends input_groupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Input_groupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Input_groupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Input_groupsGroupByOutputType[P]>
            : GetScalarType<T[P], Input_groupsGroupByOutputType[P]>
        }
      >
    >


  export type input_groupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiSuggested?: boolean
    aiConfidence?: boolean
    aiReasoning?: boolean
    avgPriority?: boolean
    color?: boolean
    createdBy?: boolean
    inputCount?: boolean
    lastActivity?: boolean
    InputToInputGroup?: boolean | input_groups$InputToInputGroupArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | Input_groupsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["input_groups"]>

  export type input_groupsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiSuggested?: boolean
    aiConfidence?: boolean
    aiReasoning?: boolean
    avgPriority?: boolean
    color?: boolean
    createdBy?: boolean
    inputCount?: boolean
    lastActivity?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["input_groups"]>

  export type input_groupsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiSuggested?: boolean
    aiConfidence?: boolean
    aiReasoning?: boolean
    avgPriority?: boolean
    color?: boolean
    createdBy?: boolean
    inputCount?: boolean
    lastActivity?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["input_groups"]>

  export type input_groupsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiSuggested?: boolean
    aiConfidence?: boolean
    aiReasoning?: boolean
    avgPriority?: boolean
    color?: boolean
    createdBy?: boolean
    inputCount?: boolean
    lastActivity?: boolean
  }

  export type input_groupsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt" | "aiSuggested" | "aiConfidence" | "aiReasoning" | "avgPriority" | "color" | "createdBy" | "inputCount" | "lastActivity", ExtArgs["result"]["input_groups"]>
  export type input_groupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    InputToInputGroup?: boolean | input_groups$InputToInputGroupArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | Input_groupsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type input_groupsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type input_groupsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $input_groupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "input_groups"
    objects: {
      InputToInputGroup: Prisma.$InputToInputGroupPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      aiSuggested: boolean
      aiConfidence: number | null
      aiReasoning: string | null
      avgPriority: number | null
      color: string | null
      createdBy: string
      inputCount: number
      lastActivity: Date | null
    }, ExtArgs["result"]["input_groups"]>
    composites: {}
  }

  type input_groupsGetPayload<S extends boolean | null | undefined | input_groupsDefaultArgs> = $Result.GetResult<Prisma.$input_groupsPayload, S>

  type input_groupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<input_groupsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Input_groupsCountAggregateInputType | true
    }

  export interface input_groupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['input_groups'], meta: { name: 'input_groups' } }
    /**
     * Find zero or one Input_groups that matches the filter.
     * @param {input_groupsFindUniqueArgs} args - Arguments to find a Input_groups
     * @example
     * // Get one Input_groups
     * const input_groups = await prisma.input_groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends input_groupsFindUniqueArgs>(args: SelectSubset<T, input_groupsFindUniqueArgs<ExtArgs>>): Prisma__input_groupsClient<$Result.GetResult<Prisma.$input_groupsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Input_groups that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {input_groupsFindUniqueOrThrowArgs} args - Arguments to find a Input_groups
     * @example
     * // Get one Input_groups
     * const input_groups = await prisma.input_groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends input_groupsFindUniqueOrThrowArgs>(args: SelectSubset<T, input_groupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__input_groupsClient<$Result.GetResult<Prisma.$input_groupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Input_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {input_groupsFindFirstArgs} args - Arguments to find a Input_groups
     * @example
     * // Get one Input_groups
     * const input_groups = await prisma.input_groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends input_groupsFindFirstArgs>(args?: SelectSubset<T, input_groupsFindFirstArgs<ExtArgs>>): Prisma__input_groupsClient<$Result.GetResult<Prisma.$input_groupsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Input_groups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {input_groupsFindFirstOrThrowArgs} args - Arguments to find a Input_groups
     * @example
     * // Get one Input_groups
     * const input_groups = await prisma.input_groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends input_groupsFindFirstOrThrowArgs>(args?: SelectSubset<T, input_groupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__input_groupsClient<$Result.GetResult<Prisma.$input_groupsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Input_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {input_groupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Input_groups
     * const input_groups = await prisma.input_groups.findMany()
     * 
     * // Get first 10 Input_groups
     * const input_groups = await prisma.input_groups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const input_groupsWithIdOnly = await prisma.input_groups.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends input_groupsFindManyArgs>(args?: SelectSubset<T, input_groupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$input_groupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Input_groups.
     * @param {input_groupsCreateArgs} args - Arguments to create a Input_groups.
     * @example
     * // Create one Input_groups
     * const Input_groups = await prisma.input_groups.create({
     *   data: {
     *     // ... data to create a Input_groups
     *   }
     * })
     * 
     */
    create<T extends input_groupsCreateArgs>(args: SelectSubset<T, input_groupsCreateArgs<ExtArgs>>): Prisma__input_groupsClient<$Result.GetResult<Prisma.$input_groupsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Input_groups.
     * @param {input_groupsCreateManyArgs} args - Arguments to create many Input_groups.
     * @example
     * // Create many Input_groups
     * const input_groups = await prisma.input_groups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends input_groupsCreateManyArgs>(args?: SelectSubset<T, input_groupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Input_groups and returns the data saved in the database.
     * @param {input_groupsCreateManyAndReturnArgs} args - Arguments to create many Input_groups.
     * @example
     * // Create many Input_groups
     * const input_groups = await prisma.input_groups.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Input_groups and only return the `id`
     * const input_groupsWithIdOnly = await prisma.input_groups.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends input_groupsCreateManyAndReturnArgs>(args?: SelectSubset<T, input_groupsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$input_groupsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Input_groups.
     * @param {input_groupsDeleteArgs} args - Arguments to delete one Input_groups.
     * @example
     * // Delete one Input_groups
     * const Input_groups = await prisma.input_groups.delete({
     *   where: {
     *     // ... filter to delete one Input_groups
     *   }
     * })
     * 
     */
    delete<T extends input_groupsDeleteArgs>(args: SelectSubset<T, input_groupsDeleteArgs<ExtArgs>>): Prisma__input_groupsClient<$Result.GetResult<Prisma.$input_groupsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Input_groups.
     * @param {input_groupsUpdateArgs} args - Arguments to update one Input_groups.
     * @example
     * // Update one Input_groups
     * const input_groups = await prisma.input_groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends input_groupsUpdateArgs>(args: SelectSubset<T, input_groupsUpdateArgs<ExtArgs>>): Prisma__input_groupsClient<$Result.GetResult<Prisma.$input_groupsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Input_groups.
     * @param {input_groupsDeleteManyArgs} args - Arguments to filter Input_groups to delete.
     * @example
     * // Delete a few Input_groups
     * const { count } = await prisma.input_groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends input_groupsDeleteManyArgs>(args?: SelectSubset<T, input_groupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Input_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {input_groupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Input_groups
     * const input_groups = await prisma.input_groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends input_groupsUpdateManyArgs>(args: SelectSubset<T, input_groupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Input_groups and returns the data updated in the database.
     * @param {input_groupsUpdateManyAndReturnArgs} args - Arguments to update many Input_groups.
     * @example
     * // Update many Input_groups
     * const input_groups = await prisma.input_groups.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Input_groups and only return the `id`
     * const input_groupsWithIdOnly = await prisma.input_groups.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends input_groupsUpdateManyAndReturnArgs>(args: SelectSubset<T, input_groupsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$input_groupsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Input_groups.
     * @param {input_groupsUpsertArgs} args - Arguments to update or create a Input_groups.
     * @example
     * // Update or create a Input_groups
     * const input_groups = await prisma.input_groups.upsert({
     *   create: {
     *     // ... data to create a Input_groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Input_groups we want to update
     *   }
     * })
     */
    upsert<T extends input_groupsUpsertArgs>(args: SelectSubset<T, input_groupsUpsertArgs<ExtArgs>>): Prisma__input_groupsClient<$Result.GetResult<Prisma.$input_groupsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Input_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {input_groupsCountArgs} args - Arguments to filter Input_groups to count.
     * @example
     * // Count the number of Input_groups
     * const count = await prisma.input_groups.count({
     *   where: {
     *     // ... the filter for the Input_groups we want to count
     *   }
     * })
    **/
    count<T extends input_groupsCountArgs>(
      args?: Subset<T, input_groupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Input_groupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Input_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Input_groupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Input_groupsAggregateArgs>(args: Subset<T, Input_groupsAggregateArgs>): Prisma.PrismaPromise<GetInput_groupsAggregateType<T>>

    /**
     * Group by Input_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {input_groupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends input_groupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: input_groupsGroupByArgs['orderBy'] }
        : { orderBy?: input_groupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, input_groupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInput_groupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the input_groups model
   */
  readonly fields: input_groupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for input_groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__input_groupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    InputToInputGroup<T extends input_groups$InputToInputGroupArgs<ExtArgs> = {}>(args?: Subset<T, input_groups$InputToInputGroupArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InputToInputGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the input_groups model
   */
  interface input_groupsFieldRefs {
    readonly id: FieldRef<"input_groups", 'String'>
    readonly name: FieldRef<"input_groups", 'String'>
    readonly description: FieldRef<"input_groups", 'String'>
    readonly createdAt: FieldRef<"input_groups", 'DateTime'>
    readonly updatedAt: FieldRef<"input_groups", 'DateTime'>
    readonly aiSuggested: FieldRef<"input_groups", 'Boolean'>
    readonly aiConfidence: FieldRef<"input_groups", 'Float'>
    readonly aiReasoning: FieldRef<"input_groups", 'String'>
    readonly avgPriority: FieldRef<"input_groups", 'Float'>
    readonly color: FieldRef<"input_groups", 'String'>
    readonly createdBy: FieldRef<"input_groups", 'String'>
    readonly inputCount: FieldRef<"input_groups", 'Int'>
    readonly lastActivity: FieldRef<"input_groups", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * input_groups findUnique
   */
  export type input_groupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the input_groups
     */
    select?: input_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the input_groups
     */
    omit?: input_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: input_groupsInclude<ExtArgs> | null
    /**
     * Filter, which input_groups to fetch.
     */
    where: input_groupsWhereUniqueInput
  }

  /**
   * input_groups findUniqueOrThrow
   */
  export type input_groupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the input_groups
     */
    select?: input_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the input_groups
     */
    omit?: input_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: input_groupsInclude<ExtArgs> | null
    /**
     * Filter, which input_groups to fetch.
     */
    where: input_groupsWhereUniqueInput
  }

  /**
   * input_groups findFirst
   */
  export type input_groupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the input_groups
     */
    select?: input_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the input_groups
     */
    omit?: input_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: input_groupsInclude<ExtArgs> | null
    /**
     * Filter, which input_groups to fetch.
     */
    where?: input_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of input_groups to fetch.
     */
    orderBy?: input_groupsOrderByWithRelationInput | input_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for input_groups.
     */
    cursor?: input_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` input_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` input_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of input_groups.
     */
    distinct?: Input_groupsScalarFieldEnum | Input_groupsScalarFieldEnum[]
  }

  /**
   * input_groups findFirstOrThrow
   */
  export type input_groupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the input_groups
     */
    select?: input_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the input_groups
     */
    omit?: input_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: input_groupsInclude<ExtArgs> | null
    /**
     * Filter, which input_groups to fetch.
     */
    where?: input_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of input_groups to fetch.
     */
    orderBy?: input_groupsOrderByWithRelationInput | input_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for input_groups.
     */
    cursor?: input_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` input_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` input_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of input_groups.
     */
    distinct?: Input_groupsScalarFieldEnum | Input_groupsScalarFieldEnum[]
  }

  /**
   * input_groups findMany
   */
  export type input_groupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the input_groups
     */
    select?: input_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the input_groups
     */
    omit?: input_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: input_groupsInclude<ExtArgs> | null
    /**
     * Filter, which input_groups to fetch.
     */
    where?: input_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of input_groups to fetch.
     */
    orderBy?: input_groupsOrderByWithRelationInput | input_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing input_groups.
     */
    cursor?: input_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` input_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` input_groups.
     */
    skip?: number
    distinct?: Input_groupsScalarFieldEnum | Input_groupsScalarFieldEnum[]
  }

  /**
   * input_groups create
   */
  export type input_groupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the input_groups
     */
    select?: input_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the input_groups
     */
    omit?: input_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: input_groupsInclude<ExtArgs> | null
    /**
     * The data needed to create a input_groups.
     */
    data: XOR<input_groupsCreateInput, input_groupsUncheckedCreateInput>
  }

  /**
   * input_groups createMany
   */
  export type input_groupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many input_groups.
     */
    data: input_groupsCreateManyInput | input_groupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * input_groups createManyAndReturn
   */
  export type input_groupsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the input_groups
     */
    select?: input_groupsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the input_groups
     */
    omit?: input_groupsOmit<ExtArgs> | null
    /**
     * The data used to create many input_groups.
     */
    data: input_groupsCreateManyInput | input_groupsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: input_groupsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * input_groups update
   */
  export type input_groupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the input_groups
     */
    select?: input_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the input_groups
     */
    omit?: input_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: input_groupsInclude<ExtArgs> | null
    /**
     * The data needed to update a input_groups.
     */
    data: XOR<input_groupsUpdateInput, input_groupsUncheckedUpdateInput>
    /**
     * Choose, which input_groups to update.
     */
    where: input_groupsWhereUniqueInput
  }

  /**
   * input_groups updateMany
   */
  export type input_groupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update input_groups.
     */
    data: XOR<input_groupsUpdateManyMutationInput, input_groupsUncheckedUpdateManyInput>
    /**
     * Filter which input_groups to update
     */
    where?: input_groupsWhereInput
    /**
     * Limit how many input_groups to update.
     */
    limit?: number
  }

  /**
   * input_groups updateManyAndReturn
   */
  export type input_groupsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the input_groups
     */
    select?: input_groupsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the input_groups
     */
    omit?: input_groupsOmit<ExtArgs> | null
    /**
     * The data used to update input_groups.
     */
    data: XOR<input_groupsUpdateManyMutationInput, input_groupsUncheckedUpdateManyInput>
    /**
     * Filter which input_groups to update
     */
    where?: input_groupsWhereInput
    /**
     * Limit how many input_groups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: input_groupsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * input_groups upsert
   */
  export type input_groupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the input_groups
     */
    select?: input_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the input_groups
     */
    omit?: input_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: input_groupsInclude<ExtArgs> | null
    /**
     * The filter to search for the input_groups to update in case it exists.
     */
    where: input_groupsWhereUniqueInput
    /**
     * In case the input_groups found by the `where` argument doesn't exist, create a new input_groups with this data.
     */
    create: XOR<input_groupsCreateInput, input_groupsUncheckedCreateInput>
    /**
     * In case the input_groups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<input_groupsUpdateInput, input_groupsUncheckedUpdateInput>
  }

  /**
   * input_groups delete
   */
  export type input_groupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the input_groups
     */
    select?: input_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the input_groups
     */
    omit?: input_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: input_groupsInclude<ExtArgs> | null
    /**
     * Filter which input_groups to delete.
     */
    where: input_groupsWhereUniqueInput
  }

  /**
   * input_groups deleteMany
   */
  export type input_groupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which input_groups to delete
     */
    where?: input_groupsWhereInput
    /**
     * Limit how many input_groups to delete.
     */
    limit?: number
  }

  /**
   * input_groups.InputToInputGroup
   */
  export type input_groups$InputToInputGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputToInputGroup
     */
    select?: InputToInputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputToInputGroup
     */
    omit?: InputToInputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputToInputGroupInclude<ExtArgs> | null
    where?: InputToInputGroupWhereInput
    orderBy?: InputToInputGroupOrderByWithRelationInput | InputToInputGroupOrderByWithRelationInput[]
    cursor?: InputToInputGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InputToInputGroupScalarFieldEnum | InputToInputGroupScalarFieldEnum[]
  }

  /**
   * input_groups without action
   */
  export type input_groupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the input_groups
     */
    select?: input_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the input_groups
     */
    omit?: input_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: input_groupsInclude<ExtArgs> | null
  }


  /**
   * Model inputs
   */

  export type AggregateInputs = {
    _count: InputsCountAggregateOutputType | null
    _avg: InputsAvgAggregateOutputType | null
    _sum: InputsSumAggregateOutputType | null
    _min: InputsMinAggregateOutputType | null
    _max: InputsMaxAggregateOutputType | null
  }

  export type InputsAvgAggregateOutputType = {
    aiConfidence: number | null
  }

  export type InputsSumAggregateOutputType = {
    aiConfidence: number | null
  }

  export type InputsMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: $Enums.InputType | null
    status: $Enums.InputStatus | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    department: string | null
    rootCause: string | null
    aiConfidence: number | null
    issueType: string | null
    priority: $Enums.priority | null
  }

  export type InputsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: $Enums.InputType | null
    status: $Enums.InputStatus | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    department: string | null
    rootCause: string | null
    aiConfidence: number | null
    issueType: string | null
    priority: $Enums.priority | null
  }

  export type InputsCountAggregateOutputType = {
    id: number
    title: number
    description: number
    type: number
    status: number
    createdBy: number
    createdAt: number
    updatedAt: number
    department: number
    rootCause: number
    aiTags: number
    aiSuggestions: number
    aiConfidence: number
    issueType: number
    priority: number
    _all: number
  }


  export type InputsAvgAggregateInputType = {
    aiConfidence?: true
  }

  export type InputsSumAggregateInputType = {
    aiConfidence?: true
  }

  export type InputsMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    department?: true
    rootCause?: true
    aiConfidence?: true
    issueType?: true
    priority?: true
  }

  export type InputsMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    department?: true
    rootCause?: true
    aiConfidence?: true
    issueType?: true
    priority?: true
  }

  export type InputsCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    department?: true
    rootCause?: true
    aiTags?: true
    aiSuggestions?: true
    aiConfidence?: true
    issueType?: true
    priority?: true
    _all?: true
  }

  export type InputsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inputs to aggregate.
     */
    where?: inputsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inputs to fetch.
     */
    orderBy?: inputsOrderByWithRelationInput | inputsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inputsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inputs
    **/
    _count?: true | InputsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InputsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InputsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InputsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InputsMaxAggregateInputType
  }

  export type GetInputsAggregateType<T extends InputsAggregateArgs> = {
        [P in keyof T & keyof AggregateInputs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInputs[P]>
      : GetScalarType<T[P], AggregateInputs[P]>
  }




  export type inputsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inputsWhereInput
    orderBy?: inputsOrderByWithAggregationInput | inputsOrderByWithAggregationInput[]
    by: InputsScalarFieldEnum[] | InputsScalarFieldEnum
    having?: inputsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InputsCountAggregateInputType | true
    _avg?: InputsAvgAggregateInputType
    _sum?: InputsSumAggregateInputType
    _min?: InputsMinAggregateInputType
    _max?: InputsMaxAggregateInputType
  }

  export type InputsGroupByOutputType = {
    id: string
    title: string
    description: string
    type: $Enums.InputType
    status: $Enums.InputStatus
    createdBy: string
    createdAt: Date
    updatedAt: Date
    department: string | null
    rootCause: string | null
    aiTags: JsonValue | null
    aiSuggestions: JsonValue | null
    aiConfidence: number | null
    issueType: string | null
    priority: $Enums.priority
    _count: InputsCountAggregateOutputType | null
    _avg: InputsAvgAggregateOutputType | null
    _sum: InputsSumAggregateOutputType | null
    _min: InputsMinAggregateOutputType | null
    _max: InputsMaxAggregateOutputType | null
  }

  type GetInputsGroupByPayload<T extends inputsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InputsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InputsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InputsGroupByOutputType[P]>
            : GetScalarType<T[P], InputsGroupByOutputType[P]>
        }
      >
    >


  export type inputsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean
    rootCause?: boolean
    aiTags?: boolean
    aiSuggestions?: boolean
    aiConfidence?: boolean
    issueType?: boolean
    priority?: boolean
    InputToInputGroup?: boolean | inputs$InputToInputGroupArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    solutions?: boolean | inputs$solutionsArgs<ExtArgs>
    _count?: boolean | InputsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inputs"]>

  export type inputsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean
    rootCause?: boolean
    aiTags?: boolean
    aiSuggestions?: boolean
    aiConfidence?: boolean
    issueType?: boolean
    priority?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inputs"]>

  export type inputsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean
    rootCause?: boolean
    aiTags?: boolean
    aiSuggestions?: boolean
    aiConfidence?: boolean
    issueType?: boolean
    priority?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inputs"]>

  export type inputsSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean
    rootCause?: boolean
    aiTags?: boolean
    aiSuggestions?: boolean
    aiConfidence?: boolean
    issueType?: boolean
    priority?: boolean
  }

  export type inputsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "type" | "status" | "createdBy" | "createdAt" | "updatedAt" | "department" | "rootCause" | "aiTags" | "aiSuggestions" | "aiConfidence" | "issueType" | "priority", ExtArgs["result"]["inputs"]>
  export type inputsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    InputToInputGroup?: boolean | inputs$InputToInputGroupArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    solutions?: boolean | inputs$solutionsArgs<ExtArgs>
    _count?: boolean | InputsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type inputsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type inputsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $inputsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "inputs"
    objects: {
      InputToInputGroup: Prisma.$InputToInputGroupPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
      solutions: Prisma.$solutionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      type: $Enums.InputType
      status: $Enums.InputStatus
      createdBy: string
      createdAt: Date
      updatedAt: Date
      department: string | null
      rootCause: string | null
      aiTags: Prisma.JsonValue | null
      aiSuggestions: Prisma.JsonValue | null
      aiConfidence: number | null
      issueType: string | null
      priority: $Enums.priority
    }, ExtArgs["result"]["inputs"]>
    composites: {}
  }

  type inputsGetPayload<S extends boolean | null | undefined | inputsDefaultArgs> = $Result.GetResult<Prisma.$inputsPayload, S>

  type inputsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<inputsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InputsCountAggregateInputType | true
    }

  export interface inputsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inputs'], meta: { name: 'inputs' } }
    /**
     * Find zero or one Inputs that matches the filter.
     * @param {inputsFindUniqueArgs} args - Arguments to find a Inputs
     * @example
     * // Get one Inputs
     * const inputs = await prisma.inputs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends inputsFindUniqueArgs>(args: SelectSubset<T, inputsFindUniqueArgs<ExtArgs>>): Prisma__inputsClient<$Result.GetResult<Prisma.$inputsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inputs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {inputsFindUniqueOrThrowArgs} args - Arguments to find a Inputs
     * @example
     * // Get one Inputs
     * const inputs = await prisma.inputs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends inputsFindUniqueOrThrowArgs>(args: SelectSubset<T, inputsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__inputsClient<$Result.GetResult<Prisma.$inputsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inputs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inputsFindFirstArgs} args - Arguments to find a Inputs
     * @example
     * // Get one Inputs
     * const inputs = await prisma.inputs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends inputsFindFirstArgs>(args?: SelectSubset<T, inputsFindFirstArgs<ExtArgs>>): Prisma__inputsClient<$Result.GetResult<Prisma.$inputsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inputs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inputsFindFirstOrThrowArgs} args - Arguments to find a Inputs
     * @example
     * // Get one Inputs
     * const inputs = await prisma.inputs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends inputsFindFirstOrThrowArgs>(args?: SelectSubset<T, inputsFindFirstOrThrowArgs<ExtArgs>>): Prisma__inputsClient<$Result.GetResult<Prisma.$inputsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inputs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inputsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inputs
     * const inputs = await prisma.inputs.findMany()
     * 
     * // Get first 10 Inputs
     * const inputs = await prisma.inputs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inputsWithIdOnly = await prisma.inputs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends inputsFindManyArgs>(args?: SelectSubset<T, inputsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inputsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inputs.
     * @param {inputsCreateArgs} args - Arguments to create a Inputs.
     * @example
     * // Create one Inputs
     * const Inputs = await prisma.inputs.create({
     *   data: {
     *     // ... data to create a Inputs
     *   }
     * })
     * 
     */
    create<T extends inputsCreateArgs>(args: SelectSubset<T, inputsCreateArgs<ExtArgs>>): Prisma__inputsClient<$Result.GetResult<Prisma.$inputsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inputs.
     * @param {inputsCreateManyArgs} args - Arguments to create many Inputs.
     * @example
     * // Create many Inputs
     * const inputs = await prisma.inputs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends inputsCreateManyArgs>(args?: SelectSubset<T, inputsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inputs and returns the data saved in the database.
     * @param {inputsCreateManyAndReturnArgs} args - Arguments to create many Inputs.
     * @example
     * // Create many Inputs
     * const inputs = await prisma.inputs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inputs and only return the `id`
     * const inputsWithIdOnly = await prisma.inputs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends inputsCreateManyAndReturnArgs>(args?: SelectSubset<T, inputsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inputsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inputs.
     * @param {inputsDeleteArgs} args - Arguments to delete one Inputs.
     * @example
     * // Delete one Inputs
     * const Inputs = await prisma.inputs.delete({
     *   where: {
     *     // ... filter to delete one Inputs
     *   }
     * })
     * 
     */
    delete<T extends inputsDeleteArgs>(args: SelectSubset<T, inputsDeleteArgs<ExtArgs>>): Prisma__inputsClient<$Result.GetResult<Prisma.$inputsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inputs.
     * @param {inputsUpdateArgs} args - Arguments to update one Inputs.
     * @example
     * // Update one Inputs
     * const inputs = await prisma.inputs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends inputsUpdateArgs>(args: SelectSubset<T, inputsUpdateArgs<ExtArgs>>): Prisma__inputsClient<$Result.GetResult<Prisma.$inputsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inputs.
     * @param {inputsDeleteManyArgs} args - Arguments to filter Inputs to delete.
     * @example
     * // Delete a few Inputs
     * const { count } = await prisma.inputs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends inputsDeleteManyArgs>(args?: SelectSubset<T, inputsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inputsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inputs
     * const inputs = await prisma.inputs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends inputsUpdateManyArgs>(args: SelectSubset<T, inputsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inputs and returns the data updated in the database.
     * @param {inputsUpdateManyAndReturnArgs} args - Arguments to update many Inputs.
     * @example
     * // Update many Inputs
     * const inputs = await prisma.inputs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inputs and only return the `id`
     * const inputsWithIdOnly = await prisma.inputs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends inputsUpdateManyAndReturnArgs>(args: SelectSubset<T, inputsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inputsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inputs.
     * @param {inputsUpsertArgs} args - Arguments to update or create a Inputs.
     * @example
     * // Update or create a Inputs
     * const inputs = await prisma.inputs.upsert({
     *   create: {
     *     // ... data to create a Inputs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inputs we want to update
     *   }
     * })
     */
    upsert<T extends inputsUpsertArgs>(args: SelectSubset<T, inputsUpsertArgs<ExtArgs>>): Prisma__inputsClient<$Result.GetResult<Prisma.$inputsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inputsCountArgs} args - Arguments to filter Inputs to count.
     * @example
     * // Count the number of Inputs
     * const count = await prisma.inputs.count({
     *   where: {
     *     // ... the filter for the Inputs we want to count
     *   }
     * })
    **/
    count<T extends inputsCountArgs>(
      args?: Subset<T, inputsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InputsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InputsAggregateArgs>(args: Subset<T, InputsAggregateArgs>): Prisma.PrismaPromise<GetInputsAggregateType<T>>

    /**
     * Group by Inputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inputsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inputsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inputsGroupByArgs['orderBy'] }
        : { orderBy?: inputsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inputsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInputsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inputs model
   */
  readonly fields: inputsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inputs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inputsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    InputToInputGroup<T extends inputs$InputToInputGroupArgs<ExtArgs> = {}>(args?: Subset<T, inputs$InputToInputGroupArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InputToInputGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    solutions<T extends inputs$solutionsArgs<ExtArgs> = {}>(args?: Subset<T, inputs$solutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$solutionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the inputs model
   */
  interface inputsFieldRefs {
    readonly id: FieldRef<"inputs", 'String'>
    readonly title: FieldRef<"inputs", 'String'>
    readonly description: FieldRef<"inputs", 'String'>
    readonly type: FieldRef<"inputs", 'InputType'>
    readonly status: FieldRef<"inputs", 'InputStatus'>
    readonly createdBy: FieldRef<"inputs", 'String'>
    readonly createdAt: FieldRef<"inputs", 'DateTime'>
    readonly updatedAt: FieldRef<"inputs", 'DateTime'>
    readonly department: FieldRef<"inputs", 'String'>
    readonly rootCause: FieldRef<"inputs", 'String'>
    readonly aiTags: FieldRef<"inputs", 'Json'>
    readonly aiSuggestions: FieldRef<"inputs", 'Json'>
    readonly aiConfidence: FieldRef<"inputs", 'Float'>
    readonly issueType: FieldRef<"inputs", 'String'>
    readonly priority: FieldRef<"inputs", 'priority'>
  }
    

  // Custom InputTypes
  /**
   * inputs findUnique
   */
  export type inputsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inputs
     */
    select?: inputsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inputs
     */
    omit?: inputsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inputsInclude<ExtArgs> | null
    /**
     * Filter, which inputs to fetch.
     */
    where: inputsWhereUniqueInput
  }

  /**
   * inputs findUniqueOrThrow
   */
  export type inputsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inputs
     */
    select?: inputsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inputs
     */
    omit?: inputsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inputsInclude<ExtArgs> | null
    /**
     * Filter, which inputs to fetch.
     */
    where: inputsWhereUniqueInput
  }

  /**
   * inputs findFirst
   */
  export type inputsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inputs
     */
    select?: inputsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inputs
     */
    omit?: inputsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inputsInclude<ExtArgs> | null
    /**
     * Filter, which inputs to fetch.
     */
    where?: inputsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inputs to fetch.
     */
    orderBy?: inputsOrderByWithRelationInput | inputsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inputs.
     */
    cursor?: inputsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inputs.
     */
    distinct?: InputsScalarFieldEnum | InputsScalarFieldEnum[]
  }

  /**
   * inputs findFirstOrThrow
   */
  export type inputsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inputs
     */
    select?: inputsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inputs
     */
    omit?: inputsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inputsInclude<ExtArgs> | null
    /**
     * Filter, which inputs to fetch.
     */
    where?: inputsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inputs to fetch.
     */
    orderBy?: inputsOrderByWithRelationInput | inputsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inputs.
     */
    cursor?: inputsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inputs.
     */
    distinct?: InputsScalarFieldEnum | InputsScalarFieldEnum[]
  }

  /**
   * inputs findMany
   */
  export type inputsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inputs
     */
    select?: inputsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inputs
     */
    omit?: inputsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inputsInclude<ExtArgs> | null
    /**
     * Filter, which inputs to fetch.
     */
    where?: inputsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inputs to fetch.
     */
    orderBy?: inputsOrderByWithRelationInput | inputsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inputs.
     */
    cursor?: inputsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inputs.
     */
    skip?: number
    distinct?: InputsScalarFieldEnum | InputsScalarFieldEnum[]
  }

  /**
   * inputs create
   */
  export type inputsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inputs
     */
    select?: inputsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inputs
     */
    omit?: inputsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inputsInclude<ExtArgs> | null
    /**
     * The data needed to create a inputs.
     */
    data: XOR<inputsCreateInput, inputsUncheckedCreateInput>
  }

  /**
   * inputs createMany
   */
  export type inputsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inputs.
     */
    data: inputsCreateManyInput | inputsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * inputs createManyAndReturn
   */
  export type inputsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inputs
     */
    select?: inputsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the inputs
     */
    omit?: inputsOmit<ExtArgs> | null
    /**
     * The data used to create many inputs.
     */
    data: inputsCreateManyInput | inputsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inputsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * inputs update
   */
  export type inputsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inputs
     */
    select?: inputsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inputs
     */
    omit?: inputsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inputsInclude<ExtArgs> | null
    /**
     * The data needed to update a inputs.
     */
    data: XOR<inputsUpdateInput, inputsUncheckedUpdateInput>
    /**
     * Choose, which inputs to update.
     */
    where: inputsWhereUniqueInput
  }

  /**
   * inputs updateMany
   */
  export type inputsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inputs.
     */
    data: XOR<inputsUpdateManyMutationInput, inputsUncheckedUpdateManyInput>
    /**
     * Filter which inputs to update
     */
    where?: inputsWhereInput
    /**
     * Limit how many inputs to update.
     */
    limit?: number
  }

  /**
   * inputs updateManyAndReturn
   */
  export type inputsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inputs
     */
    select?: inputsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the inputs
     */
    omit?: inputsOmit<ExtArgs> | null
    /**
     * The data used to update inputs.
     */
    data: XOR<inputsUpdateManyMutationInput, inputsUncheckedUpdateManyInput>
    /**
     * Filter which inputs to update
     */
    where?: inputsWhereInput
    /**
     * Limit how many inputs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inputsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * inputs upsert
   */
  export type inputsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inputs
     */
    select?: inputsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inputs
     */
    omit?: inputsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inputsInclude<ExtArgs> | null
    /**
     * The filter to search for the inputs to update in case it exists.
     */
    where: inputsWhereUniqueInput
    /**
     * In case the inputs found by the `where` argument doesn't exist, create a new inputs with this data.
     */
    create: XOR<inputsCreateInput, inputsUncheckedCreateInput>
    /**
     * In case the inputs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inputsUpdateInput, inputsUncheckedUpdateInput>
  }

  /**
   * inputs delete
   */
  export type inputsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inputs
     */
    select?: inputsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inputs
     */
    omit?: inputsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inputsInclude<ExtArgs> | null
    /**
     * Filter which inputs to delete.
     */
    where: inputsWhereUniqueInput
  }

  /**
   * inputs deleteMany
   */
  export type inputsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inputs to delete
     */
    where?: inputsWhereInput
    /**
     * Limit how many inputs to delete.
     */
    limit?: number
  }

  /**
   * inputs.InputToInputGroup
   */
  export type inputs$InputToInputGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputToInputGroup
     */
    select?: InputToInputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputToInputGroup
     */
    omit?: InputToInputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputToInputGroupInclude<ExtArgs> | null
    where?: InputToInputGroupWhereInput
    orderBy?: InputToInputGroupOrderByWithRelationInput | InputToInputGroupOrderByWithRelationInput[]
    cursor?: InputToInputGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InputToInputGroupScalarFieldEnum | InputToInputGroupScalarFieldEnum[]
  }

  /**
   * inputs.solutions
   */
  export type inputs$solutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the solutions
     */
    select?: solutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the solutions
     */
    omit?: solutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: solutionsInclude<ExtArgs> | null
    where?: solutionsWhereInput
    orderBy?: solutionsOrderByWithRelationInput | solutionsOrderByWithRelationInput[]
    cursor?: solutionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SolutionsScalarFieldEnum | SolutionsScalarFieldEnum[]
  }

  /**
   * inputs without action
   */
  export type inputsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inputs
     */
    select?: inputsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inputs
     */
    omit?: inputsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inputsInclude<ExtArgs> | null
  }


  /**
   * Model notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    readAt: Date | null
    createdAt: Date | null
    delivered: boolean | null
    entityId: string | null
    entityType: $Enums.EntityType | null
    read: boolean | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    readAt: Date | null
    createdAt: Date | null
    delivered: boolean | null
    entityId: string | null
    entityType: $Enums.EntityType | null
    read: boolean | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    readAt: number
    createdAt: number
    delivered: number
    entityId: number
    entityType: number
    read: number
    _all: number
  }


  export type NotificationsMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    readAt?: true
    createdAt?: true
    delivered?: true
    entityId?: true
    entityType?: true
    read?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    readAt?: true
    createdAt?: true
    delivered?: true
    entityId?: true
    entityType?: true
    read?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    readAt?: true
    createdAt?: true
    delivered?: true
    entityId?: true
    entityType?: true
    read?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to aggregate.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithAggregationInput | notificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    readAt: Date | null
    createdAt: Date
    delivered: boolean
    entityId: string | null
    entityType: $Enums.EntityType | null
    read: boolean
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    readAt?: boolean
    createdAt?: boolean
    delivered?: boolean
    entityId?: boolean
    entityType?: boolean
    read?: boolean
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    readAt?: boolean
    createdAt?: boolean
    delivered?: boolean
    entityId?: boolean
    entityType?: boolean
    read?: boolean
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    readAt?: boolean
    createdAt?: boolean
    delivered?: boolean
    entityId?: boolean
    entityType?: boolean
    read?: boolean
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    readAt?: boolean
    createdAt?: boolean
    delivered?: boolean
    entityId?: boolean
    entityType?: boolean
    read?: boolean
  }

  export type notificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "message" | "readAt" | "createdAt" | "delivered" | "entityId" | "entityType" | "read", ExtArgs["result"]["notifications"]>

  export type $notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notifications"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.NotificationType
      title: string
      message: string
      readAt: Date | null
      createdAt: Date
      delivered: boolean
      entityId: string | null
      entityType: $Enums.EntityType | null
      read: boolean
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type notificationsGetPayload<S extends boolean | null | undefined | notificationsDefaultArgs> = $Result.GetResult<Prisma.$notificationsPayload, S>

  type notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notifications'], meta: { name: 'notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {notificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationsFindUniqueArgs>(args: SelectSubset<T, notificationsFindUniqueArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationsFindFirstArgs>(args?: SelectSubset<T, notificationsFindFirstArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationsFindManyArgs>(args?: SelectSubset<T, notificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notifications.
     * @param {notificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends notificationsCreateArgs>(args: SelectSubset<T, notificationsCreateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {notificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationsCreateManyArgs>(args?: SelectSubset<T, notificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {notificationsCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, notificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notifications.
     * @param {notificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends notificationsDeleteArgs>(args: SelectSubset<T, notificationsDeleteArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notifications.
     * @param {notificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationsUpdateArgs>(args: SelectSubset<T, notificationsUpdateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {notificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationsDeleteManyArgs>(args?: SelectSubset<T, notificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationsUpdateManyArgs>(args: SelectSubset<T, notificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {notificationsUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notificationsUpdateManyAndReturnArgs>(args: SelectSubset<T, notificationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notifications.
     * @param {notificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends notificationsUpsertArgs>(args: SelectSubset<T, notificationsUpsertArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationsCountArgs>(
      args?: Subset<T, notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationsGroupByArgs['orderBy'] }
        : { orderBy?: notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notifications model
   */
  readonly fields: notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notifications model
   */
  interface notificationsFieldRefs {
    readonly id: FieldRef<"notifications", 'String'>
    readonly userId: FieldRef<"notifications", 'String'>
    readonly type: FieldRef<"notifications", 'NotificationType'>
    readonly title: FieldRef<"notifications", 'String'>
    readonly message: FieldRef<"notifications", 'String'>
    readonly readAt: FieldRef<"notifications", 'DateTime'>
    readonly createdAt: FieldRef<"notifications", 'DateTime'>
    readonly delivered: FieldRef<"notifications", 'Boolean'>
    readonly entityId: FieldRef<"notifications", 'String'>
    readonly entityType: FieldRef<"notifications", 'EntityType'>
    readonly read: FieldRef<"notifications", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * notifications findUnique
   */
  export type notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findUniqueOrThrow
   */
  export type notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findFirst
   */
  export type notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findFirstOrThrow
   */
  export type notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findMany
   */
  export type notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications create
   */
  export type notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The data needed to create a notifications.
     */
    data: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
  }

  /**
   * notifications createMany
   */
  export type notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifications createManyAndReturn
   */
  export type notificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifications update
   */
  export type notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The data needed to update a notifications.
     */
    data: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
    /**
     * Choose, which notifications to update.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications updateMany
   */
  export type notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
  }

  /**
   * notifications updateManyAndReturn
   */
  export type notificationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
  }

  /**
   * notifications upsert
   */
  export type notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The filter to search for the notifications to update in case it exists.
     */
    where: notificationsWhereUniqueInput
    /**
     * In case the notifications found by the `where` argument doesn't exist, create a new notifications with this data.
     */
    create: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
    /**
     * In case the notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
  }

  /**
   * notifications delete
   */
  export type notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Filter which notifications to delete.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications deleteMany
   */
  export type notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to delete.
     */
    limit?: number
  }

  /**
   * notifications without action
   */
  export type notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
  }


  /**
   * Model requirements
   */

  export type AggregateRequirements = {
    _count: RequirementsCountAggregateOutputType | null
    _min: RequirementsMinAggregateOutputType | null
    _max: RequirementsMaxAggregateOutputType | null
  }

  export type RequirementsMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.RequirementStatus | null
    estimatedEffort: string | null
    businessValue: string | null
    riskAssessment: string | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectionReason: string | null
    solutionId: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    priority: $Enums.priority | null
  }

  export type RequirementsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.RequirementStatus | null
    estimatedEffort: string | null
    businessValue: string | null
    riskAssessment: string | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectionReason: string | null
    solutionId: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    priority: $Enums.priority | null
  }

  export type RequirementsCountAggregateOutputType = {
    id: number
    title: number
    description: number
    acceptanceCriteria: number
    status: number
    estimatedEffort: number
    dependencies: number
    businessValue: number
    riskAssessment: number
    stakeholders: number
    approvedBy: number
    approvedAt: number
    rejectionReason: number
    solutionId: number
    createdBy: number
    createdAt: number
    updatedAt: number
    priority: number
    _all: number
  }


  export type RequirementsMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    estimatedEffort?: true
    businessValue?: true
    riskAssessment?: true
    approvedBy?: true
    approvedAt?: true
    rejectionReason?: true
    solutionId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    priority?: true
  }

  export type RequirementsMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    estimatedEffort?: true
    businessValue?: true
    riskAssessment?: true
    approvedBy?: true
    approvedAt?: true
    rejectionReason?: true
    solutionId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    priority?: true
  }

  export type RequirementsCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    acceptanceCriteria?: true
    status?: true
    estimatedEffort?: true
    dependencies?: true
    businessValue?: true
    riskAssessment?: true
    stakeholders?: true
    approvedBy?: true
    approvedAt?: true
    rejectionReason?: true
    solutionId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    priority?: true
    _all?: true
  }

  export type RequirementsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which requirements to aggregate.
     */
    where?: requirementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requirements to fetch.
     */
    orderBy?: requirementsOrderByWithRelationInput | requirementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: requirementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned requirements
    **/
    _count?: true | RequirementsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequirementsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequirementsMaxAggregateInputType
  }

  export type GetRequirementsAggregateType<T extends RequirementsAggregateArgs> = {
        [P in keyof T & keyof AggregateRequirements]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequirements[P]>
      : GetScalarType<T[P], AggregateRequirements[P]>
  }




  export type requirementsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: requirementsWhereInput
    orderBy?: requirementsOrderByWithAggregationInput | requirementsOrderByWithAggregationInput[]
    by: RequirementsScalarFieldEnum[] | RequirementsScalarFieldEnum
    having?: requirementsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequirementsCountAggregateInputType | true
    _min?: RequirementsMinAggregateInputType
    _max?: RequirementsMaxAggregateInputType
  }

  export type RequirementsGroupByOutputType = {
    id: string
    title: string
    description: string
    acceptanceCriteria: JsonValue
    status: $Enums.RequirementStatus
    estimatedEffort: string | null
    dependencies: JsonValue | null
    businessValue: string | null
    riskAssessment: string | null
    stakeholders: JsonValue | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectionReason: string | null
    solutionId: string
    createdBy: string
    createdAt: Date
    updatedAt: Date
    priority: $Enums.priority
    _count: RequirementsCountAggregateOutputType | null
    _min: RequirementsMinAggregateOutputType | null
    _max: RequirementsMaxAggregateOutputType | null
  }

  type GetRequirementsGroupByPayload<T extends requirementsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequirementsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequirementsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequirementsGroupByOutputType[P]>
            : GetScalarType<T[P], RequirementsGroupByOutputType[P]>
        }
      >
    >


  export type requirementsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    acceptanceCriteria?: boolean
    status?: boolean
    estimatedEffort?: boolean
    dependencies?: boolean
    businessValue?: boolean
    riskAssessment?: boolean
    stakeholders?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectionReason?: boolean
    solutionId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    priority?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    solutions?: boolean | solutionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requirements"]>

  export type requirementsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    acceptanceCriteria?: boolean
    status?: boolean
    estimatedEffort?: boolean
    dependencies?: boolean
    businessValue?: boolean
    riskAssessment?: boolean
    stakeholders?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectionReason?: boolean
    solutionId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    priority?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    solutions?: boolean | solutionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requirements"]>

  export type requirementsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    acceptanceCriteria?: boolean
    status?: boolean
    estimatedEffort?: boolean
    dependencies?: boolean
    businessValue?: boolean
    riskAssessment?: boolean
    stakeholders?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectionReason?: boolean
    solutionId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    priority?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    solutions?: boolean | solutionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requirements"]>

  export type requirementsSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    acceptanceCriteria?: boolean
    status?: boolean
    estimatedEffort?: boolean
    dependencies?: boolean
    businessValue?: boolean
    riskAssessment?: boolean
    stakeholders?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectionReason?: boolean
    solutionId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    priority?: boolean
  }

  export type requirementsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "acceptanceCriteria" | "status" | "estimatedEffort" | "dependencies" | "businessValue" | "riskAssessment" | "stakeholders" | "approvedBy" | "approvedAt" | "rejectionReason" | "solutionId" | "createdBy" | "createdAt" | "updatedAt" | "priority", ExtArgs["result"]["requirements"]>
  export type requirementsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    solutions?: boolean | solutionsDefaultArgs<ExtArgs>
  }
  export type requirementsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    solutions?: boolean | solutionsDefaultArgs<ExtArgs>
  }
  export type requirementsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    solutions?: boolean | solutionsDefaultArgs<ExtArgs>
  }

  export type $requirementsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "requirements"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      solutions: Prisma.$solutionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      acceptanceCriteria: Prisma.JsonValue
      status: $Enums.RequirementStatus
      estimatedEffort: string | null
      dependencies: Prisma.JsonValue | null
      businessValue: string | null
      riskAssessment: string | null
      stakeholders: Prisma.JsonValue | null
      approvedBy: string | null
      approvedAt: Date | null
      rejectionReason: string | null
      solutionId: string
      createdBy: string
      createdAt: Date
      updatedAt: Date
      priority: $Enums.priority
    }, ExtArgs["result"]["requirements"]>
    composites: {}
  }

  type requirementsGetPayload<S extends boolean | null | undefined | requirementsDefaultArgs> = $Result.GetResult<Prisma.$requirementsPayload, S>

  type requirementsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<requirementsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequirementsCountAggregateInputType | true
    }

  export interface requirementsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['requirements'], meta: { name: 'requirements' } }
    /**
     * Find zero or one Requirements that matches the filter.
     * @param {requirementsFindUniqueArgs} args - Arguments to find a Requirements
     * @example
     * // Get one Requirements
     * const requirements = await prisma.requirements.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends requirementsFindUniqueArgs>(args: SelectSubset<T, requirementsFindUniqueArgs<ExtArgs>>): Prisma__requirementsClient<$Result.GetResult<Prisma.$requirementsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Requirements that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {requirementsFindUniqueOrThrowArgs} args - Arguments to find a Requirements
     * @example
     * // Get one Requirements
     * const requirements = await prisma.requirements.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends requirementsFindUniqueOrThrowArgs>(args: SelectSubset<T, requirementsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__requirementsClient<$Result.GetResult<Prisma.$requirementsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Requirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requirementsFindFirstArgs} args - Arguments to find a Requirements
     * @example
     * // Get one Requirements
     * const requirements = await prisma.requirements.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends requirementsFindFirstArgs>(args?: SelectSubset<T, requirementsFindFirstArgs<ExtArgs>>): Prisma__requirementsClient<$Result.GetResult<Prisma.$requirementsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Requirements that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requirementsFindFirstOrThrowArgs} args - Arguments to find a Requirements
     * @example
     * // Get one Requirements
     * const requirements = await prisma.requirements.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends requirementsFindFirstOrThrowArgs>(args?: SelectSubset<T, requirementsFindFirstOrThrowArgs<ExtArgs>>): Prisma__requirementsClient<$Result.GetResult<Prisma.$requirementsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Requirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requirementsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Requirements
     * const requirements = await prisma.requirements.findMany()
     * 
     * // Get first 10 Requirements
     * const requirements = await prisma.requirements.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requirementsWithIdOnly = await prisma.requirements.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends requirementsFindManyArgs>(args?: SelectSubset<T, requirementsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$requirementsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Requirements.
     * @param {requirementsCreateArgs} args - Arguments to create a Requirements.
     * @example
     * // Create one Requirements
     * const Requirements = await prisma.requirements.create({
     *   data: {
     *     // ... data to create a Requirements
     *   }
     * })
     * 
     */
    create<T extends requirementsCreateArgs>(args: SelectSubset<T, requirementsCreateArgs<ExtArgs>>): Prisma__requirementsClient<$Result.GetResult<Prisma.$requirementsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Requirements.
     * @param {requirementsCreateManyArgs} args - Arguments to create many Requirements.
     * @example
     * // Create many Requirements
     * const requirements = await prisma.requirements.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends requirementsCreateManyArgs>(args?: SelectSubset<T, requirementsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Requirements and returns the data saved in the database.
     * @param {requirementsCreateManyAndReturnArgs} args - Arguments to create many Requirements.
     * @example
     * // Create many Requirements
     * const requirements = await prisma.requirements.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Requirements and only return the `id`
     * const requirementsWithIdOnly = await prisma.requirements.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends requirementsCreateManyAndReturnArgs>(args?: SelectSubset<T, requirementsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$requirementsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Requirements.
     * @param {requirementsDeleteArgs} args - Arguments to delete one Requirements.
     * @example
     * // Delete one Requirements
     * const Requirements = await prisma.requirements.delete({
     *   where: {
     *     // ... filter to delete one Requirements
     *   }
     * })
     * 
     */
    delete<T extends requirementsDeleteArgs>(args: SelectSubset<T, requirementsDeleteArgs<ExtArgs>>): Prisma__requirementsClient<$Result.GetResult<Prisma.$requirementsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Requirements.
     * @param {requirementsUpdateArgs} args - Arguments to update one Requirements.
     * @example
     * // Update one Requirements
     * const requirements = await prisma.requirements.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends requirementsUpdateArgs>(args: SelectSubset<T, requirementsUpdateArgs<ExtArgs>>): Prisma__requirementsClient<$Result.GetResult<Prisma.$requirementsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Requirements.
     * @param {requirementsDeleteManyArgs} args - Arguments to filter Requirements to delete.
     * @example
     * // Delete a few Requirements
     * const { count } = await prisma.requirements.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends requirementsDeleteManyArgs>(args?: SelectSubset<T, requirementsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requirementsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Requirements
     * const requirements = await prisma.requirements.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends requirementsUpdateManyArgs>(args: SelectSubset<T, requirementsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requirements and returns the data updated in the database.
     * @param {requirementsUpdateManyAndReturnArgs} args - Arguments to update many Requirements.
     * @example
     * // Update many Requirements
     * const requirements = await prisma.requirements.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Requirements and only return the `id`
     * const requirementsWithIdOnly = await prisma.requirements.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends requirementsUpdateManyAndReturnArgs>(args: SelectSubset<T, requirementsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$requirementsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Requirements.
     * @param {requirementsUpsertArgs} args - Arguments to update or create a Requirements.
     * @example
     * // Update or create a Requirements
     * const requirements = await prisma.requirements.upsert({
     *   create: {
     *     // ... data to create a Requirements
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Requirements we want to update
     *   }
     * })
     */
    upsert<T extends requirementsUpsertArgs>(args: SelectSubset<T, requirementsUpsertArgs<ExtArgs>>): Prisma__requirementsClient<$Result.GetResult<Prisma.$requirementsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Requirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requirementsCountArgs} args - Arguments to filter Requirements to count.
     * @example
     * // Count the number of Requirements
     * const count = await prisma.requirements.count({
     *   where: {
     *     // ... the filter for the Requirements we want to count
     *   }
     * })
    **/
    count<T extends requirementsCountArgs>(
      args?: Subset<T, requirementsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequirementsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Requirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequirementsAggregateArgs>(args: Subset<T, RequirementsAggregateArgs>): Prisma.PrismaPromise<GetRequirementsAggregateType<T>>

    /**
     * Group by Requirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requirementsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends requirementsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: requirementsGroupByArgs['orderBy'] }
        : { orderBy?: requirementsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, requirementsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequirementsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the requirements model
   */
  readonly fields: requirementsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for requirements.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__requirementsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    solutions<T extends solutionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, solutionsDefaultArgs<ExtArgs>>): Prisma__solutionsClient<$Result.GetResult<Prisma.$solutionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the requirements model
   */
  interface requirementsFieldRefs {
    readonly id: FieldRef<"requirements", 'String'>
    readonly title: FieldRef<"requirements", 'String'>
    readonly description: FieldRef<"requirements", 'String'>
    readonly acceptanceCriteria: FieldRef<"requirements", 'Json'>
    readonly status: FieldRef<"requirements", 'RequirementStatus'>
    readonly estimatedEffort: FieldRef<"requirements", 'String'>
    readonly dependencies: FieldRef<"requirements", 'Json'>
    readonly businessValue: FieldRef<"requirements", 'String'>
    readonly riskAssessment: FieldRef<"requirements", 'String'>
    readonly stakeholders: FieldRef<"requirements", 'Json'>
    readonly approvedBy: FieldRef<"requirements", 'String'>
    readonly approvedAt: FieldRef<"requirements", 'DateTime'>
    readonly rejectionReason: FieldRef<"requirements", 'String'>
    readonly solutionId: FieldRef<"requirements", 'String'>
    readonly createdBy: FieldRef<"requirements", 'String'>
    readonly createdAt: FieldRef<"requirements", 'DateTime'>
    readonly updatedAt: FieldRef<"requirements", 'DateTime'>
    readonly priority: FieldRef<"requirements", 'priority'>
  }
    

  // Custom InputTypes
  /**
   * requirements findUnique
   */
  export type requirementsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirements
     */
    select?: requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirements
     */
    omit?: requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirementsInclude<ExtArgs> | null
    /**
     * Filter, which requirements to fetch.
     */
    where: requirementsWhereUniqueInput
  }

  /**
   * requirements findUniqueOrThrow
   */
  export type requirementsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirements
     */
    select?: requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirements
     */
    omit?: requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirementsInclude<ExtArgs> | null
    /**
     * Filter, which requirements to fetch.
     */
    where: requirementsWhereUniqueInput
  }

  /**
   * requirements findFirst
   */
  export type requirementsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirements
     */
    select?: requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirements
     */
    omit?: requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirementsInclude<ExtArgs> | null
    /**
     * Filter, which requirements to fetch.
     */
    where?: requirementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requirements to fetch.
     */
    orderBy?: requirementsOrderByWithRelationInput | requirementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for requirements.
     */
    cursor?: requirementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of requirements.
     */
    distinct?: RequirementsScalarFieldEnum | RequirementsScalarFieldEnum[]
  }

  /**
   * requirements findFirstOrThrow
   */
  export type requirementsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirements
     */
    select?: requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirements
     */
    omit?: requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirementsInclude<ExtArgs> | null
    /**
     * Filter, which requirements to fetch.
     */
    where?: requirementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requirements to fetch.
     */
    orderBy?: requirementsOrderByWithRelationInput | requirementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for requirements.
     */
    cursor?: requirementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of requirements.
     */
    distinct?: RequirementsScalarFieldEnum | RequirementsScalarFieldEnum[]
  }

  /**
   * requirements findMany
   */
  export type requirementsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirements
     */
    select?: requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirements
     */
    omit?: requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirementsInclude<ExtArgs> | null
    /**
     * Filter, which requirements to fetch.
     */
    where?: requirementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requirements to fetch.
     */
    orderBy?: requirementsOrderByWithRelationInput | requirementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing requirements.
     */
    cursor?: requirementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requirements.
     */
    skip?: number
    distinct?: RequirementsScalarFieldEnum | RequirementsScalarFieldEnum[]
  }

  /**
   * requirements create
   */
  export type requirementsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirements
     */
    select?: requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirements
     */
    omit?: requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirementsInclude<ExtArgs> | null
    /**
     * The data needed to create a requirements.
     */
    data: XOR<requirementsCreateInput, requirementsUncheckedCreateInput>
  }

  /**
   * requirements createMany
   */
  export type requirementsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many requirements.
     */
    data: requirementsCreateManyInput | requirementsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * requirements createManyAndReturn
   */
  export type requirementsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirements
     */
    select?: requirementsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the requirements
     */
    omit?: requirementsOmit<ExtArgs> | null
    /**
     * The data used to create many requirements.
     */
    data: requirementsCreateManyInput | requirementsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirementsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * requirements update
   */
  export type requirementsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirements
     */
    select?: requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirements
     */
    omit?: requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirementsInclude<ExtArgs> | null
    /**
     * The data needed to update a requirements.
     */
    data: XOR<requirementsUpdateInput, requirementsUncheckedUpdateInput>
    /**
     * Choose, which requirements to update.
     */
    where: requirementsWhereUniqueInput
  }

  /**
   * requirements updateMany
   */
  export type requirementsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update requirements.
     */
    data: XOR<requirementsUpdateManyMutationInput, requirementsUncheckedUpdateManyInput>
    /**
     * Filter which requirements to update
     */
    where?: requirementsWhereInput
    /**
     * Limit how many requirements to update.
     */
    limit?: number
  }

  /**
   * requirements updateManyAndReturn
   */
  export type requirementsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirements
     */
    select?: requirementsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the requirements
     */
    omit?: requirementsOmit<ExtArgs> | null
    /**
     * The data used to update requirements.
     */
    data: XOR<requirementsUpdateManyMutationInput, requirementsUncheckedUpdateManyInput>
    /**
     * Filter which requirements to update
     */
    where?: requirementsWhereInput
    /**
     * Limit how many requirements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirementsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * requirements upsert
   */
  export type requirementsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirements
     */
    select?: requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirements
     */
    omit?: requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirementsInclude<ExtArgs> | null
    /**
     * The filter to search for the requirements to update in case it exists.
     */
    where: requirementsWhereUniqueInput
    /**
     * In case the requirements found by the `where` argument doesn't exist, create a new requirements with this data.
     */
    create: XOR<requirementsCreateInput, requirementsUncheckedCreateInput>
    /**
     * In case the requirements was found with the provided `where` argument, update it with this data.
     */
    update: XOR<requirementsUpdateInput, requirementsUncheckedUpdateInput>
  }

  /**
   * requirements delete
   */
  export type requirementsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirements
     */
    select?: requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirements
     */
    omit?: requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirementsInclude<ExtArgs> | null
    /**
     * Filter which requirements to delete.
     */
    where: requirementsWhereUniqueInput
  }

  /**
   * requirements deleteMany
   */
  export type requirementsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which requirements to delete
     */
    where?: requirementsWhereInput
    /**
     * Limit how many requirements to delete.
     */
    limit?: number
  }

  /**
   * requirements without action
   */
  export type requirementsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirements
     */
    select?: requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirements
     */
    omit?: requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirementsInclude<ExtArgs> | null
  }


  /**
   * Model signals
   */

  export type AggregateSignals = {
    _count: SignalsCountAggregateOutputType | null
    _avg: SignalsAvgAggregateOutputType | null
    _sum: SignalsSumAggregateOutputType | null
    _min: SignalsMinAggregateOutputType | null
    _max: SignalsMaxAggregateOutputType | null
  }

  export type SignalsAvgAggregateOutputType = {
    confidence: number | null
    severityScore: number | null
    featuresQualityScore: number | null
  }

  export type SignalsSumAggregateOutputType = {
    confidence: number | null
    severityScore: number | null
    featuresQualityScore: number | null
  }

  export type SignalsMinAggregateOutputType = {
    id: string | null
    inputId: string | null
    timestamp: Date | null
    receivedAt: Date | null
    schemaVersion: string | null
    confidence: number | null
    sourceType: string | null
    sourceId: string | null
    systemName: string | null
    title: string | null
    description: string | null
    severity: $Enums.Severity | null
    severityScore: number | null
    departmentId: string | null
    teamId: string | null
    categoryId: string | null
    privacyLevel: string | null
    dedupeKey: string | null
    embedding: Uint8Array | null
    aiProcessed: boolean | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastTaggedAt: Date | null
    tagModelVersion: string | null
    featuresQualityScore: number | null
    featuresVersion: string | null
    lastFeaturesGeneratedAt: Date | null
  }

  export type SignalsMaxAggregateOutputType = {
    id: string | null
    inputId: string | null
    timestamp: Date | null
    receivedAt: Date | null
    schemaVersion: string | null
    confidence: number | null
    sourceType: string | null
    sourceId: string | null
    systemName: string | null
    title: string | null
    description: string | null
    severity: $Enums.Severity | null
    severityScore: number | null
    departmentId: string | null
    teamId: string | null
    categoryId: string | null
    privacyLevel: string | null
    dedupeKey: string | null
    embedding: Uint8Array | null
    aiProcessed: boolean | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastTaggedAt: Date | null
    tagModelVersion: string | null
    featuresQualityScore: number | null
    featuresVersion: string | null
    lastFeaturesGeneratedAt: Date | null
  }

  export type SignalsCountAggregateOutputType = {
    id: number
    inputId: number
    timestamp: number
    receivedAt: number
    schemaVersion: number
    sourceJson: number
    confidence: number
    attachmentsJson: number
    sourceType: number
    sourceId: number
    systemName: number
    title: number
    description: number
    severity: number
    severityScore: number
    departmentId: number
    teamId: number
    categoryId: number
    metricsJson: number
    baselineJson: number
    impactJson: number
    tagsJson: number
    entitiesJson: number
    privacyLevel: number
    dedupeKey: number
    embedding: number
    aiProcessed: number
    aiTagsJson: number
    lineageJson: number
    createdById: number
    createdAt: number
    updatedAt: number
    domainClassification: number
    enhancedTagsJson: number
    lastTaggedAt: number
    tagGenerationMeta: number
    tagModelVersion: number
    clusteringFeaturesJson: number
    featuresQualityScore: number
    featuresVersion: number
    lastFeaturesGeneratedAt: number
    _all: number
  }


  export type SignalsAvgAggregateInputType = {
    confidence?: true
    severityScore?: true
    featuresQualityScore?: true
  }

  export type SignalsSumAggregateInputType = {
    confidence?: true
    severityScore?: true
    featuresQualityScore?: true
  }

  export type SignalsMinAggregateInputType = {
    id?: true
    inputId?: true
    timestamp?: true
    receivedAt?: true
    schemaVersion?: true
    confidence?: true
    sourceType?: true
    sourceId?: true
    systemName?: true
    title?: true
    description?: true
    severity?: true
    severityScore?: true
    departmentId?: true
    teamId?: true
    categoryId?: true
    privacyLevel?: true
    dedupeKey?: true
    embedding?: true
    aiProcessed?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    lastTaggedAt?: true
    tagModelVersion?: true
    featuresQualityScore?: true
    featuresVersion?: true
    lastFeaturesGeneratedAt?: true
  }

  export type SignalsMaxAggregateInputType = {
    id?: true
    inputId?: true
    timestamp?: true
    receivedAt?: true
    schemaVersion?: true
    confidence?: true
    sourceType?: true
    sourceId?: true
    systemName?: true
    title?: true
    description?: true
    severity?: true
    severityScore?: true
    departmentId?: true
    teamId?: true
    categoryId?: true
    privacyLevel?: true
    dedupeKey?: true
    embedding?: true
    aiProcessed?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    lastTaggedAt?: true
    tagModelVersion?: true
    featuresQualityScore?: true
    featuresVersion?: true
    lastFeaturesGeneratedAt?: true
  }

  export type SignalsCountAggregateInputType = {
    id?: true
    inputId?: true
    timestamp?: true
    receivedAt?: true
    schemaVersion?: true
    sourceJson?: true
    confidence?: true
    attachmentsJson?: true
    sourceType?: true
    sourceId?: true
    systemName?: true
    title?: true
    description?: true
    severity?: true
    severityScore?: true
    departmentId?: true
    teamId?: true
    categoryId?: true
    metricsJson?: true
    baselineJson?: true
    impactJson?: true
    tagsJson?: true
    entitiesJson?: true
    privacyLevel?: true
    dedupeKey?: true
    embedding?: true
    aiProcessed?: true
    aiTagsJson?: true
    lineageJson?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    domainClassification?: true
    enhancedTagsJson?: true
    lastTaggedAt?: true
    tagGenerationMeta?: true
    tagModelVersion?: true
    clusteringFeaturesJson?: true
    featuresQualityScore?: true
    featuresVersion?: true
    lastFeaturesGeneratedAt?: true
    _all?: true
  }

  export type SignalsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which signals to aggregate.
     */
    where?: signalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of signals to fetch.
     */
    orderBy?: signalsOrderByWithRelationInput | signalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: signalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` signals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned signals
    **/
    _count?: true | SignalsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SignalsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SignalsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SignalsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SignalsMaxAggregateInputType
  }

  export type GetSignalsAggregateType<T extends SignalsAggregateArgs> = {
        [P in keyof T & keyof AggregateSignals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSignals[P]>
      : GetScalarType<T[P], AggregateSignals[P]>
  }




  export type signalsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: signalsWhereInput
    orderBy?: signalsOrderByWithAggregationInput | signalsOrderByWithAggregationInput[]
    by: SignalsScalarFieldEnum[] | SignalsScalarFieldEnum
    having?: signalsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SignalsCountAggregateInputType | true
    _avg?: SignalsAvgAggregateInputType
    _sum?: SignalsSumAggregateInputType
    _min?: SignalsMinAggregateInputType
    _max?: SignalsMaxAggregateInputType
  }

  export type SignalsGroupByOutputType = {
    id: string
    inputId: string
    timestamp: Date
    receivedAt: Date
    schemaVersion: string
    sourceJson: JsonValue | null
    confidence: number | null
    attachmentsJson: JsonValue | null
    sourceType: string
    sourceId: string | null
    systemName: string | null
    title: string | null
    description: string
    severity: $Enums.Severity
    severityScore: number
    departmentId: string | null
    teamId: string | null
    categoryId: string | null
    metricsJson: JsonValue | null
    baselineJson: JsonValue | null
    impactJson: JsonValue | null
    tagsJson: JsonValue | null
    entitiesJson: JsonValue | null
    privacyLevel: string | null
    dedupeKey: string | null
    embedding: Uint8Array | null
    aiProcessed: boolean
    aiTagsJson: JsonValue | null
    lineageJson: JsonValue | null
    createdById: string | null
    createdAt: Date
    updatedAt: Date
    domainClassification: JsonValue | null
    enhancedTagsJson: JsonValue | null
    lastTaggedAt: Date | null
    tagGenerationMeta: JsonValue | null
    tagModelVersion: string | null
    clusteringFeaturesJson: JsonValue | null
    featuresQualityScore: number | null
    featuresVersion: string | null
    lastFeaturesGeneratedAt: Date | null
    _count: SignalsCountAggregateOutputType | null
    _avg: SignalsAvgAggregateOutputType | null
    _sum: SignalsSumAggregateOutputType | null
    _min: SignalsMinAggregateOutputType | null
    _max: SignalsMaxAggregateOutputType | null
  }

  type GetSignalsGroupByPayload<T extends signalsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SignalsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SignalsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SignalsGroupByOutputType[P]>
            : GetScalarType<T[P], SignalsGroupByOutputType[P]>
        }
      >
    >


  export type signalsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inputId?: boolean
    timestamp?: boolean
    receivedAt?: boolean
    schemaVersion?: boolean
    sourceJson?: boolean
    confidence?: boolean
    attachmentsJson?: boolean
    sourceType?: boolean
    sourceId?: boolean
    systemName?: boolean
    title?: boolean
    description?: boolean
    severity?: boolean
    severityScore?: boolean
    departmentId?: boolean
    teamId?: boolean
    categoryId?: boolean
    metricsJson?: boolean
    baselineJson?: boolean
    impactJson?: boolean
    tagsJson?: boolean
    entitiesJson?: boolean
    privacyLevel?: boolean
    dedupeKey?: boolean
    embedding?: boolean
    aiProcessed?: boolean
    aiTagsJson?: boolean
    lineageJson?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domainClassification?: boolean
    enhancedTagsJson?: boolean
    lastTaggedAt?: boolean
    tagGenerationMeta?: boolean
    tagModelVersion?: boolean
    clusteringFeaturesJson?: boolean
    featuresQualityScore?: boolean
    featuresVersion?: boolean
    lastFeaturesGeneratedAt?: boolean
    ai_insight_overrides?: boolean | signals$ai_insight_overridesArgs<ExtArgs>
    hotspot_signals?: boolean | signals$hotspot_signalsArgs<ExtArgs>
    categories?: boolean | signals$categoriesArgs<ExtArgs>
    users?: boolean | signals$usersArgs<ExtArgs>
    departments?: boolean | signals$departmentsArgs<ExtArgs>
    teams?: boolean | signals$teamsArgs<ExtArgs>
    _count?: boolean | SignalsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["signals"]>

  export type signalsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inputId?: boolean
    timestamp?: boolean
    receivedAt?: boolean
    schemaVersion?: boolean
    sourceJson?: boolean
    confidence?: boolean
    attachmentsJson?: boolean
    sourceType?: boolean
    sourceId?: boolean
    systemName?: boolean
    title?: boolean
    description?: boolean
    severity?: boolean
    severityScore?: boolean
    departmentId?: boolean
    teamId?: boolean
    categoryId?: boolean
    metricsJson?: boolean
    baselineJson?: boolean
    impactJson?: boolean
    tagsJson?: boolean
    entitiesJson?: boolean
    privacyLevel?: boolean
    dedupeKey?: boolean
    embedding?: boolean
    aiProcessed?: boolean
    aiTagsJson?: boolean
    lineageJson?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domainClassification?: boolean
    enhancedTagsJson?: boolean
    lastTaggedAt?: boolean
    tagGenerationMeta?: boolean
    tagModelVersion?: boolean
    clusteringFeaturesJson?: boolean
    featuresQualityScore?: boolean
    featuresVersion?: boolean
    lastFeaturesGeneratedAt?: boolean
    categories?: boolean | signals$categoriesArgs<ExtArgs>
    users?: boolean | signals$usersArgs<ExtArgs>
    departments?: boolean | signals$departmentsArgs<ExtArgs>
    teams?: boolean | signals$teamsArgs<ExtArgs>
  }, ExtArgs["result"]["signals"]>

  export type signalsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inputId?: boolean
    timestamp?: boolean
    receivedAt?: boolean
    schemaVersion?: boolean
    sourceJson?: boolean
    confidence?: boolean
    attachmentsJson?: boolean
    sourceType?: boolean
    sourceId?: boolean
    systemName?: boolean
    title?: boolean
    description?: boolean
    severity?: boolean
    severityScore?: boolean
    departmentId?: boolean
    teamId?: boolean
    categoryId?: boolean
    metricsJson?: boolean
    baselineJson?: boolean
    impactJson?: boolean
    tagsJson?: boolean
    entitiesJson?: boolean
    privacyLevel?: boolean
    dedupeKey?: boolean
    embedding?: boolean
    aiProcessed?: boolean
    aiTagsJson?: boolean
    lineageJson?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domainClassification?: boolean
    enhancedTagsJson?: boolean
    lastTaggedAt?: boolean
    tagGenerationMeta?: boolean
    tagModelVersion?: boolean
    clusteringFeaturesJson?: boolean
    featuresQualityScore?: boolean
    featuresVersion?: boolean
    lastFeaturesGeneratedAt?: boolean
    categories?: boolean | signals$categoriesArgs<ExtArgs>
    users?: boolean | signals$usersArgs<ExtArgs>
    departments?: boolean | signals$departmentsArgs<ExtArgs>
    teams?: boolean | signals$teamsArgs<ExtArgs>
  }, ExtArgs["result"]["signals"]>

  export type signalsSelectScalar = {
    id?: boolean
    inputId?: boolean
    timestamp?: boolean
    receivedAt?: boolean
    schemaVersion?: boolean
    sourceJson?: boolean
    confidence?: boolean
    attachmentsJson?: boolean
    sourceType?: boolean
    sourceId?: boolean
    systemName?: boolean
    title?: boolean
    description?: boolean
    severity?: boolean
    severityScore?: boolean
    departmentId?: boolean
    teamId?: boolean
    categoryId?: boolean
    metricsJson?: boolean
    baselineJson?: boolean
    impactJson?: boolean
    tagsJson?: boolean
    entitiesJson?: boolean
    privacyLevel?: boolean
    dedupeKey?: boolean
    embedding?: boolean
    aiProcessed?: boolean
    aiTagsJson?: boolean
    lineageJson?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domainClassification?: boolean
    enhancedTagsJson?: boolean
    lastTaggedAt?: boolean
    tagGenerationMeta?: boolean
    tagModelVersion?: boolean
    clusteringFeaturesJson?: boolean
    featuresQualityScore?: boolean
    featuresVersion?: boolean
    lastFeaturesGeneratedAt?: boolean
  }

  export type signalsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inputId" | "timestamp" | "receivedAt" | "schemaVersion" | "sourceJson" | "confidence" | "attachmentsJson" | "sourceType" | "sourceId" | "systemName" | "title" | "description" | "severity" | "severityScore" | "departmentId" | "teamId" | "categoryId" | "metricsJson" | "baselineJson" | "impactJson" | "tagsJson" | "entitiesJson" | "privacyLevel" | "dedupeKey" | "embedding" | "aiProcessed" | "aiTagsJson" | "lineageJson" | "createdById" | "createdAt" | "updatedAt" | "domainClassification" | "enhancedTagsJson" | "lastTaggedAt" | "tagGenerationMeta" | "tagModelVersion" | "clusteringFeaturesJson" | "featuresQualityScore" | "featuresVersion" | "lastFeaturesGeneratedAt", ExtArgs["result"]["signals"]>
  export type signalsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ai_insight_overrides?: boolean | signals$ai_insight_overridesArgs<ExtArgs>
    hotspot_signals?: boolean | signals$hotspot_signalsArgs<ExtArgs>
    categories?: boolean | signals$categoriesArgs<ExtArgs>
    users?: boolean | signals$usersArgs<ExtArgs>
    departments?: boolean | signals$departmentsArgs<ExtArgs>
    teams?: boolean | signals$teamsArgs<ExtArgs>
    _count?: boolean | SignalsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type signalsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | signals$categoriesArgs<ExtArgs>
    users?: boolean | signals$usersArgs<ExtArgs>
    departments?: boolean | signals$departmentsArgs<ExtArgs>
    teams?: boolean | signals$teamsArgs<ExtArgs>
  }
  export type signalsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | signals$categoriesArgs<ExtArgs>
    users?: boolean | signals$usersArgs<ExtArgs>
    departments?: boolean | signals$departmentsArgs<ExtArgs>
    teams?: boolean | signals$teamsArgs<ExtArgs>
  }

  export type $signalsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "signals"
    objects: {
      ai_insight_overrides: Prisma.$ai_insight_overridesPayload<ExtArgs>[]
      hotspot_signals: Prisma.$hotspot_signalsPayload<ExtArgs>[]
      categories: Prisma.$categoriesPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs> | null
      departments: Prisma.$departmentsPayload<ExtArgs> | null
      teams: Prisma.$teamsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inputId: string
      timestamp: Date
      receivedAt: Date
      schemaVersion: string
      sourceJson: Prisma.JsonValue | null
      confidence: number | null
      attachmentsJson: Prisma.JsonValue | null
      sourceType: string
      sourceId: string | null
      systemName: string | null
      title: string | null
      description: string
      severity: $Enums.Severity
      severityScore: number
      departmentId: string | null
      teamId: string | null
      categoryId: string | null
      metricsJson: Prisma.JsonValue | null
      baselineJson: Prisma.JsonValue | null
      impactJson: Prisma.JsonValue | null
      tagsJson: Prisma.JsonValue | null
      entitiesJson: Prisma.JsonValue | null
      privacyLevel: string | null
      dedupeKey: string | null
      embedding: Uint8Array | null
      aiProcessed: boolean
      aiTagsJson: Prisma.JsonValue | null
      lineageJson: Prisma.JsonValue | null
      createdById: string | null
      createdAt: Date
      updatedAt: Date
      domainClassification: Prisma.JsonValue | null
      enhancedTagsJson: Prisma.JsonValue | null
      lastTaggedAt: Date | null
      tagGenerationMeta: Prisma.JsonValue | null
      tagModelVersion: string | null
      clusteringFeaturesJson: Prisma.JsonValue | null
      featuresQualityScore: number | null
      featuresVersion: string | null
      lastFeaturesGeneratedAt: Date | null
    }, ExtArgs["result"]["signals"]>
    composites: {}
  }

  type signalsGetPayload<S extends boolean | null | undefined | signalsDefaultArgs> = $Result.GetResult<Prisma.$signalsPayload, S>

  type signalsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<signalsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SignalsCountAggregateInputType | true
    }

  export interface signalsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['signals'], meta: { name: 'signals' } }
    /**
     * Find zero or one Signals that matches the filter.
     * @param {signalsFindUniqueArgs} args - Arguments to find a Signals
     * @example
     * // Get one Signals
     * const signals = await prisma.signals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends signalsFindUniqueArgs>(args: SelectSubset<T, signalsFindUniqueArgs<ExtArgs>>): Prisma__signalsClient<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Signals that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {signalsFindUniqueOrThrowArgs} args - Arguments to find a Signals
     * @example
     * // Get one Signals
     * const signals = await prisma.signals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends signalsFindUniqueOrThrowArgs>(args: SelectSubset<T, signalsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__signalsClient<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Signals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {signalsFindFirstArgs} args - Arguments to find a Signals
     * @example
     * // Get one Signals
     * const signals = await prisma.signals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends signalsFindFirstArgs>(args?: SelectSubset<T, signalsFindFirstArgs<ExtArgs>>): Prisma__signalsClient<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Signals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {signalsFindFirstOrThrowArgs} args - Arguments to find a Signals
     * @example
     * // Get one Signals
     * const signals = await prisma.signals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends signalsFindFirstOrThrowArgs>(args?: SelectSubset<T, signalsFindFirstOrThrowArgs<ExtArgs>>): Prisma__signalsClient<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Signals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {signalsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Signals
     * const signals = await prisma.signals.findMany()
     * 
     * // Get first 10 Signals
     * const signals = await prisma.signals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const signalsWithIdOnly = await prisma.signals.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends signalsFindManyArgs>(args?: SelectSubset<T, signalsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Signals.
     * @param {signalsCreateArgs} args - Arguments to create a Signals.
     * @example
     * // Create one Signals
     * const Signals = await prisma.signals.create({
     *   data: {
     *     // ... data to create a Signals
     *   }
     * })
     * 
     */
    create<T extends signalsCreateArgs>(args: SelectSubset<T, signalsCreateArgs<ExtArgs>>): Prisma__signalsClient<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Signals.
     * @param {signalsCreateManyArgs} args - Arguments to create many Signals.
     * @example
     * // Create many Signals
     * const signals = await prisma.signals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends signalsCreateManyArgs>(args?: SelectSubset<T, signalsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Signals and returns the data saved in the database.
     * @param {signalsCreateManyAndReturnArgs} args - Arguments to create many Signals.
     * @example
     * // Create many Signals
     * const signals = await prisma.signals.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Signals and only return the `id`
     * const signalsWithIdOnly = await prisma.signals.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends signalsCreateManyAndReturnArgs>(args?: SelectSubset<T, signalsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Signals.
     * @param {signalsDeleteArgs} args - Arguments to delete one Signals.
     * @example
     * // Delete one Signals
     * const Signals = await prisma.signals.delete({
     *   where: {
     *     // ... filter to delete one Signals
     *   }
     * })
     * 
     */
    delete<T extends signalsDeleteArgs>(args: SelectSubset<T, signalsDeleteArgs<ExtArgs>>): Prisma__signalsClient<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Signals.
     * @param {signalsUpdateArgs} args - Arguments to update one Signals.
     * @example
     * // Update one Signals
     * const signals = await prisma.signals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends signalsUpdateArgs>(args: SelectSubset<T, signalsUpdateArgs<ExtArgs>>): Prisma__signalsClient<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Signals.
     * @param {signalsDeleteManyArgs} args - Arguments to filter Signals to delete.
     * @example
     * // Delete a few Signals
     * const { count } = await prisma.signals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends signalsDeleteManyArgs>(args?: SelectSubset<T, signalsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Signals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {signalsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Signals
     * const signals = await prisma.signals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends signalsUpdateManyArgs>(args: SelectSubset<T, signalsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Signals and returns the data updated in the database.
     * @param {signalsUpdateManyAndReturnArgs} args - Arguments to update many Signals.
     * @example
     * // Update many Signals
     * const signals = await prisma.signals.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Signals and only return the `id`
     * const signalsWithIdOnly = await prisma.signals.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends signalsUpdateManyAndReturnArgs>(args: SelectSubset<T, signalsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Signals.
     * @param {signalsUpsertArgs} args - Arguments to update or create a Signals.
     * @example
     * // Update or create a Signals
     * const signals = await prisma.signals.upsert({
     *   create: {
     *     // ... data to create a Signals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Signals we want to update
     *   }
     * })
     */
    upsert<T extends signalsUpsertArgs>(args: SelectSubset<T, signalsUpsertArgs<ExtArgs>>): Prisma__signalsClient<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Signals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {signalsCountArgs} args - Arguments to filter Signals to count.
     * @example
     * // Count the number of Signals
     * const count = await prisma.signals.count({
     *   where: {
     *     // ... the filter for the Signals we want to count
     *   }
     * })
    **/
    count<T extends signalsCountArgs>(
      args?: Subset<T, signalsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SignalsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Signals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SignalsAggregateArgs>(args: Subset<T, SignalsAggregateArgs>): Prisma.PrismaPromise<GetSignalsAggregateType<T>>

    /**
     * Group by Signals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {signalsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends signalsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: signalsGroupByArgs['orderBy'] }
        : { orderBy?: signalsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, signalsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSignalsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the signals model
   */
  readonly fields: signalsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for signals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__signalsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ai_insight_overrides<T extends signals$ai_insight_overridesArgs<ExtArgs> = {}>(args?: Subset<T, signals$ai_insight_overridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_insight_overridesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hotspot_signals<T extends signals$hotspot_signalsArgs<ExtArgs> = {}>(args?: Subset<T, signals$hotspot_signalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hotspot_signalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends signals$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, signals$categoriesArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends signals$usersArgs<ExtArgs> = {}>(args?: Subset<T, signals$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    departments<T extends signals$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, signals$departmentsArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teams<T extends signals$teamsArgs<ExtArgs> = {}>(args?: Subset<T, signals$teamsArgs<ExtArgs>>): Prisma__teamsClient<$Result.GetResult<Prisma.$teamsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the signals model
   */
  interface signalsFieldRefs {
    readonly id: FieldRef<"signals", 'String'>
    readonly inputId: FieldRef<"signals", 'String'>
    readonly timestamp: FieldRef<"signals", 'DateTime'>
    readonly receivedAt: FieldRef<"signals", 'DateTime'>
    readonly schemaVersion: FieldRef<"signals", 'String'>
    readonly sourceJson: FieldRef<"signals", 'Json'>
    readonly confidence: FieldRef<"signals", 'Float'>
    readonly attachmentsJson: FieldRef<"signals", 'Json'>
    readonly sourceType: FieldRef<"signals", 'String'>
    readonly sourceId: FieldRef<"signals", 'String'>
    readonly systemName: FieldRef<"signals", 'String'>
    readonly title: FieldRef<"signals", 'String'>
    readonly description: FieldRef<"signals", 'String'>
    readonly severity: FieldRef<"signals", 'Severity'>
    readonly severityScore: FieldRef<"signals", 'Int'>
    readonly departmentId: FieldRef<"signals", 'String'>
    readonly teamId: FieldRef<"signals", 'String'>
    readonly categoryId: FieldRef<"signals", 'String'>
    readonly metricsJson: FieldRef<"signals", 'Json'>
    readonly baselineJson: FieldRef<"signals", 'Json'>
    readonly impactJson: FieldRef<"signals", 'Json'>
    readonly tagsJson: FieldRef<"signals", 'Json'>
    readonly entitiesJson: FieldRef<"signals", 'Json'>
    readonly privacyLevel: FieldRef<"signals", 'String'>
    readonly dedupeKey: FieldRef<"signals", 'String'>
    readonly embedding: FieldRef<"signals", 'Bytes'>
    readonly aiProcessed: FieldRef<"signals", 'Boolean'>
    readonly aiTagsJson: FieldRef<"signals", 'Json'>
    readonly lineageJson: FieldRef<"signals", 'Json'>
    readonly createdById: FieldRef<"signals", 'String'>
    readonly createdAt: FieldRef<"signals", 'DateTime'>
    readonly updatedAt: FieldRef<"signals", 'DateTime'>
    readonly domainClassification: FieldRef<"signals", 'Json'>
    readonly enhancedTagsJson: FieldRef<"signals", 'Json'>
    readonly lastTaggedAt: FieldRef<"signals", 'DateTime'>
    readonly tagGenerationMeta: FieldRef<"signals", 'Json'>
    readonly tagModelVersion: FieldRef<"signals", 'String'>
    readonly clusteringFeaturesJson: FieldRef<"signals", 'Json'>
    readonly featuresQualityScore: FieldRef<"signals", 'Float'>
    readonly featuresVersion: FieldRef<"signals", 'String'>
    readonly lastFeaturesGeneratedAt: FieldRef<"signals", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * signals findUnique
   */
  export type signalsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: signalsInclude<ExtArgs> | null
    /**
     * Filter, which signals to fetch.
     */
    where: signalsWhereUniqueInput
  }

  /**
   * signals findUniqueOrThrow
   */
  export type signalsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: signalsInclude<ExtArgs> | null
    /**
     * Filter, which signals to fetch.
     */
    where: signalsWhereUniqueInput
  }

  /**
   * signals findFirst
   */
  export type signalsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: signalsInclude<ExtArgs> | null
    /**
     * Filter, which signals to fetch.
     */
    where?: signalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of signals to fetch.
     */
    orderBy?: signalsOrderByWithRelationInput | signalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for signals.
     */
    cursor?: signalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` signals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of signals.
     */
    distinct?: SignalsScalarFieldEnum | SignalsScalarFieldEnum[]
  }

  /**
   * signals findFirstOrThrow
   */
  export type signalsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: signalsInclude<ExtArgs> | null
    /**
     * Filter, which signals to fetch.
     */
    where?: signalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of signals to fetch.
     */
    orderBy?: signalsOrderByWithRelationInput | signalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for signals.
     */
    cursor?: signalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` signals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of signals.
     */
    distinct?: SignalsScalarFieldEnum | SignalsScalarFieldEnum[]
  }

  /**
   * signals findMany
   */
  export type signalsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: signalsInclude<ExtArgs> | null
    /**
     * Filter, which signals to fetch.
     */
    where?: signalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of signals to fetch.
     */
    orderBy?: signalsOrderByWithRelationInput | signalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing signals.
     */
    cursor?: signalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` signals.
     */
    skip?: number
    distinct?: SignalsScalarFieldEnum | SignalsScalarFieldEnum[]
  }

  /**
   * signals create
   */
  export type signalsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: signalsInclude<ExtArgs> | null
    /**
     * The data needed to create a signals.
     */
    data: XOR<signalsCreateInput, signalsUncheckedCreateInput>
  }

  /**
   * signals createMany
   */
  export type signalsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many signals.
     */
    data: signalsCreateManyInput | signalsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * signals createManyAndReturn
   */
  export type signalsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * The data used to create many signals.
     */
    data: signalsCreateManyInput | signalsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: signalsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * signals update
   */
  export type signalsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: signalsInclude<ExtArgs> | null
    /**
     * The data needed to update a signals.
     */
    data: XOR<signalsUpdateInput, signalsUncheckedUpdateInput>
    /**
     * Choose, which signals to update.
     */
    where: signalsWhereUniqueInput
  }

  /**
   * signals updateMany
   */
  export type signalsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update signals.
     */
    data: XOR<signalsUpdateManyMutationInput, signalsUncheckedUpdateManyInput>
    /**
     * Filter which signals to update
     */
    where?: signalsWhereInput
    /**
     * Limit how many signals to update.
     */
    limit?: number
  }

  /**
   * signals updateManyAndReturn
   */
  export type signalsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * The data used to update signals.
     */
    data: XOR<signalsUpdateManyMutationInput, signalsUncheckedUpdateManyInput>
    /**
     * Filter which signals to update
     */
    where?: signalsWhereInput
    /**
     * Limit how many signals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: signalsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * signals upsert
   */
  export type signalsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: signalsInclude<ExtArgs> | null
    /**
     * The filter to search for the signals to update in case it exists.
     */
    where: signalsWhereUniqueInput
    /**
     * In case the signals found by the `where` argument doesn't exist, create a new signals with this data.
     */
    create: XOR<signalsCreateInput, signalsUncheckedCreateInput>
    /**
     * In case the signals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<signalsUpdateInput, signalsUncheckedUpdateInput>
  }

  /**
   * signals delete
   */
  export type signalsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: signalsInclude<ExtArgs> | null
    /**
     * Filter which signals to delete.
     */
    where: signalsWhereUniqueInput
  }

  /**
   * signals deleteMany
   */
  export type signalsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which signals to delete
     */
    where?: signalsWhereInput
    /**
     * Limit how many signals to delete.
     */
    limit?: number
  }

  /**
   * signals.ai_insight_overrides
   */
  export type signals$ai_insight_overridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insight_overrides
     */
    select?: ai_insight_overridesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insight_overrides
     */
    omit?: ai_insight_overridesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insight_overridesInclude<ExtArgs> | null
    where?: ai_insight_overridesWhereInput
    orderBy?: ai_insight_overridesOrderByWithRelationInput | ai_insight_overridesOrderByWithRelationInput[]
    cursor?: ai_insight_overridesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ai_insight_overridesScalarFieldEnum | Ai_insight_overridesScalarFieldEnum[]
  }

  /**
   * signals.hotspot_signals
   */
  export type signals$hotspot_signalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspot_signals
     */
    select?: hotspot_signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspot_signals
     */
    omit?: hotspot_signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspot_signalsInclude<ExtArgs> | null
    where?: hotspot_signalsWhereInput
    orderBy?: hotspot_signalsOrderByWithRelationInput | hotspot_signalsOrderByWithRelationInput[]
    cursor?: hotspot_signalsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Hotspot_signalsScalarFieldEnum | Hotspot_signalsScalarFieldEnum[]
  }

  /**
   * signals.categories
   */
  export type signals$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    where?: categoriesWhereInput
  }

  /**
   * signals.users
   */
  export type signals$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * signals.departments
   */
  export type signals$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    where?: departmentsWhereInput
  }

  /**
   * signals.teams
   */
  export type signals$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teams
     */
    select?: teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teams
     */
    omit?: teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamsInclude<ExtArgs> | null
    where?: teamsWhereInput
  }

  /**
   * signals without action
   */
  export type signalsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: signalsInclude<ExtArgs> | null
  }


  /**
   * Model solutions
   */

  export type AggregateSolutions = {
    _count: SolutionsCountAggregateOutputType | null
    _avg: SolutionsAvgAggregateOutputType | null
    _sum: SolutionsSumAggregateOutputType | null
    _min: SolutionsMinAggregateOutputType | null
    _max: SolutionsMaxAggregateOutputType | null
  }

  export type SolutionsAvgAggregateOutputType = {
    progress: number | null
  }

  export type SolutionsSumAggregateOutputType = {
    progress: number | null
  }

  export type SolutionsMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.SolutionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    estimatedEffort: string | null
    actualCompletionDate: Date | null
    businessValue: string | null
    createdBy: string | null
    hotspotId: string | null
    ideaId: string | null
    initiativeId: string | null
    inputId: string | null
    progress: number | null
    targetDate: Date | null
  }

  export type SolutionsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.SolutionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    estimatedEffort: string | null
    actualCompletionDate: Date | null
    businessValue: string | null
    createdBy: string | null
    hotspotId: string | null
    ideaId: string | null
    initiativeId: string | null
    inputId: string | null
    progress: number | null
    targetDate: Date | null
  }

  export type SolutionsCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    estimatedEffort: number
    actualCompletionDate: number
    actualImpactJson: number
    businessValue: number
    createdBy: number
    expectedImpactJson: number
    hotspotId: number
    ideaId: number
    initiativeId: number
    inputId: number
    progress: number
    successMetrics: number
    targetDate: number
    tasks: number
    _all: number
  }


  export type SolutionsAvgAggregateInputType = {
    progress?: true
  }

  export type SolutionsSumAggregateInputType = {
    progress?: true
  }

  export type SolutionsMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    estimatedEffort?: true
    actualCompletionDate?: true
    businessValue?: true
    createdBy?: true
    hotspotId?: true
    ideaId?: true
    initiativeId?: true
    inputId?: true
    progress?: true
    targetDate?: true
  }

  export type SolutionsMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    estimatedEffort?: true
    actualCompletionDate?: true
    businessValue?: true
    createdBy?: true
    hotspotId?: true
    ideaId?: true
    initiativeId?: true
    inputId?: true
    progress?: true
    targetDate?: true
  }

  export type SolutionsCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    estimatedEffort?: true
    actualCompletionDate?: true
    actualImpactJson?: true
    businessValue?: true
    createdBy?: true
    expectedImpactJson?: true
    hotspotId?: true
    ideaId?: true
    initiativeId?: true
    inputId?: true
    progress?: true
    successMetrics?: true
    targetDate?: true
    tasks?: true
    _all?: true
  }

  export type SolutionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which solutions to aggregate.
     */
    where?: solutionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of solutions to fetch.
     */
    orderBy?: solutionsOrderByWithRelationInput | solutionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: solutionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` solutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` solutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned solutions
    **/
    _count?: true | SolutionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SolutionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SolutionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SolutionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SolutionsMaxAggregateInputType
  }

  export type GetSolutionsAggregateType<T extends SolutionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSolutions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSolutions[P]>
      : GetScalarType<T[P], AggregateSolutions[P]>
  }




  export type solutionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: solutionsWhereInput
    orderBy?: solutionsOrderByWithAggregationInput | solutionsOrderByWithAggregationInput[]
    by: SolutionsScalarFieldEnum[] | SolutionsScalarFieldEnum
    having?: solutionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SolutionsCountAggregateInputType | true
    _avg?: SolutionsAvgAggregateInputType
    _sum?: SolutionsSumAggregateInputType
    _min?: SolutionsMinAggregateInputType
    _max?: SolutionsMaxAggregateInputType
  }

  export type SolutionsGroupByOutputType = {
    id: string
    title: string
    description: string
    status: $Enums.SolutionStatus
    createdAt: Date
    updatedAt: Date
    estimatedEffort: string | null
    actualCompletionDate: Date | null
    actualImpactJson: JsonValue | null
    businessValue: string | null
    createdBy: string
    expectedImpactJson: JsonValue | null
    hotspotId: string | null
    ideaId: string | null
    initiativeId: string | null
    inputId: string | null
    progress: number
    successMetrics: JsonValue | null
    targetDate: Date | null
    tasks: JsonValue | null
    _count: SolutionsCountAggregateOutputType | null
    _avg: SolutionsAvgAggregateOutputType | null
    _sum: SolutionsSumAggregateOutputType | null
    _min: SolutionsMinAggregateOutputType | null
    _max: SolutionsMaxAggregateOutputType | null
  }

  type GetSolutionsGroupByPayload<T extends solutionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SolutionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SolutionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SolutionsGroupByOutputType[P]>
            : GetScalarType<T[P], SolutionsGroupByOutputType[P]>
        }
      >
    >


  export type solutionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estimatedEffort?: boolean
    actualCompletionDate?: boolean
    actualImpactJson?: boolean
    businessValue?: boolean
    createdBy?: boolean
    expectedImpactJson?: boolean
    hotspotId?: boolean
    ideaId?: boolean
    initiativeId?: boolean
    inputId?: boolean
    progress?: boolean
    successMetrics?: boolean
    targetDate?: boolean
    tasks?: boolean
    frd_documents?: boolean | solutions$frd_documentsArgs<ExtArgs>
    requirements?: boolean | solutions$requirementsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    hotspots?: boolean | solutions$hotspotsArgs<ExtArgs>
    ideas?: boolean | solutions$ideasArgs<ExtArgs>
    initiatives?: boolean | solutions$initiativesArgs<ExtArgs>
    inputs?: boolean | solutions$inputsArgs<ExtArgs>
    _count?: boolean | SolutionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["solutions"]>

  export type solutionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estimatedEffort?: boolean
    actualCompletionDate?: boolean
    actualImpactJson?: boolean
    businessValue?: boolean
    createdBy?: boolean
    expectedImpactJson?: boolean
    hotspotId?: boolean
    ideaId?: boolean
    initiativeId?: boolean
    inputId?: boolean
    progress?: boolean
    successMetrics?: boolean
    targetDate?: boolean
    tasks?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    hotspots?: boolean | solutions$hotspotsArgs<ExtArgs>
    ideas?: boolean | solutions$ideasArgs<ExtArgs>
    initiatives?: boolean | solutions$initiativesArgs<ExtArgs>
    inputs?: boolean | solutions$inputsArgs<ExtArgs>
  }, ExtArgs["result"]["solutions"]>

  export type solutionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estimatedEffort?: boolean
    actualCompletionDate?: boolean
    actualImpactJson?: boolean
    businessValue?: boolean
    createdBy?: boolean
    expectedImpactJson?: boolean
    hotspotId?: boolean
    ideaId?: boolean
    initiativeId?: boolean
    inputId?: boolean
    progress?: boolean
    successMetrics?: boolean
    targetDate?: boolean
    tasks?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    hotspots?: boolean | solutions$hotspotsArgs<ExtArgs>
    ideas?: boolean | solutions$ideasArgs<ExtArgs>
    initiatives?: boolean | solutions$initiativesArgs<ExtArgs>
    inputs?: boolean | solutions$inputsArgs<ExtArgs>
  }, ExtArgs["result"]["solutions"]>

  export type solutionsSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    estimatedEffort?: boolean
    actualCompletionDate?: boolean
    actualImpactJson?: boolean
    businessValue?: boolean
    createdBy?: boolean
    expectedImpactJson?: boolean
    hotspotId?: boolean
    ideaId?: boolean
    initiativeId?: boolean
    inputId?: boolean
    progress?: boolean
    successMetrics?: boolean
    targetDate?: boolean
    tasks?: boolean
  }

  export type solutionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "status" | "createdAt" | "updatedAt" | "estimatedEffort" | "actualCompletionDate" | "actualImpactJson" | "businessValue" | "createdBy" | "expectedImpactJson" | "hotspotId" | "ideaId" | "initiativeId" | "inputId" | "progress" | "successMetrics" | "targetDate" | "tasks", ExtArgs["result"]["solutions"]>
  export type solutionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    frd_documents?: boolean | solutions$frd_documentsArgs<ExtArgs>
    requirements?: boolean | solutions$requirementsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    hotspots?: boolean | solutions$hotspotsArgs<ExtArgs>
    ideas?: boolean | solutions$ideasArgs<ExtArgs>
    initiatives?: boolean | solutions$initiativesArgs<ExtArgs>
    inputs?: boolean | solutions$inputsArgs<ExtArgs>
    _count?: boolean | SolutionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type solutionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    hotspots?: boolean | solutions$hotspotsArgs<ExtArgs>
    ideas?: boolean | solutions$ideasArgs<ExtArgs>
    initiatives?: boolean | solutions$initiativesArgs<ExtArgs>
    inputs?: boolean | solutions$inputsArgs<ExtArgs>
  }
  export type solutionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    hotspots?: boolean | solutions$hotspotsArgs<ExtArgs>
    ideas?: boolean | solutions$ideasArgs<ExtArgs>
    initiatives?: boolean | solutions$initiativesArgs<ExtArgs>
    inputs?: boolean | solutions$inputsArgs<ExtArgs>
  }

  export type $solutionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "solutions"
    objects: {
      frd_documents: Prisma.$frd_documentsPayload<ExtArgs>[]
      requirements: Prisma.$requirementsPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
      hotspots: Prisma.$hotspotsPayload<ExtArgs> | null
      ideas: Prisma.$ideasPayload<ExtArgs> | null
      initiatives: Prisma.$initiativesPayload<ExtArgs> | null
      inputs: Prisma.$inputsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      status: $Enums.SolutionStatus
      createdAt: Date
      updatedAt: Date
      estimatedEffort: string | null
      actualCompletionDate: Date | null
      actualImpactJson: Prisma.JsonValue | null
      businessValue: string | null
      createdBy: string
      expectedImpactJson: Prisma.JsonValue | null
      hotspotId: string | null
      ideaId: string | null
      initiativeId: string | null
      inputId: string | null
      progress: number
      successMetrics: Prisma.JsonValue | null
      targetDate: Date | null
      tasks: Prisma.JsonValue | null
    }, ExtArgs["result"]["solutions"]>
    composites: {}
  }

  type solutionsGetPayload<S extends boolean | null | undefined | solutionsDefaultArgs> = $Result.GetResult<Prisma.$solutionsPayload, S>

  type solutionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<solutionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SolutionsCountAggregateInputType | true
    }

  export interface solutionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['solutions'], meta: { name: 'solutions' } }
    /**
     * Find zero or one Solutions that matches the filter.
     * @param {solutionsFindUniqueArgs} args - Arguments to find a Solutions
     * @example
     * // Get one Solutions
     * const solutions = await prisma.solutions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends solutionsFindUniqueArgs>(args: SelectSubset<T, solutionsFindUniqueArgs<ExtArgs>>): Prisma__solutionsClient<$Result.GetResult<Prisma.$solutionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Solutions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {solutionsFindUniqueOrThrowArgs} args - Arguments to find a Solutions
     * @example
     * // Get one Solutions
     * const solutions = await prisma.solutions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends solutionsFindUniqueOrThrowArgs>(args: SelectSubset<T, solutionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__solutionsClient<$Result.GetResult<Prisma.$solutionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Solutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {solutionsFindFirstArgs} args - Arguments to find a Solutions
     * @example
     * // Get one Solutions
     * const solutions = await prisma.solutions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends solutionsFindFirstArgs>(args?: SelectSubset<T, solutionsFindFirstArgs<ExtArgs>>): Prisma__solutionsClient<$Result.GetResult<Prisma.$solutionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Solutions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {solutionsFindFirstOrThrowArgs} args - Arguments to find a Solutions
     * @example
     * // Get one Solutions
     * const solutions = await prisma.solutions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends solutionsFindFirstOrThrowArgs>(args?: SelectSubset<T, solutionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__solutionsClient<$Result.GetResult<Prisma.$solutionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Solutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {solutionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Solutions
     * const solutions = await prisma.solutions.findMany()
     * 
     * // Get first 10 Solutions
     * const solutions = await prisma.solutions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const solutionsWithIdOnly = await prisma.solutions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends solutionsFindManyArgs>(args?: SelectSubset<T, solutionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$solutionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Solutions.
     * @param {solutionsCreateArgs} args - Arguments to create a Solutions.
     * @example
     * // Create one Solutions
     * const Solutions = await prisma.solutions.create({
     *   data: {
     *     // ... data to create a Solutions
     *   }
     * })
     * 
     */
    create<T extends solutionsCreateArgs>(args: SelectSubset<T, solutionsCreateArgs<ExtArgs>>): Prisma__solutionsClient<$Result.GetResult<Prisma.$solutionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Solutions.
     * @param {solutionsCreateManyArgs} args - Arguments to create many Solutions.
     * @example
     * // Create many Solutions
     * const solutions = await prisma.solutions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends solutionsCreateManyArgs>(args?: SelectSubset<T, solutionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Solutions and returns the data saved in the database.
     * @param {solutionsCreateManyAndReturnArgs} args - Arguments to create many Solutions.
     * @example
     * // Create many Solutions
     * const solutions = await prisma.solutions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Solutions and only return the `id`
     * const solutionsWithIdOnly = await prisma.solutions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends solutionsCreateManyAndReturnArgs>(args?: SelectSubset<T, solutionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$solutionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Solutions.
     * @param {solutionsDeleteArgs} args - Arguments to delete one Solutions.
     * @example
     * // Delete one Solutions
     * const Solutions = await prisma.solutions.delete({
     *   where: {
     *     // ... filter to delete one Solutions
     *   }
     * })
     * 
     */
    delete<T extends solutionsDeleteArgs>(args: SelectSubset<T, solutionsDeleteArgs<ExtArgs>>): Prisma__solutionsClient<$Result.GetResult<Prisma.$solutionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Solutions.
     * @param {solutionsUpdateArgs} args - Arguments to update one Solutions.
     * @example
     * // Update one Solutions
     * const solutions = await prisma.solutions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends solutionsUpdateArgs>(args: SelectSubset<T, solutionsUpdateArgs<ExtArgs>>): Prisma__solutionsClient<$Result.GetResult<Prisma.$solutionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Solutions.
     * @param {solutionsDeleteManyArgs} args - Arguments to filter Solutions to delete.
     * @example
     * // Delete a few Solutions
     * const { count } = await prisma.solutions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends solutionsDeleteManyArgs>(args?: SelectSubset<T, solutionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Solutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {solutionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Solutions
     * const solutions = await prisma.solutions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends solutionsUpdateManyArgs>(args: SelectSubset<T, solutionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Solutions and returns the data updated in the database.
     * @param {solutionsUpdateManyAndReturnArgs} args - Arguments to update many Solutions.
     * @example
     * // Update many Solutions
     * const solutions = await prisma.solutions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Solutions and only return the `id`
     * const solutionsWithIdOnly = await prisma.solutions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends solutionsUpdateManyAndReturnArgs>(args: SelectSubset<T, solutionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$solutionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Solutions.
     * @param {solutionsUpsertArgs} args - Arguments to update or create a Solutions.
     * @example
     * // Update or create a Solutions
     * const solutions = await prisma.solutions.upsert({
     *   create: {
     *     // ... data to create a Solutions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Solutions we want to update
     *   }
     * })
     */
    upsert<T extends solutionsUpsertArgs>(args: SelectSubset<T, solutionsUpsertArgs<ExtArgs>>): Prisma__solutionsClient<$Result.GetResult<Prisma.$solutionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Solutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {solutionsCountArgs} args - Arguments to filter Solutions to count.
     * @example
     * // Count the number of Solutions
     * const count = await prisma.solutions.count({
     *   where: {
     *     // ... the filter for the Solutions we want to count
     *   }
     * })
    **/
    count<T extends solutionsCountArgs>(
      args?: Subset<T, solutionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SolutionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Solutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolutionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SolutionsAggregateArgs>(args: Subset<T, SolutionsAggregateArgs>): Prisma.PrismaPromise<GetSolutionsAggregateType<T>>

    /**
     * Group by Solutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {solutionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends solutionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: solutionsGroupByArgs['orderBy'] }
        : { orderBy?: solutionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, solutionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSolutionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the solutions model
   */
  readonly fields: solutionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for solutions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__solutionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    frd_documents<T extends solutions$frd_documentsArgs<ExtArgs> = {}>(args?: Subset<T, solutions$frd_documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$frd_documentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requirements<T extends solutions$requirementsArgs<ExtArgs> = {}>(args?: Subset<T, solutions$requirementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$requirementsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    hotspots<T extends solutions$hotspotsArgs<ExtArgs> = {}>(args?: Subset<T, solutions$hotspotsArgs<ExtArgs>>): Prisma__hotspotsClient<$Result.GetResult<Prisma.$hotspotsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ideas<T extends solutions$ideasArgs<ExtArgs> = {}>(args?: Subset<T, solutions$ideasArgs<ExtArgs>>): Prisma__ideasClient<$Result.GetResult<Prisma.$ideasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    initiatives<T extends solutions$initiativesArgs<ExtArgs> = {}>(args?: Subset<T, solutions$initiativesArgs<ExtArgs>>): Prisma__initiativesClient<$Result.GetResult<Prisma.$initiativesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    inputs<T extends solutions$inputsArgs<ExtArgs> = {}>(args?: Subset<T, solutions$inputsArgs<ExtArgs>>): Prisma__inputsClient<$Result.GetResult<Prisma.$inputsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the solutions model
   */
  interface solutionsFieldRefs {
    readonly id: FieldRef<"solutions", 'String'>
    readonly title: FieldRef<"solutions", 'String'>
    readonly description: FieldRef<"solutions", 'String'>
    readonly status: FieldRef<"solutions", 'SolutionStatus'>
    readonly createdAt: FieldRef<"solutions", 'DateTime'>
    readonly updatedAt: FieldRef<"solutions", 'DateTime'>
    readonly estimatedEffort: FieldRef<"solutions", 'String'>
    readonly actualCompletionDate: FieldRef<"solutions", 'DateTime'>
    readonly actualImpactJson: FieldRef<"solutions", 'Json'>
    readonly businessValue: FieldRef<"solutions", 'String'>
    readonly createdBy: FieldRef<"solutions", 'String'>
    readonly expectedImpactJson: FieldRef<"solutions", 'Json'>
    readonly hotspotId: FieldRef<"solutions", 'String'>
    readonly ideaId: FieldRef<"solutions", 'String'>
    readonly initiativeId: FieldRef<"solutions", 'String'>
    readonly inputId: FieldRef<"solutions", 'String'>
    readonly progress: FieldRef<"solutions", 'Float'>
    readonly successMetrics: FieldRef<"solutions", 'Json'>
    readonly targetDate: FieldRef<"solutions", 'DateTime'>
    readonly tasks: FieldRef<"solutions", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * solutions findUnique
   */
  export type solutionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the solutions
     */
    select?: solutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the solutions
     */
    omit?: solutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: solutionsInclude<ExtArgs> | null
    /**
     * Filter, which solutions to fetch.
     */
    where: solutionsWhereUniqueInput
  }

  /**
   * solutions findUniqueOrThrow
   */
  export type solutionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the solutions
     */
    select?: solutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the solutions
     */
    omit?: solutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: solutionsInclude<ExtArgs> | null
    /**
     * Filter, which solutions to fetch.
     */
    where: solutionsWhereUniqueInput
  }

  /**
   * solutions findFirst
   */
  export type solutionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the solutions
     */
    select?: solutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the solutions
     */
    omit?: solutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: solutionsInclude<ExtArgs> | null
    /**
     * Filter, which solutions to fetch.
     */
    where?: solutionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of solutions to fetch.
     */
    orderBy?: solutionsOrderByWithRelationInput | solutionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for solutions.
     */
    cursor?: solutionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` solutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` solutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of solutions.
     */
    distinct?: SolutionsScalarFieldEnum | SolutionsScalarFieldEnum[]
  }

  /**
   * solutions findFirstOrThrow
   */
  export type solutionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the solutions
     */
    select?: solutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the solutions
     */
    omit?: solutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: solutionsInclude<ExtArgs> | null
    /**
     * Filter, which solutions to fetch.
     */
    where?: solutionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of solutions to fetch.
     */
    orderBy?: solutionsOrderByWithRelationInput | solutionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for solutions.
     */
    cursor?: solutionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` solutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` solutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of solutions.
     */
    distinct?: SolutionsScalarFieldEnum | SolutionsScalarFieldEnum[]
  }

  /**
   * solutions findMany
   */
  export type solutionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the solutions
     */
    select?: solutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the solutions
     */
    omit?: solutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: solutionsInclude<ExtArgs> | null
    /**
     * Filter, which solutions to fetch.
     */
    where?: solutionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of solutions to fetch.
     */
    orderBy?: solutionsOrderByWithRelationInput | solutionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing solutions.
     */
    cursor?: solutionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` solutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` solutions.
     */
    skip?: number
    distinct?: SolutionsScalarFieldEnum | SolutionsScalarFieldEnum[]
  }

  /**
   * solutions create
   */
  export type solutionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the solutions
     */
    select?: solutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the solutions
     */
    omit?: solutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: solutionsInclude<ExtArgs> | null
    /**
     * The data needed to create a solutions.
     */
    data: XOR<solutionsCreateInput, solutionsUncheckedCreateInput>
  }

  /**
   * solutions createMany
   */
  export type solutionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many solutions.
     */
    data: solutionsCreateManyInput | solutionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * solutions createManyAndReturn
   */
  export type solutionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the solutions
     */
    select?: solutionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the solutions
     */
    omit?: solutionsOmit<ExtArgs> | null
    /**
     * The data used to create many solutions.
     */
    data: solutionsCreateManyInput | solutionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: solutionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * solutions update
   */
  export type solutionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the solutions
     */
    select?: solutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the solutions
     */
    omit?: solutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: solutionsInclude<ExtArgs> | null
    /**
     * The data needed to update a solutions.
     */
    data: XOR<solutionsUpdateInput, solutionsUncheckedUpdateInput>
    /**
     * Choose, which solutions to update.
     */
    where: solutionsWhereUniqueInput
  }

  /**
   * solutions updateMany
   */
  export type solutionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update solutions.
     */
    data: XOR<solutionsUpdateManyMutationInput, solutionsUncheckedUpdateManyInput>
    /**
     * Filter which solutions to update
     */
    where?: solutionsWhereInput
    /**
     * Limit how many solutions to update.
     */
    limit?: number
  }

  /**
   * solutions updateManyAndReturn
   */
  export type solutionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the solutions
     */
    select?: solutionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the solutions
     */
    omit?: solutionsOmit<ExtArgs> | null
    /**
     * The data used to update solutions.
     */
    data: XOR<solutionsUpdateManyMutationInput, solutionsUncheckedUpdateManyInput>
    /**
     * Filter which solutions to update
     */
    where?: solutionsWhereInput
    /**
     * Limit how many solutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: solutionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * solutions upsert
   */
  export type solutionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the solutions
     */
    select?: solutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the solutions
     */
    omit?: solutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: solutionsInclude<ExtArgs> | null
    /**
     * The filter to search for the solutions to update in case it exists.
     */
    where: solutionsWhereUniqueInput
    /**
     * In case the solutions found by the `where` argument doesn't exist, create a new solutions with this data.
     */
    create: XOR<solutionsCreateInput, solutionsUncheckedCreateInput>
    /**
     * In case the solutions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<solutionsUpdateInput, solutionsUncheckedUpdateInput>
  }

  /**
   * solutions delete
   */
  export type solutionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the solutions
     */
    select?: solutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the solutions
     */
    omit?: solutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: solutionsInclude<ExtArgs> | null
    /**
     * Filter which solutions to delete.
     */
    where: solutionsWhereUniqueInput
  }

  /**
   * solutions deleteMany
   */
  export type solutionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which solutions to delete
     */
    where?: solutionsWhereInput
    /**
     * Limit how many solutions to delete.
     */
    limit?: number
  }

  /**
   * solutions.frd_documents
   */
  export type solutions$frd_documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frd_documents
     */
    select?: frd_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the frd_documents
     */
    omit?: frd_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frd_documentsInclude<ExtArgs> | null
    where?: frd_documentsWhereInput
    orderBy?: frd_documentsOrderByWithRelationInput | frd_documentsOrderByWithRelationInput[]
    cursor?: frd_documentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Frd_documentsScalarFieldEnum | Frd_documentsScalarFieldEnum[]
  }

  /**
   * solutions.requirements
   */
  export type solutions$requirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirements
     */
    select?: requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirements
     */
    omit?: requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirementsInclude<ExtArgs> | null
    where?: requirementsWhereInput
    orderBy?: requirementsOrderByWithRelationInput | requirementsOrderByWithRelationInput[]
    cursor?: requirementsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequirementsScalarFieldEnum | RequirementsScalarFieldEnum[]
  }

  /**
   * solutions.hotspots
   */
  export type solutions$hotspotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotspots
     */
    select?: hotspotsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotspots
     */
    omit?: hotspotsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotspotsInclude<ExtArgs> | null
    where?: hotspotsWhereInput
  }

  /**
   * solutions.ideas
   */
  export type solutions$ideasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ideas
     */
    select?: ideasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ideas
     */
    omit?: ideasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ideasInclude<ExtArgs> | null
    where?: ideasWhereInput
  }

  /**
   * solutions.initiatives
   */
  export type solutions$initiativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the initiatives
     */
    select?: initiativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the initiatives
     */
    omit?: initiativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: initiativesInclude<ExtArgs> | null
    where?: initiativesWhereInput
  }

  /**
   * solutions.inputs
   */
  export type solutions$inputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inputs
     */
    select?: inputsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inputs
     */
    omit?: inputsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inputsInclude<ExtArgs> | null
    where?: inputsWhereInput
  }

  /**
   * solutions without action
   */
  export type solutionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the solutions
     */
    select?: solutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the solutions
     */
    omit?: solutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: solutionsInclude<ExtArgs> | null
  }


  /**
   * Model teams
   */

  export type AggregateTeams = {
    _count: TeamsCountAggregateOutputType | null
    _avg: TeamsAvgAggregateOutputType | null
    _sum: TeamsSumAggregateOutputType | null
    _min: TeamsMinAggregateOutputType | null
    _max: TeamsMaxAggregateOutputType | null
  }

  export type TeamsAvgAggregateOutputType = {
    memberCount: number | null
    maxCapacity: number | null
    currentProjects: number | null
    budgetAllocation: number | null
    utilizationRate: number | null
  }

  export type TeamsSumAggregateOutputType = {
    memberCount: number | null
    maxCapacity: number | null
    currentProjects: number | null
    budgetAllocation: number | null
    utilizationRate: number | null
  }

  export type TeamsMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    departmentId: string | null
    leaderId: string | null
    memberCount: number | null
    maxCapacity: number | null
    isActive: boolean | null
    teamType: string | null
    currentProjects: number | null
    budgetAllocation: number | null
    utilizationRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    departmentId: string | null
    leaderId: string | null
    memberCount: number | null
    maxCapacity: number | null
    isActive: boolean | null
    teamType: string | null
    currentProjects: number | null
    budgetAllocation: number | null
    utilizationRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    departmentId: number
    leaderId: number
    memberCount: number
    maxCapacity: number
    isActive: number
    teamType: number
    currentProjects: number
    budgetAllocation: number
    utilizationRate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamsAvgAggregateInputType = {
    memberCount?: true
    maxCapacity?: true
    currentProjects?: true
    budgetAllocation?: true
    utilizationRate?: true
  }

  export type TeamsSumAggregateInputType = {
    memberCount?: true
    maxCapacity?: true
    currentProjects?: true
    budgetAllocation?: true
    utilizationRate?: true
  }

  export type TeamsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    departmentId?: true
    leaderId?: true
    memberCount?: true
    maxCapacity?: true
    isActive?: true
    teamType?: true
    currentProjects?: true
    budgetAllocation?: true
    utilizationRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    departmentId?: true
    leaderId?: true
    memberCount?: true
    maxCapacity?: true
    isActive?: true
    teamType?: true
    currentProjects?: true
    budgetAllocation?: true
    utilizationRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    departmentId?: true
    leaderId?: true
    memberCount?: true
    maxCapacity?: true
    isActive?: true
    teamType?: true
    currentProjects?: true
    budgetAllocation?: true
    utilizationRate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teams to aggregate.
     */
    where?: teamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamsOrderByWithRelationInput | teamsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teams
    **/
    _count?: true | TeamsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamsMaxAggregateInputType
  }

  export type GetTeamsAggregateType<T extends TeamsAggregateArgs> = {
        [P in keyof T & keyof AggregateTeams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeams[P]>
      : GetScalarType<T[P], AggregateTeams[P]>
  }




  export type teamsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamsWhereInput
    orderBy?: teamsOrderByWithAggregationInput | teamsOrderByWithAggregationInput[]
    by: TeamsScalarFieldEnum[] | TeamsScalarFieldEnum
    having?: teamsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamsCountAggregateInputType | true
    _avg?: TeamsAvgAggregateInputType
    _sum?: TeamsSumAggregateInputType
    _min?: TeamsMinAggregateInputType
    _max?: TeamsMaxAggregateInputType
  }

  export type TeamsGroupByOutputType = {
    id: string
    name: string
    description: string | null
    departmentId: string | null
    leaderId: string | null
    memberCount: number
    maxCapacity: number | null
    isActive: boolean
    teamType: string | null
    currentProjects: number
    budgetAllocation: number
    utilizationRate: number | null
    createdAt: Date
    updatedAt: Date
    _count: TeamsCountAggregateOutputType | null
    _avg: TeamsAvgAggregateOutputType | null
    _sum: TeamsSumAggregateOutputType | null
    _min: TeamsMinAggregateOutputType | null
    _max: TeamsMaxAggregateOutputType | null
  }

  type GetTeamsGroupByPayload<T extends teamsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamsGroupByOutputType[P]>
            : GetScalarType<T[P], TeamsGroupByOutputType[P]>
        }
      >
    >


  export type teamsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    departmentId?: boolean
    leaderId?: boolean
    memberCount?: boolean
    maxCapacity?: boolean
    isActive?: boolean
    teamType?: boolean
    currentProjects?: boolean
    budgetAllocation?: boolean
    utilizationRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    signals?: boolean | teams$signalsArgs<ExtArgs>
    departments?: boolean | teams$departmentsArgs<ExtArgs>
    users_teams_leaderIdTousers?: boolean | teams$users_teams_leaderIdTousersArgs<ExtArgs>
    users_TeamMembers?: boolean | teams$users_TeamMembersArgs<ExtArgs>
    _count?: boolean | TeamsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teams"]>

  export type teamsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    departmentId?: boolean
    leaderId?: boolean
    memberCount?: boolean
    maxCapacity?: boolean
    isActive?: boolean
    teamType?: boolean
    currentProjects?: boolean
    budgetAllocation?: boolean
    utilizationRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    departments?: boolean | teams$departmentsArgs<ExtArgs>
    users_teams_leaderIdTousers?: boolean | teams$users_teams_leaderIdTousersArgs<ExtArgs>
  }, ExtArgs["result"]["teams"]>

  export type teamsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    departmentId?: boolean
    leaderId?: boolean
    memberCount?: boolean
    maxCapacity?: boolean
    isActive?: boolean
    teamType?: boolean
    currentProjects?: boolean
    budgetAllocation?: boolean
    utilizationRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    departments?: boolean | teams$departmentsArgs<ExtArgs>
    users_teams_leaderIdTousers?: boolean | teams$users_teams_leaderIdTousersArgs<ExtArgs>
  }, ExtArgs["result"]["teams"]>

  export type teamsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    departmentId?: boolean
    leaderId?: boolean
    memberCount?: boolean
    maxCapacity?: boolean
    isActive?: boolean
    teamType?: boolean
    currentProjects?: boolean
    budgetAllocation?: boolean
    utilizationRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type teamsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "departmentId" | "leaderId" | "memberCount" | "maxCapacity" | "isActive" | "teamType" | "currentProjects" | "budgetAllocation" | "utilizationRate" | "createdAt" | "updatedAt", ExtArgs["result"]["teams"]>
  export type teamsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    signals?: boolean | teams$signalsArgs<ExtArgs>
    departments?: boolean | teams$departmentsArgs<ExtArgs>
    users_teams_leaderIdTousers?: boolean | teams$users_teams_leaderIdTousersArgs<ExtArgs>
    users_TeamMembers?: boolean | teams$users_TeamMembersArgs<ExtArgs>
    _count?: boolean | TeamsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type teamsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | teams$departmentsArgs<ExtArgs>
    users_teams_leaderIdTousers?: boolean | teams$users_teams_leaderIdTousersArgs<ExtArgs>
  }
  export type teamsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | teams$departmentsArgs<ExtArgs>
    users_teams_leaderIdTousers?: boolean | teams$users_teams_leaderIdTousersArgs<ExtArgs>
  }

  export type $teamsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "teams"
    objects: {
      signals: Prisma.$signalsPayload<ExtArgs>[]
      departments: Prisma.$departmentsPayload<ExtArgs> | null
      users_teams_leaderIdTousers: Prisma.$usersPayload<ExtArgs> | null
      users_TeamMembers: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      departmentId: string | null
      leaderId: string | null
      memberCount: number
      maxCapacity: number | null
      isActive: boolean
      teamType: string | null
      currentProjects: number
      budgetAllocation: number
      utilizationRate: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teams"]>
    composites: {}
  }

  type teamsGetPayload<S extends boolean | null | undefined | teamsDefaultArgs> = $Result.GetResult<Prisma.$teamsPayload, S>

  type teamsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<teamsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamsCountAggregateInputType | true
    }

  export interface teamsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['teams'], meta: { name: 'teams' } }
    /**
     * Find zero or one Teams that matches the filter.
     * @param {teamsFindUniqueArgs} args - Arguments to find a Teams
     * @example
     * // Get one Teams
     * const teams = await prisma.teams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends teamsFindUniqueArgs>(args: SelectSubset<T, teamsFindUniqueArgs<ExtArgs>>): Prisma__teamsClient<$Result.GetResult<Prisma.$teamsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teams that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {teamsFindUniqueOrThrowArgs} args - Arguments to find a Teams
     * @example
     * // Get one Teams
     * const teams = await prisma.teams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends teamsFindUniqueOrThrowArgs>(args: SelectSubset<T, teamsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__teamsClient<$Result.GetResult<Prisma.$teamsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamsFindFirstArgs} args - Arguments to find a Teams
     * @example
     * // Get one Teams
     * const teams = await prisma.teams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends teamsFindFirstArgs>(args?: SelectSubset<T, teamsFindFirstArgs<ExtArgs>>): Prisma__teamsClient<$Result.GetResult<Prisma.$teamsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teams that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamsFindFirstOrThrowArgs} args - Arguments to find a Teams
     * @example
     * // Get one Teams
     * const teams = await prisma.teams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends teamsFindFirstOrThrowArgs>(args?: SelectSubset<T, teamsFindFirstOrThrowArgs<ExtArgs>>): Prisma__teamsClient<$Result.GetResult<Prisma.$teamsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.teams.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.teams.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamsWithIdOnly = await prisma.teams.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends teamsFindManyArgs>(args?: SelectSubset<T, teamsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teams.
     * @param {teamsCreateArgs} args - Arguments to create a Teams.
     * @example
     * // Create one Teams
     * const Teams = await prisma.teams.create({
     *   data: {
     *     // ... data to create a Teams
     *   }
     * })
     * 
     */
    create<T extends teamsCreateArgs>(args: SelectSubset<T, teamsCreateArgs<ExtArgs>>): Prisma__teamsClient<$Result.GetResult<Prisma.$teamsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {teamsCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const teams = await prisma.teams.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends teamsCreateManyArgs>(args?: SelectSubset<T, teamsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {teamsCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const teams = await prisma.teams.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamsWithIdOnly = await prisma.teams.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends teamsCreateManyAndReturnArgs>(args?: SelectSubset<T, teamsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Teams.
     * @param {teamsDeleteArgs} args - Arguments to delete one Teams.
     * @example
     * // Delete one Teams
     * const Teams = await prisma.teams.delete({
     *   where: {
     *     // ... filter to delete one Teams
     *   }
     * })
     * 
     */
    delete<T extends teamsDeleteArgs>(args: SelectSubset<T, teamsDeleteArgs<ExtArgs>>): Prisma__teamsClient<$Result.GetResult<Prisma.$teamsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teams.
     * @param {teamsUpdateArgs} args - Arguments to update one Teams.
     * @example
     * // Update one Teams
     * const teams = await prisma.teams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends teamsUpdateArgs>(args: SelectSubset<T, teamsUpdateArgs<ExtArgs>>): Prisma__teamsClient<$Result.GetResult<Prisma.$teamsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {teamsDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.teams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends teamsDeleteManyArgs>(args?: SelectSubset<T, teamsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const teams = await prisma.teams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends teamsUpdateManyArgs>(args: SelectSubset<T, teamsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {teamsUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const teams = await prisma.teams.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `id`
     * const teamsWithIdOnly = await prisma.teams.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends teamsUpdateManyAndReturnArgs>(args: SelectSubset<T, teamsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Teams.
     * @param {teamsUpsertArgs} args - Arguments to update or create a Teams.
     * @example
     * // Update or create a Teams
     * const teams = await prisma.teams.upsert({
     *   create: {
     *     // ... data to create a Teams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teams we want to update
     *   }
     * })
     */
    upsert<T extends teamsUpsertArgs>(args: SelectSubset<T, teamsUpsertArgs<ExtArgs>>): Prisma__teamsClient<$Result.GetResult<Prisma.$teamsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamsCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.teams.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends teamsCountArgs>(
      args?: Subset<T, teamsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamsAggregateArgs>(args: Subset<T, TeamsAggregateArgs>): Prisma.PrismaPromise<GetTeamsAggregateType<T>>

    /**
     * Group by Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends teamsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: teamsGroupByArgs['orderBy'] }
        : { orderBy?: teamsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, teamsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the teams model
   */
  readonly fields: teamsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for teams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__teamsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    signals<T extends teams$signalsArgs<ExtArgs> = {}>(args?: Subset<T, teams$signalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departments<T extends teams$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, teams$departmentsArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users_teams_leaderIdTousers<T extends teams$users_teams_leaderIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, teams$users_teams_leaderIdTousersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users_TeamMembers<T extends teams$users_TeamMembersArgs<ExtArgs> = {}>(args?: Subset<T, teams$users_TeamMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the teams model
   */
  interface teamsFieldRefs {
    readonly id: FieldRef<"teams", 'String'>
    readonly name: FieldRef<"teams", 'String'>
    readonly description: FieldRef<"teams", 'String'>
    readonly departmentId: FieldRef<"teams", 'String'>
    readonly leaderId: FieldRef<"teams", 'String'>
    readonly memberCount: FieldRef<"teams", 'Int'>
    readonly maxCapacity: FieldRef<"teams", 'Int'>
    readonly isActive: FieldRef<"teams", 'Boolean'>
    readonly teamType: FieldRef<"teams", 'String'>
    readonly currentProjects: FieldRef<"teams", 'Int'>
    readonly budgetAllocation: FieldRef<"teams", 'Float'>
    readonly utilizationRate: FieldRef<"teams", 'Float'>
    readonly createdAt: FieldRef<"teams", 'DateTime'>
    readonly updatedAt: FieldRef<"teams", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * teams findUnique
   */
  export type teamsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teams
     */
    select?: teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teams
     */
    omit?: teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamsInclude<ExtArgs> | null
    /**
     * Filter, which teams to fetch.
     */
    where: teamsWhereUniqueInput
  }

  /**
   * teams findUniqueOrThrow
   */
  export type teamsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teams
     */
    select?: teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teams
     */
    omit?: teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamsInclude<ExtArgs> | null
    /**
     * Filter, which teams to fetch.
     */
    where: teamsWhereUniqueInput
  }

  /**
   * teams findFirst
   */
  export type teamsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teams
     */
    select?: teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teams
     */
    omit?: teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamsInclude<ExtArgs> | null
    /**
     * Filter, which teams to fetch.
     */
    where?: teamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamsOrderByWithRelationInput | teamsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teams.
     */
    cursor?: teamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teams.
     */
    distinct?: TeamsScalarFieldEnum | TeamsScalarFieldEnum[]
  }

  /**
   * teams findFirstOrThrow
   */
  export type teamsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teams
     */
    select?: teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teams
     */
    omit?: teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamsInclude<ExtArgs> | null
    /**
     * Filter, which teams to fetch.
     */
    where?: teamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamsOrderByWithRelationInput | teamsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teams.
     */
    cursor?: teamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teams.
     */
    distinct?: TeamsScalarFieldEnum | TeamsScalarFieldEnum[]
  }

  /**
   * teams findMany
   */
  export type teamsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teams
     */
    select?: teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teams
     */
    omit?: teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamsInclude<ExtArgs> | null
    /**
     * Filter, which teams to fetch.
     */
    where?: teamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamsOrderByWithRelationInput | teamsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teams.
     */
    cursor?: teamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    distinct?: TeamsScalarFieldEnum | TeamsScalarFieldEnum[]
  }

  /**
   * teams create
   */
  export type teamsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teams
     */
    select?: teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teams
     */
    omit?: teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamsInclude<ExtArgs> | null
    /**
     * The data needed to create a teams.
     */
    data: XOR<teamsCreateInput, teamsUncheckedCreateInput>
  }

  /**
   * teams createMany
   */
  export type teamsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many teams.
     */
    data: teamsCreateManyInput | teamsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * teams createManyAndReturn
   */
  export type teamsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teams
     */
    select?: teamsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teams
     */
    omit?: teamsOmit<ExtArgs> | null
    /**
     * The data used to create many teams.
     */
    data: teamsCreateManyInput | teamsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * teams update
   */
  export type teamsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teams
     */
    select?: teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teams
     */
    omit?: teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamsInclude<ExtArgs> | null
    /**
     * The data needed to update a teams.
     */
    data: XOR<teamsUpdateInput, teamsUncheckedUpdateInput>
    /**
     * Choose, which teams to update.
     */
    where: teamsWhereUniqueInput
  }

  /**
   * teams updateMany
   */
  export type teamsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update teams.
     */
    data: XOR<teamsUpdateManyMutationInput, teamsUncheckedUpdateManyInput>
    /**
     * Filter which teams to update
     */
    where?: teamsWhereInput
    /**
     * Limit how many teams to update.
     */
    limit?: number
  }

  /**
   * teams updateManyAndReturn
   */
  export type teamsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teams
     */
    select?: teamsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teams
     */
    omit?: teamsOmit<ExtArgs> | null
    /**
     * The data used to update teams.
     */
    data: XOR<teamsUpdateManyMutationInput, teamsUncheckedUpdateManyInput>
    /**
     * Filter which teams to update
     */
    where?: teamsWhereInput
    /**
     * Limit how many teams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * teams upsert
   */
  export type teamsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teams
     */
    select?: teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teams
     */
    omit?: teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamsInclude<ExtArgs> | null
    /**
     * The filter to search for the teams to update in case it exists.
     */
    where: teamsWhereUniqueInput
    /**
     * In case the teams found by the `where` argument doesn't exist, create a new teams with this data.
     */
    create: XOR<teamsCreateInput, teamsUncheckedCreateInput>
    /**
     * In case the teams was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teamsUpdateInput, teamsUncheckedUpdateInput>
  }

  /**
   * teams delete
   */
  export type teamsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teams
     */
    select?: teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teams
     */
    omit?: teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamsInclude<ExtArgs> | null
    /**
     * Filter which teams to delete.
     */
    where: teamsWhereUniqueInput
  }

  /**
   * teams deleteMany
   */
  export type teamsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teams to delete
     */
    where?: teamsWhereInput
    /**
     * Limit how many teams to delete.
     */
    limit?: number
  }

  /**
   * teams.signals
   */
  export type teams$signalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: signalsInclude<ExtArgs> | null
    where?: signalsWhereInput
    orderBy?: signalsOrderByWithRelationInput | signalsOrderByWithRelationInput[]
    cursor?: signalsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SignalsScalarFieldEnum | SignalsScalarFieldEnum[]
  }

  /**
   * teams.departments
   */
  export type teams$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    where?: departmentsWhereInput
  }

  /**
   * teams.users_teams_leaderIdTousers
   */
  export type teams$users_teams_leaderIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * teams.users_TeamMembers
   */
  export type teams$users_TeamMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * teams without action
   */
  export type teamsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teams
     */
    select?: teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teams
     */
    omit?: teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamsInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    billableRate: number | null
    targetUtilization: number | null
    utilizationRate: number | null
  }

  export type UsersSumAggregateOutputType = {
    billableRate: number | null
    targetUtilization: number | null
    utilizationRate: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: $Enums.UserRole | null
    department: string | null
    avatar: string | null
    passwordHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
    title: string | null
    managerId: string | null
    billableRate: number | null
    costCenter: string | null
    location: string | null
    isActive: boolean | null
    lastLoginAt: Date | null
    targetUtilization: number | null
    utilizationRate: number | null
    departmentObjId: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: $Enums.UserRole | null
    department: string | null
    avatar: string | null
    passwordHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
    title: string | null
    managerId: string | null
    billableRate: number | null
    costCenter: string | null
    location: string | null
    isActive: boolean | null
    lastLoginAt: Date | null
    targetUtilization: number | null
    utilizationRate: number | null
    departmentObjId: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    email: number
    name: number
    role: number
    department: number
    avatar: number
    passwordHash: number
    createdAt: number
    updatedAt: number
    title: number
    managerId: number
    billableRate: number
    costCenter: number
    location: number
    isActive: number
    lastLoginAt: number
    profileJson: number
    targetUtilization: number
    utilizationRate: number
    departmentObjId: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    billableRate?: true
    targetUtilization?: true
    utilizationRate?: true
  }

  export type UsersSumAggregateInputType = {
    billableRate?: true
    targetUtilization?: true
    utilizationRate?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    department?: true
    avatar?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    managerId?: true
    billableRate?: true
    costCenter?: true
    location?: true
    isActive?: true
    lastLoginAt?: true
    targetUtilization?: true
    utilizationRate?: true
    departmentObjId?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    department?: true
    avatar?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    managerId?: true
    billableRate?: true
    costCenter?: true
    location?: true
    isActive?: true
    lastLoginAt?: true
    targetUtilization?: true
    utilizationRate?: true
    departmentObjId?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    department?: true
    avatar?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    managerId?: true
    billableRate?: true
    costCenter?: true
    location?: true
    isActive?: true
    lastLoginAt?: true
    profileJson?: true
    targetUtilization?: true
    utilizationRate?: true
    departmentObjId?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    email: string
    name: string
    role: $Enums.UserRole
    department: string | null
    avatar: string | null
    passwordHash: string | null
    createdAt: Date
    updatedAt: Date
    title: string | null
    managerId: string | null
    billableRate: number | null
    costCenter: string | null
    location: string | null
    isActive: boolean
    lastLoginAt: Date | null
    profileJson: JsonValue | null
    targetUtilization: number | null
    utilizationRate: number | null
    departmentObjId: string | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    department?: boolean
    avatar?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    managerId?: boolean
    billableRate?: boolean
    costCenter?: boolean
    location?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    profileJson?: boolean
    targetUtilization?: boolean
    utilizationRate?: boolean
    departmentObjId?: boolean
    ai_analysis_audit?: boolean | users$ai_analysis_auditArgs<ExtArgs>
    ai_insight_overrides?: boolean | users$ai_insight_overridesArgs<ExtArgs>
    audit_logs?: boolean | users$audit_logsArgs<ExtArgs>
    comments?: boolean | users$commentsArgs<ExtArgs>
    departments_departments_managerIdTousers?: boolean | users$departments_departments_managerIdTousersArgs<ExtArgs>
    frd_documents_frd_documents_approvedByTousers?: boolean | users$frd_documents_frd_documents_approvedByTousersArgs<ExtArgs>
    frd_documents_frd_documents_createdByTousers?: boolean | users$frd_documents_frd_documents_createdByTousersArgs<ExtArgs>
    ideas?: boolean | users$ideasArgs<ExtArgs>
    initiatives?: boolean | users$initiativesArgs<ExtArgs>
    input_groups?: boolean | users$input_groupsArgs<ExtArgs>
    inputs?: boolean | users$inputsArgs<ExtArgs>
    requirements?: boolean | users$requirementsArgs<ExtArgs>
    signals?: boolean | users$signalsArgs<ExtArgs>
    solutions?: boolean | users$solutionsArgs<ExtArgs>
    teams_teams_leaderIdTousers?: boolean | users$teams_teams_leaderIdTousersArgs<ExtArgs>
    departments_users_departmentObjIdTodepartments?: boolean | users$departments_users_departmentObjIdTodepartmentsArgs<ExtArgs>
    users?: boolean | users$usersArgs<ExtArgs>
    other_users?: boolean | users$other_usersArgs<ExtArgs>
    votes?: boolean | users$votesArgs<ExtArgs>
    teams_TeamMembers?: boolean | users$teams_TeamMembersArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    department?: boolean
    avatar?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    managerId?: boolean
    billableRate?: boolean
    costCenter?: boolean
    location?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    profileJson?: boolean
    targetUtilization?: boolean
    utilizationRate?: boolean
    departmentObjId?: boolean
    departments_users_departmentObjIdTodepartments?: boolean | users$departments_users_departmentObjIdTodepartmentsArgs<ExtArgs>
    users?: boolean | users$usersArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    department?: boolean
    avatar?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    managerId?: boolean
    billableRate?: boolean
    costCenter?: boolean
    location?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    profileJson?: boolean
    targetUtilization?: boolean
    utilizationRate?: boolean
    departmentObjId?: boolean
    departments_users_departmentObjIdTodepartments?: boolean | users$departments_users_departmentObjIdTodepartmentsArgs<ExtArgs>
    users?: boolean | users$usersArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    department?: boolean
    avatar?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    managerId?: boolean
    billableRate?: boolean
    costCenter?: boolean
    location?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    profileJson?: boolean
    targetUtilization?: boolean
    utilizationRate?: boolean
    departmentObjId?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "role" | "department" | "avatar" | "passwordHash" | "createdAt" | "updatedAt" | "title" | "managerId" | "billableRate" | "costCenter" | "location" | "isActive" | "lastLoginAt" | "profileJson" | "targetUtilization" | "utilizationRate" | "departmentObjId", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ai_analysis_audit?: boolean | users$ai_analysis_auditArgs<ExtArgs>
    ai_insight_overrides?: boolean | users$ai_insight_overridesArgs<ExtArgs>
    audit_logs?: boolean | users$audit_logsArgs<ExtArgs>
    comments?: boolean | users$commentsArgs<ExtArgs>
    departments_departments_managerIdTousers?: boolean | users$departments_departments_managerIdTousersArgs<ExtArgs>
    frd_documents_frd_documents_approvedByTousers?: boolean | users$frd_documents_frd_documents_approvedByTousersArgs<ExtArgs>
    frd_documents_frd_documents_createdByTousers?: boolean | users$frd_documents_frd_documents_createdByTousersArgs<ExtArgs>
    ideas?: boolean | users$ideasArgs<ExtArgs>
    initiatives?: boolean | users$initiativesArgs<ExtArgs>
    input_groups?: boolean | users$input_groupsArgs<ExtArgs>
    inputs?: boolean | users$inputsArgs<ExtArgs>
    requirements?: boolean | users$requirementsArgs<ExtArgs>
    signals?: boolean | users$signalsArgs<ExtArgs>
    solutions?: boolean | users$solutionsArgs<ExtArgs>
    teams_teams_leaderIdTousers?: boolean | users$teams_teams_leaderIdTousersArgs<ExtArgs>
    departments_users_departmentObjIdTodepartments?: boolean | users$departments_users_departmentObjIdTodepartmentsArgs<ExtArgs>
    users?: boolean | users$usersArgs<ExtArgs>
    other_users?: boolean | users$other_usersArgs<ExtArgs>
    votes?: boolean | users$votesArgs<ExtArgs>
    teams_TeamMembers?: boolean | users$teams_TeamMembersArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments_users_departmentObjIdTodepartments?: boolean | users$departments_users_departmentObjIdTodepartmentsArgs<ExtArgs>
    users?: boolean | users$usersArgs<ExtArgs>
  }
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments_users_departmentObjIdTodepartments?: boolean | users$departments_users_departmentObjIdTodepartmentsArgs<ExtArgs>
    users?: boolean | users$usersArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      ai_analysis_audit: Prisma.$ai_analysis_auditPayload<ExtArgs>[]
      ai_insight_overrides: Prisma.$ai_insight_overridesPayload<ExtArgs>[]
      audit_logs: Prisma.$audit_logsPayload<ExtArgs>[]
      comments: Prisma.$commentsPayload<ExtArgs>[]
      departments_departments_managerIdTousers: Prisma.$departmentsPayload<ExtArgs>[]
      frd_documents_frd_documents_approvedByTousers: Prisma.$frd_documentsPayload<ExtArgs>[]
      frd_documents_frd_documents_createdByTousers: Prisma.$frd_documentsPayload<ExtArgs>[]
      ideas: Prisma.$ideasPayload<ExtArgs>[]
      initiatives: Prisma.$initiativesPayload<ExtArgs>[]
      input_groups: Prisma.$input_groupsPayload<ExtArgs>[]
      inputs: Prisma.$inputsPayload<ExtArgs>[]
      requirements: Prisma.$requirementsPayload<ExtArgs>[]
      signals: Prisma.$signalsPayload<ExtArgs>[]
      solutions: Prisma.$solutionsPayload<ExtArgs>[]
      teams_teams_leaderIdTousers: Prisma.$teamsPayload<ExtArgs>[]
      departments_users_departmentObjIdTodepartments: Prisma.$departmentsPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs> | null
      other_users: Prisma.$usersPayload<ExtArgs>[]
      votes: Prisma.$votesPayload<ExtArgs>[]
      teams_TeamMembers: Prisma.$teamsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      role: $Enums.UserRole
      department: string | null
      avatar: string | null
      passwordHash: string | null
      createdAt: Date
      updatedAt: Date
      title: string | null
      managerId: string | null
      billableRate: number | null
      costCenter: string | null
      location: string | null
      isActive: boolean
      lastLoginAt: Date | null
      profileJson: Prisma.JsonValue | null
      targetUtilization: number | null
      utilizationRate: number | null
      departmentObjId: string | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ai_analysis_audit<T extends users$ai_analysis_auditArgs<ExtArgs> = {}>(args?: Subset<T, users$ai_analysis_auditArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_analysis_auditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ai_insight_overrides<T extends users$ai_insight_overridesArgs<ExtArgs> = {}>(args?: Subset<T, users$ai_insight_overridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_insight_overridesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    audit_logs<T extends users$audit_logsArgs<ExtArgs> = {}>(args?: Subset<T, users$audit_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends users$commentsArgs<ExtArgs> = {}>(args?: Subset<T, users$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departments_departments_managerIdTousers<T extends users$departments_departments_managerIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$departments_departments_managerIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    frd_documents_frd_documents_approvedByTousers<T extends users$frd_documents_frd_documents_approvedByTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$frd_documents_frd_documents_approvedByTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$frd_documentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    frd_documents_frd_documents_createdByTousers<T extends users$frd_documents_frd_documents_createdByTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$frd_documents_frd_documents_createdByTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$frd_documentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ideas<T extends users$ideasArgs<ExtArgs> = {}>(args?: Subset<T, users$ideasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ideasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    initiatives<T extends users$initiativesArgs<ExtArgs> = {}>(args?: Subset<T, users$initiativesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$initiativesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    input_groups<T extends users$input_groupsArgs<ExtArgs> = {}>(args?: Subset<T, users$input_groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$input_groupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inputs<T extends users$inputsArgs<ExtArgs> = {}>(args?: Subset<T, users$inputsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inputsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requirements<T extends users$requirementsArgs<ExtArgs> = {}>(args?: Subset<T, users$requirementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$requirementsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    signals<T extends users$signalsArgs<ExtArgs> = {}>(args?: Subset<T, users$signalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    solutions<T extends users$solutionsArgs<ExtArgs> = {}>(args?: Subset<T, users$solutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$solutionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teams_teams_leaderIdTousers<T extends users$teams_teams_leaderIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$teams_teams_leaderIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departments_users_departmentObjIdTodepartments<T extends users$departments_users_departmentObjIdTodepartmentsArgs<ExtArgs> = {}>(args?: Subset<T, users$departments_users_departmentObjIdTodepartmentsArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends users$usersArgs<ExtArgs> = {}>(args?: Subset<T, users$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_users<T extends users$other_usersArgs<ExtArgs> = {}>(args?: Subset<T, users$other_usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    votes<T extends users$votesArgs<ExtArgs> = {}>(args?: Subset<T, users$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teams_TeamMembers<T extends users$teams_TeamMembersArgs<ExtArgs> = {}>(args?: Subset<T, users$teams_TeamMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly name: FieldRef<"users", 'String'>
    readonly role: FieldRef<"users", 'UserRole'>
    readonly department: FieldRef<"users", 'String'>
    readonly avatar: FieldRef<"users", 'String'>
    readonly passwordHash: FieldRef<"users", 'String'>
    readonly createdAt: FieldRef<"users", 'DateTime'>
    readonly updatedAt: FieldRef<"users", 'DateTime'>
    readonly title: FieldRef<"users", 'String'>
    readonly managerId: FieldRef<"users", 'String'>
    readonly billableRate: FieldRef<"users", 'Float'>
    readonly costCenter: FieldRef<"users", 'String'>
    readonly location: FieldRef<"users", 'String'>
    readonly isActive: FieldRef<"users", 'Boolean'>
    readonly lastLoginAt: FieldRef<"users", 'DateTime'>
    readonly profileJson: FieldRef<"users", 'Json'>
    readonly targetUtilization: FieldRef<"users", 'Float'>
    readonly utilizationRate: FieldRef<"users", 'Float'>
    readonly departmentObjId: FieldRef<"users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.ai_analysis_audit
   */
  export type users$ai_analysis_auditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_analysis_audit
     */
    select?: ai_analysis_auditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_analysis_audit
     */
    omit?: ai_analysis_auditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_analysis_auditInclude<ExtArgs> | null
    where?: ai_analysis_auditWhereInput
    orderBy?: ai_analysis_auditOrderByWithRelationInput | ai_analysis_auditOrderByWithRelationInput[]
    cursor?: ai_analysis_auditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ai_analysis_auditScalarFieldEnum | Ai_analysis_auditScalarFieldEnum[]
  }

  /**
   * users.ai_insight_overrides
   */
  export type users$ai_insight_overridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_insight_overrides
     */
    select?: ai_insight_overridesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ai_insight_overrides
     */
    omit?: ai_insight_overridesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_insight_overridesInclude<ExtArgs> | null
    where?: ai_insight_overridesWhereInput
    orderBy?: ai_insight_overridesOrderByWithRelationInput | ai_insight_overridesOrderByWithRelationInput[]
    cursor?: ai_insight_overridesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ai_insight_overridesScalarFieldEnum | Ai_insight_overridesScalarFieldEnum[]
  }

  /**
   * users.audit_logs
   */
  export type users$audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    where?: audit_logsWhereInput
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    cursor?: audit_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }

  /**
   * users.comments
   */
  export type users$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    where?: commentsWhereInput
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    cursor?: commentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * users.departments_departments_managerIdTousers
   */
  export type users$departments_departments_managerIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    where?: departmentsWhereInput
    orderBy?: departmentsOrderByWithRelationInput | departmentsOrderByWithRelationInput[]
    cursor?: departmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentsScalarFieldEnum | DepartmentsScalarFieldEnum[]
  }

  /**
   * users.frd_documents_frd_documents_approvedByTousers
   */
  export type users$frd_documents_frd_documents_approvedByTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frd_documents
     */
    select?: frd_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the frd_documents
     */
    omit?: frd_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frd_documentsInclude<ExtArgs> | null
    where?: frd_documentsWhereInput
    orderBy?: frd_documentsOrderByWithRelationInput | frd_documentsOrderByWithRelationInput[]
    cursor?: frd_documentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Frd_documentsScalarFieldEnum | Frd_documentsScalarFieldEnum[]
  }

  /**
   * users.frd_documents_frd_documents_createdByTousers
   */
  export type users$frd_documents_frd_documents_createdByTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frd_documents
     */
    select?: frd_documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the frd_documents
     */
    omit?: frd_documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frd_documentsInclude<ExtArgs> | null
    where?: frd_documentsWhereInput
    orderBy?: frd_documentsOrderByWithRelationInput | frd_documentsOrderByWithRelationInput[]
    cursor?: frd_documentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Frd_documentsScalarFieldEnum | Frd_documentsScalarFieldEnum[]
  }

  /**
   * users.ideas
   */
  export type users$ideasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ideas
     */
    select?: ideasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ideas
     */
    omit?: ideasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ideasInclude<ExtArgs> | null
    where?: ideasWhereInput
    orderBy?: ideasOrderByWithRelationInput | ideasOrderByWithRelationInput[]
    cursor?: ideasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IdeasScalarFieldEnum | IdeasScalarFieldEnum[]
  }

  /**
   * users.initiatives
   */
  export type users$initiativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the initiatives
     */
    select?: initiativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the initiatives
     */
    omit?: initiativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: initiativesInclude<ExtArgs> | null
    where?: initiativesWhereInput
    orderBy?: initiativesOrderByWithRelationInput | initiativesOrderByWithRelationInput[]
    cursor?: initiativesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InitiativesScalarFieldEnum | InitiativesScalarFieldEnum[]
  }

  /**
   * users.input_groups
   */
  export type users$input_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the input_groups
     */
    select?: input_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the input_groups
     */
    omit?: input_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: input_groupsInclude<ExtArgs> | null
    where?: input_groupsWhereInput
    orderBy?: input_groupsOrderByWithRelationInput | input_groupsOrderByWithRelationInput[]
    cursor?: input_groupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Input_groupsScalarFieldEnum | Input_groupsScalarFieldEnum[]
  }

  /**
   * users.inputs
   */
  export type users$inputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inputs
     */
    select?: inputsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inputs
     */
    omit?: inputsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inputsInclude<ExtArgs> | null
    where?: inputsWhereInput
    orderBy?: inputsOrderByWithRelationInput | inputsOrderByWithRelationInput[]
    cursor?: inputsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InputsScalarFieldEnum | InputsScalarFieldEnum[]
  }

  /**
   * users.requirements
   */
  export type users$requirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requirements
     */
    select?: requirementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requirements
     */
    omit?: requirementsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requirementsInclude<ExtArgs> | null
    where?: requirementsWhereInput
    orderBy?: requirementsOrderByWithRelationInput | requirementsOrderByWithRelationInput[]
    cursor?: requirementsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequirementsScalarFieldEnum | RequirementsScalarFieldEnum[]
  }

  /**
   * users.signals
   */
  export type users$signalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: signalsInclude<ExtArgs> | null
    where?: signalsWhereInput
    orderBy?: signalsOrderByWithRelationInput | signalsOrderByWithRelationInput[]
    cursor?: signalsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SignalsScalarFieldEnum | SignalsScalarFieldEnum[]
  }

  /**
   * users.solutions
   */
  export type users$solutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the solutions
     */
    select?: solutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the solutions
     */
    omit?: solutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: solutionsInclude<ExtArgs> | null
    where?: solutionsWhereInput
    orderBy?: solutionsOrderByWithRelationInput | solutionsOrderByWithRelationInput[]
    cursor?: solutionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SolutionsScalarFieldEnum | SolutionsScalarFieldEnum[]
  }

  /**
   * users.teams_teams_leaderIdTousers
   */
  export type users$teams_teams_leaderIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teams
     */
    select?: teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teams
     */
    omit?: teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamsInclude<ExtArgs> | null
    where?: teamsWhereInput
    orderBy?: teamsOrderByWithRelationInput | teamsOrderByWithRelationInput[]
    cursor?: teamsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamsScalarFieldEnum | TeamsScalarFieldEnum[]
  }

  /**
   * users.departments_users_departmentObjIdTodepartments
   */
  export type users$departments_users_departmentObjIdTodepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    where?: departmentsWhereInput
  }

  /**
   * users.users
   */
  export type users$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * users.other_users
   */
  export type users$other_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users.votes
   */
  export type users$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the votes
     */
    omit?: votesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesInclude<ExtArgs> | null
    where?: votesWhereInput
    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]
    cursor?: votesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VotesScalarFieldEnum | VotesScalarFieldEnum[]
  }

  /**
   * users.teams_TeamMembers
   */
  export type users$teams_TeamMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teams
     */
    select?: teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teams
     */
    omit?: teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamsInclude<ExtArgs> | null
    where?: teamsWhereInput
    orderBy?: teamsOrderByWithRelationInput | teamsOrderByWithRelationInput[]
    cursor?: teamsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamsScalarFieldEnum | TeamsScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model votes
   */

  export type AggregateVotes = {
    _count: VotesCountAggregateOutputType | null
    _min: VotesMinAggregateOutputType | null
    _max: VotesMaxAggregateOutputType | null
  }

  export type VotesMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    createdBy: string | null
    entityId: string | null
    entityType: $Enums.EntityType | null
    value: $Enums.VoteValue | null
  }

  export type VotesMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    createdBy: string | null
    entityId: string | null
    entityType: $Enums.EntityType | null
    value: $Enums.VoteValue | null
  }

  export type VotesCountAggregateOutputType = {
    id: number
    createdAt: number
    createdBy: number
    entityId: number
    entityType: number
    value: number
    _all: number
  }


  export type VotesMinAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    entityId?: true
    entityType?: true
    value?: true
  }

  export type VotesMaxAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    entityId?: true
    entityType?: true
    value?: true
  }

  export type VotesCountAggregateInputType = {
    id?: true
    createdAt?: true
    createdBy?: true
    entityId?: true
    entityType?: true
    value?: true
    _all?: true
  }

  export type VotesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which votes to aggregate.
     */
    where?: votesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of votes to fetch.
     */
    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: votesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned votes
    **/
    _count?: true | VotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VotesMaxAggregateInputType
  }

  export type GetVotesAggregateType<T extends VotesAggregateArgs> = {
        [P in keyof T & keyof AggregateVotes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVotes[P]>
      : GetScalarType<T[P], AggregateVotes[P]>
  }




  export type votesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: votesWhereInput
    orderBy?: votesOrderByWithAggregationInput | votesOrderByWithAggregationInput[]
    by: VotesScalarFieldEnum[] | VotesScalarFieldEnum
    having?: votesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VotesCountAggregateInputType | true
    _min?: VotesMinAggregateInputType
    _max?: VotesMaxAggregateInputType
  }

  export type VotesGroupByOutputType = {
    id: string
    createdAt: Date
    createdBy: string
    entityId: string
    entityType: $Enums.EntityType
    value: $Enums.VoteValue
    _count: VotesCountAggregateOutputType | null
    _min: VotesMinAggregateOutputType | null
    _max: VotesMaxAggregateOutputType | null
  }

  type GetVotesGroupByPayload<T extends votesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VotesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VotesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VotesGroupByOutputType[P]>
            : GetScalarType<T[P], VotesGroupByOutputType[P]>
        }
      >
    >


  export type votesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    createdBy?: boolean
    entityId?: boolean
    entityType?: boolean
    value?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["votes"]>

  export type votesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    createdBy?: boolean
    entityId?: boolean
    entityType?: boolean
    value?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["votes"]>

  export type votesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    createdBy?: boolean
    entityId?: boolean
    entityType?: boolean
    value?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["votes"]>

  export type votesSelectScalar = {
    id?: boolean
    createdAt?: boolean
    createdBy?: boolean
    entityId?: boolean
    entityType?: boolean
    value?: boolean
  }

  export type votesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "createdBy" | "entityId" | "entityType" | "value", ExtArgs["result"]["votes"]>
  export type votesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type votesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type votesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $votesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "votes"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      createdBy: string
      entityId: string
      entityType: $Enums.EntityType
      value: $Enums.VoteValue
    }, ExtArgs["result"]["votes"]>
    composites: {}
  }

  type votesGetPayload<S extends boolean | null | undefined | votesDefaultArgs> = $Result.GetResult<Prisma.$votesPayload, S>

  type votesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<votesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VotesCountAggregateInputType | true
    }

  export interface votesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['votes'], meta: { name: 'votes' } }
    /**
     * Find zero or one Votes that matches the filter.
     * @param {votesFindUniqueArgs} args - Arguments to find a Votes
     * @example
     * // Get one Votes
     * const votes = await prisma.votes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends votesFindUniqueArgs>(args: SelectSubset<T, votesFindUniqueArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Votes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {votesFindUniqueOrThrowArgs} args - Arguments to find a Votes
     * @example
     * // Get one Votes
     * const votes = await prisma.votes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends votesFindUniqueOrThrowArgs>(args: SelectSubset<T, votesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Votes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {votesFindFirstArgs} args - Arguments to find a Votes
     * @example
     * // Get one Votes
     * const votes = await prisma.votes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends votesFindFirstArgs>(args?: SelectSubset<T, votesFindFirstArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Votes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {votesFindFirstOrThrowArgs} args - Arguments to find a Votes
     * @example
     * // Get one Votes
     * const votes = await prisma.votes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends votesFindFirstOrThrowArgs>(args?: SelectSubset<T, votesFindFirstOrThrowArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Votes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {votesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Votes
     * const votes = await prisma.votes.findMany()
     * 
     * // Get first 10 Votes
     * const votes = await prisma.votes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const votesWithIdOnly = await prisma.votes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends votesFindManyArgs>(args?: SelectSubset<T, votesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Votes.
     * @param {votesCreateArgs} args - Arguments to create a Votes.
     * @example
     * // Create one Votes
     * const Votes = await prisma.votes.create({
     *   data: {
     *     // ... data to create a Votes
     *   }
     * })
     * 
     */
    create<T extends votesCreateArgs>(args: SelectSubset<T, votesCreateArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Votes.
     * @param {votesCreateManyArgs} args - Arguments to create many Votes.
     * @example
     * // Create many Votes
     * const votes = await prisma.votes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends votesCreateManyArgs>(args?: SelectSubset<T, votesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Votes and returns the data saved in the database.
     * @param {votesCreateManyAndReturnArgs} args - Arguments to create many Votes.
     * @example
     * // Create many Votes
     * const votes = await prisma.votes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Votes and only return the `id`
     * const votesWithIdOnly = await prisma.votes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends votesCreateManyAndReturnArgs>(args?: SelectSubset<T, votesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Votes.
     * @param {votesDeleteArgs} args - Arguments to delete one Votes.
     * @example
     * // Delete one Votes
     * const Votes = await prisma.votes.delete({
     *   where: {
     *     // ... filter to delete one Votes
     *   }
     * })
     * 
     */
    delete<T extends votesDeleteArgs>(args: SelectSubset<T, votesDeleteArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Votes.
     * @param {votesUpdateArgs} args - Arguments to update one Votes.
     * @example
     * // Update one Votes
     * const votes = await prisma.votes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends votesUpdateArgs>(args: SelectSubset<T, votesUpdateArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Votes.
     * @param {votesDeleteManyArgs} args - Arguments to filter Votes to delete.
     * @example
     * // Delete a few Votes
     * const { count } = await prisma.votes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends votesDeleteManyArgs>(args?: SelectSubset<T, votesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {votesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Votes
     * const votes = await prisma.votes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends votesUpdateManyArgs>(args: SelectSubset<T, votesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Votes and returns the data updated in the database.
     * @param {votesUpdateManyAndReturnArgs} args - Arguments to update many Votes.
     * @example
     * // Update many Votes
     * const votes = await prisma.votes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Votes and only return the `id`
     * const votesWithIdOnly = await prisma.votes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends votesUpdateManyAndReturnArgs>(args: SelectSubset<T, votesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Votes.
     * @param {votesUpsertArgs} args - Arguments to update or create a Votes.
     * @example
     * // Update or create a Votes
     * const votes = await prisma.votes.upsert({
     *   create: {
     *     // ... data to create a Votes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Votes we want to update
     *   }
     * })
     */
    upsert<T extends votesUpsertArgs>(args: SelectSubset<T, votesUpsertArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {votesCountArgs} args - Arguments to filter Votes to count.
     * @example
     * // Count the number of Votes
     * const count = await prisma.votes.count({
     *   where: {
     *     // ... the filter for the Votes we want to count
     *   }
     * })
    **/
    count<T extends votesCountArgs>(
      args?: Subset<T, votesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VotesAggregateArgs>(args: Subset<T, VotesAggregateArgs>): Prisma.PrismaPromise<GetVotesAggregateType<T>>

    /**
     * Group by Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {votesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends votesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: votesGroupByArgs['orderBy'] }
        : { orderBy?: votesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, votesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVotesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the votes model
   */
  readonly fields: votesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for votes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__votesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the votes model
   */
  interface votesFieldRefs {
    readonly id: FieldRef<"votes", 'String'>
    readonly createdAt: FieldRef<"votes", 'DateTime'>
    readonly createdBy: FieldRef<"votes", 'String'>
    readonly entityId: FieldRef<"votes", 'String'>
    readonly entityType: FieldRef<"votes", 'EntityType'>
    readonly value: FieldRef<"votes", 'VoteValue'>
  }
    

  // Custom InputTypes
  /**
   * votes findUnique
   */
  export type votesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the votes
     */
    omit?: votesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesInclude<ExtArgs> | null
    /**
     * Filter, which votes to fetch.
     */
    where: votesWhereUniqueInput
  }

  /**
   * votes findUniqueOrThrow
   */
  export type votesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the votes
     */
    omit?: votesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesInclude<ExtArgs> | null
    /**
     * Filter, which votes to fetch.
     */
    where: votesWhereUniqueInput
  }

  /**
   * votes findFirst
   */
  export type votesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the votes
     */
    omit?: votesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesInclude<ExtArgs> | null
    /**
     * Filter, which votes to fetch.
     */
    where?: votesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of votes to fetch.
     */
    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for votes.
     */
    cursor?: votesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of votes.
     */
    distinct?: VotesScalarFieldEnum | VotesScalarFieldEnum[]
  }

  /**
   * votes findFirstOrThrow
   */
  export type votesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the votes
     */
    omit?: votesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesInclude<ExtArgs> | null
    /**
     * Filter, which votes to fetch.
     */
    where?: votesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of votes to fetch.
     */
    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for votes.
     */
    cursor?: votesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of votes.
     */
    distinct?: VotesScalarFieldEnum | VotesScalarFieldEnum[]
  }

  /**
   * votes findMany
   */
  export type votesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the votes
     */
    omit?: votesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesInclude<ExtArgs> | null
    /**
     * Filter, which votes to fetch.
     */
    where?: votesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of votes to fetch.
     */
    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing votes.
     */
    cursor?: votesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` votes.
     */
    skip?: number
    distinct?: VotesScalarFieldEnum | VotesScalarFieldEnum[]
  }

  /**
   * votes create
   */
  export type votesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the votes
     */
    omit?: votesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesInclude<ExtArgs> | null
    /**
     * The data needed to create a votes.
     */
    data: XOR<votesCreateInput, votesUncheckedCreateInput>
  }

  /**
   * votes createMany
   */
  export type votesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many votes.
     */
    data: votesCreateManyInput | votesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * votes createManyAndReturn
   */
  export type votesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the votes
     */
    omit?: votesOmit<ExtArgs> | null
    /**
     * The data used to create many votes.
     */
    data: votesCreateManyInput | votesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * votes update
   */
  export type votesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the votes
     */
    omit?: votesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesInclude<ExtArgs> | null
    /**
     * The data needed to update a votes.
     */
    data: XOR<votesUpdateInput, votesUncheckedUpdateInput>
    /**
     * Choose, which votes to update.
     */
    where: votesWhereUniqueInput
  }

  /**
   * votes updateMany
   */
  export type votesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update votes.
     */
    data: XOR<votesUpdateManyMutationInput, votesUncheckedUpdateManyInput>
    /**
     * Filter which votes to update
     */
    where?: votesWhereInput
    /**
     * Limit how many votes to update.
     */
    limit?: number
  }

  /**
   * votes updateManyAndReturn
   */
  export type votesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the votes
     */
    omit?: votesOmit<ExtArgs> | null
    /**
     * The data used to update votes.
     */
    data: XOR<votesUpdateManyMutationInput, votesUncheckedUpdateManyInput>
    /**
     * Filter which votes to update
     */
    where?: votesWhereInput
    /**
     * Limit how many votes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * votes upsert
   */
  export type votesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the votes
     */
    omit?: votesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesInclude<ExtArgs> | null
    /**
     * The filter to search for the votes to update in case it exists.
     */
    where: votesWhereUniqueInput
    /**
     * In case the votes found by the `where` argument doesn't exist, create a new votes with this data.
     */
    create: XOR<votesCreateInput, votesUncheckedCreateInput>
    /**
     * In case the votes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<votesUpdateInput, votesUncheckedUpdateInput>
  }

  /**
   * votes delete
   */
  export type votesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the votes
     */
    omit?: votesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesInclude<ExtArgs> | null
    /**
     * Filter which votes to delete.
     */
    where: votesWhereUniqueInput
  }

  /**
   * votes deleteMany
   */
  export type votesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which votes to delete
     */
    where?: votesWhereInput
    /**
     * Limit how many votes to delete.
     */
    limit?: number
  }

  /**
   * votes without action
   */
  export type votesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the votes
     */
    select?: votesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the votes
     */
    omit?: votesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: votesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const InputToInputGroupScalarFieldEnum: {
    A: 'A',
    B: 'B'
  };

  export type InputToInputGroupScalarFieldEnum = (typeof InputToInputGroupScalarFieldEnum)[keyof typeof InputToInputGroupScalarFieldEnum]


  export const Ai_analysis_auditScalarFieldEnum: {
    id: 'id',
    hotspotId: 'hotspotId',
    analysisType: 'analysisType',
    userId: 'userId',
    requestData: 'requestData',
    responseData: 'responseData',
    processingTime: 'processingTime',
    confidence: 'confidence',
    status: 'status',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt'
  };

  export type Ai_analysis_auditScalarFieldEnum = (typeof Ai_analysis_auditScalarFieldEnum)[keyof typeof Ai_analysis_auditScalarFieldEnum]


  export const Ai_insight_overridesScalarFieldEnum: {
    id: 'id',
    signalId: 'signalId',
    insightId: 'insightId',
    insightType: 'insightType',
    originalRecommendation: 'originalRecommendation',
    overrideReason: 'overrideReason',
    executiveJustification: 'executiveJustification',
    newValue: 'newValue',
    executiveId: 'executiveId',
    executiveName: 'executiveName',
    executiveEmail: 'executiveEmail',
    overriddenAt: 'overriddenAt',
    createdAt: 'createdAt'
  };

  export type Ai_insight_overridesScalarFieldEnum = (typeof Ai_insight_overridesScalarFieldEnum)[keyof typeof Ai_insight_overridesScalarFieldEnum]


  export const Audit_logsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    changes: 'changes',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    sessionId: 'sessionId'
  };

  export type Audit_logsScalarFieldEnum = (typeof Audit_logsScalarFieldEnum)[keyof typeof Audit_logsScalarFieldEnum]


  export const CategoriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    color: 'color',
    icon: 'icon',
    parentId: 'parentId',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    usageCount: 'usageCount',
    isSystem: 'isSystem',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoriesScalarFieldEnum = (typeof CategoriesScalarFieldEnum)[keyof typeof CategoriesScalarFieldEnum]


  export const CommentsScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    parentId: 'parentId',
    createdBy: 'createdBy',
    edited: 'edited',
    editedAt: 'editedAt',
    entityId: 'entityId',
    entityType: 'entityType',
    mentions: 'mentions'
  };

  export type CommentsScalarFieldEnum = (typeof CommentsScalarFieldEnum)[keyof typeof CommentsScalarFieldEnum]


  export const DepartmentsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    headCount: 'headCount',
    budgetAllocation: 'budgetAllocation',
    managerId: 'managerId',
    costCenter: 'costCenter',
    location: 'location',
    isActive: 'isActive',
    utilizationTarget: 'utilizationTarget',
    actualUtilization: 'actualUtilization',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentsScalarFieldEnum = (typeof DepartmentsScalarFieldEnum)[keyof typeof DepartmentsScalarFieldEnum]


  export const Frd_documentsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    aiGenerated: 'aiGenerated',
    aiConfidence: 'aiConfidence',
    aiPromptUsed: 'aiPromptUsed',
    version: 'version',
    status: 'status',
    executiveApproved: 'executiveApproved',
    exportFormats: 'exportFormats',
    templateUsed: 'templateUsed',
    generationTime: 'generationTime',
    wordCount: 'wordCount',
    lastExportedAt: 'lastExportedAt',
    solutionId: 'solutionId',
    createdBy: 'createdBy',
    approvedBy: 'approvedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Frd_documentsScalarFieldEnum = (typeof Frd_documentsScalarFieldEnum)[keyof typeof Frd_documentsScalarFieldEnum]


  export const Hotspot_signalsScalarFieldEnum: {
    hotspotId: 'hotspotId',
    signalId: 'signalId',
    membershipStrength: 'membershipStrength',
    isOutlier: 'isOutlier',
    addedAt: 'addedAt'
  };

  export type Hotspot_signalsScalarFieldEnum = (typeof Hotspot_signalsScalarFieldEnum)[keyof typeof Hotspot_signalsScalarFieldEnum]


  export const HotspotsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    summary: 'summary',
    status: 'status',
    rankScore: 'rankScore',
    confidence: 'confidence',
    primaryCategoryId: 'primaryCategoryId',
    linkedEntitiesJson: 'linkedEntitiesJson',
    clusteringMethod: 'clusteringMethod',
    similarityThreshold: 'similarityThreshold',
    rcaBreakdownJson: 'rcaBreakdownJson',
    solutionSuggestionsJson: 'solutionSuggestionsJson',
    decisionMatrixJson: 'decisionMatrixJson',
    crossFunctionalImpactJson: 'crossFunctionalImpactJson',
    lastAnalysisAt: 'lastAnalysisAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clusteringQualityScore: 'clusteringQualityScore',
    clusteringResults: 'clusteringResults',
    clusteringVersion: 'clusteringVersion',
    lastClusteredAt: 'lastClusteredAt'
  };

  export type HotspotsScalarFieldEnum = (typeof HotspotsScalarFieldEnum)[keyof typeof HotspotsScalarFieldEnum]


  export const IdeasScalarFieldEnum: {
    id: 'id',
    hotspotId: 'hotspotId',
    title: 'title',
    description: 'description',
    origin: 'origin',
    votes: 'votes',
    status: 'status',
    evidenceJson: 'evidenceJson',
    tagsJson: 'tagsJson',
    confidence: 'confidence',
    createdById: 'createdById',
    initiativeId: 'initiativeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IdeasScalarFieldEnum = (typeof IdeasScalarFieldEnum)[keyof typeof IdeasScalarFieldEnum]


  export const InitiativesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    priority: 'priority',
    ownerId: 'ownerId',
    budget: 'budget',
    actualSpend: 'actualSpend',
    startDate: 'startDate',
    targetDate: 'targetDate',
    completionDate: 'completionDate',
    expectedROI: 'expectedROI',
    actualROI: 'actualROI',
    riskLevel: 'riskLevel',
    goalJson: 'goalJson',
    roiJson: 'roiJson',
    milestonesJson: 'milestonesJson',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InitiativesScalarFieldEnum = (typeof InitiativesScalarFieldEnum)[keyof typeof InitiativesScalarFieldEnum]


  export const Input_groupsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    aiSuggested: 'aiSuggested',
    aiConfidence: 'aiConfidence',
    aiReasoning: 'aiReasoning',
    avgPriority: 'avgPriority',
    color: 'color',
    createdBy: 'createdBy',
    inputCount: 'inputCount',
    lastActivity: 'lastActivity'
  };

  export type Input_groupsScalarFieldEnum = (typeof Input_groupsScalarFieldEnum)[keyof typeof Input_groupsScalarFieldEnum]


  export const InputsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    type: 'type',
    status: 'status',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    department: 'department',
    rootCause: 'rootCause',
    aiTags: 'aiTags',
    aiSuggestions: 'aiSuggestions',
    aiConfidence: 'aiConfidence',
    issueType: 'issueType',
    priority: 'priority'
  };

  export type InputsScalarFieldEnum = (typeof InputsScalarFieldEnum)[keyof typeof InputsScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    readAt: 'readAt',
    createdAt: 'createdAt',
    delivered: 'delivered',
    entityId: 'entityId',
    entityType: 'entityType',
    read: 'read'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const RequirementsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    acceptanceCriteria: 'acceptanceCriteria',
    status: 'status',
    estimatedEffort: 'estimatedEffort',
    dependencies: 'dependencies',
    businessValue: 'businessValue',
    riskAssessment: 'riskAssessment',
    stakeholders: 'stakeholders',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    rejectionReason: 'rejectionReason',
    solutionId: 'solutionId',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    priority: 'priority'
  };

  export type RequirementsScalarFieldEnum = (typeof RequirementsScalarFieldEnum)[keyof typeof RequirementsScalarFieldEnum]


  export const SignalsScalarFieldEnum: {
    id: 'id',
    inputId: 'inputId',
    timestamp: 'timestamp',
    receivedAt: 'receivedAt',
    schemaVersion: 'schemaVersion',
    sourceJson: 'sourceJson',
    confidence: 'confidence',
    attachmentsJson: 'attachmentsJson',
    sourceType: 'sourceType',
    sourceId: 'sourceId',
    systemName: 'systemName',
    title: 'title',
    description: 'description',
    severity: 'severity',
    severityScore: 'severityScore',
    departmentId: 'departmentId',
    teamId: 'teamId',
    categoryId: 'categoryId',
    metricsJson: 'metricsJson',
    baselineJson: 'baselineJson',
    impactJson: 'impactJson',
    tagsJson: 'tagsJson',
    entitiesJson: 'entitiesJson',
    privacyLevel: 'privacyLevel',
    dedupeKey: 'dedupeKey',
    embedding: 'embedding',
    aiProcessed: 'aiProcessed',
    aiTagsJson: 'aiTagsJson',
    lineageJson: 'lineageJson',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    domainClassification: 'domainClassification',
    enhancedTagsJson: 'enhancedTagsJson',
    lastTaggedAt: 'lastTaggedAt',
    tagGenerationMeta: 'tagGenerationMeta',
    tagModelVersion: 'tagModelVersion',
    clusteringFeaturesJson: 'clusteringFeaturesJson',
    featuresQualityScore: 'featuresQualityScore',
    featuresVersion: 'featuresVersion',
    lastFeaturesGeneratedAt: 'lastFeaturesGeneratedAt'
  };

  export type SignalsScalarFieldEnum = (typeof SignalsScalarFieldEnum)[keyof typeof SignalsScalarFieldEnum]


  export const SolutionsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    estimatedEffort: 'estimatedEffort',
    actualCompletionDate: 'actualCompletionDate',
    actualImpactJson: 'actualImpactJson',
    businessValue: 'businessValue',
    createdBy: 'createdBy',
    expectedImpactJson: 'expectedImpactJson',
    hotspotId: 'hotspotId',
    ideaId: 'ideaId',
    initiativeId: 'initiativeId',
    inputId: 'inputId',
    progress: 'progress',
    successMetrics: 'successMetrics',
    targetDate: 'targetDate',
    tasks: 'tasks'
  };

  export type SolutionsScalarFieldEnum = (typeof SolutionsScalarFieldEnum)[keyof typeof SolutionsScalarFieldEnum]


  export const TeamsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    departmentId: 'departmentId',
    leaderId: 'leaderId',
    memberCount: 'memberCount',
    maxCapacity: 'maxCapacity',
    isActive: 'isActive',
    teamType: 'teamType',
    currentProjects: 'currentProjects',
    budgetAllocation: 'budgetAllocation',
    utilizationRate: 'utilizationRate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamsScalarFieldEnum = (typeof TeamsScalarFieldEnum)[keyof typeof TeamsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    role: 'role',
    department: 'department',
    avatar: 'avatar',
    passwordHash: 'passwordHash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    title: 'title',
    managerId: 'managerId',
    billableRate: 'billableRate',
    costCenter: 'costCenter',
    location: 'location',
    isActive: 'isActive',
    lastLoginAt: 'lastLoginAt',
    profileJson: 'profileJson',
    targetUtilization: 'targetUtilization',
    utilizationRate: 'utilizationRate',
    departmentObjId: 'departmentObjId'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const VotesScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    entityId: 'entityId',
    entityType: 'entityType',
    value: 'value'
  };

  export type VotesScalarFieldEnum = (typeof VotesScalarFieldEnum)[keyof typeof VotesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'EntityType'
   */
  export type EnumEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntityType'>
    


  /**
   * Reference to a field of type 'EntityType[]'
   */
  export type ListEnumEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntityType[]'>
    


  /**
   * Reference to a field of type 'FRDStatus'
   */
  export type EnumFRDStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FRDStatus'>
    


  /**
   * Reference to a field of type 'FRDStatus[]'
   */
  export type ListEnumFRDStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FRDStatus[]'>
    


  /**
   * Reference to a field of type 'HotspotStatus'
   */
  export type EnumHotspotStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HotspotStatus'>
    


  /**
   * Reference to a field of type 'HotspotStatus[]'
   */
  export type ListEnumHotspotStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HotspotStatus[]'>
    


  /**
   * Reference to a field of type 'initiative_status'
   */
  export type Enuminitiative_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'initiative_status'>
    


  /**
   * Reference to a field of type 'initiative_status[]'
   */
  export type ListEnuminitiative_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'initiative_status[]'>
    


  /**
   * Reference to a field of type 'priority'
   */
  export type EnumpriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'priority'>
    


  /**
   * Reference to a field of type 'priority[]'
   */
  export type ListEnumpriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'priority[]'>
    


  /**
   * Reference to a field of type 'risk_level'
   */
  export type Enumrisk_levelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'risk_level'>
    


  /**
   * Reference to a field of type 'risk_level[]'
   */
  export type ListEnumrisk_levelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'risk_level[]'>
    


  /**
   * Reference to a field of type 'InputType'
   */
  export type EnumInputTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InputType'>
    


  /**
   * Reference to a field of type 'InputType[]'
   */
  export type ListEnumInputTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InputType[]'>
    


  /**
   * Reference to a field of type 'InputStatus'
   */
  export type EnumInputStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InputStatus'>
    


  /**
   * Reference to a field of type 'InputStatus[]'
   */
  export type ListEnumInputStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InputStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'RequirementStatus'
   */
  export type EnumRequirementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequirementStatus'>
    


  /**
   * Reference to a field of type 'RequirementStatus[]'
   */
  export type ListEnumRequirementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequirementStatus[]'>
    


  /**
   * Reference to a field of type 'Severity'
   */
  export type EnumSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Severity'>
    


  /**
   * Reference to a field of type 'Severity[]'
   */
  export type ListEnumSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Severity[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'SolutionStatus'
   */
  export type EnumSolutionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SolutionStatus'>
    


  /**
   * Reference to a field of type 'SolutionStatus[]'
   */
  export type ListEnumSolutionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SolutionStatus[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'VoteValue'
   */
  export type EnumVoteValueFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoteValue'>
    


  /**
   * Reference to a field of type 'VoteValue[]'
   */
  export type ListEnumVoteValueFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoteValue[]'>
    
  /**
   * Deep Input Types
   */


  export type InputToInputGroupWhereInput = {
    AND?: InputToInputGroupWhereInput | InputToInputGroupWhereInput[]
    OR?: InputToInputGroupWhereInput[]
    NOT?: InputToInputGroupWhereInput | InputToInputGroupWhereInput[]
    A?: StringFilter<"InputToInputGroup"> | string
    B?: StringFilter<"InputToInputGroup"> | string
    inputs?: XOR<InputsScalarRelationFilter, inputsWhereInput>
    input_groups?: XOR<Input_groupsScalarRelationFilter, input_groupsWhereInput>
  }

  export type InputToInputGroupOrderByWithRelationInput = {
    A?: SortOrder
    B?: SortOrder
    inputs?: inputsOrderByWithRelationInput
    input_groups?: input_groupsOrderByWithRelationInput
  }

  export type InputToInputGroupWhereUniqueInput = Prisma.AtLeast<{
    A_B?: InputToInputGroupABCompoundUniqueInput
    AND?: InputToInputGroupWhereInput | InputToInputGroupWhereInput[]
    OR?: InputToInputGroupWhereInput[]
    NOT?: InputToInputGroupWhereInput | InputToInputGroupWhereInput[]
    A?: StringFilter<"InputToInputGroup"> | string
    B?: StringFilter<"InputToInputGroup"> | string
    inputs?: XOR<InputsScalarRelationFilter, inputsWhereInput>
    input_groups?: XOR<Input_groupsScalarRelationFilter, input_groupsWhereInput>
  }, "A_B">

  export type InputToInputGroupOrderByWithAggregationInput = {
    A?: SortOrder
    B?: SortOrder
    _count?: InputToInputGroupCountOrderByAggregateInput
    _max?: InputToInputGroupMaxOrderByAggregateInput
    _min?: InputToInputGroupMinOrderByAggregateInput
  }

  export type InputToInputGroupScalarWhereWithAggregatesInput = {
    AND?: InputToInputGroupScalarWhereWithAggregatesInput | InputToInputGroupScalarWhereWithAggregatesInput[]
    OR?: InputToInputGroupScalarWhereWithAggregatesInput[]
    NOT?: InputToInputGroupScalarWhereWithAggregatesInput | InputToInputGroupScalarWhereWithAggregatesInput[]
    A?: StringWithAggregatesFilter<"InputToInputGroup"> | string
    B?: StringWithAggregatesFilter<"InputToInputGroup"> | string
  }

  export type ai_analysis_auditWhereInput = {
    AND?: ai_analysis_auditWhereInput | ai_analysis_auditWhereInput[]
    OR?: ai_analysis_auditWhereInput[]
    NOT?: ai_analysis_auditWhereInput | ai_analysis_auditWhereInput[]
    id?: StringFilter<"ai_analysis_audit"> | string
    hotspotId?: StringFilter<"ai_analysis_audit"> | string
    analysisType?: StringFilter<"ai_analysis_audit"> | string
    userId?: StringFilter<"ai_analysis_audit"> | string
    requestData?: JsonNullableFilter<"ai_analysis_audit">
    responseData?: JsonNullableFilter<"ai_analysis_audit">
    processingTime?: IntNullableFilter<"ai_analysis_audit"> | number | null
    confidence?: FloatNullableFilter<"ai_analysis_audit"> | number | null
    status?: StringFilter<"ai_analysis_audit"> | string
    errorMessage?: StringNullableFilter<"ai_analysis_audit"> | string | null
    createdAt?: DateTimeFilter<"ai_analysis_audit"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type ai_analysis_auditOrderByWithRelationInput = {
    id?: SortOrder
    hotspotId?: SortOrder
    analysisType?: SortOrder
    userId?: SortOrder
    requestData?: SortOrderInput | SortOrder
    responseData?: SortOrderInput | SortOrder
    processingTime?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type ai_analysis_auditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ai_analysis_auditWhereInput | ai_analysis_auditWhereInput[]
    OR?: ai_analysis_auditWhereInput[]
    NOT?: ai_analysis_auditWhereInput | ai_analysis_auditWhereInput[]
    hotspotId?: StringFilter<"ai_analysis_audit"> | string
    analysisType?: StringFilter<"ai_analysis_audit"> | string
    userId?: StringFilter<"ai_analysis_audit"> | string
    requestData?: JsonNullableFilter<"ai_analysis_audit">
    responseData?: JsonNullableFilter<"ai_analysis_audit">
    processingTime?: IntNullableFilter<"ai_analysis_audit"> | number | null
    confidence?: FloatNullableFilter<"ai_analysis_audit"> | number | null
    status?: StringFilter<"ai_analysis_audit"> | string
    errorMessage?: StringNullableFilter<"ai_analysis_audit"> | string | null
    createdAt?: DateTimeFilter<"ai_analysis_audit"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type ai_analysis_auditOrderByWithAggregationInput = {
    id?: SortOrder
    hotspotId?: SortOrder
    analysisType?: SortOrder
    userId?: SortOrder
    requestData?: SortOrderInput | SortOrder
    responseData?: SortOrderInput | SortOrder
    processingTime?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ai_analysis_auditCountOrderByAggregateInput
    _avg?: ai_analysis_auditAvgOrderByAggregateInput
    _max?: ai_analysis_auditMaxOrderByAggregateInput
    _min?: ai_analysis_auditMinOrderByAggregateInput
    _sum?: ai_analysis_auditSumOrderByAggregateInput
  }

  export type ai_analysis_auditScalarWhereWithAggregatesInput = {
    AND?: ai_analysis_auditScalarWhereWithAggregatesInput | ai_analysis_auditScalarWhereWithAggregatesInput[]
    OR?: ai_analysis_auditScalarWhereWithAggregatesInput[]
    NOT?: ai_analysis_auditScalarWhereWithAggregatesInput | ai_analysis_auditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ai_analysis_audit"> | string
    hotspotId?: StringWithAggregatesFilter<"ai_analysis_audit"> | string
    analysisType?: StringWithAggregatesFilter<"ai_analysis_audit"> | string
    userId?: StringWithAggregatesFilter<"ai_analysis_audit"> | string
    requestData?: JsonNullableWithAggregatesFilter<"ai_analysis_audit">
    responseData?: JsonNullableWithAggregatesFilter<"ai_analysis_audit">
    processingTime?: IntNullableWithAggregatesFilter<"ai_analysis_audit"> | number | null
    confidence?: FloatNullableWithAggregatesFilter<"ai_analysis_audit"> | number | null
    status?: StringWithAggregatesFilter<"ai_analysis_audit"> | string
    errorMessage?: StringNullableWithAggregatesFilter<"ai_analysis_audit"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ai_analysis_audit"> | Date | string
  }

  export type ai_insight_overridesWhereInput = {
    AND?: ai_insight_overridesWhereInput | ai_insight_overridesWhereInput[]
    OR?: ai_insight_overridesWhereInput[]
    NOT?: ai_insight_overridesWhereInput | ai_insight_overridesWhereInput[]
    id?: StringFilter<"ai_insight_overrides"> | string
    signalId?: StringFilter<"ai_insight_overrides"> | string
    insightId?: StringFilter<"ai_insight_overrides"> | string
    insightType?: StringFilter<"ai_insight_overrides"> | string
    originalRecommendation?: JsonNullableFilter<"ai_insight_overrides">
    overrideReason?: StringFilter<"ai_insight_overrides"> | string
    executiveJustification?: StringNullableFilter<"ai_insight_overrides"> | string | null
    newValue?: JsonNullableFilter<"ai_insight_overrides">
    executiveId?: StringFilter<"ai_insight_overrides"> | string
    executiveName?: StringFilter<"ai_insight_overrides"> | string
    executiveEmail?: StringFilter<"ai_insight_overrides"> | string
    overriddenAt?: DateTimeFilter<"ai_insight_overrides"> | Date | string
    createdAt?: DateTimeFilter<"ai_insight_overrides"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    signals?: XOR<SignalsScalarRelationFilter, signalsWhereInput>
  }

  export type ai_insight_overridesOrderByWithRelationInput = {
    id?: SortOrder
    signalId?: SortOrder
    insightId?: SortOrder
    insightType?: SortOrder
    originalRecommendation?: SortOrderInput | SortOrder
    overrideReason?: SortOrder
    executiveJustification?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    executiveId?: SortOrder
    executiveName?: SortOrder
    executiveEmail?: SortOrder
    overriddenAt?: SortOrder
    createdAt?: SortOrder
    users?: usersOrderByWithRelationInput
    signals?: signalsOrderByWithRelationInput
  }

  export type ai_insight_overridesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ai_insight_overridesWhereInput | ai_insight_overridesWhereInput[]
    OR?: ai_insight_overridesWhereInput[]
    NOT?: ai_insight_overridesWhereInput | ai_insight_overridesWhereInput[]
    signalId?: StringFilter<"ai_insight_overrides"> | string
    insightId?: StringFilter<"ai_insight_overrides"> | string
    insightType?: StringFilter<"ai_insight_overrides"> | string
    originalRecommendation?: JsonNullableFilter<"ai_insight_overrides">
    overrideReason?: StringFilter<"ai_insight_overrides"> | string
    executiveJustification?: StringNullableFilter<"ai_insight_overrides"> | string | null
    newValue?: JsonNullableFilter<"ai_insight_overrides">
    executiveId?: StringFilter<"ai_insight_overrides"> | string
    executiveName?: StringFilter<"ai_insight_overrides"> | string
    executiveEmail?: StringFilter<"ai_insight_overrides"> | string
    overriddenAt?: DateTimeFilter<"ai_insight_overrides"> | Date | string
    createdAt?: DateTimeFilter<"ai_insight_overrides"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    signals?: XOR<SignalsScalarRelationFilter, signalsWhereInput>
  }, "id">

  export type ai_insight_overridesOrderByWithAggregationInput = {
    id?: SortOrder
    signalId?: SortOrder
    insightId?: SortOrder
    insightType?: SortOrder
    originalRecommendation?: SortOrderInput | SortOrder
    overrideReason?: SortOrder
    executiveJustification?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    executiveId?: SortOrder
    executiveName?: SortOrder
    executiveEmail?: SortOrder
    overriddenAt?: SortOrder
    createdAt?: SortOrder
    _count?: ai_insight_overridesCountOrderByAggregateInput
    _max?: ai_insight_overridesMaxOrderByAggregateInput
    _min?: ai_insight_overridesMinOrderByAggregateInput
  }

  export type ai_insight_overridesScalarWhereWithAggregatesInput = {
    AND?: ai_insight_overridesScalarWhereWithAggregatesInput | ai_insight_overridesScalarWhereWithAggregatesInput[]
    OR?: ai_insight_overridesScalarWhereWithAggregatesInput[]
    NOT?: ai_insight_overridesScalarWhereWithAggregatesInput | ai_insight_overridesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ai_insight_overrides"> | string
    signalId?: StringWithAggregatesFilter<"ai_insight_overrides"> | string
    insightId?: StringWithAggregatesFilter<"ai_insight_overrides"> | string
    insightType?: StringWithAggregatesFilter<"ai_insight_overrides"> | string
    originalRecommendation?: JsonNullableWithAggregatesFilter<"ai_insight_overrides">
    overrideReason?: StringWithAggregatesFilter<"ai_insight_overrides"> | string
    executiveJustification?: StringNullableWithAggregatesFilter<"ai_insight_overrides"> | string | null
    newValue?: JsonNullableWithAggregatesFilter<"ai_insight_overrides">
    executiveId?: StringWithAggregatesFilter<"ai_insight_overrides"> | string
    executiveName?: StringWithAggregatesFilter<"ai_insight_overrides"> | string
    executiveEmail?: StringWithAggregatesFilter<"ai_insight_overrides"> | string
    overriddenAt?: DateTimeWithAggregatesFilter<"ai_insight_overrides"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ai_insight_overrides"> | Date | string
  }

  export type audit_logsWhereInput = {
    AND?: audit_logsWhereInput | audit_logsWhereInput[]
    OR?: audit_logsWhereInput[]
    NOT?: audit_logsWhereInput | audit_logsWhereInput[]
    id?: StringFilter<"audit_logs"> | string
    userId?: StringFilter<"audit_logs"> | string
    action?: StringFilter<"audit_logs"> | string
    entityType?: StringFilter<"audit_logs"> | string
    entityId?: StringFilter<"audit_logs"> | string
    changes?: JsonNullableFilter<"audit_logs">
    ipAddress?: StringNullableFilter<"audit_logs"> | string | null
    userAgent?: StringNullableFilter<"audit_logs"> | string | null
    createdAt?: DateTimeFilter<"audit_logs"> | Date | string
    sessionId?: StringNullableFilter<"audit_logs"> | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type audit_logsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type audit_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: audit_logsWhereInput | audit_logsWhereInput[]
    OR?: audit_logsWhereInput[]
    NOT?: audit_logsWhereInput | audit_logsWhereInput[]
    userId?: StringFilter<"audit_logs"> | string
    action?: StringFilter<"audit_logs"> | string
    entityType?: StringFilter<"audit_logs"> | string
    entityId?: StringFilter<"audit_logs"> | string
    changes?: JsonNullableFilter<"audit_logs">
    ipAddress?: StringNullableFilter<"audit_logs"> | string | null
    userAgent?: StringNullableFilter<"audit_logs"> | string | null
    createdAt?: DateTimeFilter<"audit_logs"> | Date | string
    sessionId?: StringNullableFilter<"audit_logs"> | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type audit_logsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    _count?: audit_logsCountOrderByAggregateInput
    _max?: audit_logsMaxOrderByAggregateInput
    _min?: audit_logsMinOrderByAggregateInput
  }

  export type audit_logsScalarWhereWithAggregatesInput = {
    AND?: audit_logsScalarWhereWithAggregatesInput | audit_logsScalarWhereWithAggregatesInput[]
    OR?: audit_logsScalarWhereWithAggregatesInput[]
    NOT?: audit_logsScalarWhereWithAggregatesInput | audit_logsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"audit_logs"> | string
    userId?: StringWithAggregatesFilter<"audit_logs"> | string
    action?: StringWithAggregatesFilter<"audit_logs"> | string
    entityType?: StringWithAggregatesFilter<"audit_logs"> | string
    entityId?: StringWithAggregatesFilter<"audit_logs"> | string
    changes?: JsonNullableWithAggregatesFilter<"audit_logs">
    ipAddress?: StringNullableWithAggregatesFilter<"audit_logs"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"audit_logs"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"audit_logs"> | Date | string
    sessionId?: StringNullableWithAggregatesFilter<"audit_logs"> | string | null
  }

  export type categoriesWhereInput = {
    AND?: categoriesWhereInput | categoriesWhereInput[]
    OR?: categoriesWhereInput[]
    NOT?: categoriesWhereInput | categoriesWhereInput[]
    id?: StringFilter<"categories"> | string
    name?: StringFilter<"categories"> | string
    description?: StringNullableFilter<"categories"> | string | null
    color?: StringNullableFilter<"categories"> | string | null
    icon?: StringNullableFilter<"categories"> | string | null
    parentId?: StringNullableFilter<"categories"> | string | null
    isActive?: BoolFilter<"categories"> | boolean
    sortOrder?: IntFilter<"categories"> | number
    usageCount?: IntFilter<"categories"> | number
    isSystem?: BoolFilter<"categories"> | boolean
    createdAt?: DateTimeFilter<"categories"> | Date | string
    updatedAt?: DateTimeFilter<"categories"> | Date | string
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    other_categories?: CategoriesListRelationFilter
    signals?: SignalsListRelationFilter
  }

  export type categoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    usageCount?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categories?: categoriesOrderByWithRelationInput
    other_categories?: categoriesOrderByRelationAggregateInput
    signals?: signalsOrderByRelationAggregateInput
  }

  export type categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: categoriesWhereInput | categoriesWhereInput[]
    OR?: categoriesWhereInput[]
    NOT?: categoriesWhereInput | categoriesWhereInput[]
    description?: StringNullableFilter<"categories"> | string | null
    color?: StringNullableFilter<"categories"> | string | null
    icon?: StringNullableFilter<"categories"> | string | null
    parentId?: StringNullableFilter<"categories"> | string | null
    isActive?: BoolFilter<"categories"> | boolean
    sortOrder?: IntFilter<"categories"> | number
    usageCount?: IntFilter<"categories"> | number
    isSystem?: BoolFilter<"categories"> | boolean
    createdAt?: DateTimeFilter<"categories"> | Date | string
    updatedAt?: DateTimeFilter<"categories"> | Date | string
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    other_categories?: CategoriesListRelationFilter
    signals?: SignalsListRelationFilter
  }, "id" | "name">

  export type categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    usageCount?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: categoriesCountOrderByAggregateInput
    _avg?: categoriesAvgOrderByAggregateInput
    _max?: categoriesMaxOrderByAggregateInput
    _min?: categoriesMinOrderByAggregateInput
    _sum?: categoriesSumOrderByAggregateInput
  }

  export type categoriesScalarWhereWithAggregatesInput = {
    AND?: categoriesScalarWhereWithAggregatesInput | categoriesScalarWhereWithAggregatesInput[]
    OR?: categoriesScalarWhereWithAggregatesInput[]
    NOT?: categoriesScalarWhereWithAggregatesInput | categoriesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"categories"> | string
    name?: StringWithAggregatesFilter<"categories"> | string
    description?: StringNullableWithAggregatesFilter<"categories"> | string | null
    color?: StringNullableWithAggregatesFilter<"categories"> | string | null
    icon?: StringNullableWithAggregatesFilter<"categories"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"categories"> | string | null
    isActive?: BoolWithAggregatesFilter<"categories"> | boolean
    sortOrder?: IntWithAggregatesFilter<"categories"> | number
    usageCount?: IntWithAggregatesFilter<"categories"> | number
    isSystem?: BoolWithAggregatesFilter<"categories"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"categories"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"categories"> | Date | string
  }

  export type commentsWhereInput = {
    AND?: commentsWhereInput | commentsWhereInput[]
    OR?: commentsWhereInput[]
    NOT?: commentsWhereInput | commentsWhereInput[]
    id?: StringFilter<"comments"> | string
    content?: StringFilter<"comments"> | string
    createdAt?: DateTimeFilter<"comments"> | Date | string
    updatedAt?: DateTimeFilter<"comments"> | Date | string
    parentId?: StringNullableFilter<"comments"> | string | null
    createdBy?: StringFilter<"comments"> | string
    edited?: BoolFilter<"comments"> | boolean
    editedAt?: DateTimeNullableFilter<"comments"> | Date | string | null
    entityId?: StringFilter<"comments"> | string
    entityType?: EnumEntityTypeFilter<"comments"> | $Enums.EntityType
    mentions?: JsonNullableFilter<"comments">
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    comments?: XOR<CommentsNullableScalarRelationFilter, commentsWhereInput> | null
    other_comments?: CommentsListRelationFilter
  }

  export type commentsOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    edited?: SortOrder
    editedAt?: SortOrderInput | SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    mentions?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
    comments?: commentsOrderByWithRelationInput
    other_comments?: commentsOrderByRelationAggregateInput
  }

  export type commentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: commentsWhereInput | commentsWhereInput[]
    OR?: commentsWhereInput[]
    NOT?: commentsWhereInput | commentsWhereInput[]
    content?: StringFilter<"comments"> | string
    createdAt?: DateTimeFilter<"comments"> | Date | string
    updatedAt?: DateTimeFilter<"comments"> | Date | string
    parentId?: StringNullableFilter<"comments"> | string | null
    createdBy?: StringFilter<"comments"> | string
    edited?: BoolFilter<"comments"> | boolean
    editedAt?: DateTimeNullableFilter<"comments"> | Date | string | null
    entityId?: StringFilter<"comments"> | string
    entityType?: EnumEntityTypeFilter<"comments"> | $Enums.EntityType
    mentions?: JsonNullableFilter<"comments">
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    comments?: XOR<CommentsNullableScalarRelationFilter, commentsWhereInput> | null
    other_comments?: CommentsListRelationFilter
  }, "id">

  export type commentsOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    edited?: SortOrder
    editedAt?: SortOrderInput | SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    mentions?: SortOrderInput | SortOrder
    _count?: commentsCountOrderByAggregateInput
    _max?: commentsMaxOrderByAggregateInput
    _min?: commentsMinOrderByAggregateInput
  }

  export type commentsScalarWhereWithAggregatesInput = {
    AND?: commentsScalarWhereWithAggregatesInput | commentsScalarWhereWithAggregatesInput[]
    OR?: commentsScalarWhereWithAggregatesInput[]
    NOT?: commentsScalarWhereWithAggregatesInput | commentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"comments"> | string
    content?: StringWithAggregatesFilter<"comments"> | string
    createdAt?: DateTimeWithAggregatesFilter<"comments"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"comments"> | Date | string
    parentId?: StringNullableWithAggregatesFilter<"comments"> | string | null
    createdBy?: StringWithAggregatesFilter<"comments"> | string
    edited?: BoolWithAggregatesFilter<"comments"> | boolean
    editedAt?: DateTimeNullableWithAggregatesFilter<"comments"> | Date | string | null
    entityId?: StringWithAggregatesFilter<"comments"> | string
    entityType?: EnumEntityTypeWithAggregatesFilter<"comments"> | $Enums.EntityType
    mentions?: JsonNullableWithAggregatesFilter<"comments">
  }

  export type departmentsWhereInput = {
    AND?: departmentsWhereInput | departmentsWhereInput[]
    OR?: departmentsWhereInput[]
    NOT?: departmentsWhereInput | departmentsWhereInput[]
    id?: StringFilter<"departments"> | string
    name?: StringFilter<"departments"> | string
    description?: StringNullableFilter<"departments"> | string | null
    headCount?: IntFilter<"departments"> | number
    budgetAllocation?: FloatFilter<"departments"> | number
    managerId?: StringNullableFilter<"departments"> | string | null
    costCenter?: StringNullableFilter<"departments"> | string | null
    location?: StringNullableFilter<"departments"> | string | null
    isActive?: BoolFilter<"departments"> | boolean
    utilizationTarget?: FloatNullableFilter<"departments"> | number | null
    actualUtilization?: FloatNullableFilter<"departments"> | number | null
    createdAt?: DateTimeFilter<"departments"> | Date | string
    updatedAt?: DateTimeFilter<"departments"> | Date | string
    users_departments_managerIdTousers?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    signals?: SignalsListRelationFilter
    teams?: TeamsListRelationFilter
    users_users_departmentObjIdTodepartments?: UsersListRelationFilter
  }

  export type departmentsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    headCount?: SortOrder
    budgetAllocation?: SortOrder
    managerId?: SortOrderInput | SortOrder
    costCenter?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    isActive?: SortOrder
    utilizationTarget?: SortOrderInput | SortOrder
    actualUtilization?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_departments_managerIdTousers?: usersOrderByWithRelationInput
    signals?: signalsOrderByRelationAggregateInput
    teams?: teamsOrderByRelationAggregateInput
    users_users_departmentObjIdTodepartments?: usersOrderByRelationAggregateInput
  }

  export type departmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: departmentsWhereInput | departmentsWhereInput[]
    OR?: departmentsWhereInput[]
    NOT?: departmentsWhereInput | departmentsWhereInput[]
    description?: StringNullableFilter<"departments"> | string | null
    headCount?: IntFilter<"departments"> | number
    budgetAllocation?: FloatFilter<"departments"> | number
    managerId?: StringNullableFilter<"departments"> | string | null
    costCenter?: StringNullableFilter<"departments"> | string | null
    location?: StringNullableFilter<"departments"> | string | null
    isActive?: BoolFilter<"departments"> | boolean
    utilizationTarget?: FloatNullableFilter<"departments"> | number | null
    actualUtilization?: FloatNullableFilter<"departments"> | number | null
    createdAt?: DateTimeFilter<"departments"> | Date | string
    updatedAt?: DateTimeFilter<"departments"> | Date | string
    users_departments_managerIdTousers?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    signals?: SignalsListRelationFilter
    teams?: TeamsListRelationFilter
    users_users_departmentObjIdTodepartments?: UsersListRelationFilter
  }, "id" | "name">

  export type departmentsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    headCount?: SortOrder
    budgetAllocation?: SortOrder
    managerId?: SortOrderInput | SortOrder
    costCenter?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    isActive?: SortOrder
    utilizationTarget?: SortOrderInput | SortOrder
    actualUtilization?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: departmentsCountOrderByAggregateInput
    _avg?: departmentsAvgOrderByAggregateInput
    _max?: departmentsMaxOrderByAggregateInput
    _min?: departmentsMinOrderByAggregateInput
    _sum?: departmentsSumOrderByAggregateInput
  }

  export type departmentsScalarWhereWithAggregatesInput = {
    AND?: departmentsScalarWhereWithAggregatesInput | departmentsScalarWhereWithAggregatesInput[]
    OR?: departmentsScalarWhereWithAggregatesInput[]
    NOT?: departmentsScalarWhereWithAggregatesInput | departmentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"departments"> | string
    name?: StringWithAggregatesFilter<"departments"> | string
    description?: StringNullableWithAggregatesFilter<"departments"> | string | null
    headCount?: IntWithAggregatesFilter<"departments"> | number
    budgetAllocation?: FloatWithAggregatesFilter<"departments"> | number
    managerId?: StringNullableWithAggregatesFilter<"departments"> | string | null
    costCenter?: StringNullableWithAggregatesFilter<"departments"> | string | null
    location?: StringNullableWithAggregatesFilter<"departments"> | string | null
    isActive?: BoolWithAggregatesFilter<"departments"> | boolean
    utilizationTarget?: FloatNullableWithAggregatesFilter<"departments"> | number | null
    actualUtilization?: FloatNullableWithAggregatesFilter<"departments"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"departments"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"departments"> | Date | string
  }

  export type frd_documentsWhereInput = {
    AND?: frd_documentsWhereInput | frd_documentsWhereInput[]
    OR?: frd_documentsWhereInput[]
    NOT?: frd_documentsWhereInput | frd_documentsWhereInput[]
    id?: StringFilter<"frd_documents"> | string
    title?: StringFilter<"frd_documents"> | string
    content?: JsonFilter<"frd_documents">
    aiGenerated?: BoolFilter<"frd_documents"> | boolean
    aiConfidence?: FloatNullableFilter<"frd_documents"> | number | null
    aiPromptUsed?: StringNullableFilter<"frd_documents"> | string | null
    version?: StringFilter<"frd_documents"> | string
    status?: EnumFRDStatusFilter<"frd_documents"> | $Enums.FRDStatus
    executiveApproved?: BoolFilter<"frd_documents"> | boolean
    exportFormats?: JsonNullableFilter<"frd_documents">
    templateUsed?: StringNullableFilter<"frd_documents"> | string | null
    generationTime?: FloatNullableFilter<"frd_documents"> | number | null
    wordCount?: IntNullableFilter<"frd_documents"> | number | null
    lastExportedAt?: DateTimeNullableFilter<"frd_documents"> | Date | string | null
    solutionId?: StringFilter<"frd_documents"> | string
    createdBy?: StringFilter<"frd_documents"> | string
    approvedBy?: StringNullableFilter<"frd_documents"> | string | null
    createdAt?: DateTimeFilter<"frd_documents"> | Date | string
    updatedAt?: DateTimeFilter<"frd_documents"> | Date | string
    users_frd_documents_approvedByTousers?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    users_frd_documents_createdByTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    solutions?: XOR<SolutionsScalarRelationFilter, solutionsWhereInput>
  }

  export type frd_documentsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    aiGenerated?: SortOrder
    aiConfidence?: SortOrderInput | SortOrder
    aiPromptUsed?: SortOrderInput | SortOrder
    version?: SortOrder
    status?: SortOrder
    executiveApproved?: SortOrder
    exportFormats?: SortOrderInput | SortOrder
    templateUsed?: SortOrderInput | SortOrder
    generationTime?: SortOrderInput | SortOrder
    wordCount?: SortOrderInput | SortOrder
    lastExportedAt?: SortOrderInput | SortOrder
    solutionId?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_frd_documents_approvedByTousers?: usersOrderByWithRelationInput
    users_frd_documents_createdByTousers?: usersOrderByWithRelationInput
    solutions?: solutionsOrderByWithRelationInput
  }

  export type frd_documentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: frd_documentsWhereInput | frd_documentsWhereInput[]
    OR?: frd_documentsWhereInput[]
    NOT?: frd_documentsWhereInput | frd_documentsWhereInput[]
    title?: StringFilter<"frd_documents"> | string
    content?: JsonFilter<"frd_documents">
    aiGenerated?: BoolFilter<"frd_documents"> | boolean
    aiConfidence?: FloatNullableFilter<"frd_documents"> | number | null
    aiPromptUsed?: StringNullableFilter<"frd_documents"> | string | null
    version?: StringFilter<"frd_documents"> | string
    status?: EnumFRDStatusFilter<"frd_documents"> | $Enums.FRDStatus
    executiveApproved?: BoolFilter<"frd_documents"> | boolean
    exportFormats?: JsonNullableFilter<"frd_documents">
    templateUsed?: StringNullableFilter<"frd_documents"> | string | null
    generationTime?: FloatNullableFilter<"frd_documents"> | number | null
    wordCount?: IntNullableFilter<"frd_documents"> | number | null
    lastExportedAt?: DateTimeNullableFilter<"frd_documents"> | Date | string | null
    solutionId?: StringFilter<"frd_documents"> | string
    createdBy?: StringFilter<"frd_documents"> | string
    approvedBy?: StringNullableFilter<"frd_documents"> | string | null
    createdAt?: DateTimeFilter<"frd_documents"> | Date | string
    updatedAt?: DateTimeFilter<"frd_documents"> | Date | string
    users_frd_documents_approvedByTousers?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    users_frd_documents_createdByTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    solutions?: XOR<SolutionsScalarRelationFilter, solutionsWhereInput>
  }, "id">

  export type frd_documentsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    aiGenerated?: SortOrder
    aiConfidence?: SortOrderInput | SortOrder
    aiPromptUsed?: SortOrderInput | SortOrder
    version?: SortOrder
    status?: SortOrder
    executiveApproved?: SortOrder
    exportFormats?: SortOrderInput | SortOrder
    templateUsed?: SortOrderInput | SortOrder
    generationTime?: SortOrderInput | SortOrder
    wordCount?: SortOrderInput | SortOrder
    lastExportedAt?: SortOrderInput | SortOrder
    solutionId?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: frd_documentsCountOrderByAggregateInput
    _avg?: frd_documentsAvgOrderByAggregateInput
    _max?: frd_documentsMaxOrderByAggregateInput
    _min?: frd_documentsMinOrderByAggregateInput
    _sum?: frd_documentsSumOrderByAggregateInput
  }

  export type frd_documentsScalarWhereWithAggregatesInput = {
    AND?: frd_documentsScalarWhereWithAggregatesInput | frd_documentsScalarWhereWithAggregatesInput[]
    OR?: frd_documentsScalarWhereWithAggregatesInput[]
    NOT?: frd_documentsScalarWhereWithAggregatesInput | frd_documentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"frd_documents"> | string
    title?: StringWithAggregatesFilter<"frd_documents"> | string
    content?: JsonWithAggregatesFilter<"frd_documents">
    aiGenerated?: BoolWithAggregatesFilter<"frd_documents"> | boolean
    aiConfidence?: FloatNullableWithAggregatesFilter<"frd_documents"> | number | null
    aiPromptUsed?: StringNullableWithAggregatesFilter<"frd_documents"> | string | null
    version?: StringWithAggregatesFilter<"frd_documents"> | string
    status?: EnumFRDStatusWithAggregatesFilter<"frd_documents"> | $Enums.FRDStatus
    executiveApproved?: BoolWithAggregatesFilter<"frd_documents"> | boolean
    exportFormats?: JsonNullableWithAggregatesFilter<"frd_documents">
    templateUsed?: StringNullableWithAggregatesFilter<"frd_documents"> | string | null
    generationTime?: FloatNullableWithAggregatesFilter<"frd_documents"> | number | null
    wordCount?: IntNullableWithAggregatesFilter<"frd_documents"> | number | null
    lastExportedAt?: DateTimeNullableWithAggregatesFilter<"frd_documents"> | Date | string | null
    solutionId?: StringWithAggregatesFilter<"frd_documents"> | string
    createdBy?: StringWithAggregatesFilter<"frd_documents"> | string
    approvedBy?: StringNullableWithAggregatesFilter<"frd_documents"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"frd_documents"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"frd_documents"> | Date | string
  }

  export type hotspot_signalsWhereInput = {
    AND?: hotspot_signalsWhereInput | hotspot_signalsWhereInput[]
    OR?: hotspot_signalsWhereInput[]
    NOT?: hotspot_signalsWhereInput | hotspot_signalsWhereInput[]
    hotspotId?: StringFilter<"hotspot_signals"> | string
    signalId?: StringFilter<"hotspot_signals"> | string
    membershipStrength?: FloatFilter<"hotspot_signals"> | number
    isOutlier?: BoolFilter<"hotspot_signals"> | boolean
    addedAt?: DateTimeFilter<"hotspot_signals"> | Date | string
    hotspots?: XOR<HotspotsScalarRelationFilter, hotspotsWhereInput>
    signals?: XOR<SignalsScalarRelationFilter, signalsWhereInput>
  }

  export type hotspot_signalsOrderByWithRelationInput = {
    hotspotId?: SortOrder
    signalId?: SortOrder
    membershipStrength?: SortOrder
    isOutlier?: SortOrder
    addedAt?: SortOrder
    hotspots?: hotspotsOrderByWithRelationInput
    signals?: signalsOrderByWithRelationInput
  }

  export type hotspot_signalsWhereUniqueInput = Prisma.AtLeast<{
    hotspotId_signalId?: hotspot_signalsHotspotIdSignalIdCompoundUniqueInput
    AND?: hotspot_signalsWhereInput | hotspot_signalsWhereInput[]
    OR?: hotspot_signalsWhereInput[]
    NOT?: hotspot_signalsWhereInput | hotspot_signalsWhereInput[]
    hotspotId?: StringFilter<"hotspot_signals"> | string
    signalId?: StringFilter<"hotspot_signals"> | string
    membershipStrength?: FloatFilter<"hotspot_signals"> | number
    isOutlier?: BoolFilter<"hotspot_signals"> | boolean
    addedAt?: DateTimeFilter<"hotspot_signals"> | Date | string
    hotspots?: XOR<HotspotsScalarRelationFilter, hotspotsWhereInput>
    signals?: XOR<SignalsScalarRelationFilter, signalsWhereInput>
  }, "hotspotId_signalId">

  export type hotspot_signalsOrderByWithAggregationInput = {
    hotspotId?: SortOrder
    signalId?: SortOrder
    membershipStrength?: SortOrder
    isOutlier?: SortOrder
    addedAt?: SortOrder
    _count?: hotspot_signalsCountOrderByAggregateInput
    _avg?: hotspot_signalsAvgOrderByAggregateInput
    _max?: hotspot_signalsMaxOrderByAggregateInput
    _min?: hotspot_signalsMinOrderByAggregateInput
    _sum?: hotspot_signalsSumOrderByAggregateInput
  }

  export type hotspot_signalsScalarWhereWithAggregatesInput = {
    AND?: hotspot_signalsScalarWhereWithAggregatesInput | hotspot_signalsScalarWhereWithAggregatesInput[]
    OR?: hotspot_signalsScalarWhereWithAggregatesInput[]
    NOT?: hotspot_signalsScalarWhereWithAggregatesInput | hotspot_signalsScalarWhereWithAggregatesInput[]
    hotspotId?: StringWithAggregatesFilter<"hotspot_signals"> | string
    signalId?: StringWithAggregatesFilter<"hotspot_signals"> | string
    membershipStrength?: FloatWithAggregatesFilter<"hotspot_signals"> | number
    isOutlier?: BoolWithAggregatesFilter<"hotspot_signals"> | boolean
    addedAt?: DateTimeWithAggregatesFilter<"hotspot_signals"> | Date | string
  }

  export type hotspotsWhereInput = {
    AND?: hotspotsWhereInput | hotspotsWhereInput[]
    OR?: hotspotsWhereInput[]
    NOT?: hotspotsWhereInput | hotspotsWhereInput[]
    id?: StringFilter<"hotspots"> | string
    title?: StringFilter<"hotspots"> | string
    summary?: StringFilter<"hotspots"> | string
    status?: EnumHotspotStatusFilter<"hotspots"> | $Enums.HotspotStatus
    rankScore?: FloatFilter<"hotspots"> | number
    confidence?: FloatFilter<"hotspots"> | number
    primaryCategoryId?: StringNullableFilter<"hotspots"> | string | null
    linkedEntitiesJson?: JsonNullableFilter<"hotspots">
    clusteringMethod?: StringNullableFilter<"hotspots"> | string | null
    similarityThreshold?: FloatNullableFilter<"hotspots"> | number | null
    rcaBreakdownJson?: JsonNullableFilter<"hotspots">
    solutionSuggestionsJson?: JsonNullableFilter<"hotspots">
    decisionMatrixJson?: JsonNullableFilter<"hotspots">
    crossFunctionalImpactJson?: JsonNullableFilter<"hotspots">
    lastAnalysisAt?: DateTimeNullableFilter<"hotspots"> | Date | string | null
    createdAt?: DateTimeFilter<"hotspots"> | Date | string
    updatedAt?: DateTimeFilter<"hotspots"> | Date | string
    clusteringQualityScore?: FloatNullableFilter<"hotspots"> | number | null
    clusteringResults?: JsonNullableFilter<"hotspots">
    clusteringVersion?: StringNullableFilter<"hotspots"> | string | null
    lastClusteredAt?: DateTimeNullableFilter<"hotspots"> | Date | string | null
    hotspot_signals?: Hotspot_signalsListRelationFilter
    ideas?: IdeasListRelationFilter
    solutions?: SolutionsListRelationFilter
  }

  export type hotspotsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    rankScore?: SortOrder
    confidence?: SortOrder
    primaryCategoryId?: SortOrderInput | SortOrder
    linkedEntitiesJson?: SortOrderInput | SortOrder
    clusteringMethod?: SortOrderInput | SortOrder
    similarityThreshold?: SortOrderInput | SortOrder
    rcaBreakdownJson?: SortOrderInput | SortOrder
    solutionSuggestionsJson?: SortOrderInput | SortOrder
    decisionMatrixJson?: SortOrderInput | SortOrder
    crossFunctionalImpactJson?: SortOrderInput | SortOrder
    lastAnalysisAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clusteringQualityScore?: SortOrderInput | SortOrder
    clusteringResults?: SortOrderInput | SortOrder
    clusteringVersion?: SortOrderInput | SortOrder
    lastClusteredAt?: SortOrderInput | SortOrder
    hotspot_signals?: hotspot_signalsOrderByRelationAggregateInput
    ideas?: ideasOrderByRelationAggregateInput
    solutions?: solutionsOrderByRelationAggregateInput
  }

  export type hotspotsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: hotspotsWhereInput | hotspotsWhereInput[]
    OR?: hotspotsWhereInput[]
    NOT?: hotspotsWhereInput | hotspotsWhereInput[]
    title?: StringFilter<"hotspots"> | string
    summary?: StringFilter<"hotspots"> | string
    status?: EnumHotspotStatusFilter<"hotspots"> | $Enums.HotspotStatus
    rankScore?: FloatFilter<"hotspots"> | number
    confidence?: FloatFilter<"hotspots"> | number
    primaryCategoryId?: StringNullableFilter<"hotspots"> | string | null
    linkedEntitiesJson?: JsonNullableFilter<"hotspots">
    clusteringMethod?: StringNullableFilter<"hotspots"> | string | null
    similarityThreshold?: FloatNullableFilter<"hotspots"> | number | null
    rcaBreakdownJson?: JsonNullableFilter<"hotspots">
    solutionSuggestionsJson?: JsonNullableFilter<"hotspots">
    decisionMatrixJson?: JsonNullableFilter<"hotspots">
    crossFunctionalImpactJson?: JsonNullableFilter<"hotspots">
    lastAnalysisAt?: DateTimeNullableFilter<"hotspots"> | Date | string | null
    createdAt?: DateTimeFilter<"hotspots"> | Date | string
    updatedAt?: DateTimeFilter<"hotspots"> | Date | string
    clusteringQualityScore?: FloatNullableFilter<"hotspots"> | number | null
    clusteringResults?: JsonNullableFilter<"hotspots">
    clusteringVersion?: StringNullableFilter<"hotspots"> | string | null
    lastClusteredAt?: DateTimeNullableFilter<"hotspots"> | Date | string | null
    hotspot_signals?: Hotspot_signalsListRelationFilter
    ideas?: IdeasListRelationFilter
    solutions?: SolutionsListRelationFilter
  }, "id">

  export type hotspotsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    rankScore?: SortOrder
    confidence?: SortOrder
    primaryCategoryId?: SortOrderInput | SortOrder
    linkedEntitiesJson?: SortOrderInput | SortOrder
    clusteringMethod?: SortOrderInput | SortOrder
    similarityThreshold?: SortOrderInput | SortOrder
    rcaBreakdownJson?: SortOrderInput | SortOrder
    solutionSuggestionsJson?: SortOrderInput | SortOrder
    decisionMatrixJson?: SortOrderInput | SortOrder
    crossFunctionalImpactJson?: SortOrderInput | SortOrder
    lastAnalysisAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clusteringQualityScore?: SortOrderInput | SortOrder
    clusteringResults?: SortOrderInput | SortOrder
    clusteringVersion?: SortOrderInput | SortOrder
    lastClusteredAt?: SortOrderInput | SortOrder
    _count?: hotspotsCountOrderByAggregateInput
    _avg?: hotspotsAvgOrderByAggregateInput
    _max?: hotspotsMaxOrderByAggregateInput
    _min?: hotspotsMinOrderByAggregateInput
    _sum?: hotspotsSumOrderByAggregateInput
  }

  export type hotspotsScalarWhereWithAggregatesInput = {
    AND?: hotspotsScalarWhereWithAggregatesInput | hotspotsScalarWhereWithAggregatesInput[]
    OR?: hotspotsScalarWhereWithAggregatesInput[]
    NOT?: hotspotsScalarWhereWithAggregatesInput | hotspotsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"hotspots"> | string
    title?: StringWithAggregatesFilter<"hotspots"> | string
    summary?: StringWithAggregatesFilter<"hotspots"> | string
    status?: EnumHotspotStatusWithAggregatesFilter<"hotspots"> | $Enums.HotspotStatus
    rankScore?: FloatWithAggregatesFilter<"hotspots"> | number
    confidence?: FloatWithAggregatesFilter<"hotspots"> | number
    primaryCategoryId?: StringNullableWithAggregatesFilter<"hotspots"> | string | null
    linkedEntitiesJson?: JsonNullableWithAggregatesFilter<"hotspots">
    clusteringMethod?: StringNullableWithAggregatesFilter<"hotspots"> | string | null
    similarityThreshold?: FloatNullableWithAggregatesFilter<"hotspots"> | number | null
    rcaBreakdownJson?: JsonNullableWithAggregatesFilter<"hotspots">
    solutionSuggestionsJson?: JsonNullableWithAggregatesFilter<"hotspots">
    decisionMatrixJson?: JsonNullableWithAggregatesFilter<"hotspots">
    crossFunctionalImpactJson?: JsonNullableWithAggregatesFilter<"hotspots">
    lastAnalysisAt?: DateTimeNullableWithAggregatesFilter<"hotspots"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"hotspots"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"hotspots"> | Date | string
    clusteringQualityScore?: FloatNullableWithAggregatesFilter<"hotspots"> | number | null
    clusteringResults?: JsonNullableWithAggregatesFilter<"hotspots">
    clusteringVersion?: StringNullableWithAggregatesFilter<"hotspots"> | string | null
    lastClusteredAt?: DateTimeNullableWithAggregatesFilter<"hotspots"> | Date | string | null
  }

  export type ideasWhereInput = {
    AND?: ideasWhereInput | ideasWhereInput[]
    OR?: ideasWhereInput[]
    NOT?: ideasWhereInput | ideasWhereInput[]
    id?: StringFilter<"ideas"> | string
    hotspotId?: StringFilter<"ideas"> | string
    title?: StringNullableFilter<"ideas"> | string | null
    description?: StringFilter<"ideas"> | string
    origin?: StringFilter<"ideas"> | string
    votes?: IntFilter<"ideas"> | number
    status?: StringFilter<"ideas"> | string
    evidenceJson?: JsonNullableFilter<"ideas">
    tagsJson?: JsonNullableFilter<"ideas">
    confidence?: FloatNullableFilter<"ideas"> | number | null
    createdById?: StringNullableFilter<"ideas"> | string | null
    initiativeId?: StringNullableFilter<"ideas"> | string | null
    createdAt?: DateTimeFilter<"ideas"> | Date | string
    updatedAt?: DateTimeFilter<"ideas"> | Date | string
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    hotspots?: XOR<HotspotsScalarRelationFilter, hotspotsWhereInput>
    initiatives?: XOR<InitiativesNullableScalarRelationFilter, initiativesWhereInput> | null
    solutions?: XOR<SolutionsNullableScalarRelationFilter, solutionsWhereInput> | null
  }

  export type ideasOrderByWithRelationInput = {
    id?: SortOrder
    hotspotId?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrder
    origin?: SortOrder
    votes?: SortOrder
    status?: SortOrder
    evidenceJson?: SortOrderInput | SortOrder
    tagsJson?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    initiativeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: usersOrderByWithRelationInput
    hotspots?: hotspotsOrderByWithRelationInput
    initiatives?: initiativesOrderByWithRelationInput
    solutions?: solutionsOrderByWithRelationInput
  }

  export type ideasWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ideasWhereInput | ideasWhereInput[]
    OR?: ideasWhereInput[]
    NOT?: ideasWhereInput | ideasWhereInput[]
    hotspotId?: StringFilter<"ideas"> | string
    title?: StringNullableFilter<"ideas"> | string | null
    description?: StringFilter<"ideas"> | string
    origin?: StringFilter<"ideas"> | string
    votes?: IntFilter<"ideas"> | number
    status?: StringFilter<"ideas"> | string
    evidenceJson?: JsonNullableFilter<"ideas">
    tagsJson?: JsonNullableFilter<"ideas">
    confidence?: FloatNullableFilter<"ideas"> | number | null
    createdById?: StringNullableFilter<"ideas"> | string | null
    initiativeId?: StringNullableFilter<"ideas"> | string | null
    createdAt?: DateTimeFilter<"ideas"> | Date | string
    updatedAt?: DateTimeFilter<"ideas"> | Date | string
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    hotspots?: XOR<HotspotsScalarRelationFilter, hotspotsWhereInput>
    initiatives?: XOR<InitiativesNullableScalarRelationFilter, initiativesWhereInput> | null
    solutions?: XOR<SolutionsNullableScalarRelationFilter, solutionsWhereInput> | null
  }, "id">

  export type ideasOrderByWithAggregationInput = {
    id?: SortOrder
    hotspotId?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrder
    origin?: SortOrder
    votes?: SortOrder
    status?: SortOrder
    evidenceJson?: SortOrderInput | SortOrder
    tagsJson?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    initiativeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ideasCountOrderByAggregateInput
    _avg?: ideasAvgOrderByAggregateInput
    _max?: ideasMaxOrderByAggregateInput
    _min?: ideasMinOrderByAggregateInput
    _sum?: ideasSumOrderByAggregateInput
  }

  export type ideasScalarWhereWithAggregatesInput = {
    AND?: ideasScalarWhereWithAggregatesInput | ideasScalarWhereWithAggregatesInput[]
    OR?: ideasScalarWhereWithAggregatesInput[]
    NOT?: ideasScalarWhereWithAggregatesInput | ideasScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ideas"> | string
    hotspotId?: StringWithAggregatesFilter<"ideas"> | string
    title?: StringNullableWithAggregatesFilter<"ideas"> | string | null
    description?: StringWithAggregatesFilter<"ideas"> | string
    origin?: StringWithAggregatesFilter<"ideas"> | string
    votes?: IntWithAggregatesFilter<"ideas"> | number
    status?: StringWithAggregatesFilter<"ideas"> | string
    evidenceJson?: JsonNullableWithAggregatesFilter<"ideas">
    tagsJson?: JsonNullableWithAggregatesFilter<"ideas">
    confidence?: FloatNullableWithAggregatesFilter<"ideas"> | number | null
    createdById?: StringNullableWithAggregatesFilter<"ideas"> | string | null
    initiativeId?: StringNullableWithAggregatesFilter<"ideas"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ideas"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ideas"> | Date | string
  }

  export type initiativesWhereInput = {
    AND?: initiativesWhereInput | initiativesWhereInput[]
    OR?: initiativesWhereInput[]
    NOT?: initiativesWhereInput | initiativesWhereInput[]
    id?: StringFilter<"initiatives"> | string
    name?: StringFilter<"initiatives"> | string
    description?: StringNullableFilter<"initiatives"> | string | null
    status?: Enuminitiative_statusFilter<"initiatives"> | $Enums.initiative_status
    priority?: EnumpriorityFilter<"initiatives"> | $Enums.priority
    ownerId?: StringNullableFilter<"initiatives"> | string | null
    budget?: FloatFilter<"initiatives"> | number
    actualSpend?: FloatFilter<"initiatives"> | number
    startDate?: DateTimeNullableFilter<"initiatives"> | Date | string | null
    targetDate?: DateTimeNullableFilter<"initiatives"> | Date | string | null
    completionDate?: DateTimeNullableFilter<"initiatives"> | Date | string | null
    expectedROI?: FloatNullableFilter<"initiatives"> | number | null
    actualROI?: FloatNullableFilter<"initiatives"> | number | null
    riskLevel?: Enumrisk_levelFilter<"initiatives"> | $Enums.risk_level
    goalJson?: JsonNullableFilter<"initiatives">
    roiJson?: JsonNullableFilter<"initiatives">
    milestonesJson?: JsonNullableFilter<"initiatives">
    createdAt?: DateTimeFilter<"initiatives"> | Date | string
    updatedAt?: DateTimeFilter<"initiatives"> | Date | string
    ideas?: IdeasListRelationFilter
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    solutions?: SolutionsListRelationFilter
  }

  export type initiativesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    budget?: SortOrder
    actualSpend?: SortOrder
    startDate?: SortOrderInput | SortOrder
    targetDate?: SortOrderInput | SortOrder
    completionDate?: SortOrderInput | SortOrder
    expectedROI?: SortOrderInput | SortOrder
    actualROI?: SortOrderInput | SortOrder
    riskLevel?: SortOrder
    goalJson?: SortOrderInput | SortOrder
    roiJson?: SortOrderInput | SortOrder
    milestonesJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ideas?: ideasOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
    solutions?: solutionsOrderByRelationAggregateInput
  }

  export type initiativesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: initiativesWhereInput | initiativesWhereInput[]
    OR?: initiativesWhereInput[]
    NOT?: initiativesWhereInput | initiativesWhereInput[]
    description?: StringNullableFilter<"initiatives"> | string | null
    status?: Enuminitiative_statusFilter<"initiatives"> | $Enums.initiative_status
    priority?: EnumpriorityFilter<"initiatives"> | $Enums.priority
    ownerId?: StringNullableFilter<"initiatives"> | string | null
    budget?: FloatFilter<"initiatives"> | number
    actualSpend?: FloatFilter<"initiatives"> | number
    startDate?: DateTimeNullableFilter<"initiatives"> | Date | string | null
    targetDate?: DateTimeNullableFilter<"initiatives"> | Date | string | null
    completionDate?: DateTimeNullableFilter<"initiatives"> | Date | string | null
    expectedROI?: FloatNullableFilter<"initiatives"> | number | null
    actualROI?: FloatNullableFilter<"initiatives"> | number | null
    riskLevel?: Enumrisk_levelFilter<"initiatives"> | $Enums.risk_level
    goalJson?: JsonNullableFilter<"initiatives">
    roiJson?: JsonNullableFilter<"initiatives">
    milestonesJson?: JsonNullableFilter<"initiatives">
    createdAt?: DateTimeFilter<"initiatives"> | Date | string
    updatedAt?: DateTimeFilter<"initiatives"> | Date | string
    ideas?: IdeasListRelationFilter
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    solutions?: SolutionsListRelationFilter
  }, "id" | "name">

  export type initiativesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    budget?: SortOrder
    actualSpend?: SortOrder
    startDate?: SortOrderInput | SortOrder
    targetDate?: SortOrderInput | SortOrder
    completionDate?: SortOrderInput | SortOrder
    expectedROI?: SortOrderInput | SortOrder
    actualROI?: SortOrderInput | SortOrder
    riskLevel?: SortOrder
    goalJson?: SortOrderInput | SortOrder
    roiJson?: SortOrderInput | SortOrder
    milestonesJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: initiativesCountOrderByAggregateInput
    _avg?: initiativesAvgOrderByAggregateInput
    _max?: initiativesMaxOrderByAggregateInput
    _min?: initiativesMinOrderByAggregateInput
    _sum?: initiativesSumOrderByAggregateInput
  }

  export type initiativesScalarWhereWithAggregatesInput = {
    AND?: initiativesScalarWhereWithAggregatesInput | initiativesScalarWhereWithAggregatesInput[]
    OR?: initiativesScalarWhereWithAggregatesInput[]
    NOT?: initiativesScalarWhereWithAggregatesInput | initiativesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"initiatives"> | string
    name?: StringWithAggregatesFilter<"initiatives"> | string
    description?: StringNullableWithAggregatesFilter<"initiatives"> | string | null
    status?: Enuminitiative_statusWithAggregatesFilter<"initiatives"> | $Enums.initiative_status
    priority?: EnumpriorityWithAggregatesFilter<"initiatives"> | $Enums.priority
    ownerId?: StringNullableWithAggregatesFilter<"initiatives"> | string | null
    budget?: FloatWithAggregatesFilter<"initiatives"> | number
    actualSpend?: FloatWithAggregatesFilter<"initiatives"> | number
    startDate?: DateTimeNullableWithAggregatesFilter<"initiatives"> | Date | string | null
    targetDate?: DateTimeNullableWithAggregatesFilter<"initiatives"> | Date | string | null
    completionDate?: DateTimeNullableWithAggregatesFilter<"initiatives"> | Date | string | null
    expectedROI?: FloatNullableWithAggregatesFilter<"initiatives"> | number | null
    actualROI?: FloatNullableWithAggregatesFilter<"initiatives"> | number | null
    riskLevel?: Enumrisk_levelWithAggregatesFilter<"initiatives"> | $Enums.risk_level
    goalJson?: JsonNullableWithAggregatesFilter<"initiatives">
    roiJson?: JsonNullableWithAggregatesFilter<"initiatives">
    milestonesJson?: JsonNullableWithAggregatesFilter<"initiatives">
    createdAt?: DateTimeWithAggregatesFilter<"initiatives"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"initiatives"> | Date | string
  }

  export type input_groupsWhereInput = {
    AND?: input_groupsWhereInput | input_groupsWhereInput[]
    OR?: input_groupsWhereInput[]
    NOT?: input_groupsWhereInput | input_groupsWhereInput[]
    id?: StringFilter<"input_groups"> | string
    name?: StringFilter<"input_groups"> | string
    description?: StringNullableFilter<"input_groups"> | string | null
    createdAt?: DateTimeFilter<"input_groups"> | Date | string
    updatedAt?: DateTimeFilter<"input_groups"> | Date | string
    aiSuggested?: BoolFilter<"input_groups"> | boolean
    aiConfidence?: FloatNullableFilter<"input_groups"> | number | null
    aiReasoning?: StringNullableFilter<"input_groups"> | string | null
    avgPriority?: FloatNullableFilter<"input_groups"> | number | null
    color?: StringNullableFilter<"input_groups"> | string | null
    createdBy?: StringFilter<"input_groups"> | string
    inputCount?: IntFilter<"input_groups"> | number
    lastActivity?: DateTimeNullableFilter<"input_groups"> | Date | string | null
    InputToInputGroup?: InputToInputGroupListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type input_groupsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiSuggested?: SortOrder
    aiConfidence?: SortOrderInput | SortOrder
    aiReasoning?: SortOrderInput | SortOrder
    avgPriority?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    inputCount?: SortOrder
    lastActivity?: SortOrderInput | SortOrder
    InputToInputGroup?: InputToInputGroupOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
  }

  export type input_groupsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: input_groupsWhereInput | input_groupsWhereInput[]
    OR?: input_groupsWhereInput[]
    NOT?: input_groupsWhereInput | input_groupsWhereInput[]
    name?: StringFilter<"input_groups"> | string
    description?: StringNullableFilter<"input_groups"> | string | null
    createdAt?: DateTimeFilter<"input_groups"> | Date | string
    updatedAt?: DateTimeFilter<"input_groups"> | Date | string
    aiSuggested?: BoolFilter<"input_groups"> | boolean
    aiConfidence?: FloatNullableFilter<"input_groups"> | number | null
    aiReasoning?: StringNullableFilter<"input_groups"> | string | null
    avgPriority?: FloatNullableFilter<"input_groups"> | number | null
    color?: StringNullableFilter<"input_groups"> | string | null
    createdBy?: StringFilter<"input_groups"> | string
    inputCount?: IntFilter<"input_groups"> | number
    lastActivity?: DateTimeNullableFilter<"input_groups"> | Date | string | null
    InputToInputGroup?: InputToInputGroupListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type input_groupsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiSuggested?: SortOrder
    aiConfidence?: SortOrderInput | SortOrder
    aiReasoning?: SortOrderInput | SortOrder
    avgPriority?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    inputCount?: SortOrder
    lastActivity?: SortOrderInput | SortOrder
    _count?: input_groupsCountOrderByAggregateInput
    _avg?: input_groupsAvgOrderByAggregateInput
    _max?: input_groupsMaxOrderByAggregateInput
    _min?: input_groupsMinOrderByAggregateInput
    _sum?: input_groupsSumOrderByAggregateInput
  }

  export type input_groupsScalarWhereWithAggregatesInput = {
    AND?: input_groupsScalarWhereWithAggregatesInput | input_groupsScalarWhereWithAggregatesInput[]
    OR?: input_groupsScalarWhereWithAggregatesInput[]
    NOT?: input_groupsScalarWhereWithAggregatesInput | input_groupsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"input_groups"> | string
    name?: StringWithAggregatesFilter<"input_groups"> | string
    description?: StringNullableWithAggregatesFilter<"input_groups"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"input_groups"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"input_groups"> | Date | string
    aiSuggested?: BoolWithAggregatesFilter<"input_groups"> | boolean
    aiConfidence?: FloatNullableWithAggregatesFilter<"input_groups"> | number | null
    aiReasoning?: StringNullableWithAggregatesFilter<"input_groups"> | string | null
    avgPriority?: FloatNullableWithAggregatesFilter<"input_groups"> | number | null
    color?: StringNullableWithAggregatesFilter<"input_groups"> | string | null
    createdBy?: StringWithAggregatesFilter<"input_groups"> | string
    inputCount?: IntWithAggregatesFilter<"input_groups"> | number
    lastActivity?: DateTimeNullableWithAggregatesFilter<"input_groups"> | Date | string | null
  }

  export type inputsWhereInput = {
    AND?: inputsWhereInput | inputsWhereInput[]
    OR?: inputsWhereInput[]
    NOT?: inputsWhereInput | inputsWhereInput[]
    id?: StringFilter<"inputs"> | string
    title?: StringFilter<"inputs"> | string
    description?: StringFilter<"inputs"> | string
    type?: EnumInputTypeFilter<"inputs"> | $Enums.InputType
    status?: EnumInputStatusFilter<"inputs"> | $Enums.InputStatus
    createdBy?: StringFilter<"inputs"> | string
    createdAt?: DateTimeFilter<"inputs"> | Date | string
    updatedAt?: DateTimeFilter<"inputs"> | Date | string
    department?: StringNullableFilter<"inputs"> | string | null
    rootCause?: StringNullableFilter<"inputs"> | string | null
    aiTags?: JsonNullableFilter<"inputs">
    aiSuggestions?: JsonNullableFilter<"inputs">
    aiConfidence?: FloatNullableFilter<"inputs"> | number | null
    issueType?: StringNullableFilter<"inputs"> | string | null
    priority?: EnumpriorityFilter<"inputs"> | $Enums.priority
    InputToInputGroup?: InputToInputGroupListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    solutions?: SolutionsListRelationFilter
  }

  export type inputsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: SortOrderInput | SortOrder
    rootCause?: SortOrderInput | SortOrder
    aiTags?: SortOrderInput | SortOrder
    aiSuggestions?: SortOrderInput | SortOrder
    aiConfidence?: SortOrderInput | SortOrder
    issueType?: SortOrderInput | SortOrder
    priority?: SortOrder
    InputToInputGroup?: InputToInputGroupOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
    solutions?: solutionsOrderByRelationAggregateInput
  }

  export type inputsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: inputsWhereInput | inputsWhereInput[]
    OR?: inputsWhereInput[]
    NOT?: inputsWhereInput | inputsWhereInput[]
    title?: StringFilter<"inputs"> | string
    description?: StringFilter<"inputs"> | string
    type?: EnumInputTypeFilter<"inputs"> | $Enums.InputType
    status?: EnumInputStatusFilter<"inputs"> | $Enums.InputStatus
    createdBy?: StringFilter<"inputs"> | string
    createdAt?: DateTimeFilter<"inputs"> | Date | string
    updatedAt?: DateTimeFilter<"inputs"> | Date | string
    department?: StringNullableFilter<"inputs"> | string | null
    rootCause?: StringNullableFilter<"inputs"> | string | null
    aiTags?: JsonNullableFilter<"inputs">
    aiSuggestions?: JsonNullableFilter<"inputs">
    aiConfidence?: FloatNullableFilter<"inputs"> | number | null
    issueType?: StringNullableFilter<"inputs"> | string | null
    priority?: EnumpriorityFilter<"inputs"> | $Enums.priority
    InputToInputGroup?: InputToInputGroupListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    solutions?: SolutionsListRelationFilter
  }, "id">

  export type inputsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: SortOrderInput | SortOrder
    rootCause?: SortOrderInput | SortOrder
    aiTags?: SortOrderInput | SortOrder
    aiSuggestions?: SortOrderInput | SortOrder
    aiConfidence?: SortOrderInput | SortOrder
    issueType?: SortOrderInput | SortOrder
    priority?: SortOrder
    _count?: inputsCountOrderByAggregateInput
    _avg?: inputsAvgOrderByAggregateInput
    _max?: inputsMaxOrderByAggregateInput
    _min?: inputsMinOrderByAggregateInput
    _sum?: inputsSumOrderByAggregateInput
  }

  export type inputsScalarWhereWithAggregatesInput = {
    AND?: inputsScalarWhereWithAggregatesInput | inputsScalarWhereWithAggregatesInput[]
    OR?: inputsScalarWhereWithAggregatesInput[]
    NOT?: inputsScalarWhereWithAggregatesInput | inputsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"inputs"> | string
    title?: StringWithAggregatesFilter<"inputs"> | string
    description?: StringWithAggregatesFilter<"inputs"> | string
    type?: EnumInputTypeWithAggregatesFilter<"inputs"> | $Enums.InputType
    status?: EnumInputStatusWithAggregatesFilter<"inputs"> | $Enums.InputStatus
    createdBy?: StringWithAggregatesFilter<"inputs"> | string
    createdAt?: DateTimeWithAggregatesFilter<"inputs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"inputs"> | Date | string
    department?: StringNullableWithAggregatesFilter<"inputs"> | string | null
    rootCause?: StringNullableWithAggregatesFilter<"inputs"> | string | null
    aiTags?: JsonNullableWithAggregatesFilter<"inputs">
    aiSuggestions?: JsonNullableWithAggregatesFilter<"inputs">
    aiConfidence?: FloatNullableWithAggregatesFilter<"inputs"> | number | null
    issueType?: StringNullableWithAggregatesFilter<"inputs"> | string | null
    priority?: EnumpriorityWithAggregatesFilter<"inputs"> | $Enums.priority
  }

  export type notificationsWhereInput = {
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    id?: StringFilter<"notifications"> | string
    userId?: StringFilter<"notifications"> | string
    type?: EnumNotificationTypeFilter<"notifications"> | $Enums.NotificationType
    title?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    readAt?: DateTimeNullableFilter<"notifications"> | Date | string | null
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    delivered?: BoolFilter<"notifications"> | boolean
    entityId?: StringNullableFilter<"notifications"> | string | null
    entityType?: EnumEntityTypeNullableFilter<"notifications"> | $Enums.EntityType | null
    read?: BoolFilter<"notifications"> | boolean
  }

  export type notificationsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    delivered?: SortOrder
    entityId?: SortOrderInput | SortOrder
    entityType?: SortOrderInput | SortOrder
    read?: SortOrder
  }

  export type notificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    userId?: StringFilter<"notifications"> | string
    type?: EnumNotificationTypeFilter<"notifications"> | $Enums.NotificationType
    title?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    readAt?: DateTimeNullableFilter<"notifications"> | Date | string | null
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    delivered?: BoolFilter<"notifications"> | boolean
    entityId?: StringNullableFilter<"notifications"> | string | null
    entityType?: EnumEntityTypeNullableFilter<"notifications"> | $Enums.EntityType | null
    read?: BoolFilter<"notifications"> | boolean
  }, "id">

  export type notificationsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    delivered?: SortOrder
    entityId?: SortOrderInput | SortOrder
    entityType?: SortOrderInput | SortOrder
    read?: SortOrder
    _count?: notificationsCountOrderByAggregateInput
    _max?: notificationsMaxOrderByAggregateInput
    _min?: notificationsMinOrderByAggregateInput
  }

  export type notificationsScalarWhereWithAggregatesInput = {
    AND?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    OR?: notificationsScalarWhereWithAggregatesInput[]
    NOT?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"notifications"> | string
    userId?: StringWithAggregatesFilter<"notifications"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"notifications"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"notifications"> | string
    message?: StringWithAggregatesFilter<"notifications"> | string
    readAt?: DateTimeNullableWithAggregatesFilter<"notifications"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"notifications"> | Date | string
    delivered?: BoolWithAggregatesFilter<"notifications"> | boolean
    entityId?: StringNullableWithAggregatesFilter<"notifications"> | string | null
    entityType?: EnumEntityTypeNullableWithAggregatesFilter<"notifications"> | $Enums.EntityType | null
    read?: BoolWithAggregatesFilter<"notifications"> | boolean
  }

  export type requirementsWhereInput = {
    AND?: requirementsWhereInput | requirementsWhereInput[]
    OR?: requirementsWhereInput[]
    NOT?: requirementsWhereInput | requirementsWhereInput[]
    id?: StringFilter<"requirements"> | string
    title?: StringFilter<"requirements"> | string
    description?: StringFilter<"requirements"> | string
    acceptanceCriteria?: JsonFilter<"requirements">
    status?: EnumRequirementStatusFilter<"requirements"> | $Enums.RequirementStatus
    estimatedEffort?: StringNullableFilter<"requirements"> | string | null
    dependencies?: JsonNullableFilter<"requirements">
    businessValue?: StringNullableFilter<"requirements"> | string | null
    riskAssessment?: StringNullableFilter<"requirements"> | string | null
    stakeholders?: JsonNullableFilter<"requirements">
    approvedBy?: StringNullableFilter<"requirements"> | string | null
    approvedAt?: DateTimeNullableFilter<"requirements"> | Date | string | null
    rejectionReason?: StringNullableFilter<"requirements"> | string | null
    solutionId?: StringFilter<"requirements"> | string
    createdBy?: StringFilter<"requirements"> | string
    createdAt?: DateTimeFilter<"requirements"> | Date | string
    updatedAt?: DateTimeFilter<"requirements"> | Date | string
    priority?: EnumpriorityFilter<"requirements"> | $Enums.priority
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    solutions?: XOR<SolutionsScalarRelationFilter, solutionsWhereInput>
  }

  export type requirementsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    acceptanceCriteria?: SortOrder
    status?: SortOrder
    estimatedEffort?: SortOrderInput | SortOrder
    dependencies?: SortOrderInput | SortOrder
    businessValue?: SortOrderInput | SortOrder
    riskAssessment?: SortOrderInput | SortOrder
    stakeholders?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    solutionId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    priority?: SortOrder
    users?: usersOrderByWithRelationInput
    solutions?: solutionsOrderByWithRelationInput
  }

  export type requirementsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: requirementsWhereInput | requirementsWhereInput[]
    OR?: requirementsWhereInput[]
    NOT?: requirementsWhereInput | requirementsWhereInput[]
    title?: StringFilter<"requirements"> | string
    description?: StringFilter<"requirements"> | string
    acceptanceCriteria?: JsonFilter<"requirements">
    status?: EnumRequirementStatusFilter<"requirements"> | $Enums.RequirementStatus
    estimatedEffort?: StringNullableFilter<"requirements"> | string | null
    dependencies?: JsonNullableFilter<"requirements">
    businessValue?: StringNullableFilter<"requirements"> | string | null
    riskAssessment?: StringNullableFilter<"requirements"> | string | null
    stakeholders?: JsonNullableFilter<"requirements">
    approvedBy?: StringNullableFilter<"requirements"> | string | null
    approvedAt?: DateTimeNullableFilter<"requirements"> | Date | string | null
    rejectionReason?: StringNullableFilter<"requirements"> | string | null
    solutionId?: StringFilter<"requirements"> | string
    createdBy?: StringFilter<"requirements"> | string
    createdAt?: DateTimeFilter<"requirements"> | Date | string
    updatedAt?: DateTimeFilter<"requirements"> | Date | string
    priority?: EnumpriorityFilter<"requirements"> | $Enums.priority
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    solutions?: XOR<SolutionsScalarRelationFilter, solutionsWhereInput>
  }, "id">

  export type requirementsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    acceptanceCriteria?: SortOrder
    status?: SortOrder
    estimatedEffort?: SortOrderInput | SortOrder
    dependencies?: SortOrderInput | SortOrder
    businessValue?: SortOrderInput | SortOrder
    riskAssessment?: SortOrderInput | SortOrder
    stakeholders?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    solutionId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    priority?: SortOrder
    _count?: requirementsCountOrderByAggregateInput
    _max?: requirementsMaxOrderByAggregateInput
    _min?: requirementsMinOrderByAggregateInput
  }

  export type requirementsScalarWhereWithAggregatesInput = {
    AND?: requirementsScalarWhereWithAggregatesInput | requirementsScalarWhereWithAggregatesInput[]
    OR?: requirementsScalarWhereWithAggregatesInput[]
    NOT?: requirementsScalarWhereWithAggregatesInput | requirementsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"requirements"> | string
    title?: StringWithAggregatesFilter<"requirements"> | string
    description?: StringWithAggregatesFilter<"requirements"> | string
    acceptanceCriteria?: JsonWithAggregatesFilter<"requirements">
    status?: EnumRequirementStatusWithAggregatesFilter<"requirements"> | $Enums.RequirementStatus
    estimatedEffort?: StringNullableWithAggregatesFilter<"requirements"> | string | null
    dependencies?: JsonNullableWithAggregatesFilter<"requirements">
    businessValue?: StringNullableWithAggregatesFilter<"requirements"> | string | null
    riskAssessment?: StringNullableWithAggregatesFilter<"requirements"> | string | null
    stakeholders?: JsonNullableWithAggregatesFilter<"requirements">
    approvedBy?: StringNullableWithAggregatesFilter<"requirements"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"requirements"> | Date | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"requirements"> | string | null
    solutionId?: StringWithAggregatesFilter<"requirements"> | string
    createdBy?: StringWithAggregatesFilter<"requirements"> | string
    createdAt?: DateTimeWithAggregatesFilter<"requirements"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"requirements"> | Date | string
    priority?: EnumpriorityWithAggregatesFilter<"requirements"> | $Enums.priority
  }

  export type signalsWhereInput = {
    AND?: signalsWhereInput | signalsWhereInput[]
    OR?: signalsWhereInput[]
    NOT?: signalsWhereInput | signalsWhereInput[]
    id?: StringFilter<"signals"> | string
    inputId?: StringFilter<"signals"> | string
    timestamp?: DateTimeFilter<"signals"> | Date | string
    receivedAt?: DateTimeFilter<"signals"> | Date | string
    schemaVersion?: StringFilter<"signals"> | string
    sourceJson?: JsonNullableFilter<"signals">
    confidence?: FloatNullableFilter<"signals"> | number | null
    attachmentsJson?: JsonNullableFilter<"signals">
    sourceType?: StringFilter<"signals"> | string
    sourceId?: StringNullableFilter<"signals"> | string | null
    systemName?: StringNullableFilter<"signals"> | string | null
    title?: StringNullableFilter<"signals"> | string | null
    description?: StringFilter<"signals"> | string
    severity?: EnumSeverityFilter<"signals"> | $Enums.Severity
    severityScore?: IntFilter<"signals"> | number
    departmentId?: StringNullableFilter<"signals"> | string | null
    teamId?: StringNullableFilter<"signals"> | string | null
    categoryId?: StringNullableFilter<"signals"> | string | null
    metricsJson?: JsonNullableFilter<"signals">
    baselineJson?: JsonNullableFilter<"signals">
    impactJson?: JsonNullableFilter<"signals">
    tagsJson?: JsonNullableFilter<"signals">
    entitiesJson?: JsonNullableFilter<"signals">
    privacyLevel?: StringNullableFilter<"signals"> | string | null
    dedupeKey?: StringNullableFilter<"signals"> | string | null
    embedding?: BytesNullableFilter<"signals"> | Uint8Array | null
    aiProcessed?: BoolFilter<"signals"> | boolean
    aiTagsJson?: JsonNullableFilter<"signals">
    lineageJson?: JsonNullableFilter<"signals">
    createdById?: StringNullableFilter<"signals"> | string | null
    createdAt?: DateTimeFilter<"signals"> | Date | string
    updatedAt?: DateTimeFilter<"signals"> | Date | string
    domainClassification?: JsonNullableFilter<"signals">
    enhancedTagsJson?: JsonNullableFilter<"signals">
    lastTaggedAt?: DateTimeNullableFilter<"signals"> | Date | string | null
    tagGenerationMeta?: JsonNullableFilter<"signals">
    tagModelVersion?: StringNullableFilter<"signals"> | string | null
    clusteringFeaturesJson?: JsonNullableFilter<"signals">
    featuresQualityScore?: FloatNullableFilter<"signals"> | number | null
    featuresVersion?: StringNullableFilter<"signals"> | string | null
    lastFeaturesGeneratedAt?: DateTimeNullableFilter<"signals"> | Date | string | null
    ai_insight_overrides?: Ai_insight_overridesListRelationFilter
    hotspot_signals?: Hotspot_signalsListRelationFilter
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    departments?: XOR<DepartmentsNullableScalarRelationFilter, departmentsWhereInput> | null
    teams?: XOR<TeamsNullableScalarRelationFilter, teamsWhereInput> | null
  }

  export type signalsOrderByWithRelationInput = {
    id?: SortOrder
    inputId?: SortOrder
    timestamp?: SortOrder
    receivedAt?: SortOrder
    schemaVersion?: SortOrder
    sourceJson?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    attachmentsJson?: SortOrderInput | SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    systemName?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrder
    severity?: SortOrder
    severityScore?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    metricsJson?: SortOrderInput | SortOrder
    baselineJson?: SortOrderInput | SortOrder
    impactJson?: SortOrderInput | SortOrder
    tagsJson?: SortOrderInput | SortOrder
    entitiesJson?: SortOrderInput | SortOrder
    privacyLevel?: SortOrderInput | SortOrder
    dedupeKey?: SortOrderInput | SortOrder
    embedding?: SortOrderInput | SortOrder
    aiProcessed?: SortOrder
    aiTagsJson?: SortOrderInput | SortOrder
    lineageJson?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domainClassification?: SortOrderInput | SortOrder
    enhancedTagsJson?: SortOrderInput | SortOrder
    lastTaggedAt?: SortOrderInput | SortOrder
    tagGenerationMeta?: SortOrderInput | SortOrder
    tagModelVersion?: SortOrderInput | SortOrder
    clusteringFeaturesJson?: SortOrderInput | SortOrder
    featuresQualityScore?: SortOrderInput | SortOrder
    featuresVersion?: SortOrderInput | SortOrder
    lastFeaturesGeneratedAt?: SortOrderInput | SortOrder
    ai_insight_overrides?: ai_insight_overridesOrderByRelationAggregateInput
    hotspot_signals?: hotspot_signalsOrderByRelationAggregateInput
    categories?: categoriesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    departments?: departmentsOrderByWithRelationInput
    teams?: teamsOrderByWithRelationInput
  }

  export type signalsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    inputId?: string
    dedupeKey?: string
    AND?: signalsWhereInput | signalsWhereInput[]
    OR?: signalsWhereInput[]
    NOT?: signalsWhereInput | signalsWhereInput[]
    timestamp?: DateTimeFilter<"signals"> | Date | string
    receivedAt?: DateTimeFilter<"signals"> | Date | string
    schemaVersion?: StringFilter<"signals"> | string
    sourceJson?: JsonNullableFilter<"signals">
    confidence?: FloatNullableFilter<"signals"> | number | null
    attachmentsJson?: JsonNullableFilter<"signals">
    sourceType?: StringFilter<"signals"> | string
    sourceId?: StringNullableFilter<"signals"> | string | null
    systemName?: StringNullableFilter<"signals"> | string | null
    title?: StringNullableFilter<"signals"> | string | null
    description?: StringFilter<"signals"> | string
    severity?: EnumSeverityFilter<"signals"> | $Enums.Severity
    severityScore?: IntFilter<"signals"> | number
    departmentId?: StringNullableFilter<"signals"> | string | null
    teamId?: StringNullableFilter<"signals"> | string | null
    categoryId?: StringNullableFilter<"signals"> | string | null
    metricsJson?: JsonNullableFilter<"signals">
    baselineJson?: JsonNullableFilter<"signals">
    impactJson?: JsonNullableFilter<"signals">
    tagsJson?: JsonNullableFilter<"signals">
    entitiesJson?: JsonNullableFilter<"signals">
    privacyLevel?: StringNullableFilter<"signals"> | string | null
    embedding?: BytesNullableFilter<"signals"> | Uint8Array | null
    aiProcessed?: BoolFilter<"signals"> | boolean
    aiTagsJson?: JsonNullableFilter<"signals">
    lineageJson?: JsonNullableFilter<"signals">
    createdById?: StringNullableFilter<"signals"> | string | null
    createdAt?: DateTimeFilter<"signals"> | Date | string
    updatedAt?: DateTimeFilter<"signals"> | Date | string
    domainClassification?: JsonNullableFilter<"signals">
    enhancedTagsJson?: JsonNullableFilter<"signals">
    lastTaggedAt?: DateTimeNullableFilter<"signals"> | Date | string | null
    tagGenerationMeta?: JsonNullableFilter<"signals">
    tagModelVersion?: StringNullableFilter<"signals"> | string | null
    clusteringFeaturesJson?: JsonNullableFilter<"signals">
    featuresQualityScore?: FloatNullableFilter<"signals"> | number | null
    featuresVersion?: StringNullableFilter<"signals"> | string | null
    lastFeaturesGeneratedAt?: DateTimeNullableFilter<"signals"> | Date | string | null
    ai_insight_overrides?: Ai_insight_overridesListRelationFilter
    hotspot_signals?: Hotspot_signalsListRelationFilter
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    departments?: XOR<DepartmentsNullableScalarRelationFilter, departmentsWhereInput> | null
    teams?: XOR<TeamsNullableScalarRelationFilter, teamsWhereInput> | null
  }, "id" | "inputId" | "dedupeKey">

  export type signalsOrderByWithAggregationInput = {
    id?: SortOrder
    inputId?: SortOrder
    timestamp?: SortOrder
    receivedAt?: SortOrder
    schemaVersion?: SortOrder
    sourceJson?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    attachmentsJson?: SortOrderInput | SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    systemName?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrder
    severity?: SortOrder
    severityScore?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    metricsJson?: SortOrderInput | SortOrder
    baselineJson?: SortOrderInput | SortOrder
    impactJson?: SortOrderInput | SortOrder
    tagsJson?: SortOrderInput | SortOrder
    entitiesJson?: SortOrderInput | SortOrder
    privacyLevel?: SortOrderInput | SortOrder
    dedupeKey?: SortOrderInput | SortOrder
    embedding?: SortOrderInput | SortOrder
    aiProcessed?: SortOrder
    aiTagsJson?: SortOrderInput | SortOrder
    lineageJson?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domainClassification?: SortOrderInput | SortOrder
    enhancedTagsJson?: SortOrderInput | SortOrder
    lastTaggedAt?: SortOrderInput | SortOrder
    tagGenerationMeta?: SortOrderInput | SortOrder
    tagModelVersion?: SortOrderInput | SortOrder
    clusteringFeaturesJson?: SortOrderInput | SortOrder
    featuresQualityScore?: SortOrderInput | SortOrder
    featuresVersion?: SortOrderInput | SortOrder
    lastFeaturesGeneratedAt?: SortOrderInput | SortOrder
    _count?: signalsCountOrderByAggregateInput
    _avg?: signalsAvgOrderByAggregateInput
    _max?: signalsMaxOrderByAggregateInput
    _min?: signalsMinOrderByAggregateInput
    _sum?: signalsSumOrderByAggregateInput
  }

  export type signalsScalarWhereWithAggregatesInput = {
    AND?: signalsScalarWhereWithAggregatesInput | signalsScalarWhereWithAggregatesInput[]
    OR?: signalsScalarWhereWithAggregatesInput[]
    NOT?: signalsScalarWhereWithAggregatesInput | signalsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"signals"> | string
    inputId?: StringWithAggregatesFilter<"signals"> | string
    timestamp?: DateTimeWithAggregatesFilter<"signals"> | Date | string
    receivedAt?: DateTimeWithAggregatesFilter<"signals"> | Date | string
    schemaVersion?: StringWithAggregatesFilter<"signals"> | string
    sourceJson?: JsonNullableWithAggregatesFilter<"signals">
    confidence?: FloatNullableWithAggregatesFilter<"signals"> | number | null
    attachmentsJson?: JsonNullableWithAggregatesFilter<"signals">
    sourceType?: StringWithAggregatesFilter<"signals"> | string
    sourceId?: StringNullableWithAggregatesFilter<"signals"> | string | null
    systemName?: StringNullableWithAggregatesFilter<"signals"> | string | null
    title?: StringNullableWithAggregatesFilter<"signals"> | string | null
    description?: StringWithAggregatesFilter<"signals"> | string
    severity?: EnumSeverityWithAggregatesFilter<"signals"> | $Enums.Severity
    severityScore?: IntWithAggregatesFilter<"signals"> | number
    departmentId?: StringNullableWithAggregatesFilter<"signals"> | string | null
    teamId?: StringNullableWithAggregatesFilter<"signals"> | string | null
    categoryId?: StringNullableWithAggregatesFilter<"signals"> | string | null
    metricsJson?: JsonNullableWithAggregatesFilter<"signals">
    baselineJson?: JsonNullableWithAggregatesFilter<"signals">
    impactJson?: JsonNullableWithAggregatesFilter<"signals">
    tagsJson?: JsonNullableWithAggregatesFilter<"signals">
    entitiesJson?: JsonNullableWithAggregatesFilter<"signals">
    privacyLevel?: StringNullableWithAggregatesFilter<"signals"> | string | null
    dedupeKey?: StringNullableWithAggregatesFilter<"signals"> | string | null
    embedding?: BytesNullableWithAggregatesFilter<"signals"> | Uint8Array | null
    aiProcessed?: BoolWithAggregatesFilter<"signals"> | boolean
    aiTagsJson?: JsonNullableWithAggregatesFilter<"signals">
    lineageJson?: JsonNullableWithAggregatesFilter<"signals">
    createdById?: StringNullableWithAggregatesFilter<"signals"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"signals"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"signals"> | Date | string
    domainClassification?: JsonNullableWithAggregatesFilter<"signals">
    enhancedTagsJson?: JsonNullableWithAggregatesFilter<"signals">
    lastTaggedAt?: DateTimeNullableWithAggregatesFilter<"signals"> | Date | string | null
    tagGenerationMeta?: JsonNullableWithAggregatesFilter<"signals">
    tagModelVersion?: StringNullableWithAggregatesFilter<"signals"> | string | null
    clusteringFeaturesJson?: JsonNullableWithAggregatesFilter<"signals">
    featuresQualityScore?: FloatNullableWithAggregatesFilter<"signals"> | number | null
    featuresVersion?: StringNullableWithAggregatesFilter<"signals"> | string | null
    lastFeaturesGeneratedAt?: DateTimeNullableWithAggregatesFilter<"signals"> | Date | string | null
  }

  export type solutionsWhereInput = {
    AND?: solutionsWhereInput | solutionsWhereInput[]
    OR?: solutionsWhereInput[]
    NOT?: solutionsWhereInput | solutionsWhereInput[]
    id?: StringFilter<"solutions"> | string
    title?: StringFilter<"solutions"> | string
    description?: StringFilter<"solutions"> | string
    status?: EnumSolutionStatusFilter<"solutions"> | $Enums.SolutionStatus
    createdAt?: DateTimeFilter<"solutions"> | Date | string
    updatedAt?: DateTimeFilter<"solutions"> | Date | string
    estimatedEffort?: StringNullableFilter<"solutions"> | string | null
    actualCompletionDate?: DateTimeNullableFilter<"solutions"> | Date | string | null
    actualImpactJson?: JsonNullableFilter<"solutions">
    businessValue?: StringNullableFilter<"solutions"> | string | null
    createdBy?: StringFilter<"solutions"> | string
    expectedImpactJson?: JsonNullableFilter<"solutions">
    hotspotId?: StringNullableFilter<"solutions"> | string | null
    ideaId?: StringNullableFilter<"solutions"> | string | null
    initiativeId?: StringNullableFilter<"solutions"> | string | null
    inputId?: StringNullableFilter<"solutions"> | string | null
    progress?: FloatFilter<"solutions"> | number
    successMetrics?: JsonNullableFilter<"solutions">
    targetDate?: DateTimeNullableFilter<"solutions"> | Date | string | null
    tasks?: JsonNullableFilter<"solutions">
    frd_documents?: Frd_documentsListRelationFilter
    requirements?: RequirementsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    hotspots?: XOR<HotspotsNullableScalarRelationFilter, hotspotsWhereInput> | null
    ideas?: XOR<IdeasNullableScalarRelationFilter, ideasWhereInput> | null
    initiatives?: XOR<InitiativesNullableScalarRelationFilter, initiativesWhereInput> | null
    inputs?: XOR<InputsNullableScalarRelationFilter, inputsWhereInput> | null
  }

  export type solutionsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estimatedEffort?: SortOrderInput | SortOrder
    actualCompletionDate?: SortOrderInput | SortOrder
    actualImpactJson?: SortOrderInput | SortOrder
    businessValue?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    expectedImpactJson?: SortOrderInput | SortOrder
    hotspotId?: SortOrderInput | SortOrder
    ideaId?: SortOrderInput | SortOrder
    initiativeId?: SortOrderInput | SortOrder
    inputId?: SortOrderInput | SortOrder
    progress?: SortOrder
    successMetrics?: SortOrderInput | SortOrder
    targetDate?: SortOrderInput | SortOrder
    tasks?: SortOrderInput | SortOrder
    frd_documents?: frd_documentsOrderByRelationAggregateInput
    requirements?: requirementsOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
    hotspots?: hotspotsOrderByWithRelationInput
    ideas?: ideasOrderByWithRelationInput
    initiatives?: initiativesOrderByWithRelationInput
    inputs?: inputsOrderByWithRelationInput
  }

  export type solutionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ideaId?: string
    AND?: solutionsWhereInput | solutionsWhereInput[]
    OR?: solutionsWhereInput[]
    NOT?: solutionsWhereInput | solutionsWhereInput[]
    title?: StringFilter<"solutions"> | string
    description?: StringFilter<"solutions"> | string
    status?: EnumSolutionStatusFilter<"solutions"> | $Enums.SolutionStatus
    createdAt?: DateTimeFilter<"solutions"> | Date | string
    updatedAt?: DateTimeFilter<"solutions"> | Date | string
    estimatedEffort?: StringNullableFilter<"solutions"> | string | null
    actualCompletionDate?: DateTimeNullableFilter<"solutions"> | Date | string | null
    actualImpactJson?: JsonNullableFilter<"solutions">
    businessValue?: StringNullableFilter<"solutions"> | string | null
    createdBy?: StringFilter<"solutions"> | string
    expectedImpactJson?: JsonNullableFilter<"solutions">
    hotspotId?: StringNullableFilter<"solutions"> | string | null
    initiativeId?: StringNullableFilter<"solutions"> | string | null
    inputId?: StringNullableFilter<"solutions"> | string | null
    progress?: FloatFilter<"solutions"> | number
    successMetrics?: JsonNullableFilter<"solutions">
    targetDate?: DateTimeNullableFilter<"solutions"> | Date | string | null
    tasks?: JsonNullableFilter<"solutions">
    frd_documents?: Frd_documentsListRelationFilter
    requirements?: RequirementsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    hotspots?: XOR<HotspotsNullableScalarRelationFilter, hotspotsWhereInput> | null
    ideas?: XOR<IdeasNullableScalarRelationFilter, ideasWhereInput> | null
    initiatives?: XOR<InitiativesNullableScalarRelationFilter, initiativesWhereInput> | null
    inputs?: XOR<InputsNullableScalarRelationFilter, inputsWhereInput> | null
  }, "id" | "ideaId">

  export type solutionsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estimatedEffort?: SortOrderInput | SortOrder
    actualCompletionDate?: SortOrderInput | SortOrder
    actualImpactJson?: SortOrderInput | SortOrder
    businessValue?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    expectedImpactJson?: SortOrderInput | SortOrder
    hotspotId?: SortOrderInput | SortOrder
    ideaId?: SortOrderInput | SortOrder
    initiativeId?: SortOrderInput | SortOrder
    inputId?: SortOrderInput | SortOrder
    progress?: SortOrder
    successMetrics?: SortOrderInput | SortOrder
    targetDate?: SortOrderInput | SortOrder
    tasks?: SortOrderInput | SortOrder
    _count?: solutionsCountOrderByAggregateInput
    _avg?: solutionsAvgOrderByAggregateInput
    _max?: solutionsMaxOrderByAggregateInput
    _min?: solutionsMinOrderByAggregateInput
    _sum?: solutionsSumOrderByAggregateInput
  }

  export type solutionsScalarWhereWithAggregatesInput = {
    AND?: solutionsScalarWhereWithAggregatesInput | solutionsScalarWhereWithAggregatesInput[]
    OR?: solutionsScalarWhereWithAggregatesInput[]
    NOT?: solutionsScalarWhereWithAggregatesInput | solutionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"solutions"> | string
    title?: StringWithAggregatesFilter<"solutions"> | string
    description?: StringWithAggregatesFilter<"solutions"> | string
    status?: EnumSolutionStatusWithAggregatesFilter<"solutions"> | $Enums.SolutionStatus
    createdAt?: DateTimeWithAggregatesFilter<"solutions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"solutions"> | Date | string
    estimatedEffort?: StringNullableWithAggregatesFilter<"solutions"> | string | null
    actualCompletionDate?: DateTimeNullableWithAggregatesFilter<"solutions"> | Date | string | null
    actualImpactJson?: JsonNullableWithAggregatesFilter<"solutions">
    businessValue?: StringNullableWithAggregatesFilter<"solutions"> | string | null
    createdBy?: StringWithAggregatesFilter<"solutions"> | string
    expectedImpactJson?: JsonNullableWithAggregatesFilter<"solutions">
    hotspotId?: StringNullableWithAggregatesFilter<"solutions"> | string | null
    ideaId?: StringNullableWithAggregatesFilter<"solutions"> | string | null
    initiativeId?: StringNullableWithAggregatesFilter<"solutions"> | string | null
    inputId?: StringNullableWithAggregatesFilter<"solutions"> | string | null
    progress?: FloatWithAggregatesFilter<"solutions"> | number
    successMetrics?: JsonNullableWithAggregatesFilter<"solutions">
    targetDate?: DateTimeNullableWithAggregatesFilter<"solutions"> | Date | string | null
    tasks?: JsonNullableWithAggregatesFilter<"solutions">
  }

  export type teamsWhereInput = {
    AND?: teamsWhereInput | teamsWhereInput[]
    OR?: teamsWhereInput[]
    NOT?: teamsWhereInput | teamsWhereInput[]
    id?: StringFilter<"teams"> | string
    name?: StringFilter<"teams"> | string
    description?: StringNullableFilter<"teams"> | string | null
    departmentId?: StringNullableFilter<"teams"> | string | null
    leaderId?: StringNullableFilter<"teams"> | string | null
    memberCount?: IntFilter<"teams"> | number
    maxCapacity?: IntNullableFilter<"teams"> | number | null
    isActive?: BoolFilter<"teams"> | boolean
    teamType?: StringNullableFilter<"teams"> | string | null
    currentProjects?: IntFilter<"teams"> | number
    budgetAllocation?: FloatFilter<"teams"> | number
    utilizationRate?: FloatNullableFilter<"teams"> | number | null
    createdAt?: DateTimeFilter<"teams"> | Date | string
    updatedAt?: DateTimeFilter<"teams"> | Date | string
    signals?: SignalsListRelationFilter
    departments?: XOR<DepartmentsNullableScalarRelationFilter, departmentsWhereInput> | null
    users_teams_leaderIdTousers?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    users_TeamMembers?: UsersListRelationFilter
  }

  export type teamsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    leaderId?: SortOrderInput | SortOrder
    memberCount?: SortOrder
    maxCapacity?: SortOrderInput | SortOrder
    isActive?: SortOrder
    teamType?: SortOrderInput | SortOrder
    currentProjects?: SortOrder
    budgetAllocation?: SortOrder
    utilizationRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    signals?: signalsOrderByRelationAggregateInput
    departments?: departmentsOrderByWithRelationInput
    users_teams_leaderIdTousers?: usersOrderByWithRelationInput
    users_TeamMembers?: usersOrderByRelationAggregateInput
  }

  export type teamsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: teamsWhereInput | teamsWhereInput[]
    OR?: teamsWhereInput[]
    NOT?: teamsWhereInput | teamsWhereInput[]
    name?: StringFilter<"teams"> | string
    description?: StringNullableFilter<"teams"> | string | null
    departmentId?: StringNullableFilter<"teams"> | string | null
    leaderId?: StringNullableFilter<"teams"> | string | null
    memberCount?: IntFilter<"teams"> | number
    maxCapacity?: IntNullableFilter<"teams"> | number | null
    isActive?: BoolFilter<"teams"> | boolean
    teamType?: StringNullableFilter<"teams"> | string | null
    currentProjects?: IntFilter<"teams"> | number
    budgetAllocation?: FloatFilter<"teams"> | number
    utilizationRate?: FloatNullableFilter<"teams"> | number | null
    createdAt?: DateTimeFilter<"teams"> | Date | string
    updatedAt?: DateTimeFilter<"teams"> | Date | string
    signals?: SignalsListRelationFilter
    departments?: XOR<DepartmentsNullableScalarRelationFilter, departmentsWhereInput> | null
    users_teams_leaderIdTousers?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    users_TeamMembers?: UsersListRelationFilter
  }, "id">

  export type teamsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    leaderId?: SortOrderInput | SortOrder
    memberCount?: SortOrder
    maxCapacity?: SortOrderInput | SortOrder
    isActive?: SortOrder
    teamType?: SortOrderInput | SortOrder
    currentProjects?: SortOrder
    budgetAllocation?: SortOrder
    utilizationRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: teamsCountOrderByAggregateInput
    _avg?: teamsAvgOrderByAggregateInput
    _max?: teamsMaxOrderByAggregateInput
    _min?: teamsMinOrderByAggregateInput
    _sum?: teamsSumOrderByAggregateInput
  }

  export type teamsScalarWhereWithAggregatesInput = {
    AND?: teamsScalarWhereWithAggregatesInput | teamsScalarWhereWithAggregatesInput[]
    OR?: teamsScalarWhereWithAggregatesInput[]
    NOT?: teamsScalarWhereWithAggregatesInput | teamsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"teams"> | string
    name?: StringWithAggregatesFilter<"teams"> | string
    description?: StringNullableWithAggregatesFilter<"teams"> | string | null
    departmentId?: StringNullableWithAggregatesFilter<"teams"> | string | null
    leaderId?: StringNullableWithAggregatesFilter<"teams"> | string | null
    memberCount?: IntWithAggregatesFilter<"teams"> | number
    maxCapacity?: IntNullableWithAggregatesFilter<"teams"> | number | null
    isActive?: BoolWithAggregatesFilter<"teams"> | boolean
    teamType?: StringNullableWithAggregatesFilter<"teams"> | string | null
    currentProjects?: IntWithAggregatesFilter<"teams"> | number
    budgetAllocation?: FloatWithAggregatesFilter<"teams"> | number
    utilizationRate?: FloatNullableWithAggregatesFilter<"teams"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"teams"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"teams"> | Date | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    name?: StringFilter<"users"> | string
    role?: EnumUserRoleFilter<"users"> | $Enums.UserRole
    department?: StringNullableFilter<"users"> | string | null
    avatar?: StringNullableFilter<"users"> | string | null
    passwordHash?: StringNullableFilter<"users"> | string | null
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    title?: StringNullableFilter<"users"> | string | null
    managerId?: StringNullableFilter<"users"> | string | null
    billableRate?: FloatNullableFilter<"users"> | number | null
    costCenter?: StringNullableFilter<"users"> | string | null
    location?: StringNullableFilter<"users"> | string | null
    isActive?: BoolFilter<"users"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"users"> | Date | string | null
    profileJson?: JsonNullableFilter<"users">
    targetUtilization?: FloatNullableFilter<"users"> | number | null
    utilizationRate?: FloatNullableFilter<"users"> | number | null
    departmentObjId?: StringNullableFilter<"users"> | string | null
    ai_analysis_audit?: Ai_analysis_auditListRelationFilter
    ai_insight_overrides?: Ai_insight_overridesListRelationFilter
    audit_logs?: Audit_logsListRelationFilter
    comments?: CommentsListRelationFilter
    departments_departments_managerIdTousers?: DepartmentsListRelationFilter
    frd_documents_frd_documents_approvedByTousers?: Frd_documentsListRelationFilter
    frd_documents_frd_documents_createdByTousers?: Frd_documentsListRelationFilter
    ideas?: IdeasListRelationFilter
    initiatives?: InitiativesListRelationFilter
    input_groups?: Input_groupsListRelationFilter
    inputs?: InputsListRelationFilter
    requirements?: RequirementsListRelationFilter
    signals?: SignalsListRelationFilter
    solutions?: SolutionsListRelationFilter
    teams_teams_leaderIdTousers?: TeamsListRelationFilter
    departments_users_departmentObjIdTodepartments?: XOR<DepartmentsNullableScalarRelationFilter, departmentsWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    other_users?: UsersListRelationFilter
    votes?: VotesListRelationFilter
    teams_TeamMembers?: TeamsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    billableRate?: SortOrderInput | SortOrder
    costCenter?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    profileJson?: SortOrderInput | SortOrder
    targetUtilization?: SortOrderInput | SortOrder
    utilizationRate?: SortOrderInput | SortOrder
    departmentObjId?: SortOrderInput | SortOrder
    ai_analysis_audit?: ai_analysis_auditOrderByRelationAggregateInput
    ai_insight_overrides?: ai_insight_overridesOrderByRelationAggregateInput
    audit_logs?: audit_logsOrderByRelationAggregateInput
    comments?: commentsOrderByRelationAggregateInput
    departments_departments_managerIdTousers?: departmentsOrderByRelationAggregateInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsOrderByRelationAggregateInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsOrderByRelationAggregateInput
    ideas?: ideasOrderByRelationAggregateInput
    initiatives?: initiativesOrderByRelationAggregateInput
    input_groups?: input_groupsOrderByRelationAggregateInput
    inputs?: inputsOrderByRelationAggregateInput
    requirements?: requirementsOrderByRelationAggregateInput
    signals?: signalsOrderByRelationAggregateInput
    solutions?: solutionsOrderByRelationAggregateInput
    teams_teams_leaderIdTousers?: teamsOrderByRelationAggregateInput
    departments_users_departmentObjIdTodepartments?: departmentsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    other_users?: usersOrderByRelationAggregateInput
    votes?: votesOrderByRelationAggregateInput
    teams_TeamMembers?: teamsOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    name?: StringFilter<"users"> | string
    role?: EnumUserRoleFilter<"users"> | $Enums.UserRole
    department?: StringNullableFilter<"users"> | string | null
    avatar?: StringNullableFilter<"users"> | string | null
    passwordHash?: StringNullableFilter<"users"> | string | null
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    title?: StringNullableFilter<"users"> | string | null
    managerId?: StringNullableFilter<"users"> | string | null
    billableRate?: FloatNullableFilter<"users"> | number | null
    costCenter?: StringNullableFilter<"users"> | string | null
    location?: StringNullableFilter<"users"> | string | null
    isActive?: BoolFilter<"users"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"users"> | Date | string | null
    profileJson?: JsonNullableFilter<"users">
    targetUtilization?: FloatNullableFilter<"users"> | number | null
    utilizationRate?: FloatNullableFilter<"users"> | number | null
    departmentObjId?: StringNullableFilter<"users"> | string | null
    ai_analysis_audit?: Ai_analysis_auditListRelationFilter
    ai_insight_overrides?: Ai_insight_overridesListRelationFilter
    audit_logs?: Audit_logsListRelationFilter
    comments?: CommentsListRelationFilter
    departments_departments_managerIdTousers?: DepartmentsListRelationFilter
    frd_documents_frd_documents_approvedByTousers?: Frd_documentsListRelationFilter
    frd_documents_frd_documents_createdByTousers?: Frd_documentsListRelationFilter
    ideas?: IdeasListRelationFilter
    initiatives?: InitiativesListRelationFilter
    input_groups?: Input_groupsListRelationFilter
    inputs?: InputsListRelationFilter
    requirements?: RequirementsListRelationFilter
    signals?: SignalsListRelationFilter
    solutions?: SolutionsListRelationFilter
    teams_teams_leaderIdTousers?: TeamsListRelationFilter
    departments_users_departmentObjIdTodepartments?: XOR<DepartmentsNullableScalarRelationFilter, departmentsWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    other_users?: UsersListRelationFilter
    votes?: VotesListRelationFilter
    teams_TeamMembers?: TeamsListRelationFilter
  }, "id" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    billableRate?: SortOrderInput | SortOrder
    costCenter?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    profileJson?: SortOrderInput | SortOrder
    targetUtilization?: SortOrderInput | SortOrder
    utilizationRate?: SortOrderInput | SortOrder
    departmentObjId?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    name?: StringWithAggregatesFilter<"users"> | string
    role?: EnumUserRoleWithAggregatesFilter<"users"> | $Enums.UserRole
    department?: StringNullableWithAggregatesFilter<"users"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"users"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"users"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    title?: StringNullableWithAggregatesFilter<"users"> | string | null
    managerId?: StringNullableWithAggregatesFilter<"users"> | string | null
    billableRate?: FloatNullableWithAggregatesFilter<"users"> | number | null
    costCenter?: StringNullableWithAggregatesFilter<"users"> | string | null
    location?: StringNullableWithAggregatesFilter<"users"> | string | null
    isActive?: BoolWithAggregatesFilter<"users"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    profileJson?: JsonNullableWithAggregatesFilter<"users">
    targetUtilization?: FloatNullableWithAggregatesFilter<"users"> | number | null
    utilizationRate?: FloatNullableWithAggregatesFilter<"users"> | number | null
    departmentObjId?: StringNullableWithAggregatesFilter<"users"> | string | null
  }

  export type votesWhereInput = {
    AND?: votesWhereInput | votesWhereInput[]
    OR?: votesWhereInput[]
    NOT?: votesWhereInput | votesWhereInput[]
    id?: StringFilter<"votes"> | string
    createdAt?: DateTimeFilter<"votes"> | Date | string
    createdBy?: StringFilter<"votes"> | string
    entityId?: StringFilter<"votes"> | string
    entityType?: EnumEntityTypeFilter<"votes"> | $Enums.EntityType
    value?: EnumVoteValueFilter<"votes"> | $Enums.VoteValue
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type votesOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    value?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type votesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    entityType_entityId_createdBy?: votesEntityTypeEntityIdCreatedByCompoundUniqueInput
    AND?: votesWhereInput | votesWhereInput[]
    OR?: votesWhereInput[]
    NOT?: votesWhereInput | votesWhereInput[]
    createdAt?: DateTimeFilter<"votes"> | Date | string
    createdBy?: StringFilter<"votes"> | string
    entityId?: StringFilter<"votes"> | string
    entityType?: EnumEntityTypeFilter<"votes"> | $Enums.EntityType
    value?: EnumVoteValueFilter<"votes"> | $Enums.VoteValue
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "entityType_entityId_createdBy">

  export type votesOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    value?: SortOrder
    _count?: votesCountOrderByAggregateInput
    _max?: votesMaxOrderByAggregateInput
    _min?: votesMinOrderByAggregateInput
  }

  export type votesScalarWhereWithAggregatesInput = {
    AND?: votesScalarWhereWithAggregatesInput | votesScalarWhereWithAggregatesInput[]
    OR?: votesScalarWhereWithAggregatesInput[]
    NOT?: votesScalarWhereWithAggregatesInput | votesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"votes"> | string
    createdAt?: DateTimeWithAggregatesFilter<"votes"> | Date | string
    createdBy?: StringWithAggregatesFilter<"votes"> | string
    entityId?: StringWithAggregatesFilter<"votes"> | string
    entityType?: EnumEntityTypeWithAggregatesFilter<"votes"> | $Enums.EntityType
    value?: EnumVoteValueWithAggregatesFilter<"votes"> | $Enums.VoteValue
  }

  export type InputToInputGroupCreateInput = {
    inputs: inputsCreateNestedOneWithoutInputToInputGroupInput
    input_groups: input_groupsCreateNestedOneWithoutInputToInputGroupInput
  }

  export type InputToInputGroupUncheckedCreateInput = {
    A: string
    B: string
  }

  export type InputToInputGroupUpdateInput = {
    inputs?: inputsUpdateOneRequiredWithoutInputToInputGroupNestedInput
    input_groups?: input_groupsUpdateOneRequiredWithoutInputToInputGroupNestedInput
  }

  export type InputToInputGroupUncheckedUpdateInput = {
    A?: StringFieldUpdateOperationsInput | string
    B?: StringFieldUpdateOperationsInput | string
  }

  export type InputToInputGroupCreateManyInput = {
    A: string
    B: string
  }

  export type InputToInputGroupUpdateManyMutationInput = {

  }

  export type InputToInputGroupUncheckedUpdateManyInput = {
    A?: StringFieldUpdateOperationsInput | string
    B?: StringFieldUpdateOperationsInput | string
  }

  export type ai_analysis_auditCreateInput = {
    id: string
    hotspotId: string
    analysisType: string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: number | null
    confidence?: number | null
    status: string
    errorMessage?: string | null
    createdAt?: Date | string
    users: usersCreateNestedOneWithoutAi_analysis_auditInput
  }

  export type ai_analysis_auditUncheckedCreateInput = {
    id: string
    hotspotId: string
    analysisType: string
    userId: string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: number | null
    confidence?: number | null
    status: string
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type ai_analysis_auditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotspotId?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutAi_analysis_auditNestedInput
  }

  export type ai_analysis_auditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotspotId?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_analysis_auditCreateManyInput = {
    id: string
    hotspotId: string
    analysisType: string
    userId: string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: number | null
    confidence?: number | null
    status: string
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type ai_analysis_auditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotspotId?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_analysis_auditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotspotId?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_insight_overridesCreateInput = {
    id: string
    insightId: string
    insightType: string
    originalRecommendation?: NullableJsonNullValueInput | InputJsonValue
    overrideReason: string
    executiveJustification?: string | null
    newValue?: NullableJsonNullValueInput | InputJsonValue
    executiveName: string
    executiveEmail: string
    overriddenAt?: Date | string
    createdAt?: Date | string
    users: usersCreateNestedOneWithoutAi_insight_overridesInput
    signals: signalsCreateNestedOneWithoutAi_insight_overridesInput
  }

  export type ai_insight_overridesUncheckedCreateInput = {
    id: string
    signalId: string
    insightId: string
    insightType: string
    originalRecommendation?: NullableJsonNullValueInput | InputJsonValue
    overrideReason: string
    executiveJustification?: string | null
    newValue?: NullableJsonNullValueInput | InputJsonValue
    executiveId: string
    executiveName: string
    executiveEmail: string
    overriddenAt?: Date | string
    createdAt?: Date | string
  }

  export type ai_insight_overridesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    originalRecommendation?: NullableJsonNullValueInput | InputJsonValue
    overrideReason?: StringFieldUpdateOperationsInput | string
    executiveJustification?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableJsonNullValueInput | InputJsonValue
    executiveName?: StringFieldUpdateOperationsInput | string
    executiveEmail?: StringFieldUpdateOperationsInput | string
    overriddenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutAi_insight_overridesNestedInput
    signals?: signalsUpdateOneRequiredWithoutAi_insight_overridesNestedInput
  }

  export type ai_insight_overridesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    signalId?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    originalRecommendation?: NullableJsonNullValueInput | InputJsonValue
    overrideReason?: StringFieldUpdateOperationsInput | string
    executiveJustification?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableJsonNullValueInput | InputJsonValue
    executiveId?: StringFieldUpdateOperationsInput | string
    executiveName?: StringFieldUpdateOperationsInput | string
    executiveEmail?: StringFieldUpdateOperationsInput | string
    overriddenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_insight_overridesCreateManyInput = {
    id: string
    signalId: string
    insightId: string
    insightType: string
    originalRecommendation?: NullableJsonNullValueInput | InputJsonValue
    overrideReason: string
    executiveJustification?: string | null
    newValue?: NullableJsonNullValueInput | InputJsonValue
    executiveId: string
    executiveName: string
    executiveEmail: string
    overriddenAt?: Date | string
    createdAt?: Date | string
  }

  export type ai_insight_overridesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    originalRecommendation?: NullableJsonNullValueInput | InputJsonValue
    overrideReason?: StringFieldUpdateOperationsInput | string
    executiveJustification?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableJsonNullValueInput | InputJsonValue
    executiveName?: StringFieldUpdateOperationsInput | string
    executiveEmail?: StringFieldUpdateOperationsInput | string
    overriddenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_insight_overridesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    signalId?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    originalRecommendation?: NullableJsonNullValueInput | InputJsonValue
    overrideReason?: StringFieldUpdateOperationsInput | string
    executiveJustification?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableJsonNullValueInput | InputJsonValue
    executiveId?: StringFieldUpdateOperationsInput | string
    executiveName?: StringFieldUpdateOperationsInput | string
    executiveEmail?: StringFieldUpdateOperationsInput | string
    overriddenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type audit_logsCreateInput = {
    id: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    sessionId?: string | null
    users: usersCreateNestedOneWithoutAudit_logsInput
  }

  export type audit_logsUncheckedCreateInput = {
    id: string
    userId: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    sessionId?: string | null
  }

  export type audit_logsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUpdateOneRequiredWithoutAudit_logsNestedInput
  }

  export type audit_logsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type audit_logsCreateManyInput = {
    id: string
    userId: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    sessionId?: string | null
  }

  export type audit_logsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type audit_logsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categoriesCreateInput = {
    id: string
    name: string
    description?: string | null
    color?: string | null
    icon?: string | null
    isActive?: boolean
    sortOrder?: number
    usageCount?: number
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    categories?: categoriesCreateNestedOneWithoutOther_categoriesInput
    other_categories?: categoriesCreateNestedManyWithoutCategoriesInput
    signals?: signalsCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    color?: string | null
    icon?: string | null
    parentId?: string | null
    isActive?: boolean
    sortOrder?: number
    usageCount?: number
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    other_categories?: categoriesUncheckedCreateNestedManyWithoutCategoriesInput
    signals?: signalsUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: categoriesUpdateOneWithoutOther_categoriesNestedInput
    other_categories?: categoriesUpdateManyWithoutCategoriesNestedInput
    signals?: signalsUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    other_categories?: categoriesUncheckedUpdateManyWithoutCategoriesNestedInput
    signals?: signalsUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesCreateManyInput = {
    id: string
    name: string
    description?: string | null
    color?: string | null
    icon?: string | null
    parentId?: string | null
    isActive?: boolean
    sortOrder?: number
    usageCount?: number
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type categoriesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoriesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentsCreateInput = {
    id: string
    content: string
    createdAt?: Date | string
    updatedAt: Date | string
    edited?: boolean
    editedAt?: Date | string | null
    entityId: string
    entityType: $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
    users: usersCreateNestedOneWithoutCommentsInput
    comments?: commentsCreateNestedOneWithoutOther_commentsInput
    other_comments?: commentsCreateNestedManyWithoutCommentsInput
  }

  export type commentsUncheckedCreateInput = {
    id: string
    content: string
    createdAt?: Date | string
    updatedAt: Date | string
    parentId?: string | null
    createdBy: string
    edited?: boolean
    editedAt?: Date | string | null
    entityId: string
    entityType: $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
    other_comments?: commentsUncheckedCreateNestedManyWithoutCommentsInput
  }

  export type commentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
    users?: usersUpdateOneRequiredWithoutCommentsNestedInput
    comments?: commentsUpdateOneWithoutOther_commentsNestedInput
    other_comments?: commentsUpdateManyWithoutCommentsNestedInput
  }

  export type commentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
    other_comments?: commentsUncheckedUpdateManyWithoutCommentsNestedInput
  }

  export type commentsCreateManyInput = {
    id: string
    content: string
    createdAt?: Date | string
    updatedAt: Date | string
    parentId?: string | null
    createdBy: string
    edited?: boolean
    editedAt?: Date | string | null
    entityId: string
    entityType: $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type commentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type commentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type departmentsCreateInput = {
    id: string
    name: string
    description?: string | null
    headCount?: number
    budgetAllocation?: number
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    utilizationTarget?: number | null
    actualUtilization?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    users_departments_managerIdTousers?: usersCreateNestedOneWithoutDepartments_departments_managerIdTousersInput
    signals?: signalsCreateNestedManyWithoutDepartmentsInput
    teams?: teamsCreateNestedManyWithoutDepartmentsInput
    users_users_departmentObjIdTodepartments?: usersCreateNestedManyWithoutDepartments_users_departmentObjIdTodepartmentsInput
  }

  export type departmentsUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    headCount?: number
    budgetAllocation?: number
    managerId?: string | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    utilizationTarget?: number | null
    actualUtilization?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    signals?: signalsUncheckedCreateNestedManyWithoutDepartmentsInput
    teams?: teamsUncheckedCreateNestedManyWithoutDepartmentsInput
    users_users_departmentObjIdTodepartments?: usersUncheckedCreateNestedManyWithoutDepartments_users_departmentObjIdTodepartmentsInput
  }

  export type departmentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headCount?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    utilizationTarget?: NullableFloatFieldUpdateOperationsInput | number | null
    actualUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_departments_managerIdTousers?: usersUpdateOneWithoutDepartments_departments_managerIdTousersNestedInput
    signals?: signalsUpdateManyWithoutDepartmentsNestedInput
    teams?: teamsUpdateManyWithoutDepartmentsNestedInput
    users_users_departmentObjIdTodepartments?: usersUpdateManyWithoutDepartments_users_departmentObjIdTodepartmentsNestedInput
  }

  export type departmentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headCount?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    utilizationTarget?: NullableFloatFieldUpdateOperationsInput | number | null
    actualUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: signalsUncheckedUpdateManyWithoutDepartmentsNestedInput
    teams?: teamsUncheckedUpdateManyWithoutDepartmentsNestedInput
    users_users_departmentObjIdTodepartments?: usersUncheckedUpdateManyWithoutDepartments_users_departmentObjIdTodepartmentsNestedInput
  }

  export type departmentsCreateManyInput = {
    id: string
    name: string
    description?: string | null
    headCount?: number
    budgetAllocation?: number
    managerId?: string | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    utilizationTarget?: number | null
    actualUtilization?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type departmentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headCount?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    utilizationTarget?: NullableFloatFieldUpdateOperationsInput | number | null
    actualUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type departmentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headCount?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    utilizationTarget?: NullableFloatFieldUpdateOperationsInput | number | null
    actualUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type frd_documentsCreateInput = {
    id: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    users_frd_documents_approvedByTousers?: usersCreateNestedOneWithoutFrd_documents_frd_documents_approvedByTousersInput
    users_frd_documents_createdByTousers: usersCreateNestedOneWithoutFrd_documents_frd_documents_createdByTousersInput
    solutions: solutionsCreateNestedOneWithoutFrd_documentsInput
  }

  export type frd_documentsUncheckedCreateInput = {
    id: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    solutionId: string
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type frd_documentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_frd_documents_approvedByTousers?: usersUpdateOneWithoutFrd_documents_frd_documents_approvedByTousersNestedInput
    users_frd_documents_createdByTousers?: usersUpdateOneRequiredWithoutFrd_documents_frd_documents_createdByTousersNestedInput
    solutions?: solutionsUpdateOneRequiredWithoutFrd_documentsNestedInput
  }

  export type frd_documentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    solutionId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type frd_documentsCreateManyInput = {
    id: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    solutionId: string
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type frd_documentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type frd_documentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    solutionId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type hotspot_signalsCreateInput = {
    membershipStrength?: number
    isOutlier?: boolean
    addedAt?: Date | string
    hotspots: hotspotsCreateNestedOneWithoutHotspot_signalsInput
    signals: signalsCreateNestedOneWithoutHotspot_signalsInput
  }

  export type hotspot_signalsUncheckedCreateInput = {
    hotspotId: string
    signalId: string
    membershipStrength?: number
    isOutlier?: boolean
    addedAt?: Date | string
  }

  export type hotspot_signalsUpdateInput = {
    membershipStrength?: FloatFieldUpdateOperationsInput | number
    isOutlier?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotspots?: hotspotsUpdateOneRequiredWithoutHotspot_signalsNestedInput
    signals?: signalsUpdateOneRequiredWithoutHotspot_signalsNestedInput
  }

  export type hotspot_signalsUncheckedUpdateInput = {
    hotspotId?: StringFieldUpdateOperationsInput | string
    signalId?: StringFieldUpdateOperationsInput | string
    membershipStrength?: FloatFieldUpdateOperationsInput | number
    isOutlier?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type hotspot_signalsCreateManyInput = {
    hotspotId: string
    signalId: string
    membershipStrength?: number
    isOutlier?: boolean
    addedAt?: Date | string
  }

  export type hotspot_signalsUpdateManyMutationInput = {
    membershipStrength?: FloatFieldUpdateOperationsInput | number
    isOutlier?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type hotspot_signalsUncheckedUpdateManyInput = {
    hotspotId?: StringFieldUpdateOperationsInput | string
    signalId?: StringFieldUpdateOperationsInput | string
    membershipStrength?: FloatFieldUpdateOperationsInput | number
    isOutlier?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type hotspotsCreateInput = {
    id: string
    title: string
    summary: string
    status?: $Enums.HotspotStatus
    rankScore?: number
    confidence?: number
    primaryCategoryId?: string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: string | null
    similarityThreshold?: number | null
    rcaBreakdownJson?: NullableJsonNullValueInput | InputJsonValue
    solutionSuggestionsJson?: NullableJsonNullValueInput | InputJsonValue
    decisionMatrixJson?: NullableJsonNullValueInput | InputJsonValue
    crossFunctionalImpactJson?: NullableJsonNullValueInput | InputJsonValue
    lastAnalysisAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    clusteringQualityScore?: number | null
    clusteringResults?: NullableJsonNullValueInput | InputJsonValue
    clusteringVersion?: string | null
    lastClusteredAt?: Date | string | null
    hotspot_signals?: hotspot_signalsCreateNestedManyWithoutHotspotsInput
    ideas?: ideasCreateNestedManyWithoutHotspotsInput
    solutions?: solutionsCreateNestedManyWithoutHotspotsInput
  }

  export type hotspotsUncheckedCreateInput = {
    id: string
    title: string
    summary: string
    status?: $Enums.HotspotStatus
    rankScore?: number
    confidence?: number
    primaryCategoryId?: string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: string | null
    similarityThreshold?: number | null
    rcaBreakdownJson?: NullableJsonNullValueInput | InputJsonValue
    solutionSuggestionsJson?: NullableJsonNullValueInput | InputJsonValue
    decisionMatrixJson?: NullableJsonNullValueInput | InputJsonValue
    crossFunctionalImpactJson?: NullableJsonNullValueInput | InputJsonValue
    lastAnalysisAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    clusteringQualityScore?: number | null
    clusteringResults?: NullableJsonNullValueInput | InputJsonValue
    clusteringVersion?: string | null
    lastClusteredAt?: Date | string | null
    hotspot_signals?: hotspot_signalsUncheckedCreateNestedManyWithoutHotspotsInput
    ideas?: ideasUncheckedCreateNestedManyWithoutHotspotsInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutHotspotsInput
  }

  export type hotspotsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumHotspotStatusFieldUpdateOperationsInput | $Enums.HotspotStatus
    rankScore?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    primaryCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: NullableStringFieldUpdateOperationsInput | string | null
    similarityThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    rcaBreakdownJson?: NullableJsonNullValueInput | InputJsonValue
    solutionSuggestionsJson?: NullableJsonNullValueInput | InputJsonValue
    decisionMatrixJson?: NullableJsonNullValueInput | InputJsonValue
    crossFunctionalImpactJson?: NullableJsonNullValueInput | InputJsonValue
    lastAnalysisAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clusteringQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    clusteringResults?: NullableJsonNullValueInput | InputJsonValue
    clusteringVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastClusteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotspot_signals?: hotspot_signalsUpdateManyWithoutHotspotsNestedInput
    ideas?: ideasUpdateManyWithoutHotspotsNestedInput
    solutions?: solutionsUpdateManyWithoutHotspotsNestedInput
  }

  export type hotspotsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumHotspotStatusFieldUpdateOperationsInput | $Enums.HotspotStatus
    rankScore?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    primaryCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: NullableStringFieldUpdateOperationsInput | string | null
    similarityThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    rcaBreakdownJson?: NullableJsonNullValueInput | InputJsonValue
    solutionSuggestionsJson?: NullableJsonNullValueInput | InputJsonValue
    decisionMatrixJson?: NullableJsonNullValueInput | InputJsonValue
    crossFunctionalImpactJson?: NullableJsonNullValueInput | InputJsonValue
    lastAnalysisAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clusteringQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    clusteringResults?: NullableJsonNullValueInput | InputJsonValue
    clusteringVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastClusteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotspot_signals?: hotspot_signalsUncheckedUpdateManyWithoutHotspotsNestedInput
    ideas?: ideasUncheckedUpdateManyWithoutHotspotsNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutHotspotsNestedInput
  }

  export type hotspotsCreateManyInput = {
    id: string
    title: string
    summary: string
    status?: $Enums.HotspotStatus
    rankScore?: number
    confidence?: number
    primaryCategoryId?: string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: string | null
    similarityThreshold?: number | null
    rcaBreakdownJson?: NullableJsonNullValueInput | InputJsonValue
    solutionSuggestionsJson?: NullableJsonNullValueInput | InputJsonValue
    decisionMatrixJson?: NullableJsonNullValueInput | InputJsonValue
    crossFunctionalImpactJson?: NullableJsonNullValueInput | InputJsonValue
    lastAnalysisAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    clusteringQualityScore?: number | null
    clusteringResults?: NullableJsonNullValueInput | InputJsonValue
    clusteringVersion?: string | null
    lastClusteredAt?: Date | string | null
  }

  export type hotspotsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumHotspotStatusFieldUpdateOperationsInput | $Enums.HotspotStatus
    rankScore?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    primaryCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: NullableStringFieldUpdateOperationsInput | string | null
    similarityThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    rcaBreakdownJson?: NullableJsonNullValueInput | InputJsonValue
    solutionSuggestionsJson?: NullableJsonNullValueInput | InputJsonValue
    decisionMatrixJson?: NullableJsonNullValueInput | InputJsonValue
    crossFunctionalImpactJson?: NullableJsonNullValueInput | InputJsonValue
    lastAnalysisAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clusteringQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    clusteringResults?: NullableJsonNullValueInput | InputJsonValue
    clusteringVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastClusteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hotspotsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumHotspotStatusFieldUpdateOperationsInput | $Enums.HotspotStatus
    rankScore?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    primaryCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: NullableStringFieldUpdateOperationsInput | string | null
    similarityThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    rcaBreakdownJson?: NullableJsonNullValueInput | InputJsonValue
    solutionSuggestionsJson?: NullableJsonNullValueInput | InputJsonValue
    decisionMatrixJson?: NullableJsonNullValueInput | InputJsonValue
    crossFunctionalImpactJson?: NullableJsonNullValueInput | InputJsonValue
    lastAnalysisAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clusteringQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    clusteringResults?: NullableJsonNullValueInput | InputJsonValue
    clusteringVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastClusteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ideasCreateInput = {
    id: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    users?: usersCreateNestedOneWithoutIdeasInput
    hotspots: hotspotsCreateNestedOneWithoutIdeasInput
    initiatives?: initiativesCreateNestedOneWithoutIdeasInput
    solutions?: solutionsCreateNestedOneWithoutIdeasInput
  }

  export type ideasUncheckedCreateInput = {
    id: string
    hotspotId: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdById?: string | null
    initiativeId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    solutions?: solutionsUncheckedCreateNestedOneWithoutIdeasInput
  }

  export type ideasUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutIdeasNestedInput
    hotspots?: hotspotsUpdateOneRequiredWithoutIdeasNestedInput
    initiatives?: initiativesUpdateOneWithoutIdeasNestedInput
    solutions?: solutionsUpdateOneWithoutIdeasNestedInput
  }

  export type ideasUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotspotId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solutions?: solutionsUncheckedUpdateOneWithoutIdeasNestedInput
  }

  export type ideasCreateManyInput = {
    id: string
    hotspotId: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdById?: string | null
    initiativeId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ideasUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ideasUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotspotId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type initiativesCreateInput = {
    id: string
    name: string
    description?: string | null
    status?: $Enums.initiative_status
    priority?: $Enums.priority
    budget?: number
    actualSpend?: number
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completionDate?: Date | string | null
    expectedROI?: number | null
    actualROI?: number | null
    riskLevel?: $Enums.risk_level
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    milestonesJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    ideas?: ideasCreateNestedManyWithoutInitiativesInput
    users?: usersCreateNestedOneWithoutInitiativesInput
    solutions?: solutionsCreateNestedManyWithoutInitiativesInput
  }

  export type initiativesUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    status?: $Enums.initiative_status
    priority?: $Enums.priority
    ownerId?: string | null
    budget?: number
    actualSpend?: number
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completionDate?: Date | string | null
    expectedROI?: number | null
    actualROI?: number | null
    riskLevel?: $Enums.risk_level
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    milestonesJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    ideas?: ideasUncheckedCreateNestedManyWithoutInitiativesInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutInitiativesInput
  }

  export type initiativesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enuminitiative_statusFieldUpdateOperationsInput | $Enums.initiative_status
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    budget?: FloatFieldUpdateOperationsInput | number
    actualSpend?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedROI?: NullableFloatFieldUpdateOperationsInput | number | null
    actualROI?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: Enumrisk_levelFieldUpdateOperationsInput | $Enums.risk_level
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    milestonesJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ideas?: ideasUpdateManyWithoutInitiativesNestedInput
    users?: usersUpdateOneWithoutInitiativesNestedInput
    solutions?: solutionsUpdateManyWithoutInitiativesNestedInput
  }

  export type initiativesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enuminitiative_statusFieldUpdateOperationsInput | $Enums.initiative_status
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    actualSpend?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedROI?: NullableFloatFieldUpdateOperationsInput | number | null
    actualROI?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: Enumrisk_levelFieldUpdateOperationsInput | $Enums.risk_level
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    milestonesJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ideas?: ideasUncheckedUpdateManyWithoutInitiativesNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutInitiativesNestedInput
  }

  export type initiativesCreateManyInput = {
    id: string
    name: string
    description?: string | null
    status?: $Enums.initiative_status
    priority?: $Enums.priority
    ownerId?: string | null
    budget?: number
    actualSpend?: number
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completionDate?: Date | string | null
    expectedROI?: number | null
    actualROI?: number | null
    riskLevel?: $Enums.risk_level
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    milestonesJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type initiativesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enuminitiative_statusFieldUpdateOperationsInput | $Enums.initiative_status
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    budget?: FloatFieldUpdateOperationsInput | number
    actualSpend?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedROI?: NullableFloatFieldUpdateOperationsInput | number | null
    actualROI?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: Enumrisk_levelFieldUpdateOperationsInput | $Enums.risk_level
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    milestonesJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type initiativesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enuminitiative_statusFieldUpdateOperationsInput | $Enums.initiative_status
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    actualSpend?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedROI?: NullableFloatFieldUpdateOperationsInput | number | null
    actualROI?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: Enumrisk_levelFieldUpdateOperationsInput | $Enums.risk_level
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    milestonesJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type input_groupsCreateInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    aiSuggested?: boolean
    aiConfidence?: number | null
    aiReasoning?: string | null
    avgPriority?: number | null
    color?: string | null
    inputCount?: number
    lastActivity?: Date | string | null
    InputToInputGroup?: InputToInputGroupCreateNestedManyWithoutInput_groupsInput
    users: usersCreateNestedOneWithoutInput_groupsInput
  }

  export type input_groupsUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    aiSuggested?: boolean
    aiConfidence?: number | null
    aiReasoning?: string | null
    avgPriority?: number | null
    color?: string | null
    createdBy: string
    inputCount?: number
    lastActivity?: Date | string | null
    InputToInputGroup?: InputToInputGroupUncheckedCreateNestedManyWithoutInput_groupsInput
  }

  export type input_groupsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    avgPriority?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    inputCount?: IntFieldUpdateOperationsInput | number
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    InputToInputGroup?: InputToInputGroupUpdateManyWithoutInput_groupsNestedInput
    users?: usersUpdateOneRequiredWithoutInput_groupsNestedInput
  }

  export type input_groupsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    avgPriority?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    inputCount?: IntFieldUpdateOperationsInput | number
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    InputToInputGroup?: InputToInputGroupUncheckedUpdateManyWithoutInput_groupsNestedInput
  }

  export type input_groupsCreateManyInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    aiSuggested?: boolean
    aiConfidence?: number | null
    aiReasoning?: string | null
    avgPriority?: number | null
    color?: string | null
    createdBy: string
    inputCount?: number
    lastActivity?: Date | string | null
  }

  export type input_groupsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    avgPriority?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    inputCount?: IntFieldUpdateOperationsInput | number
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type input_groupsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    avgPriority?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    inputCount?: IntFieldUpdateOperationsInput | number
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type inputsCreateInput = {
    id: string
    title: string
    description: string
    type?: $Enums.InputType
    status?: $Enums.InputStatus
    createdAt?: Date | string
    updatedAt: Date | string
    department?: string | null
    rootCause?: string | null
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: number | null
    issueType?: string | null
    priority?: $Enums.priority
    InputToInputGroup?: InputToInputGroupCreateNestedManyWithoutInputsInput
    users: usersCreateNestedOneWithoutInputsInput
    solutions?: solutionsCreateNestedManyWithoutInputsInput
  }

  export type inputsUncheckedCreateInput = {
    id: string
    title: string
    description: string
    type?: $Enums.InputType
    status?: $Enums.InputStatus
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
    department?: string | null
    rootCause?: string | null
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: number | null
    issueType?: string | null
    priority?: $Enums.priority
    InputToInputGroup?: InputToInputGroupUncheckedCreateNestedManyWithoutInputsInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutInputsInput
  }

  export type inputsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    InputToInputGroup?: InputToInputGroupUpdateManyWithoutInputsNestedInput
    users?: usersUpdateOneRequiredWithoutInputsNestedInput
    solutions?: solutionsUpdateManyWithoutInputsNestedInput
  }

  export type inputsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    InputToInputGroup?: InputToInputGroupUncheckedUpdateManyWithoutInputsNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutInputsNestedInput
  }

  export type inputsCreateManyInput = {
    id: string
    title: string
    description: string
    type?: $Enums.InputType
    status?: $Enums.InputStatus
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
    department?: string | null
    rootCause?: string | null
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: number | null
    issueType?: string | null
    priority?: $Enums.priority
  }

  export type inputsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
  }

  export type inputsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
  }

  export type notificationsCreateInput = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    readAt?: Date | string | null
    createdAt?: Date | string
    delivered?: boolean
    entityId?: string | null
    entityType?: $Enums.EntityType | null
    read?: boolean
  }

  export type notificationsUncheckedCreateInput = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    readAt?: Date | string | null
    createdAt?: Date | string
    delivered?: boolean
    entityId?: string | null
    entityType?: $Enums.EntityType | null
    read?: boolean
  }

  export type notificationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered?: BoolFieldUpdateOperationsInput | boolean
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notificationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered?: BoolFieldUpdateOperationsInput | boolean
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notificationsCreateManyInput = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    readAt?: Date | string | null
    createdAt?: Date | string
    delivered?: boolean
    entityId?: string | null
    entityType?: $Enums.EntityType | null
    read?: boolean
  }

  export type notificationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered?: BoolFieldUpdateOperationsInput | boolean
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notificationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered?: BoolFieldUpdateOperationsInput | boolean
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type requirementsCreateInput = {
    id: string
    title: string
    description: string
    acceptanceCriteria: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequirementStatus
    estimatedEffort?: string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    riskAssessment?: string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    priority?: $Enums.priority
    users: usersCreateNestedOneWithoutRequirementsInput
    solutions: solutionsCreateNestedOneWithoutRequirementsInput
  }

  export type requirementsUncheckedCreateInput = {
    id: string
    title: string
    description: string
    acceptanceCriteria: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequirementStatus
    estimatedEffort?: string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    riskAssessment?: string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    solutionId: string
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
    priority?: $Enums.priority
  }

  export type requirementsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    users?: usersUpdateOneRequiredWithoutRequirementsNestedInput
    solutions?: solutionsUpdateOneRequiredWithoutRequirementsNestedInput
  }

  export type requirementsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
  }

  export type requirementsCreateManyInput = {
    id: string
    title: string
    description: string
    acceptanceCriteria: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequirementStatus
    estimatedEffort?: string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    riskAssessment?: string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    solutionId: string
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
    priority?: $Enums.priority
  }

  export type requirementsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
  }

  export type requirementsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
  }

  export type signalsCreateInput = {
    id: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: number | null
    featuresVersion?: string | null
    lastFeaturesGeneratedAt?: Date | string | null
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutSignalsInput
    hotspot_signals?: hotspot_signalsCreateNestedManyWithoutSignalsInput
    categories?: categoriesCreateNestedOneWithoutSignalsInput
    users?: usersCreateNestedOneWithoutSignalsInput
    departments?: departmentsCreateNestedOneWithoutSignalsInput
    teams?: teamsCreateNestedOneWithoutSignalsInput
  }

  export type signalsUncheckedCreateInput = {
    id: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    departmentId?: string | null
    teamId?: string | null
    categoryId?: string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: number | null
    featuresVersion?: string | null
    lastFeaturesGeneratedAt?: Date | string | null
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutSignalsInput
    hotspot_signals?: hotspot_signalsUncheckedCreateNestedManyWithoutSignalsInput
  }

  export type signalsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    featuresVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastFeaturesGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutSignalsNestedInput
    hotspot_signals?: hotspot_signalsUpdateManyWithoutSignalsNestedInput
    categories?: categoriesUpdateOneWithoutSignalsNestedInput
    users?: usersUpdateOneWithoutSignalsNestedInput
    departments?: departmentsUpdateOneWithoutSignalsNestedInput
    teams?: teamsUpdateOneWithoutSignalsNestedInput
  }

  export type signalsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    featuresVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastFeaturesGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutSignalsNestedInput
    hotspot_signals?: hotspot_signalsUncheckedUpdateManyWithoutSignalsNestedInput
  }

  export type signalsCreateManyInput = {
    id: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    departmentId?: string | null
    teamId?: string | null
    categoryId?: string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: number | null
    featuresVersion?: string | null
    lastFeaturesGeneratedAt?: Date | string | null
  }

  export type signalsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    featuresVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastFeaturesGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type signalsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    featuresVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastFeaturesGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type solutionsCreateInput = {
    id: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    createdAt?: Date | string
    updatedAt: Date | string
    estimatedEffort?: string | null
    actualCompletionDate?: Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsCreateNestedManyWithoutSolutionsInput
    requirements?: requirementsCreateNestedManyWithoutSolutionsInput
    users: usersCreateNestedOneWithoutSolutionsInput
    hotspots?: hotspotsCreateNestedOneWithoutSolutionsInput
    ideas?: ideasCreateNestedOneWithoutSolutionsInput
    initiatives?: initiativesCreateNestedOneWithoutSolutionsInput
    inputs?: inputsCreateNestedOneWithoutSolutionsInput
  }

  export type solutionsUncheckedCreateInput = {
    id: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    createdAt?: Date | string
    updatedAt: Date | string
    estimatedEffort?: string | null
    actualCompletionDate?: Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    createdBy: string
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    hotspotId?: string | null
    ideaId?: string | null
    initiativeId?: string | null
    inputId?: string | null
    progress?: number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsUncheckedCreateNestedManyWithoutSolutionsInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutSolutionsInput
  }

  export type solutionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsUpdateManyWithoutSolutionsNestedInput
    requirements?: requirementsUpdateManyWithoutSolutionsNestedInput
    users?: usersUpdateOneRequiredWithoutSolutionsNestedInput
    hotspots?: hotspotsUpdateOneWithoutSolutionsNestedInput
    ideas?: ideasUpdateOneWithoutSolutionsNestedInput
    initiatives?: initiativesUpdateOneWithoutSolutionsNestedInput
    inputs?: inputsUpdateOneWithoutSolutionsNestedInput
  }

  export type solutionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    hotspotId?: NullableStringFieldUpdateOperationsInput | string | null
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    inputId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsUncheckedUpdateManyWithoutSolutionsNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutSolutionsNestedInput
  }

  export type solutionsCreateManyInput = {
    id: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    createdAt?: Date | string
    updatedAt: Date | string
    estimatedEffort?: string | null
    actualCompletionDate?: Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    createdBy: string
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    hotspotId?: string | null
    ideaId?: string | null
    initiativeId?: string | null
    inputId?: string | null
    progress?: number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
  }

  export type solutionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
  }

  export type solutionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    hotspotId?: NullableStringFieldUpdateOperationsInput | string | null
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    inputId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
  }

  export type teamsCreateInput = {
    id: string
    name: string
    description?: string | null
    memberCount?: number
    maxCapacity?: number | null
    isActive?: boolean
    teamType?: string | null
    currentProjects?: number
    budgetAllocation?: number
    utilizationRate?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    signals?: signalsCreateNestedManyWithoutTeamsInput
    departments?: departmentsCreateNestedOneWithoutTeamsInput
    users_teams_leaderIdTousers?: usersCreateNestedOneWithoutTeams_teams_leaderIdTousersInput
    users_TeamMembers?: usersCreateNestedManyWithoutTeams_TeamMembersInput
  }

  export type teamsUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    departmentId?: string | null
    leaderId?: string | null
    memberCount?: number
    maxCapacity?: number | null
    isActive?: boolean
    teamType?: string | null
    currentProjects?: number
    budgetAllocation?: number
    utilizationRate?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    signals?: signalsUncheckedCreateNestedManyWithoutTeamsInput
    users_TeamMembers?: usersUncheckedCreateNestedManyWithoutTeams_TeamMembersInput
  }

  export type teamsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: IntFieldUpdateOperationsInput | number
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teamType?: NullableStringFieldUpdateOperationsInput | string | null
    currentProjects?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: signalsUpdateManyWithoutTeamsNestedInput
    departments?: departmentsUpdateOneWithoutTeamsNestedInput
    users_teams_leaderIdTousers?: usersUpdateOneWithoutTeams_teams_leaderIdTousersNestedInput
    users_TeamMembers?: usersUpdateManyWithoutTeams_TeamMembersNestedInput
  }

  export type teamsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: IntFieldUpdateOperationsInput | number
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teamType?: NullableStringFieldUpdateOperationsInput | string | null
    currentProjects?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: signalsUncheckedUpdateManyWithoutTeamsNestedInput
    users_TeamMembers?: usersUncheckedUpdateManyWithoutTeams_TeamMembersNestedInput
  }

  export type teamsCreateManyInput = {
    id: string
    name: string
    description?: string | null
    departmentId?: string | null
    leaderId?: string | null
    memberCount?: number
    maxCapacity?: number | null
    isActive?: boolean
    teamType?: string | null
    currentProjects?: number
    budgetAllocation?: number
    utilizationRate?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type teamsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: IntFieldUpdateOperationsInput | number
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teamType?: NullableStringFieldUpdateOperationsInput | string | null
    currentProjects?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teamsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: IntFieldUpdateOperationsInput | number
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teamType?: NullableStringFieldUpdateOperationsInput | string | null
    currentProjects?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    ai_analysis_audit?: ai_analysis_auditCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasCreateNestedManyWithoutUsersInput
    initiatives?: initiativesCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsCreateNestedManyWithoutUsersInput
    inputs?: inputsCreateNestedManyWithoutUsersInput
    requirements?: requirementsCreateNestedManyWithoutUsersInput
    signals?: signalsCreateNestedManyWithoutUsersInput
    solutions?: solutionsCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    departments_users_departmentObjIdTodepartments?: departmentsCreateNestedOneWithoutUsers_users_departmentObjIdTodepartmentsInput
    users?: usersCreateNestedOneWithoutOther_usersInput
    other_users?: usersCreateNestedManyWithoutUsersInput
    votes?: votesCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersUncheckedCreateInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    managerId?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    departmentObjId?: string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsUncheckedCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasUncheckedCreateNestedManyWithoutUsersInput
    initiatives?: initiativesUncheckedCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsUncheckedCreateNestedManyWithoutUsersInput
    inputs?: inputsUncheckedCreateNestedManyWithoutUsersInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutUsersInput
    signals?: signalsUncheckedCreateNestedManyWithoutUsersInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsUncheckedCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    other_users?: usersUncheckedCreateNestedManyWithoutUsersInput
    votes?: votesUncheckedCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsUncheckedCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    ai_analysis_audit?: ai_analysis_auditUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUpdateManyWithoutUsersNestedInput
    inputs?: inputsUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUpdateManyWithoutUsersNestedInput
    signals?: signalsUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    departments_users_departmentObjIdTodepartments?: departmentsUpdateOneWithoutUsers_users_departmentObjIdTodepartmentsNestedInput
    users?: usersUpdateOneWithoutOther_usersNestedInput
    other_users?: usersUpdateManyWithoutUsersNestedInput
    votes?: votesUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUncheckedUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUncheckedUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUncheckedUpdateManyWithoutUsersNestedInput
    inputs?: inputsUncheckedUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutUsersNestedInput
    signals?: signalsUncheckedUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    other_users?: usersUncheckedUpdateManyWithoutUsersNestedInput
    votes?: votesUncheckedUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUncheckedUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersCreateManyInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    managerId?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    departmentObjId?: string | null
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type votesCreateInput = {
    id: string
    createdAt?: Date | string
    entityId: string
    entityType: $Enums.EntityType
    value: $Enums.VoteValue
    users: usersCreateNestedOneWithoutVotesInput
  }

  export type votesUncheckedCreateInput = {
    id: string
    createdAt?: Date | string
    createdBy: string
    entityId: string
    entityType: $Enums.EntityType
    value: $Enums.VoteValue
  }

  export type votesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    value?: EnumVoteValueFieldUpdateOperationsInput | $Enums.VoteValue
    users?: usersUpdateOneRequiredWithoutVotesNestedInput
  }

  export type votesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    value?: EnumVoteValueFieldUpdateOperationsInput | $Enums.VoteValue
  }

  export type votesCreateManyInput = {
    id: string
    createdAt?: Date | string
    createdBy: string
    entityId: string
    entityType: $Enums.EntityType
    value: $Enums.VoteValue
  }

  export type votesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    value?: EnumVoteValueFieldUpdateOperationsInput | $Enums.VoteValue
  }

  export type votesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    value?: EnumVoteValueFieldUpdateOperationsInput | $Enums.VoteValue
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type InputsScalarRelationFilter = {
    is?: inputsWhereInput
    isNot?: inputsWhereInput
  }

  export type Input_groupsScalarRelationFilter = {
    is?: input_groupsWhereInput
    isNot?: input_groupsWhereInput
  }

  export type InputToInputGroupABCompoundUniqueInput = {
    A: string
    B: string
  }

  export type InputToInputGroupCountOrderByAggregateInput = {
    A?: SortOrder
    B?: SortOrder
  }

  export type InputToInputGroupMaxOrderByAggregateInput = {
    A?: SortOrder
    B?: SortOrder
  }

  export type InputToInputGroupMinOrderByAggregateInput = {
    A?: SortOrder
    B?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ai_analysis_auditCountOrderByAggregateInput = {
    id?: SortOrder
    hotspotId?: SortOrder
    analysisType?: SortOrder
    userId?: SortOrder
    requestData?: SortOrder
    responseData?: SortOrder
    processingTime?: SortOrder
    confidence?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type ai_analysis_auditAvgOrderByAggregateInput = {
    processingTime?: SortOrder
    confidence?: SortOrder
  }

  export type ai_analysis_auditMaxOrderByAggregateInput = {
    id?: SortOrder
    hotspotId?: SortOrder
    analysisType?: SortOrder
    userId?: SortOrder
    processingTime?: SortOrder
    confidence?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type ai_analysis_auditMinOrderByAggregateInput = {
    id?: SortOrder
    hotspotId?: SortOrder
    analysisType?: SortOrder
    userId?: SortOrder
    processingTime?: SortOrder
    confidence?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type ai_analysis_auditSumOrderByAggregateInput = {
    processingTime?: SortOrder
    confidence?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type SignalsScalarRelationFilter = {
    is?: signalsWhereInput
    isNot?: signalsWhereInput
  }

  export type ai_insight_overridesCountOrderByAggregateInput = {
    id?: SortOrder
    signalId?: SortOrder
    insightId?: SortOrder
    insightType?: SortOrder
    originalRecommendation?: SortOrder
    overrideReason?: SortOrder
    executiveJustification?: SortOrder
    newValue?: SortOrder
    executiveId?: SortOrder
    executiveName?: SortOrder
    executiveEmail?: SortOrder
    overriddenAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ai_insight_overridesMaxOrderByAggregateInput = {
    id?: SortOrder
    signalId?: SortOrder
    insightId?: SortOrder
    insightType?: SortOrder
    overrideReason?: SortOrder
    executiveJustification?: SortOrder
    executiveId?: SortOrder
    executiveName?: SortOrder
    executiveEmail?: SortOrder
    overriddenAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ai_insight_overridesMinOrderByAggregateInput = {
    id?: SortOrder
    signalId?: SortOrder
    insightId?: SortOrder
    insightType?: SortOrder
    overrideReason?: SortOrder
    executiveJustification?: SortOrder
    executiveId?: SortOrder
    executiveName?: SortOrder
    executiveEmail?: SortOrder
    overriddenAt?: SortOrder
    createdAt?: SortOrder
  }

  export type audit_logsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    sessionId?: SortOrder
  }

  export type audit_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    sessionId?: SortOrder
  }

  export type audit_logsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    sessionId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CategoriesNullableScalarRelationFilter = {
    is?: categoriesWhereInput | null
    isNot?: categoriesWhereInput | null
  }

  export type CategoriesListRelationFilter = {
    every?: categoriesWhereInput
    some?: categoriesWhereInput
    none?: categoriesWhereInput
  }

  export type SignalsListRelationFilter = {
    every?: signalsWhereInput
    some?: signalsWhereInput
    none?: signalsWhereInput
  }

  export type categoriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type signalsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    parentId?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    usageCount?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type categoriesAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
    usageCount?: SortOrder
  }

  export type categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    parentId?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    usageCount?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    parentId?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    usageCount?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type categoriesSumOrderByAggregateInput = {
    sortOrder?: SortOrder
    usageCount?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityTypeFilter<$PrismaModel> | $Enums.EntityType
  }

  export type CommentsNullableScalarRelationFilter = {
    is?: commentsWhereInput | null
    isNot?: commentsWhereInput | null
  }

  export type CommentsListRelationFilter = {
    every?: commentsWhereInput
    some?: commentsWhereInput
    none?: commentsWhereInput
  }

  export type commentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type commentsCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    createdBy?: SortOrder
    edited?: SortOrder
    editedAt?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    mentions?: SortOrder
  }

  export type commentsMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    createdBy?: SortOrder
    edited?: SortOrder
    editedAt?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
  }

  export type commentsMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    createdBy?: SortOrder
    edited?: SortOrder
    editedAt?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.EntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumEntityTypeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type UsersNullableScalarRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type TeamsListRelationFilter = {
    every?: teamsWhereInput
    some?: teamsWhereInput
    none?: teamsWhereInput
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type teamsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type departmentsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    headCount?: SortOrder
    budgetAllocation?: SortOrder
    managerId?: SortOrder
    costCenter?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    utilizationTarget?: SortOrder
    actualUtilization?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type departmentsAvgOrderByAggregateInput = {
    headCount?: SortOrder
    budgetAllocation?: SortOrder
    utilizationTarget?: SortOrder
    actualUtilization?: SortOrder
  }

  export type departmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    headCount?: SortOrder
    budgetAllocation?: SortOrder
    managerId?: SortOrder
    costCenter?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    utilizationTarget?: SortOrder
    actualUtilization?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type departmentsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    headCount?: SortOrder
    budgetAllocation?: SortOrder
    managerId?: SortOrder
    costCenter?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    utilizationTarget?: SortOrder
    actualUtilization?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type departmentsSumOrderByAggregateInput = {
    headCount?: SortOrder
    budgetAllocation?: SortOrder
    utilizationTarget?: SortOrder
    actualUtilization?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumFRDStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FRDStatus | EnumFRDStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFRDStatusFilter<$PrismaModel> | $Enums.FRDStatus
  }

  export type SolutionsScalarRelationFilter = {
    is?: solutionsWhereInput
    isNot?: solutionsWhereInput
  }

  export type frd_documentsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    aiGenerated?: SortOrder
    aiConfidence?: SortOrder
    aiPromptUsed?: SortOrder
    version?: SortOrder
    status?: SortOrder
    executiveApproved?: SortOrder
    exportFormats?: SortOrder
    templateUsed?: SortOrder
    generationTime?: SortOrder
    wordCount?: SortOrder
    lastExportedAt?: SortOrder
    solutionId?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type frd_documentsAvgOrderByAggregateInput = {
    aiConfidence?: SortOrder
    generationTime?: SortOrder
    wordCount?: SortOrder
  }

  export type frd_documentsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    aiGenerated?: SortOrder
    aiConfidence?: SortOrder
    aiPromptUsed?: SortOrder
    version?: SortOrder
    status?: SortOrder
    executiveApproved?: SortOrder
    templateUsed?: SortOrder
    generationTime?: SortOrder
    wordCount?: SortOrder
    lastExportedAt?: SortOrder
    solutionId?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type frd_documentsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    aiGenerated?: SortOrder
    aiConfidence?: SortOrder
    aiPromptUsed?: SortOrder
    version?: SortOrder
    status?: SortOrder
    executiveApproved?: SortOrder
    templateUsed?: SortOrder
    generationTime?: SortOrder
    wordCount?: SortOrder
    lastExportedAt?: SortOrder
    solutionId?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type frd_documentsSumOrderByAggregateInput = {
    aiConfidence?: SortOrder
    generationTime?: SortOrder
    wordCount?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumFRDStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FRDStatus | EnumFRDStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFRDStatusWithAggregatesFilter<$PrismaModel> | $Enums.FRDStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFRDStatusFilter<$PrismaModel>
    _max?: NestedEnumFRDStatusFilter<$PrismaModel>
  }

  export type HotspotsScalarRelationFilter = {
    is?: hotspotsWhereInput
    isNot?: hotspotsWhereInput
  }

  export type hotspot_signalsHotspotIdSignalIdCompoundUniqueInput = {
    hotspotId: string
    signalId: string
  }

  export type hotspot_signalsCountOrderByAggregateInput = {
    hotspotId?: SortOrder
    signalId?: SortOrder
    membershipStrength?: SortOrder
    isOutlier?: SortOrder
    addedAt?: SortOrder
  }

  export type hotspot_signalsAvgOrderByAggregateInput = {
    membershipStrength?: SortOrder
  }

  export type hotspot_signalsMaxOrderByAggregateInput = {
    hotspotId?: SortOrder
    signalId?: SortOrder
    membershipStrength?: SortOrder
    isOutlier?: SortOrder
    addedAt?: SortOrder
  }

  export type hotspot_signalsMinOrderByAggregateInput = {
    hotspotId?: SortOrder
    signalId?: SortOrder
    membershipStrength?: SortOrder
    isOutlier?: SortOrder
    addedAt?: SortOrder
  }

  export type hotspot_signalsSumOrderByAggregateInput = {
    membershipStrength?: SortOrder
  }

  export type EnumHotspotStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HotspotStatus | EnumHotspotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HotspotStatus[] | ListEnumHotspotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HotspotStatus[] | ListEnumHotspotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHotspotStatusFilter<$PrismaModel> | $Enums.HotspotStatus
  }

  export type Hotspot_signalsListRelationFilter = {
    every?: hotspot_signalsWhereInput
    some?: hotspot_signalsWhereInput
    none?: hotspot_signalsWhereInput
  }

  export type IdeasListRelationFilter = {
    every?: ideasWhereInput
    some?: ideasWhereInput
    none?: ideasWhereInput
  }

  export type SolutionsListRelationFilter = {
    every?: solutionsWhereInput
    some?: solutionsWhereInput
    none?: solutionsWhereInput
  }

  export type hotspot_signalsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ideasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type solutionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type hotspotsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    rankScore?: SortOrder
    confidence?: SortOrder
    primaryCategoryId?: SortOrder
    linkedEntitiesJson?: SortOrder
    clusteringMethod?: SortOrder
    similarityThreshold?: SortOrder
    rcaBreakdownJson?: SortOrder
    solutionSuggestionsJson?: SortOrder
    decisionMatrixJson?: SortOrder
    crossFunctionalImpactJson?: SortOrder
    lastAnalysisAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clusteringQualityScore?: SortOrder
    clusteringResults?: SortOrder
    clusteringVersion?: SortOrder
    lastClusteredAt?: SortOrder
  }

  export type hotspotsAvgOrderByAggregateInput = {
    rankScore?: SortOrder
    confidence?: SortOrder
    similarityThreshold?: SortOrder
    clusteringQualityScore?: SortOrder
  }

  export type hotspotsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    rankScore?: SortOrder
    confidence?: SortOrder
    primaryCategoryId?: SortOrder
    clusteringMethod?: SortOrder
    similarityThreshold?: SortOrder
    lastAnalysisAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clusteringQualityScore?: SortOrder
    clusteringVersion?: SortOrder
    lastClusteredAt?: SortOrder
  }

  export type hotspotsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    rankScore?: SortOrder
    confidence?: SortOrder
    primaryCategoryId?: SortOrder
    clusteringMethod?: SortOrder
    similarityThreshold?: SortOrder
    lastAnalysisAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clusteringQualityScore?: SortOrder
    clusteringVersion?: SortOrder
    lastClusteredAt?: SortOrder
  }

  export type hotspotsSumOrderByAggregateInput = {
    rankScore?: SortOrder
    confidence?: SortOrder
    similarityThreshold?: SortOrder
    clusteringQualityScore?: SortOrder
  }

  export type EnumHotspotStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HotspotStatus | EnumHotspotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HotspotStatus[] | ListEnumHotspotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HotspotStatus[] | ListEnumHotspotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHotspotStatusWithAggregatesFilter<$PrismaModel> | $Enums.HotspotStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHotspotStatusFilter<$PrismaModel>
    _max?: NestedEnumHotspotStatusFilter<$PrismaModel>
  }

  export type InitiativesNullableScalarRelationFilter = {
    is?: initiativesWhereInput | null
    isNot?: initiativesWhereInput | null
  }

  export type SolutionsNullableScalarRelationFilter = {
    is?: solutionsWhereInput | null
    isNot?: solutionsWhereInput | null
  }

  export type ideasCountOrderByAggregateInput = {
    id?: SortOrder
    hotspotId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    origin?: SortOrder
    votes?: SortOrder
    status?: SortOrder
    evidenceJson?: SortOrder
    tagsJson?: SortOrder
    confidence?: SortOrder
    createdById?: SortOrder
    initiativeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ideasAvgOrderByAggregateInput = {
    votes?: SortOrder
    confidence?: SortOrder
  }

  export type ideasMaxOrderByAggregateInput = {
    id?: SortOrder
    hotspotId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    origin?: SortOrder
    votes?: SortOrder
    status?: SortOrder
    confidence?: SortOrder
    createdById?: SortOrder
    initiativeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ideasMinOrderByAggregateInput = {
    id?: SortOrder
    hotspotId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    origin?: SortOrder
    votes?: SortOrder
    status?: SortOrder
    confidence?: SortOrder
    createdById?: SortOrder
    initiativeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ideasSumOrderByAggregateInput = {
    votes?: SortOrder
    confidence?: SortOrder
  }

  export type Enuminitiative_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.initiative_status | Enuminitiative_statusFieldRefInput<$PrismaModel>
    in?: $Enums.initiative_status[] | ListEnuminitiative_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.initiative_status[] | ListEnuminitiative_statusFieldRefInput<$PrismaModel>
    not?: NestedEnuminitiative_statusFilter<$PrismaModel> | $Enums.initiative_status
  }

  export type EnumpriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.priority | EnumpriorityFieldRefInput<$PrismaModel>
    in?: $Enums.priority[] | ListEnumpriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.priority[] | ListEnumpriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumpriorityFilter<$PrismaModel> | $Enums.priority
  }

  export type Enumrisk_levelFilter<$PrismaModel = never> = {
    equals?: $Enums.risk_level | Enumrisk_levelFieldRefInput<$PrismaModel>
    in?: $Enums.risk_level[] | ListEnumrisk_levelFieldRefInput<$PrismaModel>
    notIn?: $Enums.risk_level[] | ListEnumrisk_levelFieldRefInput<$PrismaModel>
    not?: NestedEnumrisk_levelFilter<$PrismaModel> | $Enums.risk_level
  }

  export type initiativesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    ownerId?: SortOrder
    budget?: SortOrder
    actualSpend?: SortOrder
    startDate?: SortOrder
    targetDate?: SortOrder
    completionDate?: SortOrder
    expectedROI?: SortOrder
    actualROI?: SortOrder
    riskLevel?: SortOrder
    goalJson?: SortOrder
    roiJson?: SortOrder
    milestonesJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type initiativesAvgOrderByAggregateInput = {
    budget?: SortOrder
    actualSpend?: SortOrder
    expectedROI?: SortOrder
    actualROI?: SortOrder
  }

  export type initiativesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    ownerId?: SortOrder
    budget?: SortOrder
    actualSpend?: SortOrder
    startDate?: SortOrder
    targetDate?: SortOrder
    completionDate?: SortOrder
    expectedROI?: SortOrder
    actualROI?: SortOrder
    riskLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type initiativesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    ownerId?: SortOrder
    budget?: SortOrder
    actualSpend?: SortOrder
    startDate?: SortOrder
    targetDate?: SortOrder
    completionDate?: SortOrder
    expectedROI?: SortOrder
    actualROI?: SortOrder
    riskLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type initiativesSumOrderByAggregateInput = {
    budget?: SortOrder
    actualSpend?: SortOrder
    expectedROI?: SortOrder
    actualROI?: SortOrder
  }

  export type Enuminitiative_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.initiative_status | Enuminitiative_statusFieldRefInput<$PrismaModel>
    in?: $Enums.initiative_status[] | ListEnuminitiative_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.initiative_status[] | ListEnuminitiative_statusFieldRefInput<$PrismaModel>
    not?: NestedEnuminitiative_statusWithAggregatesFilter<$PrismaModel> | $Enums.initiative_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminitiative_statusFilter<$PrismaModel>
    _max?: NestedEnuminitiative_statusFilter<$PrismaModel>
  }

  export type EnumpriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.priority | EnumpriorityFieldRefInput<$PrismaModel>
    in?: $Enums.priority[] | ListEnumpriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.priority[] | ListEnumpriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumpriorityWithAggregatesFilter<$PrismaModel> | $Enums.priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpriorityFilter<$PrismaModel>
    _max?: NestedEnumpriorityFilter<$PrismaModel>
  }

  export type Enumrisk_levelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.risk_level | Enumrisk_levelFieldRefInput<$PrismaModel>
    in?: $Enums.risk_level[] | ListEnumrisk_levelFieldRefInput<$PrismaModel>
    notIn?: $Enums.risk_level[] | ListEnumrisk_levelFieldRefInput<$PrismaModel>
    not?: NestedEnumrisk_levelWithAggregatesFilter<$PrismaModel> | $Enums.risk_level
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrisk_levelFilter<$PrismaModel>
    _max?: NestedEnumrisk_levelFilter<$PrismaModel>
  }

  export type InputToInputGroupListRelationFilter = {
    every?: InputToInputGroupWhereInput
    some?: InputToInputGroupWhereInput
    none?: InputToInputGroupWhereInput
  }

  export type InputToInputGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type input_groupsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiSuggested?: SortOrder
    aiConfidence?: SortOrder
    aiReasoning?: SortOrder
    avgPriority?: SortOrder
    color?: SortOrder
    createdBy?: SortOrder
    inputCount?: SortOrder
    lastActivity?: SortOrder
  }

  export type input_groupsAvgOrderByAggregateInput = {
    aiConfidence?: SortOrder
    avgPriority?: SortOrder
    inputCount?: SortOrder
  }

  export type input_groupsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiSuggested?: SortOrder
    aiConfidence?: SortOrder
    aiReasoning?: SortOrder
    avgPriority?: SortOrder
    color?: SortOrder
    createdBy?: SortOrder
    inputCount?: SortOrder
    lastActivity?: SortOrder
  }

  export type input_groupsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiSuggested?: SortOrder
    aiConfidence?: SortOrder
    aiReasoning?: SortOrder
    avgPriority?: SortOrder
    color?: SortOrder
    createdBy?: SortOrder
    inputCount?: SortOrder
    lastActivity?: SortOrder
  }

  export type input_groupsSumOrderByAggregateInput = {
    aiConfidence?: SortOrder
    avgPriority?: SortOrder
    inputCount?: SortOrder
  }

  export type EnumInputTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InputType | EnumInputTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInputTypeFilter<$PrismaModel> | $Enums.InputType
  }

  export type EnumInputStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InputStatus | EnumInputStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InputStatus[] | ListEnumInputStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InputStatus[] | ListEnumInputStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInputStatusFilter<$PrismaModel> | $Enums.InputStatus
  }

  export type inputsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: SortOrder
    rootCause?: SortOrder
    aiTags?: SortOrder
    aiSuggestions?: SortOrder
    aiConfidence?: SortOrder
    issueType?: SortOrder
    priority?: SortOrder
  }

  export type inputsAvgOrderByAggregateInput = {
    aiConfidence?: SortOrder
  }

  export type inputsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: SortOrder
    rootCause?: SortOrder
    aiConfidence?: SortOrder
    issueType?: SortOrder
    priority?: SortOrder
  }

  export type inputsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: SortOrder
    rootCause?: SortOrder
    aiConfidence?: SortOrder
    issueType?: SortOrder
    priority?: SortOrder
  }

  export type inputsSumOrderByAggregateInput = {
    aiConfidence?: SortOrder
  }

  export type EnumInputTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InputType | EnumInputTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInputTypeWithAggregatesFilter<$PrismaModel> | $Enums.InputType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInputTypeFilter<$PrismaModel>
    _max?: NestedEnumInputTypeFilter<$PrismaModel>
  }

  export type EnumInputStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InputStatus | EnumInputStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InputStatus[] | ListEnumInputStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InputStatus[] | ListEnumInputStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInputStatusWithAggregatesFilter<$PrismaModel> | $Enums.InputStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInputStatusFilter<$PrismaModel>
    _max?: NestedEnumInputStatusFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumEntityTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEntityTypeNullableFilter<$PrismaModel> | $Enums.EntityType | null
  }

  export type notificationsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    delivered?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    read?: SortOrder
  }

  export type notificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    delivered?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    read?: SortOrder
  }

  export type notificationsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    delivered?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    read?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumEntityTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEntityTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EntityType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEntityTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumEntityTypeNullableFilter<$PrismaModel>
  }

  export type EnumRequirementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementStatus | EnumRequirementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementStatusFilter<$PrismaModel> | $Enums.RequirementStatus
  }

  export type requirementsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    acceptanceCriteria?: SortOrder
    status?: SortOrder
    estimatedEffort?: SortOrder
    dependencies?: SortOrder
    businessValue?: SortOrder
    riskAssessment?: SortOrder
    stakeholders?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectionReason?: SortOrder
    solutionId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    priority?: SortOrder
  }

  export type requirementsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    estimatedEffort?: SortOrder
    businessValue?: SortOrder
    riskAssessment?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectionReason?: SortOrder
    solutionId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    priority?: SortOrder
  }

  export type requirementsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    estimatedEffort?: SortOrder
    businessValue?: SortOrder
    riskAssessment?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectionReason?: SortOrder
    solutionId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    priority?: SortOrder
  }

  export type EnumRequirementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementStatus | EnumRequirementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequirementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequirementStatusFilter<$PrismaModel>
    _max?: NestedEnumRequirementStatusFilter<$PrismaModel>
  }

  export type EnumSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSeverityFilter<$PrismaModel> | $Enums.Severity
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type Ai_insight_overridesListRelationFilter = {
    every?: ai_insight_overridesWhereInput
    some?: ai_insight_overridesWhereInput
    none?: ai_insight_overridesWhereInput
  }

  export type DepartmentsNullableScalarRelationFilter = {
    is?: departmentsWhereInput | null
    isNot?: departmentsWhereInput | null
  }

  export type TeamsNullableScalarRelationFilter = {
    is?: teamsWhereInput | null
    isNot?: teamsWhereInput | null
  }

  export type ai_insight_overridesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type signalsCountOrderByAggregateInput = {
    id?: SortOrder
    inputId?: SortOrder
    timestamp?: SortOrder
    receivedAt?: SortOrder
    schemaVersion?: SortOrder
    sourceJson?: SortOrder
    confidence?: SortOrder
    attachmentsJson?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    systemName?: SortOrder
    title?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    severityScore?: SortOrder
    departmentId?: SortOrder
    teamId?: SortOrder
    categoryId?: SortOrder
    metricsJson?: SortOrder
    baselineJson?: SortOrder
    impactJson?: SortOrder
    tagsJson?: SortOrder
    entitiesJson?: SortOrder
    privacyLevel?: SortOrder
    dedupeKey?: SortOrder
    embedding?: SortOrder
    aiProcessed?: SortOrder
    aiTagsJson?: SortOrder
    lineageJson?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domainClassification?: SortOrder
    enhancedTagsJson?: SortOrder
    lastTaggedAt?: SortOrder
    tagGenerationMeta?: SortOrder
    tagModelVersion?: SortOrder
    clusteringFeaturesJson?: SortOrder
    featuresQualityScore?: SortOrder
    featuresVersion?: SortOrder
    lastFeaturesGeneratedAt?: SortOrder
  }

  export type signalsAvgOrderByAggregateInput = {
    confidence?: SortOrder
    severityScore?: SortOrder
    featuresQualityScore?: SortOrder
  }

  export type signalsMaxOrderByAggregateInput = {
    id?: SortOrder
    inputId?: SortOrder
    timestamp?: SortOrder
    receivedAt?: SortOrder
    schemaVersion?: SortOrder
    confidence?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    systemName?: SortOrder
    title?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    severityScore?: SortOrder
    departmentId?: SortOrder
    teamId?: SortOrder
    categoryId?: SortOrder
    privacyLevel?: SortOrder
    dedupeKey?: SortOrder
    embedding?: SortOrder
    aiProcessed?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastTaggedAt?: SortOrder
    tagModelVersion?: SortOrder
    featuresQualityScore?: SortOrder
    featuresVersion?: SortOrder
    lastFeaturesGeneratedAt?: SortOrder
  }

  export type signalsMinOrderByAggregateInput = {
    id?: SortOrder
    inputId?: SortOrder
    timestamp?: SortOrder
    receivedAt?: SortOrder
    schemaVersion?: SortOrder
    confidence?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    systemName?: SortOrder
    title?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    severityScore?: SortOrder
    departmentId?: SortOrder
    teamId?: SortOrder
    categoryId?: SortOrder
    privacyLevel?: SortOrder
    dedupeKey?: SortOrder
    embedding?: SortOrder
    aiProcessed?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastTaggedAt?: SortOrder
    tagModelVersion?: SortOrder
    featuresQualityScore?: SortOrder
    featuresVersion?: SortOrder
    lastFeaturesGeneratedAt?: SortOrder
  }

  export type signalsSumOrderByAggregateInput = {
    confidence?: SortOrder
    severityScore?: SortOrder
    featuresQualityScore?: SortOrder
  }

  export type EnumSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSeverityWithAggregatesFilter<$PrismaModel> | $Enums.Severity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeverityFilter<$PrismaModel>
    _max?: NestedEnumSeverityFilter<$PrismaModel>
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type EnumSolutionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SolutionStatus | EnumSolutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SolutionStatus[] | ListEnumSolutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SolutionStatus[] | ListEnumSolutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSolutionStatusFilter<$PrismaModel> | $Enums.SolutionStatus
  }

  export type Frd_documentsListRelationFilter = {
    every?: frd_documentsWhereInput
    some?: frd_documentsWhereInput
    none?: frd_documentsWhereInput
  }

  export type RequirementsListRelationFilter = {
    every?: requirementsWhereInput
    some?: requirementsWhereInput
    none?: requirementsWhereInput
  }

  export type HotspotsNullableScalarRelationFilter = {
    is?: hotspotsWhereInput | null
    isNot?: hotspotsWhereInput | null
  }

  export type IdeasNullableScalarRelationFilter = {
    is?: ideasWhereInput | null
    isNot?: ideasWhereInput | null
  }

  export type InputsNullableScalarRelationFilter = {
    is?: inputsWhereInput | null
    isNot?: inputsWhereInput | null
  }

  export type frd_documentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type requirementsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type solutionsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estimatedEffort?: SortOrder
    actualCompletionDate?: SortOrder
    actualImpactJson?: SortOrder
    businessValue?: SortOrder
    createdBy?: SortOrder
    expectedImpactJson?: SortOrder
    hotspotId?: SortOrder
    ideaId?: SortOrder
    initiativeId?: SortOrder
    inputId?: SortOrder
    progress?: SortOrder
    successMetrics?: SortOrder
    targetDate?: SortOrder
    tasks?: SortOrder
  }

  export type solutionsAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type solutionsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estimatedEffort?: SortOrder
    actualCompletionDate?: SortOrder
    businessValue?: SortOrder
    createdBy?: SortOrder
    hotspotId?: SortOrder
    ideaId?: SortOrder
    initiativeId?: SortOrder
    inputId?: SortOrder
    progress?: SortOrder
    targetDate?: SortOrder
  }

  export type solutionsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    estimatedEffort?: SortOrder
    actualCompletionDate?: SortOrder
    businessValue?: SortOrder
    createdBy?: SortOrder
    hotspotId?: SortOrder
    ideaId?: SortOrder
    initiativeId?: SortOrder
    inputId?: SortOrder
    progress?: SortOrder
    targetDate?: SortOrder
  }

  export type solutionsSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type EnumSolutionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SolutionStatus | EnumSolutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SolutionStatus[] | ListEnumSolutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SolutionStatus[] | ListEnumSolutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSolutionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SolutionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSolutionStatusFilter<$PrismaModel>
    _max?: NestedEnumSolutionStatusFilter<$PrismaModel>
  }

  export type teamsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    departmentId?: SortOrder
    leaderId?: SortOrder
    memberCount?: SortOrder
    maxCapacity?: SortOrder
    isActive?: SortOrder
    teamType?: SortOrder
    currentProjects?: SortOrder
    budgetAllocation?: SortOrder
    utilizationRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type teamsAvgOrderByAggregateInput = {
    memberCount?: SortOrder
    maxCapacity?: SortOrder
    currentProjects?: SortOrder
    budgetAllocation?: SortOrder
    utilizationRate?: SortOrder
  }

  export type teamsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    departmentId?: SortOrder
    leaderId?: SortOrder
    memberCount?: SortOrder
    maxCapacity?: SortOrder
    isActive?: SortOrder
    teamType?: SortOrder
    currentProjects?: SortOrder
    budgetAllocation?: SortOrder
    utilizationRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type teamsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    departmentId?: SortOrder
    leaderId?: SortOrder
    memberCount?: SortOrder
    maxCapacity?: SortOrder
    isActive?: SortOrder
    teamType?: SortOrder
    currentProjects?: SortOrder
    budgetAllocation?: SortOrder
    utilizationRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type teamsSumOrderByAggregateInput = {
    memberCount?: SortOrder
    maxCapacity?: SortOrder
    currentProjects?: SortOrder
    budgetAllocation?: SortOrder
    utilizationRate?: SortOrder
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type Ai_analysis_auditListRelationFilter = {
    every?: ai_analysis_auditWhereInput
    some?: ai_analysis_auditWhereInput
    none?: ai_analysis_auditWhereInput
  }

  export type Audit_logsListRelationFilter = {
    every?: audit_logsWhereInput
    some?: audit_logsWhereInput
    none?: audit_logsWhereInput
  }

  export type DepartmentsListRelationFilter = {
    every?: departmentsWhereInput
    some?: departmentsWhereInput
    none?: departmentsWhereInput
  }

  export type InitiativesListRelationFilter = {
    every?: initiativesWhereInput
    some?: initiativesWhereInput
    none?: initiativesWhereInput
  }

  export type Input_groupsListRelationFilter = {
    every?: input_groupsWhereInput
    some?: input_groupsWhereInput
    none?: input_groupsWhereInput
  }

  export type InputsListRelationFilter = {
    every?: inputsWhereInput
    some?: inputsWhereInput
    none?: inputsWhereInput
  }

  export type VotesListRelationFilter = {
    every?: votesWhereInput
    some?: votesWhereInput
    none?: votesWhereInput
  }

  export type ai_analysis_auditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type audit_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type departmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type initiativesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type input_groupsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type inputsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type votesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrder
    avatar?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    managerId?: SortOrder
    billableRate?: SortOrder
    costCenter?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    profileJson?: SortOrder
    targetUtilization?: SortOrder
    utilizationRate?: SortOrder
    departmentObjId?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    billableRate?: SortOrder
    targetUtilization?: SortOrder
    utilizationRate?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrder
    avatar?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    managerId?: SortOrder
    billableRate?: SortOrder
    costCenter?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    targetUtilization?: SortOrder
    utilizationRate?: SortOrder
    departmentObjId?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrder
    avatar?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    managerId?: SortOrder
    billableRate?: SortOrder
    costCenter?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    targetUtilization?: SortOrder
    utilizationRate?: SortOrder
    departmentObjId?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    billableRate?: SortOrder
    targetUtilization?: SortOrder
    utilizationRate?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumVoteValueFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteValue | EnumVoteValueFieldRefInput<$PrismaModel>
    in?: $Enums.VoteValue[] | ListEnumVoteValueFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteValue[] | ListEnumVoteValueFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteValueFilter<$PrismaModel> | $Enums.VoteValue
  }

  export type votesEntityTypeEntityIdCreatedByCompoundUniqueInput = {
    entityType: $Enums.EntityType
    entityId: string
    createdBy: string
  }

  export type votesCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    value?: SortOrder
  }

  export type votesMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    value?: SortOrder
  }

  export type votesMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    value?: SortOrder
  }

  export type EnumVoteValueWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteValue | EnumVoteValueFieldRefInput<$PrismaModel>
    in?: $Enums.VoteValue[] | ListEnumVoteValueFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteValue[] | ListEnumVoteValueFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteValueWithAggregatesFilter<$PrismaModel> | $Enums.VoteValue
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoteValueFilter<$PrismaModel>
    _max?: NestedEnumVoteValueFilter<$PrismaModel>
  }

  export type inputsCreateNestedOneWithoutInputToInputGroupInput = {
    create?: XOR<inputsCreateWithoutInputToInputGroupInput, inputsUncheckedCreateWithoutInputToInputGroupInput>
    connectOrCreate?: inputsCreateOrConnectWithoutInputToInputGroupInput
    connect?: inputsWhereUniqueInput
  }

  export type input_groupsCreateNestedOneWithoutInputToInputGroupInput = {
    create?: XOR<input_groupsCreateWithoutInputToInputGroupInput, input_groupsUncheckedCreateWithoutInputToInputGroupInput>
    connectOrCreate?: input_groupsCreateOrConnectWithoutInputToInputGroupInput
    connect?: input_groupsWhereUniqueInput
  }

  export type inputsUpdateOneRequiredWithoutInputToInputGroupNestedInput = {
    create?: XOR<inputsCreateWithoutInputToInputGroupInput, inputsUncheckedCreateWithoutInputToInputGroupInput>
    connectOrCreate?: inputsCreateOrConnectWithoutInputToInputGroupInput
    upsert?: inputsUpsertWithoutInputToInputGroupInput
    connect?: inputsWhereUniqueInput
    update?: XOR<XOR<inputsUpdateToOneWithWhereWithoutInputToInputGroupInput, inputsUpdateWithoutInputToInputGroupInput>, inputsUncheckedUpdateWithoutInputToInputGroupInput>
  }

  export type input_groupsUpdateOneRequiredWithoutInputToInputGroupNestedInput = {
    create?: XOR<input_groupsCreateWithoutInputToInputGroupInput, input_groupsUncheckedCreateWithoutInputToInputGroupInput>
    connectOrCreate?: input_groupsCreateOrConnectWithoutInputToInputGroupInput
    upsert?: input_groupsUpsertWithoutInputToInputGroupInput
    connect?: input_groupsWhereUniqueInput
    update?: XOR<XOR<input_groupsUpdateToOneWithWhereWithoutInputToInputGroupInput, input_groupsUpdateWithoutInputToInputGroupInput>, input_groupsUncheckedUpdateWithoutInputToInputGroupInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type usersCreateNestedOneWithoutAi_analysis_auditInput = {
    create?: XOR<usersCreateWithoutAi_analysis_auditInput, usersUncheckedCreateWithoutAi_analysis_auditInput>
    connectOrCreate?: usersCreateOrConnectWithoutAi_analysis_auditInput
    connect?: usersWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type usersUpdateOneRequiredWithoutAi_analysis_auditNestedInput = {
    create?: XOR<usersCreateWithoutAi_analysis_auditInput, usersUncheckedCreateWithoutAi_analysis_auditInput>
    connectOrCreate?: usersCreateOrConnectWithoutAi_analysis_auditInput
    upsert?: usersUpsertWithoutAi_analysis_auditInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAi_analysis_auditInput, usersUpdateWithoutAi_analysis_auditInput>, usersUncheckedUpdateWithoutAi_analysis_auditInput>
  }

  export type usersCreateNestedOneWithoutAi_insight_overridesInput = {
    create?: XOR<usersCreateWithoutAi_insight_overridesInput, usersUncheckedCreateWithoutAi_insight_overridesInput>
    connectOrCreate?: usersCreateOrConnectWithoutAi_insight_overridesInput
    connect?: usersWhereUniqueInput
  }

  export type signalsCreateNestedOneWithoutAi_insight_overridesInput = {
    create?: XOR<signalsCreateWithoutAi_insight_overridesInput, signalsUncheckedCreateWithoutAi_insight_overridesInput>
    connectOrCreate?: signalsCreateOrConnectWithoutAi_insight_overridesInput
    connect?: signalsWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutAi_insight_overridesNestedInput = {
    create?: XOR<usersCreateWithoutAi_insight_overridesInput, usersUncheckedCreateWithoutAi_insight_overridesInput>
    connectOrCreate?: usersCreateOrConnectWithoutAi_insight_overridesInput
    upsert?: usersUpsertWithoutAi_insight_overridesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAi_insight_overridesInput, usersUpdateWithoutAi_insight_overridesInput>, usersUncheckedUpdateWithoutAi_insight_overridesInput>
  }

  export type signalsUpdateOneRequiredWithoutAi_insight_overridesNestedInput = {
    create?: XOR<signalsCreateWithoutAi_insight_overridesInput, signalsUncheckedCreateWithoutAi_insight_overridesInput>
    connectOrCreate?: signalsCreateOrConnectWithoutAi_insight_overridesInput
    upsert?: signalsUpsertWithoutAi_insight_overridesInput
    connect?: signalsWhereUniqueInput
    update?: XOR<XOR<signalsUpdateToOneWithWhereWithoutAi_insight_overridesInput, signalsUpdateWithoutAi_insight_overridesInput>, signalsUncheckedUpdateWithoutAi_insight_overridesInput>
  }

  export type usersCreateNestedOneWithoutAudit_logsInput = {
    create?: XOR<usersCreateWithoutAudit_logsInput, usersUncheckedCreateWithoutAudit_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAudit_logsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutAudit_logsNestedInput = {
    create?: XOR<usersCreateWithoutAudit_logsInput, usersUncheckedCreateWithoutAudit_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAudit_logsInput
    upsert?: usersUpsertWithoutAudit_logsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAudit_logsInput, usersUpdateWithoutAudit_logsInput>, usersUncheckedUpdateWithoutAudit_logsInput>
  }

  export type categoriesCreateNestedOneWithoutOther_categoriesInput = {
    create?: XOR<categoriesCreateWithoutOther_categoriesInput, categoriesUncheckedCreateWithoutOther_categoriesInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutOther_categoriesInput
    connect?: categoriesWhereUniqueInput
  }

  export type categoriesCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<categoriesCreateWithoutCategoriesInput, categoriesUncheckedCreateWithoutCategoriesInput> | categoriesCreateWithoutCategoriesInput[] | categoriesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutCategoriesInput | categoriesCreateOrConnectWithoutCategoriesInput[]
    createMany?: categoriesCreateManyCategoriesInputEnvelope
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
  }

  export type signalsCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<signalsCreateWithoutCategoriesInput, signalsUncheckedCreateWithoutCategoriesInput> | signalsCreateWithoutCategoriesInput[] | signalsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: signalsCreateOrConnectWithoutCategoriesInput | signalsCreateOrConnectWithoutCategoriesInput[]
    createMany?: signalsCreateManyCategoriesInputEnvelope
    connect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
  }

  export type categoriesUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<categoriesCreateWithoutCategoriesInput, categoriesUncheckedCreateWithoutCategoriesInput> | categoriesCreateWithoutCategoriesInput[] | categoriesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutCategoriesInput | categoriesCreateOrConnectWithoutCategoriesInput[]
    createMany?: categoriesCreateManyCategoriesInputEnvelope
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
  }

  export type signalsUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<signalsCreateWithoutCategoriesInput, signalsUncheckedCreateWithoutCategoriesInput> | signalsCreateWithoutCategoriesInput[] | signalsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: signalsCreateOrConnectWithoutCategoriesInput | signalsCreateOrConnectWithoutCategoriesInput[]
    createMany?: signalsCreateManyCategoriesInputEnvelope
    connect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type categoriesUpdateOneWithoutOther_categoriesNestedInput = {
    create?: XOR<categoriesCreateWithoutOther_categoriesInput, categoriesUncheckedCreateWithoutOther_categoriesInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutOther_categoriesInput
    upsert?: categoriesUpsertWithoutOther_categoriesInput
    disconnect?: categoriesWhereInput | boolean
    delete?: categoriesWhereInput | boolean
    connect?: categoriesWhereUniqueInput
    update?: XOR<XOR<categoriesUpdateToOneWithWhereWithoutOther_categoriesInput, categoriesUpdateWithoutOther_categoriesInput>, categoriesUncheckedUpdateWithoutOther_categoriesInput>
  }

  export type categoriesUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<categoriesCreateWithoutCategoriesInput, categoriesUncheckedCreateWithoutCategoriesInput> | categoriesCreateWithoutCategoriesInput[] | categoriesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutCategoriesInput | categoriesCreateOrConnectWithoutCategoriesInput[]
    upsert?: categoriesUpsertWithWhereUniqueWithoutCategoriesInput | categoriesUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: categoriesCreateManyCategoriesInputEnvelope
    set?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    disconnect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    delete?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    update?: categoriesUpdateWithWhereUniqueWithoutCategoriesInput | categoriesUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: categoriesUpdateManyWithWhereWithoutCategoriesInput | categoriesUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
  }

  export type signalsUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<signalsCreateWithoutCategoriesInput, signalsUncheckedCreateWithoutCategoriesInput> | signalsCreateWithoutCategoriesInput[] | signalsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: signalsCreateOrConnectWithoutCategoriesInput | signalsCreateOrConnectWithoutCategoriesInput[]
    upsert?: signalsUpsertWithWhereUniqueWithoutCategoriesInput | signalsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: signalsCreateManyCategoriesInputEnvelope
    set?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    disconnect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    delete?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    connect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    update?: signalsUpdateWithWhereUniqueWithoutCategoriesInput | signalsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: signalsUpdateManyWithWhereWithoutCategoriesInput | signalsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: signalsScalarWhereInput | signalsScalarWhereInput[]
  }

  export type categoriesUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<categoriesCreateWithoutCategoriesInput, categoriesUncheckedCreateWithoutCategoriesInput> | categoriesCreateWithoutCategoriesInput[] | categoriesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutCategoriesInput | categoriesCreateOrConnectWithoutCategoriesInput[]
    upsert?: categoriesUpsertWithWhereUniqueWithoutCategoriesInput | categoriesUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: categoriesCreateManyCategoriesInputEnvelope
    set?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    disconnect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    delete?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    update?: categoriesUpdateWithWhereUniqueWithoutCategoriesInput | categoriesUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: categoriesUpdateManyWithWhereWithoutCategoriesInput | categoriesUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
  }

  export type signalsUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<signalsCreateWithoutCategoriesInput, signalsUncheckedCreateWithoutCategoriesInput> | signalsCreateWithoutCategoriesInput[] | signalsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: signalsCreateOrConnectWithoutCategoriesInput | signalsCreateOrConnectWithoutCategoriesInput[]
    upsert?: signalsUpsertWithWhereUniqueWithoutCategoriesInput | signalsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: signalsCreateManyCategoriesInputEnvelope
    set?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    disconnect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    delete?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    connect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    update?: signalsUpdateWithWhereUniqueWithoutCategoriesInput | signalsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: signalsUpdateManyWithWhereWithoutCategoriesInput | signalsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: signalsScalarWhereInput | signalsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutCommentsInput = {
    create?: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCommentsInput
    connect?: usersWhereUniqueInput
  }

  export type commentsCreateNestedOneWithoutOther_commentsInput = {
    create?: XOR<commentsCreateWithoutOther_commentsInput, commentsUncheckedCreateWithoutOther_commentsInput>
    connectOrCreate?: commentsCreateOrConnectWithoutOther_commentsInput
    connect?: commentsWhereUniqueInput
  }

  export type commentsCreateNestedManyWithoutCommentsInput = {
    create?: XOR<commentsCreateWithoutCommentsInput, commentsUncheckedCreateWithoutCommentsInput> | commentsCreateWithoutCommentsInput[] | commentsUncheckedCreateWithoutCommentsInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutCommentsInput | commentsCreateOrConnectWithoutCommentsInput[]
    createMany?: commentsCreateManyCommentsInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type commentsUncheckedCreateNestedManyWithoutCommentsInput = {
    create?: XOR<commentsCreateWithoutCommentsInput, commentsUncheckedCreateWithoutCommentsInput> | commentsCreateWithoutCommentsInput[] | commentsUncheckedCreateWithoutCommentsInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutCommentsInput | commentsCreateOrConnectWithoutCommentsInput[]
    createMany?: commentsCreateManyCommentsInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.EntityType
  }

  export type usersUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCommentsInput
    upsert?: usersUpsertWithoutCommentsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCommentsInput, usersUpdateWithoutCommentsInput>, usersUncheckedUpdateWithoutCommentsInput>
  }

  export type commentsUpdateOneWithoutOther_commentsNestedInput = {
    create?: XOR<commentsCreateWithoutOther_commentsInput, commentsUncheckedCreateWithoutOther_commentsInput>
    connectOrCreate?: commentsCreateOrConnectWithoutOther_commentsInput
    upsert?: commentsUpsertWithoutOther_commentsInput
    disconnect?: commentsWhereInput | boolean
    delete?: commentsWhereInput | boolean
    connect?: commentsWhereUniqueInput
    update?: XOR<XOR<commentsUpdateToOneWithWhereWithoutOther_commentsInput, commentsUpdateWithoutOther_commentsInput>, commentsUncheckedUpdateWithoutOther_commentsInput>
  }

  export type commentsUpdateManyWithoutCommentsNestedInput = {
    create?: XOR<commentsCreateWithoutCommentsInput, commentsUncheckedCreateWithoutCommentsInput> | commentsCreateWithoutCommentsInput[] | commentsUncheckedCreateWithoutCommentsInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutCommentsInput | commentsCreateOrConnectWithoutCommentsInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutCommentsInput | commentsUpsertWithWhereUniqueWithoutCommentsInput[]
    createMany?: commentsCreateManyCommentsInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutCommentsInput | commentsUpdateWithWhereUniqueWithoutCommentsInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutCommentsInput | commentsUpdateManyWithWhereWithoutCommentsInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type commentsUncheckedUpdateManyWithoutCommentsNestedInput = {
    create?: XOR<commentsCreateWithoutCommentsInput, commentsUncheckedCreateWithoutCommentsInput> | commentsCreateWithoutCommentsInput[] | commentsUncheckedCreateWithoutCommentsInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutCommentsInput | commentsCreateOrConnectWithoutCommentsInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutCommentsInput | commentsUpsertWithWhereUniqueWithoutCommentsInput[]
    createMany?: commentsCreateManyCommentsInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutCommentsInput | commentsUpdateWithWhereUniqueWithoutCommentsInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutCommentsInput | commentsUpdateManyWithWhereWithoutCommentsInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutDepartments_departments_managerIdTousersInput = {
    create?: XOR<usersCreateWithoutDepartments_departments_managerIdTousersInput, usersUncheckedCreateWithoutDepartments_departments_managerIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutDepartments_departments_managerIdTousersInput
    connect?: usersWhereUniqueInput
  }

  export type signalsCreateNestedManyWithoutDepartmentsInput = {
    create?: XOR<signalsCreateWithoutDepartmentsInput, signalsUncheckedCreateWithoutDepartmentsInput> | signalsCreateWithoutDepartmentsInput[] | signalsUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: signalsCreateOrConnectWithoutDepartmentsInput | signalsCreateOrConnectWithoutDepartmentsInput[]
    createMany?: signalsCreateManyDepartmentsInputEnvelope
    connect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
  }

  export type teamsCreateNestedManyWithoutDepartmentsInput = {
    create?: XOR<teamsCreateWithoutDepartmentsInput, teamsUncheckedCreateWithoutDepartmentsInput> | teamsCreateWithoutDepartmentsInput[] | teamsUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: teamsCreateOrConnectWithoutDepartmentsInput | teamsCreateOrConnectWithoutDepartmentsInput[]
    createMany?: teamsCreateManyDepartmentsInputEnvelope
    connect?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
  }

  export type usersCreateNestedManyWithoutDepartments_users_departmentObjIdTodepartmentsInput = {
    create?: XOR<usersCreateWithoutDepartments_users_departmentObjIdTodepartmentsInput, usersUncheckedCreateWithoutDepartments_users_departmentObjIdTodepartmentsInput> | usersCreateWithoutDepartments_users_departmentObjIdTodepartmentsInput[] | usersUncheckedCreateWithoutDepartments_users_departmentObjIdTodepartmentsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutDepartments_users_departmentObjIdTodepartmentsInput | usersCreateOrConnectWithoutDepartments_users_departmentObjIdTodepartmentsInput[]
    createMany?: usersCreateManyDepartments_users_departmentObjIdTodepartmentsInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type signalsUncheckedCreateNestedManyWithoutDepartmentsInput = {
    create?: XOR<signalsCreateWithoutDepartmentsInput, signalsUncheckedCreateWithoutDepartmentsInput> | signalsCreateWithoutDepartmentsInput[] | signalsUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: signalsCreateOrConnectWithoutDepartmentsInput | signalsCreateOrConnectWithoutDepartmentsInput[]
    createMany?: signalsCreateManyDepartmentsInputEnvelope
    connect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
  }

  export type teamsUncheckedCreateNestedManyWithoutDepartmentsInput = {
    create?: XOR<teamsCreateWithoutDepartmentsInput, teamsUncheckedCreateWithoutDepartmentsInput> | teamsCreateWithoutDepartmentsInput[] | teamsUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: teamsCreateOrConnectWithoutDepartmentsInput | teamsCreateOrConnectWithoutDepartmentsInput[]
    createMany?: teamsCreateManyDepartmentsInputEnvelope
    connect?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutDepartments_users_departmentObjIdTodepartmentsInput = {
    create?: XOR<usersCreateWithoutDepartments_users_departmentObjIdTodepartmentsInput, usersUncheckedCreateWithoutDepartments_users_departmentObjIdTodepartmentsInput> | usersCreateWithoutDepartments_users_departmentObjIdTodepartmentsInput[] | usersUncheckedCreateWithoutDepartments_users_departmentObjIdTodepartmentsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutDepartments_users_departmentObjIdTodepartmentsInput | usersCreateOrConnectWithoutDepartments_users_departmentObjIdTodepartmentsInput[]
    createMany?: usersCreateManyDepartments_users_departmentObjIdTodepartmentsInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type usersUpdateOneWithoutDepartments_departments_managerIdTousersNestedInput = {
    create?: XOR<usersCreateWithoutDepartments_departments_managerIdTousersInput, usersUncheckedCreateWithoutDepartments_departments_managerIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutDepartments_departments_managerIdTousersInput
    upsert?: usersUpsertWithoutDepartments_departments_managerIdTousersInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutDepartments_departments_managerIdTousersInput, usersUpdateWithoutDepartments_departments_managerIdTousersInput>, usersUncheckedUpdateWithoutDepartments_departments_managerIdTousersInput>
  }

  export type signalsUpdateManyWithoutDepartmentsNestedInput = {
    create?: XOR<signalsCreateWithoutDepartmentsInput, signalsUncheckedCreateWithoutDepartmentsInput> | signalsCreateWithoutDepartmentsInput[] | signalsUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: signalsCreateOrConnectWithoutDepartmentsInput | signalsCreateOrConnectWithoutDepartmentsInput[]
    upsert?: signalsUpsertWithWhereUniqueWithoutDepartmentsInput | signalsUpsertWithWhereUniqueWithoutDepartmentsInput[]
    createMany?: signalsCreateManyDepartmentsInputEnvelope
    set?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    disconnect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    delete?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    connect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    update?: signalsUpdateWithWhereUniqueWithoutDepartmentsInput | signalsUpdateWithWhereUniqueWithoutDepartmentsInput[]
    updateMany?: signalsUpdateManyWithWhereWithoutDepartmentsInput | signalsUpdateManyWithWhereWithoutDepartmentsInput[]
    deleteMany?: signalsScalarWhereInput | signalsScalarWhereInput[]
  }

  export type teamsUpdateManyWithoutDepartmentsNestedInput = {
    create?: XOR<teamsCreateWithoutDepartmentsInput, teamsUncheckedCreateWithoutDepartmentsInput> | teamsCreateWithoutDepartmentsInput[] | teamsUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: teamsCreateOrConnectWithoutDepartmentsInput | teamsCreateOrConnectWithoutDepartmentsInput[]
    upsert?: teamsUpsertWithWhereUniqueWithoutDepartmentsInput | teamsUpsertWithWhereUniqueWithoutDepartmentsInput[]
    createMany?: teamsCreateManyDepartmentsInputEnvelope
    set?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    disconnect?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    delete?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    connect?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    update?: teamsUpdateWithWhereUniqueWithoutDepartmentsInput | teamsUpdateWithWhereUniqueWithoutDepartmentsInput[]
    updateMany?: teamsUpdateManyWithWhereWithoutDepartmentsInput | teamsUpdateManyWithWhereWithoutDepartmentsInput[]
    deleteMany?: teamsScalarWhereInput | teamsScalarWhereInput[]
  }

  export type usersUpdateManyWithoutDepartments_users_departmentObjIdTodepartmentsNestedInput = {
    create?: XOR<usersCreateWithoutDepartments_users_departmentObjIdTodepartmentsInput, usersUncheckedCreateWithoutDepartments_users_departmentObjIdTodepartmentsInput> | usersCreateWithoutDepartments_users_departmentObjIdTodepartmentsInput[] | usersUncheckedCreateWithoutDepartments_users_departmentObjIdTodepartmentsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutDepartments_users_departmentObjIdTodepartmentsInput | usersCreateOrConnectWithoutDepartments_users_departmentObjIdTodepartmentsInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutDepartments_users_departmentObjIdTodepartmentsInput | usersUpsertWithWhereUniqueWithoutDepartments_users_departmentObjIdTodepartmentsInput[]
    createMany?: usersCreateManyDepartments_users_departmentObjIdTodepartmentsInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutDepartments_users_departmentObjIdTodepartmentsInput | usersUpdateWithWhereUniqueWithoutDepartments_users_departmentObjIdTodepartmentsInput[]
    updateMany?: usersUpdateManyWithWhereWithoutDepartments_users_departmentObjIdTodepartmentsInput | usersUpdateManyWithWhereWithoutDepartments_users_departmentObjIdTodepartmentsInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type signalsUncheckedUpdateManyWithoutDepartmentsNestedInput = {
    create?: XOR<signalsCreateWithoutDepartmentsInput, signalsUncheckedCreateWithoutDepartmentsInput> | signalsCreateWithoutDepartmentsInput[] | signalsUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: signalsCreateOrConnectWithoutDepartmentsInput | signalsCreateOrConnectWithoutDepartmentsInput[]
    upsert?: signalsUpsertWithWhereUniqueWithoutDepartmentsInput | signalsUpsertWithWhereUniqueWithoutDepartmentsInput[]
    createMany?: signalsCreateManyDepartmentsInputEnvelope
    set?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    disconnect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    delete?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    connect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    update?: signalsUpdateWithWhereUniqueWithoutDepartmentsInput | signalsUpdateWithWhereUniqueWithoutDepartmentsInput[]
    updateMany?: signalsUpdateManyWithWhereWithoutDepartmentsInput | signalsUpdateManyWithWhereWithoutDepartmentsInput[]
    deleteMany?: signalsScalarWhereInput | signalsScalarWhereInput[]
  }

  export type teamsUncheckedUpdateManyWithoutDepartmentsNestedInput = {
    create?: XOR<teamsCreateWithoutDepartmentsInput, teamsUncheckedCreateWithoutDepartmentsInput> | teamsCreateWithoutDepartmentsInput[] | teamsUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: teamsCreateOrConnectWithoutDepartmentsInput | teamsCreateOrConnectWithoutDepartmentsInput[]
    upsert?: teamsUpsertWithWhereUniqueWithoutDepartmentsInput | teamsUpsertWithWhereUniqueWithoutDepartmentsInput[]
    createMany?: teamsCreateManyDepartmentsInputEnvelope
    set?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    disconnect?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    delete?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    connect?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    update?: teamsUpdateWithWhereUniqueWithoutDepartmentsInput | teamsUpdateWithWhereUniqueWithoutDepartmentsInput[]
    updateMany?: teamsUpdateManyWithWhereWithoutDepartmentsInput | teamsUpdateManyWithWhereWithoutDepartmentsInput[]
    deleteMany?: teamsScalarWhereInput | teamsScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutDepartments_users_departmentObjIdTodepartmentsNestedInput = {
    create?: XOR<usersCreateWithoutDepartments_users_departmentObjIdTodepartmentsInput, usersUncheckedCreateWithoutDepartments_users_departmentObjIdTodepartmentsInput> | usersCreateWithoutDepartments_users_departmentObjIdTodepartmentsInput[] | usersUncheckedCreateWithoutDepartments_users_departmentObjIdTodepartmentsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutDepartments_users_departmentObjIdTodepartmentsInput | usersCreateOrConnectWithoutDepartments_users_departmentObjIdTodepartmentsInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutDepartments_users_departmentObjIdTodepartmentsInput | usersUpsertWithWhereUniqueWithoutDepartments_users_departmentObjIdTodepartmentsInput[]
    createMany?: usersCreateManyDepartments_users_departmentObjIdTodepartmentsInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutDepartments_users_departmentObjIdTodepartmentsInput | usersUpdateWithWhereUniqueWithoutDepartments_users_departmentObjIdTodepartmentsInput[]
    updateMany?: usersUpdateManyWithWhereWithoutDepartments_users_departmentObjIdTodepartmentsInput | usersUpdateManyWithWhereWithoutDepartments_users_departmentObjIdTodepartmentsInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutFrd_documents_frd_documents_approvedByTousersInput = {
    create?: XOR<usersCreateWithoutFrd_documents_frd_documents_approvedByTousersInput, usersUncheckedCreateWithoutFrd_documents_frd_documents_approvedByTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutFrd_documents_frd_documents_approvedByTousersInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutFrd_documents_frd_documents_createdByTousersInput = {
    create?: XOR<usersCreateWithoutFrd_documents_frd_documents_createdByTousersInput, usersUncheckedCreateWithoutFrd_documents_frd_documents_createdByTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutFrd_documents_frd_documents_createdByTousersInput
    connect?: usersWhereUniqueInput
  }

  export type solutionsCreateNestedOneWithoutFrd_documentsInput = {
    create?: XOR<solutionsCreateWithoutFrd_documentsInput, solutionsUncheckedCreateWithoutFrd_documentsInput>
    connectOrCreate?: solutionsCreateOrConnectWithoutFrd_documentsInput
    connect?: solutionsWhereUniqueInput
  }

  export type EnumFRDStatusFieldUpdateOperationsInput = {
    set?: $Enums.FRDStatus
  }

  export type usersUpdateOneWithoutFrd_documents_frd_documents_approvedByTousersNestedInput = {
    create?: XOR<usersCreateWithoutFrd_documents_frd_documents_approvedByTousersInput, usersUncheckedCreateWithoutFrd_documents_frd_documents_approvedByTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutFrd_documents_frd_documents_approvedByTousersInput
    upsert?: usersUpsertWithoutFrd_documents_frd_documents_approvedByTousersInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutFrd_documents_frd_documents_approvedByTousersInput, usersUpdateWithoutFrd_documents_frd_documents_approvedByTousersInput>, usersUncheckedUpdateWithoutFrd_documents_frd_documents_approvedByTousersInput>
  }

  export type usersUpdateOneRequiredWithoutFrd_documents_frd_documents_createdByTousersNestedInput = {
    create?: XOR<usersCreateWithoutFrd_documents_frd_documents_createdByTousersInput, usersUncheckedCreateWithoutFrd_documents_frd_documents_createdByTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutFrd_documents_frd_documents_createdByTousersInput
    upsert?: usersUpsertWithoutFrd_documents_frd_documents_createdByTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutFrd_documents_frd_documents_createdByTousersInput, usersUpdateWithoutFrd_documents_frd_documents_createdByTousersInput>, usersUncheckedUpdateWithoutFrd_documents_frd_documents_createdByTousersInput>
  }

  export type solutionsUpdateOneRequiredWithoutFrd_documentsNestedInput = {
    create?: XOR<solutionsCreateWithoutFrd_documentsInput, solutionsUncheckedCreateWithoutFrd_documentsInput>
    connectOrCreate?: solutionsCreateOrConnectWithoutFrd_documentsInput
    upsert?: solutionsUpsertWithoutFrd_documentsInput
    connect?: solutionsWhereUniqueInput
    update?: XOR<XOR<solutionsUpdateToOneWithWhereWithoutFrd_documentsInput, solutionsUpdateWithoutFrd_documentsInput>, solutionsUncheckedUpdateWithoutFrd_documentsInput>
  }

  export type hotspotsCreateNestedOneWithoutHotspot_signalsInput = {
    create?: XOR<hotspotsCreateWithoutHotspot_signalsInput, hotspotsUncheckedCreateWithoutHotspot_signalsInput>
    connectOrCreate?: hotspotsCreateOrConnectWithoutHotspot_signalsInput
    connect?: hotspotsWhereUniqueInput
  }

  export type signalsCreateNestedOneWithoutHotspot_signalsInput = {
    create?: XOR<signalsCreateWithoutHotspot_signalsInput, signalsUncheckedCreateWithoutHotspot_signalsInput>
    connectOrCreate?: signalsCreateOrConnectWithoutHotspot_signalsInput
    connect?: signalsWhereUniqueInput
  }

  export type hotspotsUpdateOneRequiredWithoutHotspot_signalsNestedInput = {
    create?: XOR<hotspotsCreateWithoutHotspot_signalsInput, hotspotsUncheckedCreateWithoutHotspot_signalsInput>
    connectOrCreate?: hotspotsCreateOrConnectWithoutHotspot_signalsInput
    upsert?: hotspotsUpsertWithoutHotspot_signalsInput
    connect?: hotspotsWhereUniqueInput
    update?: XOR<XOR<hotspotsUpdateToOneWithWhereWithoutHotspot_signalsInput, hotspotsUpdateWithoutHotspot_signalsInput>, hotspotsUncheckedUpdateWithoutHotspot_signalsInput>
  }

  export type signalsUpdateOneRequiredWithoutHotspot_signalsNestedInput = {
    create?: XOR<signalsCreateWithoutHotspot_signalsInput, signalsUncheckedCreateWithoutHotspot_signalsInput>
    connectOrCreate?: signalsCreateOrConnectWithoutHotspot_signalsInput
    upsert?: signalsUpsertWithoutHotspot_signalsInput
    connect?: signalsWhereUniqueInput
    update?: XOR<XOR<signalsUpdateToOneWithWhereWithoutHotspot_signalsInput, signalsUpdateWithoutHotspot_signalsInput>, signalsUncheckedUpdateWithoutHotspot_signalsInput>
  }

  export type hotspot_signalsCreateNestedManyWithoutHotspotsInput = {
    create?: XOR<hotspot_signalsCreateWithoutHotspotsInput, hotspot_signalsUncheckedCreateWithoutHotspotsInput> | hotspot_signalsCreateWithoutHotspotsInput[] | hotspot_signalsUncheckedCreateWithoutHotspotsInput[]
    connectOrCreate?: hotspot_signalsCreateOrConnectWithoutHotspotsInput | hotspot_signalsCreateOrConnectWithoutHotspotsInput[]
    createMany?: hotspot_signalsCreateManyHotspotsInputEnvelope
    connect?: hotspot_signalsWhereUniqueInput | hotspot_signalsWhereUniqueInput[]
  }

  export type ideasCreateNestedManyWithoutHotspotsInput = {
    create?: XOR<ideasCreateWithoutHotspotsInput, ideasUncheckedCreateWithoutHotspotsInput> | ideasCreateWithoutHotspotsInput[] | ideasUncheckedCreateWithoutHotspotsInput[]
    connectOrCreate?: ideasCreateOrConnectWithoutHotspotsInput | ideasCreateOrConnectWithoutHotspotsInput[]
    createMany?: ideasCreateManyHotspotsInputEnvelope
    connect?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
  }

  export type solutionsCreateNestedManyWithoutHotspotsInput = {
    create?: XOR<solutionsCreateWithoutHotspotsInput, solutionsUncheckedCreateWithoutHotspotsInput> | solutionsCreateWithoutHotspotsInput[] | solutionsUncheckedCreateWithoutHotspotsInput[]
    connectOrCreate?: solutionsCreateOrConnectWithoutHotspotsInput | solutionsCreateOrConnectWithoutHotspotsInput[]
    createMany?: solutionsCreateManyHotspotsInputEnvelope
    connect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
  }

  export type hotspot_signalsUncheckedCreateNestedManyWithoutHotspotsInput = {
    create?: XOR<hotspot_signalsCreateWithoutHotspotsInput, hotspot_signalsUncheckedCreateWithoutHotspotsInput> | hotspot_signalsCreateWithoutHotspotsInput[] | hotspot_signalsUncheckedCreateWithoutHotspotsInput[]
    connectOrCreate?: hotspot_signalsCreateOrConnectWithoutHotspotsInput | hotspot_signalsCreateOrConnectWithoutHotspotsInput[]
    createMany?: hotspot_signalsCreateManyHotspotsInputEnvelope
    connect?: hotspot_signalsWhereUniqueInput | hotspot_signalsWhereUniqueInput[]
  }

  export type ideasUncheckedCreateNestedManyWithoutHotspotsInput = {
    create?: XOR<ideasCreateWithoutHotspotsInput, ideasUncheckedCreateWithoutHotspotsInput> | ideasCreateWithoutHotspotsInput[] | ideasUncheckedCreateWithoutHotspotsInput[]
    connectOrCreate?: ideasCreateOrConnectWithoutHotspotsInput | ideasCreateOrConnectWithoutHotspotsInput[]
    createMany?: ideasCreateManyHotspotsInputEnvelope
    connect?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
  }

  export type solutionsUncheckedCreateNestedManyWithoutHotspotsInput = {
    create?: XOR<solutionsCreateWithoutHotspotsInput, solutionsUncheckedCreateWithoutHotspotsInput> | solutionsCreateWithoutHotspotsInput[] | solutionsUncheckedCreateWithoutHotspotsInput[]
    connectOrCreate?: solutionsCreateOrConnectWithoutHotspotsInput | solutionsCreateOrConnectWithoutHotspotsInput[]
    createMany?: solutionsCreateManyHotspotsInputEnvelope
    connect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
  }

  export type EnumHotspotStatusFieldUpdateOperationsInput = {
    set?: $Enums.HotspotStatus
  }

  export type hotspot_signalsUpdateManyWithoutHotspotsNestedInput = {
    create?: XOR<hotspot_signalsCreateWithoutHotspotsInput, hotspot_signalsUncheckedCreateWithoutHotspotsInput> | hotspot_signalsCreateWithoutHotspotsInput[] | hotspot_signalsUncheckedCreateWithoutHotspotsInput[]
    connectOrCreate?: hotspot_signalsCreateOrConnectWithoutHotspotsInput | hotspot_signalsCreateOrConnectWithoutHotspotsInput[]
    upsert?: hotspot_signalsUpsertWithWhereUniqueWithoutHotspotsInput | hotspot_signalsUpsertWithWhereUniqueWithoutHotspotsInput[]
    createMany?: hotspot_signalsCreateManyHotspotsInputEnvelope
    set?: hotspot_signalsWhereUniqueInput | hotspot_signalsWhereUniqueInput[]
    disconnect?: hotspot_signalsWhereUniqueInput | hotspot_signalsWhereUniqueInput[]
    delete?: hotspot_signalsWhereUniqueInput | hotspot_signalsWhereUniqueInput[]
    connect?: hotspot_signalsWhereUniqueInput | hotspot_signalsWhereUniqueInput[]
    update?: hotspot_signalsUpdateWithWhereUniqueWithoutHotspotsInput | hotspot_signalsUpdateWithWhereUniqueWithoutHotspotsInput[]
    updateMany?: hotspot_signalsUpdateManyWithWhereWithoutHotspotsInput | hotspot_signalsUpdateManyWithWhereWithoutHotspotsInput[]
    deleteMany?: hotspot_signalsScalarWhereInput | hotspot_signalsScalarWhereInput[]
  }

  export type ideasUpdateManyWithoutHotspotsNestedInput = {
    create?: XOR<ideasCreateWithoutHotspotsInput, ideasUncheckedCreateWithoutHotspotsInput> | ideasCreateWithoutHotspotsInput[] | ideasUncheckedCreateWithoutHotspotsInput[]
    connectOrCreate?: ideasCreateOrConnectWithoutHotspotsInput | ideasCreateOrConnectWithoutHotspotsInput[]
    upsert?: ideasUpsertWithWhereUniqueWithoutHotspotsInput | ideasUpsertWithWhereUniqueWithoutHotspotsInput[]
    createMany?: ideasCreateManyHotspotsInputEnvelope
    set?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    disconnect?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    delete?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    connect?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    update?: ideasUpdateWithWhereUniqueWithoutHotspotsInput | ideasUpdateWithWhereUniqueWithoutHotspotsInput[]
    updateMany?: ideasUpdateManyWithWhereWithoutHotspotsInput | ideasUpdateManyWithWhereWithoutHotspotsInput[]
    deleteMany?: ideasScalarWhereInput | ideasScalarWhereInput[]
  }

  export type solutionsUpdateManyWithoutHotspotsNestedInput = {
    create?: XOR<solutionsCreateWithoutHotspotsInput, solutionsUncheckedCreateWithoutHotspotsInput> | solutionsCreateWithoutHotspotsInput[] | solutionsUncheckedCreateWithoutHotspotsInput[]
    connectOrCreate?: solutionsCreateOrConnectWithoutHotspotsInput | solutionsCreateOrConnectWithoutHotspotsInput[]
    upsert?: solutionsUpsertWithWhereUniqueWithoutHotspotsInput | solutionsUpsertWithWhereUniqueWithoutHotspotsInput[]
    createMany?: solutionsCreateManyHotspotsInputEnvelope
    set?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    disconnect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    delete?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    connect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    update?: solutionsUpdateWithWhereUniqueWithoutHotspotsInput | solutionsUpdateWithWhereUniqueWithoutHotspotsInput[]
    updateMany?: solutionsUpdateManyWithWhereWithoutHotspotsInput | solutionsUpdateManyWithWhereWithoutHotspotsInput[]
    deleteMany?: solutionsScalarWhereInput | solutionsScalarWhereInput[]
  }

  export type hotspot_signalsUncheckedUpdateManyWithoutHotspotsNestedInput = {
    create?: XOR<hotspot_signalsCreateWithoutHotspotsInput, hotspot_signalsUncheckedCreateWithoutHotspotsInput> | hotspot_signalsCreateWithoutHotspotsInput[] | hotspot_signalsUncheckedCreateWithoutHotspotsInput[]
    connectOrCreate?: hotspot_signalsCreateOrConnectWithoutHotspotsInput | hotspot_signalsCreateOrConnectWithoutHotspotsInput[]
    upsert?: hotspot_signalsUpsertWithWhereUniqueWithoutHotspotsInput | hotspot_signalsUpsertWithWhereUniqueWithoutHotspotsInput[]
    createMany?: hotspot_signalsCreateManyHotspotsInputEnvelope
    set?: hotspot_signalsWhereUniqueInput | hotspot_signalsWhereUniqueInput[]
    disconnect?: hotspot_signalsWhereUniqueInput | hotspot_signalsWhereUniqueInput[]
    delete?: hotspot_signalsWhereUniqueInput | hotspot_signalsWhereUniqueInput[]
    connect?: hotspot_signalsWhereUniqueInput | hotspot_signalsWhereUniqueInput[]
    update?: hotspot_signalsUpdateWithWhereUniqueWithoutHotspotsInput | hotspot_signalsUpdateWithWhereUniqueWithoutHotspotsInput[]
    updateMany?: hotspot_signalsUpdateManyWithWhereWithoutHotspotsInput | hotspot_signalsUpdateManyWithWhereWithoutHotspotsInput[]
    deleteMany?: hotspot_signalsScalarWhereInput | hotspot_signalsScalarWhereInput[]
  }

  export type ideasUncheckedUpdateManyWithoutHotspotsNestedInput = {
    create?: XOR<ideasCreateWithoutHotspotsInput, ideasUncheckedCreateWithoutHotspotsInput> | ideasCreateWithoutHotspotsInput[] | ideasUncheckedCreateWithoutHotspotsInput[]
    connectOrCreate?: ideasCreateOrConnectWithoutHotspotsInput | ideasCreateOrConnectWithoutHotspotsInput[]
    upsert?: ideasUpsertWithWhereUniqueWithoutHotspotsInput | ideasUpsertWithWhereUniqueWithoutHotspotsInput[]
    createMany?: ideasCreateManyHotspotsInputEnvelope
    set?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    disconnect?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    delete?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    connect?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    update?: ideasUpdateWithWhereUniqueWithoutHotspotsInput | ideasUpdateWithWhereUniqueWithoutHotspotsInput[]
    updateMany?: ideasUpdateManyWithWhereWithoutHotspotsInput | ideasUpdateManyWithWhereWithoutHotspotsInput[]
    deleteMany?: ideasScalarWhereInput | ideasScalarWhereInput[]
  }

  export type solutionsUncheckedUpdateManyWithoutHotspotsNestedInput = {
    create?: XOR<solutionsCreateWithoutHotspotsInput, solutionsUncheckedCreateWithoutHotspotsInput> | solutionsCreateWithoutHotspotsInput[] | solutionsUncheckedCreateWithoutHotspotsInput[]
    connectOrCreate?: solutionsCreateOrConnectWithoutHotspotsInput | solutionsCreateOrConnectWithoutHotspotsInput[]
    upsert?: solutionsUpsertWithWhereUniqueWithoutHotspotsInput | solutionsUpsertWithWhereUniqueWithoutHotspotsInput[]
    createMany?: solutionsCreateManyHotspotsInputEnvelope
    set?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    disconnect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    delete?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    connect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    update?: solutionsUpdateWithWhereUniqueWithoutHotspotsInput | solutionsUpdateWithWhereUniqueWithoutHotspotsInput[]
    updateMany?: solutionsUpdateManyWithWhereWithoutHotspotsInput | solutionsUpdateManyWithWhereWithoutHotspotsInput[]
    deleteMany?: solutionsScalarWhereInput | solutionsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutIdeasInput = {
    create?: XOR<usersCreateWithoutIdeasInput, usersUncheckedCreateWithoutIdeasInput>
    connectOrCreate?: usersCreateOrConnectWithoutIdeasInput
    connect?: usersWhereUniqueInput
  }

  export type hotspotsCreateNestedOneWithoutIdeasInput = {
    create?: XOR<hotspotsCreateWithoutIdeasInput, hotspotsUncheckedCreateWithoutIdeasInput>
    connectOrCreate?: hotspotsCreateOrConnectWithoutIdeasInput
    connect?: hotspotsWhereUniqueInput
  }

  export type initiativesCreateNestedOneWithoutIdeasInput = {
    create?: XOR<initiativesCreateWithoutIdeasInput, initiativesUncheckedCreateWithoutIdeasInput>
    connectOrCreate?: initiativesCreateOrConnectWithoutIdeasInput
    connect?: initiativesWhereUniqueInput
  }

  export type solutionsCreateNestedOneWithoutIdeasInput = {
    create?: XOR<solutionsCreateWithoutIdeasInput, solutionsUncheckedCreateWithoutIdeasInput>
    connectOrCreate?: solutionsCreateOrConnectWithoutIdeasInput
    connect?: solutionsWhereUniqueInput
  }

  export type solutionsUncheckedCreateNestedOneWithoutIdeasInput = {
    create?: XOR<solutionsCreateWithoutIdeasInput, solutionsUncheckedCreateWithoutIdeasInput>
    connectOrCreate?: solutionsCreateOrConnectWithoutIdeasInput
    connect?: solutionsWhereUniqueInput
  }

  export type usersUpdateOneWithoutIdeasNestedInput = {
    create?: XOR<usersCreateWithoutIdeasInput, usersUncheckedCreateWithoutIdeasInput>
    connectOrCreate?: usersCreateOrConnectWithoutIdeasInput
    upsert?: usersUpsertWithoutIdeasInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutIdeasInput, usersUpdateWithoutIdeasInput>, usersUncheckedUpdateWithoutIdeasInput>
  }

  export type hotspotsUpdateOneRequiredWithoutIdeasNestedInput = {
    create?: XOR<hotspotsCreateWithoutIdeasInput, hotspotsUncheckedCreateWithoutIdeasInput>
    connectOrCreate?: hotspotsCreateOrConnectWithoutIdeasInput
    upsert?: hotspotsUpsertWithoutIdeasInput
    connect?: hotspotsWhereUniqueInput
    update?: XOR<XOR<hotspotsUpdateToOneWithWhereWithoutIdeasInput, hotspotsUpdateWithoutIdeasInput>, hotspotsUncheckedUpdateWithoutIdeasInput>
  }

  export type initiativesUpdateOneWithoutIdeasNestedInput = {
    create?: XOR<initiativesCreateWithoutIdeasInput, initiativesUncheckedCreateWithoutIdeasInput>
    connectOrCreate?: initiativesCreateOrConnectWithoutIdeasInput
    upsert?: initiativesUpsertWithoutIdeasInput
    disconnect?: initiativesWhereInput | boolean
    delete?: initiativesWhereInput | boolean
    connect?: initiativesWhereUniqueInput
    update?: XOR<XOR<initiativesUpdateToOneWithWhereWithoutIdeasInput, initiativesUpdateWithoutIdeasInput>, initiativesUncheckedUpdateWithoutIdeasInput>
  }

  export type solutionsUpdateOneWithoutIdeasNestedInput = {
    create?: XOR<solutionsCreateWithoutIdeasInput, solutionsUncheckedCreateWithoutIdeasInput>
    connectOrCreate?: solutionsCreateOrConnectWithoutIdeasInput
    upsert?: solutionsUpsertWithoutIdeasInput
    disconnect?: solutionsWhereInput | boolean
    delete?: solutionsWhereInput | boolean
    connect?: solutionsWhereUniqueInput
    update?: XOR<XOR<solutionsUpdateToOneWithWhereWithoutIdeasInput, solutionsUpdateWithoutIdeasInput>, solutionsUncheckedUpdateWithoutIdeasInput>
  }

  export type solutionsUncheckedUpdateOneWithoutIdeasNestedInput = {
    create?: XOR<solutionsCreateWithoutIdeasInput, solutionsUncheckedCreateWithoutIdeasInput>
    connectOrCreate?: solutionsCreateOrConnectWithoutIdeasInput
    upsert?: solutionsUpsertWithoutIdeasInput
    disconnect?: solutionsWhereInput | boolean
    delete?: solutionsWhereInput | boolean
    connect?: solutionsWhereUniqueInput
    update?: XOR<XOR<solutionsUpdateToOneWithWhereWithoutIdeasInput, solutionsUpdateWithoutIdeasInput>, solutionsUncheckedUpdateWithoutIdeasInput>
  }

  export type ideasCreateNestedManyWithoutInitiativesInput = {
    create?: XOR<ideasCreateWithoutInitiativesInput, ideasUncheckedCreateWithoutInitiativesInput> | ideasCreateWithoutInitiativesInput[] | ideasUncheckedCreateWithoutInitiativesInput[]
    connectOrCreate?: ideasCreateOrConnectWithoutInitiativesInput | ideasCreateOrConnectWithoutInitiativesInput[]
    createMany?: ideasCreateManyInitiativesInputEnvelope
    connect?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutInitiativesInput = {
    create?: XOR<usersCreateWithoutInitiativesInput, usersUncheckedCreateWithoutInitiativesInput>
    connectOrCreate?: usersCreateOrConnectWithoutInitiativesInput
    connect?: usersWhereUniqueInput
  }

  export type solutionsCreateNestedManyWithoutInitiativesInput = {
    create?: XOR<solutionsCreateWithoutInitiativesInput, solutionsUncheckedCreateWithoutInitiativesInput> | solutionsCreateWithoutInitiativesInput[] | solutionsUncheckedCreateWithoutInitiativesInput[]
    connectOrCreate?: solutionsCreateOrConnectWithoutInitiativesInput | solutionsCreateOrConnectWithoutInitiativesInput[]
    createMany?: solutionsCreateManyInitiativesInputEnvelope
    connect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
  }

  export type ideasUncheckedCreateNestedManyWithoutInitiativesInput = {
    create?: XOR<ideasCreateWithoutInitiativesInput, ideasUncheckedCreateWithoutInitiativesInput> | ideasCreateWithoutInitiativesInput[] | ideasUncheckedCreateWithoutInitiativesInput[]
    connectOrCreate?: ideasCreateOrConnectWithoutInitiativesInput | ideasCreateOrConnectWithoutInitiativesInput[]
    createMany?: ideasCreateManyInitiativesInputEnvelope
    connect?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
  }

  export type solutionsUncheckedCreateNestedManyWithoutInitiativesInput = {
    create?: XOR<solutionsCreateWithoutInitiativesInput, solutionsUncheckedCreateWithoutInitiativesInput> | solutionsCreateWithoutInitiativesInput[] | solutionsUncheckedCreateWithoutInitiativesInput[]
    connectOrCreate?: solutionsCreateOrConnectWithoutInitiativesInput | solutionsCreateOrConnectWithoutInitiativesInput[]
    createMany?: solutionsCreateManyInitiativesInputEnvelope
    connect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
  }

  export type Enuminitiative_statusFieldUpdateOperationsInput = {
    set?: $Enums.initiative_status
  }

  export type EnumpriorityFieldUpdateOperationsInput = {
    set?: $Enums.priority
  }

  export type Enumrisk_levelFieldUpdateOperationsInput = {
    set?: $Enums.risk_level
  }

  export type ideasUpdateManyWithoutInitiativesNestedInput = {
    create?: XOR<ideasCreateWithoutInitiativesInput, ideasUncheckedCreateWithoutInitiativesInput> | ideasCreateWithoutInitiativesInput[] | ideasUncheckedCreateWithoutInitiativesInput[]
    connectOrCreate?: ideasCreateOrConnectWithoutInitiativesInput | ideasCreateOrConnectWithoutInitiativesInput[]
    upsert?: ideasUpsertWithWhereUniqueWithoutInitiativesInput | ideasUpsertWithWhereUniqueWithoutInitiativesInput[]
    createMany?: ideasCreateManyInitiativesInputEnvelope
    set?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    disconnect?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    delete?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    connect?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    update?: ideasUpdateWithWhereUniqueWithoutInitiativesInput | ideasUpdateWithWhereUniqueWithoutInitiativesInput[]
    updateMany?: ideasUpdateManyWithWhereWithoutInitiativesInput | ideasUpdateManyWithWhereWithoutInitiativesInput[]
    deleteMany?: ideasScalarWhereInput | ideasScalarWhereInput[]
  }

  export type usersUpdateOneWithoutInitiativesNestedInput = {
    create?: XOR<usersCreateWithoutInitiativesInput, usersUncheckedCreateWithoutInitiativesInput>
    connectOrCreate?: usersCreateOrConnectWithoutInitiativesInput
    upsert?: usersUpsertWithoutInitiativesInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutInitiativesInput, usersUpdateWithoutInitiativesInput>, usersUncheckedUpdateWithoutInitiativesInput>
  }

  export type solutionsUpdateManyWithoutInitiativesNestedInput = {
    create?: XOR<solutionsCreateWithoutInitiativesInput, solutionsUncheckedCreateWithoutInitiativesInput> | solutionsCreateWithoutInitiativesInput[] | solutionsUncheckedCreateWithoutInitiativesInput[]
    connectOrCreate?: solutionsCreateOrConnectWithoutInitiativesInput | solutionsCreateOrConnectWithoutInitiativesInput[]
    upsert?: solutionsUpsertWithWhereUniqueWithoutInitiativesInput | solutionsUpsertWithWhereUniqueWithoutInitiativesInput[]
    createMany?: solutionsCreateManyInitiativesInputEnvelope
    set?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    disconnect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    delete?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    connect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    update?: solutionsUpdateWithWhereUniqueWithoutInitiativesInput | solutionsUpdateWithWhereUniqueWithoutInitiativesInput[]
    updateMany?: solutionsUpdateManyWithWhereWithoutInitiativesInput | solutionsUpdateManyWithWhereWithoutInitiativesInput[]
    deleteMany?: solutionsScalarWhereInput | solutionsScalarWhereInput[]
  }

  export type ideasUncheckedUpdateManyWithoutInitiativesNestedInput = {
    create?: XOR<ideasCreateWithoutInitiativesInput, ideasUncheckedCreateWithoutInitiativesInput> | ideasCreateWithoutInitiativesInput[] | ideasUncheckedCreateWithoutInitiativesInput[]
    connectOrCreate?: ideasCreateOrConnectWithoutInitiativesInput | ideasCreateOrConnectWithoutInitiativesInput[]
    upsert?: ideasUpsertWithWhereUniqueWithoutInitiativesInput | ideasUpsertWithWhereUniqueWithoutInitiativesInput[]
    createMany?: ideasCreateManyInitiativesInputEnvelope
    set?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    disconnect?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    delete?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    connect?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    update?: ideasUpdateWithWhereUniqueWithoutInitiativesInput | ideasUpdateWithWhereUniqueWithoutInitiativesInput[]
    updateMany?: ideasUpdateManyWithWhereWithoutInitiativesInput | ideasUpdateManyWithWhereWithoutInitiativesInput[]
    deleteMany?: ideasScalarWhereInput | ideasScalarWhereInput[]
  }

  export type solutionsUncheckedUpdateManyWithoutInitiativesNestedInput = {
    create?: XOR<solutionsCreateWithoutInitiativesInput, solutionsUncheckedCreateWithoutInitiativesInput> | solutionsCreateWithoutInitiativesInput[] | solutionsUncheckedCreateWithoutInitiativesInput[]
    connectOrCreate?: solutionsCreateOrConnectWithoutInitiativesInput | solutionsCreateOrConnectWithoutInitiativesInput[]
    upsert?: solutionsUpsertWithWhereUniqueWithoutInitiativesInput | solutionsUpsertWithWhereUniqueWithoutInitiativesInput[]
    createMany?: solutionsCreateManyInitiativesInputEnvelope
    set?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    disconnect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    delete?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    connect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    update?: solutionsUpdateWithWhereUniqueWithoutInitiativesInput | solutionsUpdateWithWhereUniqueWithoutInitiativesInput[]
    updateMany?: solutionsUpdateManyWithWhereWithoutInitiativesInput | solutionsUpdateManyWithWhereWithoutInitiativesInput[]
    deleteMany?: solutionsScalarWhereInput | solutionsScalarWhereInput[]
  }

  export type InputToInputGroupCreateNestedManyWithoutInput_groupsInput = {
    create?: XOR<InputToInputGroupCreateWithoutInput_groupsInput, InputToInputGroupUncheckedCreateWithoutInput_groupsInput> | InputToInputGroupCreateWithoutInput_groupsInput[] | InputToInputGroupUncheckedCreateWithoutInput_groupsInput[]
    connectOrCreate?: InputToInputGroupCreateOrConnectWithoutInput_groupsInput | InputToInputGroupCreateOrConnectWithoutInput_groupsInput[]
    createMany?: InputToInputGroupCreateManyInput_groupsInputEnvelope
    connect?: InputToInputGroupWhereUniqueInput | InputToInputGroupWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutInput_groupsInput = {
    create?: XOR<usersCreateWithoutInput_groupsInput, usersUncheckedCreateWithoutInput_groupsInput>
    connectOrCreate?: usersCreateOrConnectWithoutInput_groupsInput
    connect?: usersWhereUniqueInput
  }

  export type InputToInputGroupUncheckedCreateNestedManyWithoutInput_groupsInput = {
    create?: XOR<InputToInputGroupCreateWithoutInput_groupsInput, InputToInputGroupUncheckedCreateWithoutInput_groupsInput> | InputToInputGroupCreateWithoutInput_groupsInput[] | InputToInputGroupUncheckedCreateWithoutInput_groupsInput[]
    connectOrCreate?: InputToInputGroupCreateOrConnectWithoutInput_groupsInput | InputToInputGroupCreateOrConnectWithoutInput_groupsInput[]
    createMany?: InputToInputGroupCreateManyInput_groupsInputEnvelope
    connect?: InputToInputGroupWhereUniqueInput | InputToInputGroupWhereUniqueInput[]
  }

  export type InputToInputGroupUpdateManyWithoutInput_groupsNestedInput = {
    create?: XOR<InputToInputGroupCreateWithoutInput_groupsInput, InputToInputGroupUncheckedCreateWithoutInput_groupsInput> | InputToInputGroupCreateWithoutInput_groupsInput[] | InputToInputGroupUncheckedCreateWithoutInput_groupsInput[]
    connectOrCreate?: InputToInputGroupCreateOrConnectWithoutInput_groupsInput | InputToInputGroupCreateOrConnectWithoutInput_groupsInput[]
    upsert?: InputToInputGroupUpsertWithWhereUniqueWithoutInput_groupsInput | InputToInputGroupUpsertWithWhereUniqueWithoutInput_groupsInput[]
    createMany?: InputToInputGroupCreateManyInput_groupsInputEnvelope
    set?: InputToInputGroupWhereUniqueInput | InputToInputGroupWhereUniqueInput[]
    disconnect?: InputToInputGroupWhereUniqueInput | InputToInputGroupWhereUniqueInput[]
    delete?: InputToInputGroupWhereUniqueInput | InputToInputGroupWhereUniqueInput[]
    connect?: InputToInputGroupWhereUniqueInput | InputToInputGroupWhereUniqueInput[]
    update?: InputToInputGroupUpdateWithWhereUniqueWithoutInput_groupsInput | InputToInputGroupUpdateWithWhereUniqueWithoutInput_groupsInput[]
    updateMany?: InputToInputGroupUpdateManyWithWhereWithoutInput_groupsInput | InputToInputGroupUpdateManyWithWhereWithoutInput_groupsInput[]
    deleteMany?: InputToInputGroupScalarWhereInput | InputToInputGroupScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutInput_groupsNestedInput = {
    create?: XOR<usersCreateWithoutInput_groupsInput, usersUncheckedCreateWithoutInput_groupsInput>
    connectOrCreate?: usersCreateOrConnectWithoutInput_groupsInput
    upsert?: usersUpsertWithoutInput_groupsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutInput_groupsInput, usersUpdateWithoutInput_groupsInput>, usersUncheckedUpdateWithoutInput_groupsInput>
  }

  export type InputToInputGroupUncheckedUpdateManyWithoutInput_groupsNestedInput = {
    create?: XOR<InputToInputGroupCreateWithoutInput_groupsInput, InputToInputGroupUncheckedCreateWithoutInput_groupsInput> | InputToInputGroupCreateWithoutInput_groupsInput[] | InputToInputGroupUncheckedCreateWithoutInput_groupsInput[]
    connectOrCreate?: InputToInputGroupCreateOrConnectWithoutInput_groupsInput | InputToInputGroupCreateOrConnectWithoutInput_groupsInput[]
    upsert?: InputToInputGroupUpsertWithWhereUniqueWithoutInput_groupsInput | InputToInputGroupUpsertWithWhereUniqueWithoutInput_groupsInput[]
    createMany?: InputToInputGroupCreateManyInput_groupsInputEnvelope
    set?: InputToInputGroupWhereUniqueInput | InputToInputGroupWhereUniqueInput[]
    disconnect?: InputToInputGroupWhereUniqueInput | InputToInputGroupWhereUniqueInput[]
    delete?: InputToInputGroupWhereUniqueInput | InputToInputGroupWhereUniqueInput[]
    connect?: InputToInputGroupWhereUniqueInput | InputToInputGroupWhereUniqueInput[]
    update?: InputToInputGroupUpdateWithWhereUniqueWithoutInput_groupsInput | InputToInputGroupUpdateWithWhereUniqueWithoutInput_groupsInput[]
    updateMany?: InputToInputGroupUpdateManyWithWhereWithoutInput_groupsInput | InputToInputGroupUpdateManyWithWhereWithoutInput_groupsInput[]
    deleteMany?: InputToInputGroupScalarWhereInput | InputToInputGroupScalarWhereInput[]
  }

  export type InputToInputGroupCreateNestedManyWithoutInputsInput = {
    create?: XOR<InputToInputGroupCreateWithoutInputsInput, InputToInputGroupUncheckedCreateWithoutInputsInput> | InputToInputGroupCreateWithoutInputsInput[] | InputToInputGroupUncheckedCreateWithoutInputsInput[]
    connectOrCreate?: InputToInputGroupCreateOrConnectWithoutInputsInput | InputToInputGroupCreateOrConnectWithoutInputsInput[]
    createMany?: InputToInputGroupCreateManyInputsInputEnvelope
    connect?: InputToInputGroupWhereUniqueInput | InputToInputGroupWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutInputsInput = {
    create?: XOR<usersCreateWithoutInputsInput, usersUncheckedCreateWithoutInputsInput>
    connectOrCreate?: usersCreateOrConnectWithoutInputsInput
    connect?: usersWhereUniqueInput
  }

  export type solutionsCreateNestedManyWithoutInputsInput = {
    create?: XOR<solutionsCreateWithoutInputsInput, solutionsUncheckedCreateWithoutInputsInput> | solutionsCreateWithoutInputsInput[] | solutionsUncheckedCreateWithoutInputsInput[]
    connectOrCreate?: solutionsCreateOrConnectWithoutInputsInput | solutionsCreateOrConnectWithoutInputsInput[]
    createMany?: solutionsCreateManyInputsInputEnvelope
    connect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
  }

  export type InputToInputGroupUncheckedCreateNestedManyWithoutInputsInput = {
    create?: XOR<InputToInputGroupCreateWithoutInputsInput, InputToInputGroupUncheckedCreateWithoutInputsInput> | InputToInputGroupCreateWithoutInputsInput[] | InputToInputGroupUncheckedCreateWithoutInputsInput[]
    connectOrCreate?: InputToInputGroupCreateOrConnectWithoutInputsInput | InputToInputGroupCreateOrConnectWithoutInputsInput[]
    createMany?: InputToInputGroupCreateManyInputsInputEnvelope
    connect?: InputToInputGroupWhereUniqueInput | InputToInputGroupWhereUniqueInput[]
  }

  export type solutionsUncheckedCreateNestedManyWithoutInputsInput = {
    create?: XOR<solutionsCreateWithoutInputsInput, solutionsUncheckedCreateWithoutInputsInput> | solutionsCreateWithoutInputsInput[] | solutionsUncheckedCreateWithoutInputsInput[]
    connectOrCreate?: solutionsCreateOrConnectWithoutInputsInput | solutionsCreateOrConnectWithoutInputsInput[]
    createMany?: solutionsCreateManyInputsInputEnvelope
    connect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
  }

  export type EnumInputTypeFieldUpdateOperationsInput = {
    set?: $Enums.InputType
  }

  export type EnumInputStatusFieldUpdateOperationsInput = {
    set?: $Enums.InputStatus
  }

  export type InputToInputGroupUpdateManyWithoutInputsNestedInput = {
    create?: XOR<InputToInputGroupCreateWithoutInputsInput, InputToInputGroupUncheckedCreateWithoutInputsInput> | InputToInputGroupCreateWithoutInputsInput[] | InputToInputGroupUncheckedCreateWithoutInputsInput[]
    connectOrCreate?: InputToInputGroupCreateOrConnectWithoutInputsInput | InputToInputGroupCreateOrConnectWithoutInputsInput[]
    upsert?: InputToInputGroupUpsertWithWhereUniqueWithoutInputsInput | InputToInputGroupUpsertWithWhereUniqueWithoutInputsInput[]
    createMany?: InputToInputGroupCreateManyInputsInputEnvelope
    set?: InputToInputGroupWhereUniqueInput | InputToInputGroupWhereUniqueInput[]
    disconnect?: InputToInputGroupWhereUniqueInput | InputToInputGroupWhereUniqueInput[]
    delete?: InputToInputGroupWhereUniqueInput | InputToInputGroupWhereUniqueInput[]
    connect?: InputToInputGroupWhereUniqueInput | InputToInputGroupWhereUniqueInput[]
    update?: InputToInputGroupUpdateWithWhereUniqueWithoutInputsInput | InputToInputGroupUpdateWithWhereUniqueWithoutInputsInput[]
    updateMany?: InputToInputGroupUpdateManyWithWhereWithoutInputsInput | InputToInputGroupUpdateManyWithWhereWithoutInputsInput[]
    deleteMany?: InputToInputGroupScalarWhereInput | InputToInputGroupScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutInputsNestedInput = {
    create?: XOR<usersCreateWithoutInputsInput, usersUncheckedCreateWithoutInputsInput>
    connectOrCreate?: usersCreateOrConnectWithoutInputsInput
    upsert?: usersUpsertWithoutInputsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutInputsInput, usersUpdateWithoutInputsInput>, usersUncheckedUpdateWithoutInputsInput>
  }

  export type solutionsUpdateManyWithoutInputsNestedInput = {
    create?: XOR<solutionsCreateWithoutInputsInput, solutionsUncheckedCreateWithoutInputsInput> | solutionsCreateWithoutInputsInput[] | solutionsUncheckedCreateWithoutInputsInput[]
    connectOrCreate?: solutionsCreateOrConnectWithoutInputsInput | solutionsCreateOrConnectWithoutInputsInput[]
    upsert?: solutionsUpsertWithWhereUniqueWithoutInputsInput | solutionsUpsertWithWhereUniqueWithoutInputsInput[]
    createMany?: solutionsCreateManyInputsInputEnvelope
    set?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    disconnect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    delete?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    connect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    update?: solutionsUpdateWithWhereUniqueWithoutInputsInput | solutionsUpdateWithWhereUniqueWithoutInputsInput[]
    updateMany?: solutionsUpdateManyWithWhereWithoutInputsInput | solutionsUpdateManyWithWhereWithoutInputsInput[]
    deleteMany?: solutionsScalarWhereInput | solutionsScalarWhereInput[]
  }

  export type InputToInputGroupUncheckedUpdateManyWithoutInputsNestedInput = {
    create?: XOR<InputToInputGroupCreateWithoutInputsInput, InputToInputGroupUncheckedCreateWithoutInputsInput> | InputToInputGroupCreateWithoutInputsInput[] | InputToInputGroupUncheckedCreateWithoutInputsInput[]
    connectOrCreate?: InputToInputGroupCreateOrConnectWithoutInputsInput | InputToInputGroupCreateOrConnectWithoutInputsInput[]
    upsert?: InputToInputGroupUpsertWithWhereUniqueWithoutInputsInput | InputToInputGroupUpsertWithWhereUniqueWithoutInputsInput[]
    createMany?: InputToInputGroupCreateManyInputsInputEnvelope
    set?: InputToInputGroupWhereUniqueInput | InputToInputGroupWhereUniqueInput[]
    disconnect?: InputToInputGroupWhereUniqueInput | InputToInputGroupWhereUniqueInput[]
    delete?: InputToInputGroupWhereUniqueInput | InputToInputGroupWhereUniqueInput[]
    connect?: InputToInputGroupWhereUniqueInput | InputToInputGroupWhereUniqueInput[]
    update?: InputToInputGroupUpdateWithWhereUniqueWithoutInputsInput | InputToInputGroupUpdateWithWhereUniqueWithoutInputsInput[]
    updateMany?: InputToInputGroupUpdateManyWithWhereWithoutInputsInput | InputToInputGroupUpdateManyWithWhereWithoutInputsInput[]
    deleteMany?: InputToInputGroupScalarWhereInput | InputToInputGroupScalarWhereInput[]
  }

  export type solutionsUncheckedUpdateManyWithoutInputsNestedInput = {
    create?: XOR<solutionsCreateWithoutInputsInput, solutionsUncheckedCreateWithoutInputsInput> | solutionsCreateWithoutInputsInput[] | solutionsUncheckedCreateWithoutInputsInput[]
    connectOrCreate?: solutionsCreateOrConnectWithoutInputsInput | solutionsCreateOrConnectWithoutInputsInput[]
    upsert?: solutionsUpsertWithWhereUniqueWithoutInputsInput | solutionsUpsertWithWhereUniqueWithoutInputsInput[]
    createMany?: solutionsCreateManyInputsInputEnvelope
    set?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    disconnect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    delete?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    connect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    update?: solutionsUpdateWithWhereUniqueWithoutInputsInput | solutionsUpdateWithWhereUniqueWithoutInputsInput[]
    updateMany?: solutionsUpdateManyWithWhereWithoutInputsInput | solutionsUpdateManyWithWhereWithoutInputsInput[]
    deleteMany?: solutionsScalarWhereInput | solutionsScalarWhereInput[]
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type NullableEnumEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.EntityType | null
  }

  export type usersCreateNestedOneWithoutRequirementsInput = {
    create?: XOR<usersCreateWithoutRequirementsInput, usersUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: usersCreateOrConnectWithoutRequirementsInput
    connect?: usersWhereUniqueInput
  }

  export type solutionsCreateNestedOneWithoutRequirementsInput = {
    create?: XOR<solutionsCreateWithoutRequirementsInput, solutionsUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: solutionsCreateOrConnectWithoutRequirementsInput
    connect?: solutionsWhereUniqueInput
  }

  export type EnumRequirementStatusFieldUpdateOperationsInput = {
    set?: $Enums.RequirementStatus
  }

  export type usersUpdateOneRequiredWithoutRequirementsNestedInput = {
    create?: XOR<usersCreateWithoutRequirementsInput, usersUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: usersCreateOrConnectWithoutRequirementsInput
    upsert?: usersUpsertWithoutRequirementsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutRequirementsInput, usersUpdateWithoutRequirementsInput>, usersUncheckedUpdateWithoutRequirementsInput>
  }

  export type solutionsUpdateOneRequiredWithoutRequirementsNestedInput = {
    create?: XOR<solutionsCreateWithoutRequirementsInput, solutionsUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: solutionsCreateOrConnectWithoutRequirementsInput
    upsert?: solutionsUpsertWithoutRequirementsInput
    connect?: solutionsWhereUniqueInput
    update?: XOR<XOR<solutionsUpdateToOneWithWhereWithoutRequirementsInput, solutionsUpdateWithoutRequirementsInput>, solutionsUncheckedUpdateWithoutRequirementsInput>
  }

  export type ai_insight_overridesCreateNestedManyWithoutSignalsInput = {
    create?: XOR<ai_insight_overridesCreateWithoutSignalsInput, ai_insight_overridesUncheckedCreateWithoutSignalsInput> | ai_insight_overridesCreateWithoutSignalsInput[] | ai_insight_overridesUncheckedCreateWithoutSignalsInput[]
    connectOrCreate?: ai_insight_overridesCreateOrConnectWithoutSignalsInput | ai_insight_overridesCreateOrConnectWithoutSignalsInput[]
    createMany?: ai_insight_overridesCreateManySignalsInputEnvelope
    connect?: ai_insight_overridesWhereUniqueInput | ai_insight_overridesWhereUniqueInput[]
  }

  export type hotspot_signalsCreateNestedManyWithoutSignalsInput = {
    create?: XOR<hotspot_signalsCreateWithoutSignalsInput, hotspot_signalsUncheckedCreateWithoutSignalsInput> | hotspot_signalsCreateWithoutSignalsInput[] | hotspot_signalsUncheckedCreateWithoutSignalsInput[]
    connectOrCreate?: hotspot_signalsCreateOrConnectWithoutSignalsInput | hotspot_signalsCreateOrConnectWithoutSignalsInput[]
    createMany?: hotspot_signalsCreateManySignalsInputEnvelope
    connect?: hotspot_signalsWhereUniqueInput | hotspot_signalsWhereUniqueInput[]
  }

  export type categoriesCreateNestedOneWithoutSignalsInput = {
    create?: XOR<categoriesCreateWithoutSignalsInput, categoriesUncheckedCreateWithoutSignalsInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutSignalsInput
    connect?: categoriesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutSignalsInput = {
    create?: XOR<usersCreateWithoutSignalsInput, usersUncheckedCreateWithoutSignalsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSignalsInput
    connect?: usersWhereUniqueInput
  }

  export type departmentsCreateNestedOneWithoutSignalsInput = {
    create?: XOR<departmentsCreateWithoutSignalsInput, departmentsUncheckedCreateWithoutSignalsInput>
    connectOrCreate?: departmentsCreateOrConnectWithoutSignalsInput
    connect?: departmentsWhereUniqueInput
  }

  export type teamsCreateNestedOneWithoutSignalsInput = {
    create?: XOR<teamsCreateWithoutSignalsInput, teamsUncheckedCreateWithoutSignalsInput>
    connectOrCreate?: teamsCreateOrConnectWithoutSignalsInput
    connect?: teamsWhereUniqueInput
  }

  export type ai_insight_overridesUncheckedCreateNestedManyWithoutSignalsInput = {
    create?: XOR<ai_insight_overridesCreateWithoutSignalsInput, ai_insight_overridesUncheckedCreateWithoutSignalsInput> | ai_insight_overridesCreateWithoutSignalsInput[] | ai_insight_overridesUncheckedCreateWithoutSignalsInput[]
    connectOrCreate?: ai_insight_overridesCreateOrConnectWithoutSignalsInput | ai_insight_overridesCreateOrConnectWithoutSignalsInput[]
    createMany?: ai_insight_overridesCreateManySignalsInputEnvelope
    connect?: ai_insight_overridesWhereUniqueInput | ai_insight_overridesWhereUniqueInput[]
  }

  export type hotspot_signalsUncheckedCreateNestedManyWithoutSignalsInput = {
    create?: XOR<hotspot_signalsCreateWithoutSignalsInput, hotspot_signalsUncheckedCreateWithoutSignalsInput> | hotspot_signalsCreateWithoutSignalsInput[] | hotspot_signalsUncheckedCreateWithoutSignalsInput[]
    connectOrCreate?: hotspot_signalsCreateOrConnectWithoutSignalsInput | hotspot_signalsCreateOrConnectWithoutSignalsInput[]
    createMany?: hotspot_signalsCreateManySignalsInputEnvelope
    connect?: hotspot_signalsWhereUniqueInput | hotspot_signalsWhereUniqueInput[]
  }

  export type EnumSeverityFieldUpdateOperationsInput = {
    set?: $Enums.Severity
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Uint8Array | null
  }

  export type ai_insight_overridesUpdateManyWithoutSignalsNestedInput = {
    create?: XOR<ai_insight_overridesCreateWithoutSignalsInput, ai_insight_overridesUncheckedCreateWithoutSignalsInput> | ai_insight_overridesCreateWithoutSignalsInput[] | ai_insight_overridesUncheckedCreateWithoutSignalsInput[]
    connectOrCreate?: ai_insight_overridesCreateOrConnectWithoutSignalsInput | ai_insight_overridesCreateOrConnectWithoutSignalsInput[]
    upsert?: ai_insight_overridesUpsertWithWhereUniqueWithoutSignalsInput | ai_insight_overridesUpsertWithWhereUniqueWithoutSignalsInput[]
    createMany?: ai_insight_overridesCreateManySignalsInputEnvelope
    set?: ai_insight_overridesWhereUniqueInput | ai_insight_overridesWhereUniqueInput[]
    disconnect?: ai_insight_overridesWhereUniqueInput | ai_insight_overridesWhereUniqueInput[]
    delete?: ai_insight_overridesWhereUniqueInput | ai_insight_overridesWhereUniqueInput[]
    connect?: ai_insight_overridesWhereUniqueInput | ai_insight_overridesWhereUniqueInput[]
    update?: ai_insight_overridesUpdateWithWhereUniqueWithoutSignalsInput | ai_insight_overridesUpdateWithWhereUniqueWithoutSignalsInput[]
    updateMany?: ai_insight_overridesUpdateManyWithWhereWithoutSignalsInput | ai_insight_overridesUpdateManyWithWhereWithoutSignalsInput[]
    deleteMany?: ai_insight_overridesScalarWhereInput | ai_insight_overridesScalarWhereInput[]
  }

  export type hotspot_signalsUpdateManyWithoutSignalsNestedInput = {
    create?: XOR<hotspot_signalsCreateWithoutSignalsInput, hotspot_signalsUncheckedCreateWithoutSignalsInput> | hotspot_signalsCreateWithoutSignalsInput[] | hotspot_signalsUncheckedCreateWithoutSignalsInput[]
    connectOrCreate?: hotspot_signalsCreateOrConnectWithoutSignalsInput | hotspot_signalsCreateOrConnectWithoutSignalsInput[]
    upsert?: hotspot_signalsUpsertWithWhereUniqueWithoutSignalsInput | hotspot_signalsUpsertWithWhereUniqueWithoutSignalsInput[]
    createMany?: hotspot_signalsCreateManySignalsInputEnvelope
    set?: hotspot_signalsWhereUniqueInput | hotspot_signalsWhereUniqueInput[]
    disconnect?: hotspot_signalsWhereUniqueInput | hotspot_signalsWhereUniqueInput[]
    delete?: hotspot_signalsWhereUniqueInput | hotspot_signalsWhereUniqueInput[]
    connect?: hotspot_signalsWhereUniqueInput | hotspot_signalsWhereUniqueInput[]
    update?: hotspot_signalsUpdateWithWhereUniqueWithoutSignalsInput | hotspot_signalsUpdateWithWhereUniqueWithoutSignalsInput[]
    updateMany?: hotspot_signalsUpdateManyWithWhereWithoutSignalsInput | hotspot_signalsUpdateManyWithWhereWithoutSignalsInput[]
    deleteMany?: hotspot_signalsScalarWhereInput | hotspot_signalsScalarWhereInput[]
  }

  export type categoriesUpdateOneWithoutSignalsNestedInput = {
    create?: XOR<categoriesCreateWithoutSignalsInput, categoriesUncheckedCreateWithoutSignalsInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutSignalsInput
    upsert?: categoriesUpsertWithoutSignalsInput
    disconnect?: categoriesWhereInput | boolean
    delete?: categoriesWhereInput | boolean
    connect?: categoriesWhereUniqueInput
    update?: XOR<XOR<categoriesUpdateToOneWithWhereWithoutSignalsInput, categoriesUpdateWithoutSignalsInput>, categoriesUncheckedUpdateWithoutSignalsInput>
  }

  export type usersUpdateOneWithoutSignalsNestedInput = {
    create?: XOR<usersCreateWithoutSignalsInput, usersUncheckedCreateWithoutSignalsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSignalsInput
    upsert?: usersUpsertWithoutSignalsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSignalsInput, usersUpdateWithoutSignalsInput>, usersUncheckedUpdateWithoutSignalsInput>
  }

  export type departmentsUpdateOneWithoutSignalsNestedInput = {
    create?: XOR<departmentsCreateWithoutSignalsInput, departmentsUncheckedCreateWithoutSignalsInput>
    connectOrCreate?: departmentsCreateOrConnectWithoutSignalsInput
    upsert?: departmentsUpsertWithoutSignalsInput
    disconnect?: departmentsWhereInput | boolean
    delete?: departmentsWhereInput | boolean
    connect?: departmentsWhereUniqueInput
    update?: XOR<XOR<departmentsUpdateToOneWithWhereWithoutSignalsInput, departmentsUpdateWithoutSignalsInput>, departmentsUncheckedUpdateWithoutSignalsInput>
  }

  export type teamsUpdateOneWithoutSignalsNestedInput = {
    create?: XOR<teamsCreateWithoutSignalsInput, teamsUncheckedCreateWithoutSignalsInput>
    connectOrCreate?: teamsCreateOrConnectWithoutSignalsInput
    upsert?: teamsUpsertWithoutSignalsInput
    disconnect?: teamsWhereInput | boolean
    delete?: teamsWhereInput | boolean
    connect?: teamsWhereUniqueInput
    update?: XOR<XOR<teamsUpdateToOneWithWhereWithoutSignalsInput, teamsUpdateWithoutSignalsInput>, teamsUncheckedUpdateWithoutSignalsInput>
  }

  export type ai_insight_overridesUncheckedUpdateManyWithoutSignalsNestedInput = {
    create?: XOR<ai_insight_overridesCreateWithoutSignalsInput, ai_insight_overridesUncheckedCreateWithoutSignalsInput> | ai_insight_overridesCreateWithoutSignalsInput[] | ai_insight_overridesUncheckedCreateWithoutSignalsInput[]
    connectOrCreate?: ai_insight_overridesCreateOrConnectWithoutSignalsInput | ai_insight_overridesCreateOrConnectWithoutSignalsInput[]
    upsert?: ai_insight_overridesUpsertWithWhereUniqueWithoutSignalsInput | ai_insight_overridesUpsertWithWhereUniqueWithoutSignalsInput[]
    createMany?: ai_insight_overridesCreateManySignalsInputEnvelope
    set?: ai_insight_overridesWhereUniqueInput | ai_insight_overridesWhereUniqueInput[]
    disconnect?: ai_insight_overridesWhereUniqueInput | ai_insight_overridesWhereUniqueInput[]
    delete?: ai_insight_overridesWhereUniqueInput | ai_insight_overridesWhereUniqueInput[]
    connect?: ai_insight_overridesWhereUniqueInput | ai_insight_overridesWhereUniqueInput[]
    update?: ai_insight_overridesUpdateWithWhereUniqueWithoutSignalsInput | ai_insight_overridesUpdateWithWhereUniqueWithoutSignalsInput[]
    updateMany?: ai_insight_overridesUpdateManyWithWhereWithoutSignalsInput | ai_insight_overridesUpdateManyWithWhereWithoutSignalsInput[]
    deleteMany?: ai_insight_overridesScalarWhereInput | ai_insight_overridesScalarWhereInput[]
  }

  export type hotspot_signalsUncheckedUpdateManyWithoutSignalsNestedInput = {
    create?: XOR<hotspot_signalsCreateWithoutSignalsInput, hotspot_signalsUncheckedCreateWithoutSignalsInput> | hotspot_signalsCreateWithoutSignalsInput[] | hotspot_signalsUncheckedCreateWithoutSignalsInput[]
    connectOrCreate?: hotspot_signalsCreateOrConnectWithoutSignalsInput | hotspot_signalsCreateOrConnectWithoutSignalsInput[]
    upsert?: hotspot_signalsUpsertWithWhereUniqueWithoutSignalsInput | hotspot_signalsUpsertWithWhereUniqueWithoutSignalsInput[]
    createMany?: hotspot_signalsCreateManySignalsInputEnvelope
    set?: hotspot_signalsWhereUniqueInput | hotspot_signalsWhereUniqueInput[]
    disconnect?: hotspot_signalsWhereUniqueInput | hotspot_signalsWhereUniqueInput[]
    delete?: hotspot_signalsWhereUniqueInput | hotspot_signalsWhereUniqueInput[]
    connect?: hotspot_signalsWhereUniqueInput | hotspot_signalsWhereUniqueInput[]
    update?: hotspot_signalsUpdateWithWhereUniqueWithoutSignalsInput | hotspot_signalsUpdateWithWhereUniqueWithoutSignalsInput[]
    updateMany?: hotspot_signalsUpdateManyWithWhereWithoutSignalsInput | hotspot_signalsUpdateManyWithWhereWithoutSignalsInput[]
    deleteMany?: hotspot_signalsScalarWhereInput | hotspot_signalsScalarWhereInput[]
  }

  export type frd_documentsCreateNestedManyWithoutSolutionsInput = {
    create?: XOR<frd_documentsCreateWithoutSolutionsInput, frd_documentsUncheckedCreateWithoutSolutionsInput> | frd_documentsCreateWithoutSolutionsInput[] | frd_documentsUncheckedCreateWithoutSolutionsInput[]
    connectOrCreate?: frd_documentsCreateOrConnectWithoutSolutionsInput | frd_documentsCreateOrConnectWithoutSolutionsInput[]
    createMany?: frd_documentsCreateManySolutionsInputEnvelope
    connect?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
  }

  export type requirementsCreateNestedManyWithoutSolutionsInput = {
    create?: XOR<requirementsCreateWithoutSolutionsInput, requirementsUncheckedCreateWithoutSolutionsInput> | requirementsCreateWithoutSolutionsInput[] | requirementsUncheckedCreateWithoutSolutionsInput[]
    connectOrCreate?: requirementsCreateOrConnectWithoutSolutionsInput | requirementsCreateOrConnectWithoutSolutionsInput[]
    createMany?: requirementsCreateManySolutionsInputEnvelope
    connect?: requirementsWhereUniqueInput | requirementsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutSolutionsInput = {
    create?: XOR<usersCreateWithoutSolutionsInput, usersUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSolutionsInput
    connect?: usersWhereUniqueInput
  }

  export type hotspotsCreateNestedOneWithoutSolutionsInput = {
    create?: XOR<hotspotsCreateWithoutSolutionsInput, hotspotsUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: hotspotsCreateOrConnectWithoutSolutionsInput
    connect?: hotspotsWhereUniqueInput
  }

  export type ideasCreateNestedOneWithoutSolutionsInput = {
    create?: XOR<ideasCreateWithoutSolutionsInput, ideasUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: ideasCreateOrConnectWithoutSolutionsInput
    connect?: ideasWhereUniqueInput
  }

  export type initiativesCreateNestedOneWithoutSolutionsInput = {
    create?: XOR<initiativesCreateWithoutSolutionsInput, initiativesUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: initiativesCreateOrConnectWithoutSolutionsInput
    connect?: initiativesWhereUniqueInput
  }

  export type inputsCreateNestedOneWithoutSolutionsInput = {
    create?: XOR<inputsCreateWithoutSolutionsInput, inputsUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: inputsCreateOrConnectWithoutSolutionsInput
    connect?: inputsWhereUniqueInput
  }

  export type frd_documentsUncheckedCreateNestedManyWithoutSolutionsInput = {
    create?: XOR<frd_documentsCreateWithoutSolutionsInput, frd_documentsUncheckedCreateWithoutSolutionsInput> | frd_documentsCreateWithoutSolutionsInput[] | frd_documentsUncheckedCreateWithoutSolutionsInput[]
    connectOrCreate?: frd_documentsCreateOrConnectWithoutSolutionsInput | frd_documentsCreateOrConnectWithoutSolutionsInput[]
    createMany?: frd_documentsCreateManySolutionsInputEnvelope
    connect?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
  }

  export type requirementsUncheckedCreateNestedManyWithoutSolutionsInput = {
    create?: XOR<requirementsCreateWithoutSolutionsInput, requirementsUncheckedCreateWithoutSolutionsInput> | requirementsCreateWithoutSolutionsInput[] | requirementsUncheckedCreateWithoutSolutionsInput[]
    connectOrCreate?: requirementsCreateOrConnectWithoutSolutionsInput | requirementsCreateOrConnectWithoutSolutionsInput[]
    createMany?: requirementsCreateManySolutionsInputEnvelope
    connect?: requirementsWhereUniqueInput | requirementsWhereUniqueInput[]
  }

  export type EnumSolutionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SolutionStatus
  }

  export type frd_documentsUpdateManyWithoutSolutionsNestedInput = {
    create?: XOR<frd_documentsCreateWithoutSolutionsInput, frd_documentsUncheckedCreateWithoutSolutionsInput> | frd_documentsCreateWithoutSolutionsInput[] | frd_documentsUncheckedCreateWithoutSolutionsInput[]
    connectOrCreate?: frd_documentsCreateOrConnectWithoutSolutionsInput | frd_documentsCreateOrConnectWithoutSolutionsInput[]
    upsert?: frd_documentsUpsertWithWhereUniqueWithoutSolutionsInput | frd_documentsUpsertWithWhereUniqueWithoutSolutionsInput[]
    createMany?: frd_documentsCreateManySolutionsInputEnvelope
    set?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    disconnect?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    delete?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    connect?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    update?: frd_documentsUpdateWithWhereUniqueWithoutSolutionsInput | frd_documentsUpdateWithWhereUniqueWithoutSolutionsInput[]
    updateMany?: frd_documentsUpdateManyWithWhereWithoutSolutionsInput | frd_documentsUpdateManyWithWhereWithoutSolutionsInput[]
    deleteMany?: frd_documentsScalarWhereInput | frd_documentsScalarWhereInput[]
  }

  export type requirementsUpdateManyWithoutSolutionsNestedInput = {
    create?: XOR<requirementsCreateWithoutSolutionsInput, requirementsUncheckedCreateWithoutSolutionsInput> | requirementsCreateWithoutSolutionsInput[] | requirementsUncheckedCreateWithoutSolutionsInput[]
    connectOrCreate?: requirementsCreateOrConnectWithoutSolutionsInput | requirementsCreateOrConnectWithoutSolutionsInput[]
    upsert?: requirementsUpsertWithWhereUniqueWithoutSolutionsInput | requirementsUpsertWithWhereUniqueWithoutSolutionsInput[]
    createMany?: requirementsCreateManySolutionsInputEnvelope
    set?: requirementsWhereUniqueInput | requirementsWhereUniqueInput[]
    disconnect?: requirementsWhereUniqueInput | requirementsWhereUniqueInput[]
    delete?: requirementsWhereUniqueInput | requirementsWhereUniqueInput[]
    connect?: requirementsWhereUniqueInput | requirementsWhereUniqueInput[]
    update?: requirementsUpdateWithWhereUniqueWithoutSolutionsInput | requirementsUpdateWithWhereUniqueWithoutSolutionsInput[]
    updateMany?: requirementsUpdateManyWithWhereWithoutSolutionsInput | requirementsUpdateManyWithWhereWithoutSolutionsInput[]
    deleteMany?: requirementsScalarWhereInput | requirementsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutSolutionsNestedInput = {
    create?: XOR<usersCreateWithoutSolutionsInput, usersUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSolutionsInput
    upsert?: usersUpsertWithoutSolutionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSolutionsInput, usersUpdateWithoutSolutionsInput>, usersUncheckedUpdateWithoutSolutionsInput>
  }

  export type hotspotsUpdateOneWithoutSolutionsNestedInput = {
    create?: XOR<hotspotsCreateWithoutSolutionsInput, hotspotsUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: hotspotsCreateOrConnectWithoutSolutionsInput
    upsert?: hotspotsUpsertWithoutSolutionsInput
    disconnect?: hotspotsWhereInput | boolean
    delete?: hotspotsWhereInput | boolean
    connect?: hotspotsWhereUniqueInput
    update?: XOR<XOR<hotspotsUpdateToOneWithWhereWithoutSolutionsInput, hotspotsUpdateWithoutSolutionsInput>, hotspotsUncheckedUpdateWithoutSolutionsInput>
  }

  export type ideasUpdateOneWithoutSolutionsNestedInput = {
    create?: XOR<ideasCreateWithoutSolutionsInput, ideasUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: ideasCreateOrConnectWithoutSolutionsInput
    upsert?: ideasUpsertWithoutSolutionsInput
    disconnect?: ideasWhereInput | boolean
    delete?: ideasWhereInput | boolean
    connect?: ideasWhereUniqueInput
    update?: XOR<XOR<ideasUpdateToOneWithWhereWithoutSolutionsInput, ideasUpdateWithoutSolutionsInput>, ideasUncheckedUpdateWithoutSolutionsInput>
  }

  export type initiativesUpdateOneWithoutSolutionsNestedInput = {
    create?: XOR<initiativesCreateWithoutSolutionsInput, initiativesUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: initiativesCreateOrConnectWithoutSolutionsInput
    upsert?: initiativesUpsertWithoutSolutionsInput
    disconnect?: initiativesWhereInput | boolean
    delete?: initiativesWhereInput | boolean
    connect?: initiativesWhereUniqueInput
    update?: XOR<XOR<initiativesUpdateToOneWithWhereWithoutSolutionsInput, initiativesUpdateWithoutSolutionsInput>, initiativesUncheckedUpdateWithoutSolutionsInput>
  }

  export type inputsUpdateOneWithoutSolutionsNestedInput = {
    create?: XOR<inputsCreateWithoutSolutionsInput, inputsUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: inputsCreateOrConnectWithoutSolutionsInput
    upsert?: inputsUpsertWithoutSolutionsInput
    disconnect?: inputsWhereInput | boolean
    delete?: inputsWhereInput | boolean
    connect?: inputsWhereUniqueInput
    update?: XOR<XOR<inputsUpdateToOneWithWhereWithoutSolutionsInput, inputsUpdateWithoutSolutionsInput>, inputsUncheckedUpdateWithoutSolutionsInput>
  }

  export type frd_documentsUncheckedUpdateManyWithoutSolutionsNestedInput = {
    create?: XOR<frd_documentsCreateWithoutSolutionsInput, frd_documentsUncheckedCreateWithoutSolutionsInput> | frd_documentsCreateWithoutSolutionsInput[] | frd_documentsUncheckedCreateWithoutSolutionsInput[]
    connectOrCreate?: frd_documentsCreateOrConnectWithoutSolutionsInput | frd_documentsCreateOrConnectWithoutSolutionsInput[]
    upsert?: frd_documentsUpsertWithWhereUniqueWithoutSolutionsInput | frd_documentsUpsertWithWhereUniqueWithoutSolutionsInput[]
    createMany?: frd_documentsCreateManySolutionsInputEnvelope
    set?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    disconnect?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    delete?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    connect?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    update?: frd_documentsUpdateWithWhereUniqueWithoutSolutionsInput | frd_documentsUpdateWithWhereUniqueWithoutSolutionsInput[]
    updateMany?: frd_documentsUpdateManyWithWhereWithoutSolutionsInput | frd_documentsUpdateManyWithWhereWithoutSolutionsInput[]
    deleteMany?: frd_documentsScalarWhereInput | frd_documentsScalarWhereInput[]
  }

  export type requirementsUncheckedUpdateManyWithoutSolutionsNestedInput = {
    create?: XOR<requirementsCreateWithoutSolutionsInput, requirementsUncheckedCreateWithoutSolutionsInput> | requirementsCreateWithoutSolutionsInput[] | requirementsUncheckedCreateWithoutSolutionsInput[]
    connectOrCreate?: requirementsCreateOrConnectWithoutSolutionsInput | requirementsCreateOrConnectWithoutSolutionsInput[]
    upsert?: requirementsUpsertWithWhereUniqueWithoutSolutionsInput | requirementsUpsertWithWhereUniqueWithoutSolutionsInput[]
    createMany?: requirementsCreateManySolutionsInputEnvelope
    set?: requirementsWhereUniqueInput | requirementsWhereUniqueInput[]
    disconnect?: requirementsWhereUniqueInput | requirementsWhereUniqueInput[]
    delete?: requirementsWhereUniqueInput | requirementsWhereUniqueInput[]
    connect?: requirementsWhereUniqueInput | requirementsWhereUniqueInput[]
    update?: requirementsUpdateWithWhereUniqueWithoutSolutionsInput | requirementsUpdateWithWhereUniqueWithoutSolutionsInput[]
    updateMany?: requirementsUpdateManyWithWhereWithoutSolutionsInput | requirementsUpdateManyWithWhereWithoutSolutionsInput[]
    deleteMany?: requirementsScalarWhereInput | requirementsScalarWhereInput[]
  }

  export type signalsCreateNestedManyWithoutTeamsInput = {
    create?: XOR<signalsCreateWithoutTeamsInput, signalsUncheckedCreateWithoutTeamsInput> | signalsCreateWithoutTeamsInput[] | signalsUncheckedCreateWithoutTeamsInput[]
    connectOrCreate?: signalsCreateOrConnectWithoutTeamsInput | signalsCreateOrConnectWithoutTeamsInput[]
    createMany?: signalsCreateManyTeamsInputEnvelope
    connect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
  }

  export type departmentsCreateNestedOneWithoutTeamsInput = {
    create?: XOR<departmentsCreateWithoutTeamsInput, departmentsUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: departmentsCreateOrConnectWithoutTeamsInput
    connect?: departmentsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutTeams_teams_leaderIdTousersInput = {
    create?: XOR<usersCreateWithoutTeams_teams_leaderIdTousersInput, usersUncheckedCreateWithoutTeams_teams_leaderIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutTeams_teams_leaderIdTousersInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedManyWithoutTeams_TeamMembersInput = {
    create?: XOR<usersCreateWithoutTeams_TeamMembersInput, usersUncheckedCreateWithoutTeams_TeamMembersInput> | usersCreateWithoutTeams_TeamMembersInput[] | usersUncheckedCreateWithoutTeams_TeamMembersInput[]
    connectOrCreate?: usersCreateOrConnectWithoutTeams_TeamMembersInput | usersCreateOrConnectWithoutTeams_TeamMembersInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type signalsUncheckedCreateNestedManyWithoutTeamsInput = {
    create?: XOR<signalsCreateWithoutTeamsInput, signalsUncheckedCreateWithoutTeamsInput> | signalsCreateWithoutTeamsInput[] | signalsUncheckedCreateWithoutTeamsInput[]
    connectOrCreate?: signalsCreateOrConnectWithoutTeamsInput | signalsCreateOrConnectWithoutTeamsInput[]
    createMany?: signalsCreateManyTeamsInputEnvelope
    connect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutTeams_TeamMembersInput = {
    create?: XOR<usersCreateWithoutTeams_TeamMembersInput, usersUncheckedCreateWithoutTeams_TeamMembersInput> | usersCreateWithoutTeams_TeamMembersInput[] | usersUncheckedCreateWithoutTeams_TeamMembersInput[]
    connectOrCreate?: usersCreateOrConnectWithoutTeams_TeamMembersInput | usersCreateOrConnectWithoutTeams_TeamMembersInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type signalsUpdateManyWithoutTeamsNestedInput = {
    create?: XOR<signalsCreateWithoutTeamsInput, signalsUncheckedCreateWithoutTeamsInput> | signalsCreateWithoutTeamsInput[] | signalsUncheckedCreateWithoutTeamsInput[]
    connectOrCreate?: signalsCreateOrConnectWithoutTeamsInput | signalsCreateOrConnectWithoutTeamsInput[]
    upsert?: signalsUpsertWithWhereUniqueWithoutTeamsInput | signalsUpsertWithWhereUniqueWithoutTeamsInput[]
    createMany?: signalsCreateManyTeamsInputEnvelope
    set?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    disconnect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    delete?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    connect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    update?: signalsUpdateWithWhereUniqueWithoutTeamsInput | signalsUpdateWithWhereUniqueWithoutTeamsInput[]
    updateMany?: signalsUpdateManyWithWhereWithoutTeamsInput | signalsUpdateManyWithWhereWithoutTeamsInput[]
    deleteMany?: signalsScalarWhereInput | signalsScalarWhereInput[]
  }

  export type departmentsUpdateOneWithoutTeamsNestedInput = {
    create?: XOR<departmentsCreateWithoutTeamsInput, departmentsUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: departmentsCreateOrConnectWithoutTeamsInput
    upsert?: departmentsUpsertWithoutTeamsInput
    disconnect?: departmentsWhereInput | boolean
    delete?: departmentsWhereInput | boolean
    connect?: departmentsWhereUniqueInput
    update?: XOR<XOR<departmentsUpdateToOneWithWhereWithoutTeamsInput, departmentsUpdateWithoutTeamsInput>, departmentsUncheckedUpdateWithoutTeamsInput>
  }

  export type usersUpdateOneWithoutTeams_teams_leaderIdTousersNestedInput = {
    create?: XOR<usersCreateWithoutTeams_teams_leaderIdTousersInput, usersUncheckedCreateWithoutTeams_teams_leaderIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutTeams_teams_leaderIdTousersInput
    upsert?: usersUpsertWithoutTeams_teams_leaderIdTousersInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTeams_teams_leaderIdTousersInput, usersUpdateWithoutTeams_teams_leaderIdTousersInput>, usersUncheckedUpdateWithoutTeams_teams_leaderIdTousersInput>
  }

  export type usersUpdateManyWithoutTeams_TeamMembersNestedInput = {
    create?: XOR<usersCreateWithoutTeams_TeamMembersInput, usersUncheckedCreateWithoutTeams_TeamMembersInput> | usersCreateWithoutTeams_TeamMembersInput[] | usersUncheckedCreateWithoutTeams_TeamMembersInput[]
    connectOrCreate?: usersCreateOrConnectWithoutTeams_TeamMembersInput | usersCreateOrConnectWithoutTeams_TeamMembersInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutTeams_TeamMembersInput | usersUpsertWithWhereUniqueWithoutTeams_TeamMembersInput[]
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutTeams_TeamMembersInput | usersUpdateWithWhereUniqueWithoutTeams_TeamMembersInput[]
    updateMany?: usersUpdateManyWithWhereWithoutTeams_TeamMembersInput | usersUpdateManyWithWhereWithoutTeams_TeamMembersInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type signalsUncheckedUpdateManyWithoutTeamsNestedInput = {
    create?: XOR<signalsCreateWithoutTeamsInput, signalsUncheckedCreateWithoutTeamsInput> | signalsCreateWithoutTeamsInput[] | signalsUncheckedCreateWithoutTeamsInput[]
    connectOrCreate?: signalsCreateOrConnectWithoutTeamsInput | signalsCreateOrConnectWithoutTeamsInput[]
    upsert?: signalsUpsertWithWhereUniqueWithoutTeamsInput | signalsUpsertWithWhereUniqueWithoutTeamsInput[]
    createMany?: signalsCreateManyTeamsInputEnvelope
    set?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    disconnect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    delete?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    connect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    update?: signalsUpdateWithWhereUniqueWithoutTeamsInput | signalsUpdateWithWhereUniqueWithoutTeamsInput[]
    updateMany?: signalsUpdateManyWithWhereWithoutTeamsInput | signalsUpdateManyWithWhereWithoutTeamsInput[]
    deleteMany?: signalsScalarWhereInput | signalsScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutTeams_TeamMembersNestedInput = {
    create?: XOR<usersCreateWithoutTeams_TeamMembersInput, usersUncheckedCreateWithoutTeams_TeamMembersInput> | usersCreateWithoutTeams_TeamMembersInput[] | usersUncheckedCreateWithoutTeams_TeamMembersInput[]
    connectOrCreate?: usersCreateOrConnectWithoutTeams_TeamMembersInput | usersCreateOrConnectWithoutTeams_TeamMembersInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutTeams_TeamMembersInput | usersUpsertWithWhereUniqueWithoutTeams_TeamMembersInput[]
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutTeams_TeamMembersInput | usersUpdateWithWhereUniqueWithoutTeams_TeamMembersInput[]
    updateMany?: usersUpdateManyWithWhereWithoutTeams_TeamMembersInput | usersUpdateManyWithWhereWithoutTeams_TeamMembersInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type ai_analysis_auditCreateNestedManyWithoutUsersInput = {
    create?: XOR<ai_analysis_auditCreateWithoutUsersInput, ai_analysis_auditUncheckedCreateWithoutUsersInput> | ai_analysis_auditCreateWithoutUsersInput[] | ai_analysis_auditUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_analysis_auditCreateOrConnectWithoutUsersInput | ai_analysis_auditCreateOrConnectWithoutUsersInput[]
    createMany?: ai_analysis_auditCreateManyUsersInputEnvelope
    connect?: ai_analysis_auditWhereUniqueInput | ai_analysis_auditWhereUniqueInput[]
  }

  export type ai_insight_overridesCreateNestedManyWithoutUsersInput = {
    create?: XOR<ai_insight_overridesCreateWithoutUsersInput, ai_insight_overridesUncheckedCreateWithoutUsersInput> | ai_insight_overridesCreateWithoutUsersInput[] | ai_insight_overridesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_insight_overridesCreateOrConnectWithoutUsersInput | ai_insight_overridesCreateOrConnectWithoutUsersInput[]
    createMany?: ai_insight_overridesCreateManyUsersInputEnvelope
    connect?: ai_insight_overridesWhereUniqueInput | ai_insight_overridesWhereUniqueInput[]
  }

  export type audit_logsCreateNestedManyWithoutUsersInput = {
    create?: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput> | audit_logsCreateWithoutUsersInput[] | audit_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: audit_logsCreateOrConnectWithoutUsersInput | audit_logsCreateOrConnectWithoutUsersInput[]
    createMany?: audit_logsCreateManyUsersInputEnvelope
    connect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
  }

  export type commentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput> | commentsCreateWithoutUsersInput[] | commentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutUsersInput | commentsCreateOrConnectWithoutUsersInput[]
    createMany?: commentsCreateManyUsersInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type departmentsCreateNestedManyWithoutUsers_departments_managerIdTousersInput = {
    create?: XOR<departmentsCreateWithoutUsers_departments_managerIdTousersInput, departmentsUncheckedCreateWithoutUsers_departments_managerIdTousersInput> | departmentsCreateWithoutUsers_departments_managerIdTousersInput[] | departmentsUncheckedCreateWithoutUsers_departments_managerIdTousersInput[]
    connectOrCreate?: departmentsCreateOrConnectWithoutUsers_departments_managerIdTousersInput | departmentsCreateOrConnectWithoutUsers_departments_managerIdTousersInput[]
    createMany?: departmentsCreateManyUsers_departments_managerIdTousersInputEnvelope
    connect?: departmentsWhereUniqueInput | departmentsWhereUniqueInput[]
  }

  export type frd_documentsCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput = {
    create?: XOR<frd_documentsCreateWithoutUsers_frd_documents_approvedByTousersInput, frd_documentsUncheckedCreateWithoutUsers_frd_documents_approvedByTousersInput> | frd_documentsCreateWithoutUsers_frd_documents_approvedByTousersInput[] | frd_documentsUncheckedCreateWithoutUsers_frd_documents_approvedByTousersInput[]
    connectOrCreate?: frd_documentsCreateOrConnectWithoutUsers_frd_documents_approvedByTousersInput | frd_documentsCreateOrConnectWithoutUsers_frd_documents_approvedByTousersInput[]
    createMany?: frd_documentsCreateManyUsers_frd_documents_approvedByTousersInputEnvelope
    connect?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
  }

  export type frd_documentsCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput = {
    create?: XOR<frd_documentsCreateWithoutUsers_frd_documents_createdByTousersInput, frd_documentsUncheckedCreateWithoutUsers_frd_documents_createdByTousersInput> | frd_documentsCreateWithoutUsers_frd_documents_createdByTousersInput[] | frd_documentsUncheckedCreateWithoutUsers_frd_documents_createdByTousersInput[]
    connectOrCreate?: frd_documentsCreateOrConnectWithoutUsers_frd_documents_createdByTousersInput | frd_documentsCreateOrConnectWithoutUsers_frd_documents_createdByTousersInput[]
    createMany?: frd_documentsCreateManyUsers_frd_documents_createdByTousersInputEnvelope
    connect?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
  }

  export type ideasCreateNestedManyWithoutUsersInput = {
    create?: XOR<ideasCreateWithoutUsersInput, ideasUncheckedCreateWithoutUsersInput> | ideasCreateWithoutUsersInput[] | ideasUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ideasCreateOrConnectWithoutUsersInput | ideasCreateOrConnectWithoutUsersInput[]
    createMany?: ideasCreateManyUsersInputEnvelope
    connect?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
  }

  export type initiativesCreateNestedManyWithoutUsersInput = {
    create?: XOR<initiativesCreateWithoutUsersInput, initiativesUncheckedCreateWithoutUsersInput> | initiativesCreateWithoutUsersInput[] | initiativesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: initiativesCreateOrConnectWithoutUsersInput | initiativesCreateOrConnectWithoutUsersInput[]
    createMany?: initiativesCreateManyUsersInputEnvelope
    connect?: initiativesWhereUniqueInput | initiativesWhereUniqueInput[]
  }

  export type input_groupsCreateNestedManyWithoutUsersInput = {
    create?: XOR<input_groupsCreateWithoutUsersInput, input_groupsUncheckedCreateWithoutUsersInput> | input_groupsCreateWithoutUsersInput[] | input_groupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: input_groupsCreateOrConnectWithoutUsersInput | input_groupsCreateOrConnectWithoutUsersInput[]
    createMany?: input_groupsCreateManyUsersInputEnvelope
    connect?: input_groupsWhereUniqueInput | input_groupsWhereUniqueInput[]
  }

  export type inputsCreateNestedManyWithoutUsersInput = {
    create?: XOR<inputsCreateWithoutUsersInput, inputsUncheckedCreateWithoutUsersInput> | inputsCreateWithoutUsersInput[] | inputsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: inputsCreateOrConnectWithoutUsersInput | inputsCreateOrConnectWithoutUsersInput[]
    createMany?: inputsCreateManyUsersInputEnvelope
    connect?: inputsWhereUniqueInput | inputsWhereUniqueInput[]
  }

  export type requirementsCreateNestedManyWithoutUsersInput = {
    create?: XOR<requirementsCreateWithoutUsersInput, requirementsUncheckedCreateWithoutUsersInput> | requirementsCreateWithoutUsersInput[] | requirementsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: requirementsCreateOrConnectWithoutUsersInput | requirementsCreateOrConnectWithoutUsersInput[]
    createMany?: requirementsCreateManyUsersInputEnvelope
    connect?: requirementsWhereUniqueInput | requirementsWhereUniqueInput[]
  }

  export type signalsCreateNestedManyWithoutUsersInput = {
    create?: XOR<signalsCreateWithoutUsersInput, signalsUncheckedCreateWithoutUsersInput> | signalsCreateWithoutUsersInput[] | signalsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: signalsCreateOrConnectWithoutUsersInput | signalsCreateOrConnectWithoutUsersInput[]
    createMany?: signalsCreateManyUsersInputEnvelope
    connect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
  }

  export type solutionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<solutionsCreateWithoutUsersInput, solutionsUncheckedCreateWithoutUsersInput> | solutionsCreateWithoutUsersInput[] | solutionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: solutionsCreateOrConnectWithoutUsersInput | solutionsCreateOrConnectWithoutUsersInput[]
    createMany?: solutionsCreateManyUsersInputEnvelope
    connect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
  }

  export type teamsCreateNestedManyWithoutUsers_teams_leaderIdTousersInput = {
    create?: XOR<teamsCreateWithoutUsers_teams_leaderIdTousersInput, teamsUncheckedCreateWithoutUsers_teams_leaderIdTousersInput> | teamsCreateWithoutUsers_teams_leaderIdTousersInput[] | teamsUncheckedCreateWithoutUsers_teams_leaderIdTousersInput[]
    connectOrCreate?: teamsCreateOrConnectWithoutUsers_teams_leaderIdTousersInput | teamsCreateOrConnectWithoutUsers_teams_leaderIdTousersInput[]
    createMany?: teamsCreateManyUsers_teams_leaderIdTousersInputEnvelope
    connect?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
  }

  export type departmentsCreateNestedOneWithoutUsers_users_departmentObjIdTodepartmentsInput = {
    create?: XOR<departmentsCreateWithoutUsers_users_departmentObjIdTodepartmentsInput, departmentsUncheckedCreateWithoutUsers_users_departmentObjIdTodepartmentsInput>
    connectOrCreate?: departmentsCreateOrConnectWithoutUsers_users_departmentObjIdTodepartmentsInput
    connect?: departmentsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutOther_usersInput = {
    create?: XOR<usersCreateWithoutOther_usersInput, usersUncheckedCreateWithoutOther_usersInput>
    connectOrCreate?: usersCreateOrConnectWithoutOther_usersInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedManyWithoutUsersInput = {
    create?: XOR<usersCreateWithoutUsersInput, usersUncheckedCreateWithoutUsersInput> | usersCreateWithoutUsersInput[] | usersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: usersCreateOrConnectWithoutUsersInput | usersCreateOrConnectWithoutUsersInput[]
    createMany?: usersCreateManyUsersInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type votesCreateNestedManyWithoutUsersInput = {
    create?: XOR<votesCreateWithoutUsersInput, votesUncheckedCreateWithoutUsersInput> | votesCreateWithoutUsersInput[] | votesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: votesCreateOrConnectWithoutUsersInput | votesCreateOrConnectWithoutUsersInput[]
    createMany?: votesCreateManyUsersInputEnvelope
    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]
  }

  export type teamsCreateNestedManyWithoutUsers_TeamMembersInput = {
    create?: XOR<teamsCreateWithoutUsers_TeamMembersInput, teamsUncheckedCreateWithoutUsers_TeamMembersInput> | teamsCreateWithoutUsers_TeamMembersInput[] | teamsUncheckedCreateWithoutUsers_TeamMembersInput[]
    connectOrCreate?: teamsCreateOrConnectWithoutUsers_TeamMembersInput | teamsCreateOrConnectWithoutUsers_TeamMembersInput[]
    connect?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
  }

  export type ai_analysis_auditUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ai_analysis_auditCreateWithoutUsersInput, ai_analysis_auditUncheckedCreateWithoutUsersInput> | ai_analysis_auditCreateWithoutUsersInput[] | ai_analysis_auditUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_analysis_auditCreateOrConnectWithoutUsersInput | ai_analysis_auditCreateOrConnectWithoutUsersInput[]
    createMany?: ai_analysis_auditCreateManyUsersInputEnvelope
    connect?: ai_analysis_auditWhereUniqueInput | ai_analysis_auditWhereUniqueInput[]
  }

  export type ai_insight_overridesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ai_insight_overridesCreateWithoutUsersInput, ai_insight_overridesUncheckedCreateWithoutUsersInput> | ai_insight_overridesCreateWithoutUsersInput[] | ai_insight_overridesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_insight_overridesCreateOrConnectWithoutUsersInput | ai_insight_overridesCreateOrConnectWithoutUsersInput[]
    createMany?: ai_insight_overridesCreateManyUsersInputEnvelope
    connect?: ai_insight_overridesWhereUniqueInput | ai_insight_overridesWhereUniqueInput[]
  }

  export type audit_logsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput> | audit_logsCreateWithoutUsersInput[] | audit_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: audit_logsCreateOrConnectWithoutUsersInput | audit_logsCreateOrConnectWithoutUsersInput[]
    createMany?: audit_logsCreateManyUsersInputEnvelope
    connect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
  }

  export type commentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput> | commentsCreateWithoutUsersInput[] | commentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutUsersInput | commentsCreateOrConnectWithoutUsersInput[]
    createMany?: commentsCreateManyUsersInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type departmentsUncheckedCreateNestedManyWithoutUsers_departments_managerIdTousersInput = {
    create?: XOR<departmentsCreateWithoutUsers_departments_managerIdTousersInput, departmentsUncheckedCreateWithoutUsers_departments_managerIdTousersInput> | departmentsCreateWithoutUsers_departments_managerIdTousersInput[] | departmentsUncheckedCreateWithoutUsers_departments_managerIdTousersInput[]
    connectOrCreate?: departmentsCreateOrConnectWithoutUsers_departments_managerIdTousersInput | departmentsCreateOrConnectWithoutUsers_departments_managerIdTousersInput[]
    createMany?: departmentsCreateManyUsers_departments_managerIdTousersInputEnvelope
    connect?: departmentsWhereUniqueInput | departmentsWhereUniqueInput[]
  }

  export type frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput = {
    create?: XOR<frd_documentsCreateWithoutUsers_frd_documents_approvedByTousersInput, frd_documentsUncheckedCreateWithoutUsers_frd_documents_approvedByTousersInput> | frd_documentsCreateWithoutUsers_frd_documents_approvedByTousersInput[] | frd_documentsUncheckedCreateWithoutUsers_frd_documents_approvedByTousersInput[]
    connectOrCreate?: frd_documentsCreateOrConnectWithoutUsers_frd_documents_approvedByTousersInput | frd_documentsCreateOrConnectWithoutUsers_frd_documents_approvedByTousersInput[]
    createMany?: frd_documentsCreateManyUsers_frd_documents_approvedByTousersInputEnvelope
    connect?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
  }

  export type frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput = {
    create?: XOR<frd_documentsCreateWithoutUsers_frd_documents_createdByTousersInput, frd_documentsUncheckedCreateWithoutUsers_frd_documents_createdByTousersInput> | frd_documentsCreateWithoutUsers_frd_documents_createdByTousersInput[] | frd_documentsUncheckedCreateWithoutUsers_frd_documents_createdByTousersInput[]
    connectOrCreate?: frd_documentsCreateOrConnectWithoutUsers_frd_documents_createdByTousersInput | frd_documentsCreateOrConnectWithoutUsers_frd_documents_createdByTousersInput[]
    createMany?: frd_documentsCreateManyUsers_frd_documents_createdByTousersInputEnvelope
    connect?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
  }

  export type ideasUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ideasCreateWithoutUsersInput, ideasUncheckedCreateWithoutUsersInput> | ideasCreateWithoutUsersInput[] | ideasUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ideasCreateOrConnectWithoutUsersInput | ideasCreateOrConnectWithoutUsersInput[]
    createMany?: ideasCreateManyUsersInputEnvelope
    connect?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
  }

  export type initiativesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<initiativesCreateWithoutUsersInput, initiativesUncheckedCreateWithoutUsersInput> | initiativesCreateWithoutUsersInput[] | initiativesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: initiativesCreateOrConnectWithoutUsersInput | initiativesCreateOrConnectWithoutUsersInput[]
    createMany?: initiativesCreateManyUsersInputEnvelope
    connect?: initiativesWhereUniqueInput | initiativesWhereUniqueInput[]
  }

  export type input_groupsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<input_groupsCreateWithoutUsersInput, input_groupsUncheckedCreateWithoutUsersInput> | input_groupsCreateWithoutUsersInput[] | input_groupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: input_groupsCreateOrConnectWithoutUsersInput | input_groupsCreateOrConnectWithoutUsersInput[]
    createMany?: input_groupsCreateManyUsersInputEnvelope
    connect?: input_groupsWhereUniqueInput | input_groupsWhereUniqueInput[]
  }

  export type inputsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<inputsCreateWithoutUsersInput, inputsUncheckedCreateWithoutUsersInput> | inputsCreateWithoutUsersInput[] | inputsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: inputsCreateOrConnectWithoutUsersInput | inputsCreateOrConnectWithoutUsersInput[]
    createMany?: inputsCreateManyUsersInputEnvelope
    connect?: inputsWhereUniqueInput | inputsWhereUniqueInput[]
  }

  export type requirementsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<requirementsCreateWithoutUsersInput, requirementsUncheckedCreateWithoutUsersInput> | requirementsCreateWithoutUsersInput[] | requirementsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: requirementsCreateOrConnectWithoutUsersInput | requirementsCreateOrConnectWithoutUsersInput[]
    createMany?: requirementsCreateManyUsersInputEnvelope
    connect?: requirementsWhereUniqueInput | requirementsWhereUniqueInput[]
  }

  export type signalsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<signalsCreateWithoutUsersInput, signalsUncheckedCreateWithoutUsersInput> | signalsCreateWithoutUsersInput[] | signalsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: signalsCreateOrConnectWithoutUsersInput | signalsCreateOrConnectWithoutUsersInput[]
    createMany?: signalsCreateManyUsersInputEnvelope
    connect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
  }

  export type solutionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<solutionsCreateWithoutUsersInput, solutionsUncheckedCreateWithoutUsersInput> | solutionsCreateWithoutUsersInput[] | solutionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: solutionsCreateOrConnectWithoutUsersInput | solutionsCreateOrConnectWithoutUsersInput[]
    createMany?: solutionsCreateManyUsersInputEnvelope
    connect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
  }

  export type teamsUncheckedCreateNestedManyWithoutUsers_teams_leaderIdTousersInput = {
    create?: XOR<teamsCreateWithoutUsers_teams_leaderIdTousersInput, teamsUncheckedCreateWithoutUsers_teams_leaderIdTousersInput> | teamsCreateWithoutUsers_teams_leaderIdTousersInput[] | teamsUncheckedCreateWithoutUsers_teams_leaderIdTousersInput[]
    connectOrCreate?: teamsCreateOrConnectWithoutUsers_teams_leaderIdTousersInput | teamsCreateOrConnectWithoutUsers_teams_leaderIdTousersInput[]
    createMany?: teamsCreateManyUsers_teams_leaderIdTousersInputEnvelope
    connect?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<usersCreateWithoutUsersInput, usersUncheckedCreateWithoutUsersInput> | usersCreateWithoutUsersInput[] | usersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: usersCreateOrConnectWithoutUsersInput | usersCreateOrConnectWithoutUsersInput[]
    createMany?: usersCreateManyUsersInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type votesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<votesCreateWithoutUsersInput, votesUncheckedCreateWithoutUsersInput> | votesCreateWithoutUsersInput[] | votesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: votesCreateOrConnectWithoutUsersInput | votesCreateOrConnectWithoutUsersInput[]
    createMany?: votesCreateManyUsersInputEnvelope
    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]
  }

  export type teamsUncheckedCreateNestedManyWithoutUsers_TeamMembersInput = {
    create?: XOR<teamsCreateWithoutUsers_TeamMembersInput, teamsUncheckedCreateWithoutUsers_TeamMembersInput> | teamsCreateWithoutUsers_TeamMembersInput[] | teamsUncheckedCreateWithoutUsers_TeamMembersInput[]
    connectOrCreate?: teamsCreateOrConnectWithoutUsers_TeamMembersInput | teamsCreateOrConnectWithoutUsers_TeamMembersInput[]
    connect?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type ai_analysis_auditUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ai_analysis_auditCreateWithoutUsersInput, ai_analysis_auditUncheckedCreateWithoutUsersInput> | ai_analysis_auditCreateWithoutUsersInput[] | ai_analysis_auditUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_analysis_auditCreateOrConnectWithoutUsersInput | ai_analysis_auditCreateOrConnectWithoutUsersInput[]
    upsert?: ai_analysis_auditUpsertWithWhereUniqueWithoutUsersInput | ai_analysis_auditUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ai_analysis_auditCreateManyUsersInputEnvelope
    set?: ai_analysis_auditWhereUniqueInput | ai_analysis_auditWhereUniqueInput[]
    disconnect?: ai_analysis_auditWhereUniqueInput | ai_analysis_auditWhereUniqueInput[]
    delete?: ai_analysis_auditWhereUniqueInput | ai_analysis_auditWhereUniqueInput[]
    connect?: ai_analysis_auditWhereUniqueInput | ai_analysis_auditWhereUniqueInput[]
    update?: ai_analysis_auditUpdateWithWhereUniqueWithoutUsersInput | ai_analysis_auditUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ai_analysis_auditUpdateManyWithWhereWithoutUsersInput | ai_analysis_auditUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ai_analysis_auditScalarWhereInput | ai_analysis_auditScalarWhereInput[]
  }

  export type ai_insight_overridesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ai_insight_overridesCreateWithoutUsersInput, ai_insight_overridesUncheckedCreateWithoutUsersInput> | ai_insight_overridesCreateWithoutUsersInput[] | ai_insight_overridesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_insight_overridesCreateOrConnectWithoutUsersInput | ai_insight_overridesCreateOrConnectWithoutUsersInput[]
    upsert?: ai_insight_overridesUpsertWithWhereUniqueWithoutUsersInput | ai_insight_overridesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ai_insight_overridesCreateManyUsersInputEnvelope
    set?: ai_insight_overridesWhereUniqueInput | ai_insight_overridesWhereUniqueInput[]
    disconnect?: ai_insight_overridesWhereUniqueInput | ai_insight_overridesWhereUniqueInput[]
    delete?: ai_insight_overridesWhereUniqueInput | ai_insight_overridesWhereUniqueInput[]
    connect?: ai_insight_overridesWhereUniqueInput | ai_insight_overridesWhereUniqueInput[]
    update?: ai_insight_overridesUpdateWithWhereUniqueWithoutUsersInput | ai_insight_overridesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ai_insight_overridesUpdateManyWithWhereWithoutUsersInput | ai_insight_overridesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ai_insight_overridesScalarWhereInput | ai_insight_overridesScalarWhereInput[]
  }

  export type audit_logsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput> | audit_logsCreateWithoutUsersInput[] | audit_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: audit_logsCreateOrConnectWithoutUsersInput | audit_logsCreateOrConnectWithoutUsersInput[]
    upsert?: audit_logsUpsertWithWhereUniqueWithoutUsersInput | audit_logsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: audit_logsCreateManyUsersInputEnvelope
    set?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    disconnect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    delete?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    connect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    update?: audit_logsUpdateWithWhereUniqueWithoutUsersInput | audit_logsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: audit_logsUpdateManyWithWhereWithoutUsersInput | audit_logsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: audit_logsScalarWhereInput | audit_logsScalarWhereInput[]
  }

  export type commentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput> | commentsCreateWithoutUsersInput[] | commentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutUsersInput | commentsCreateOrConnectWithoutUsersInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutUsersInput | commentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: commentsCreateManyUsersInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutUsersInput | commentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutUsersInput | commentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type departmentsUpdateManyWithoutUsers_departments_managerIdTousersNestedInput = {
    create?: XOR<departmentsCreateWithoutUsers_departments_managerIdTousersInput, departmentsUncheckedCreateWithoutUsers_departments_managerIdTousersInput> | departmentsCreateWithoutUsers_departments_managerIdTousersInput[] | departmentsUncheckedCreateWithoutUsers_departments_managerIdTousersInput[]
    connectOrCreate?: departmentsCreateOrConnectWithoutUsers_departments_managerIdTousersInput | departmentsCreateOrConnectWithoutUsers_departments_managerIdTousersInput[]
    upsert?: departmentsUpsertWithWhereUniqueWithoutUsers_departments_managerIdTousersInput | departmentsUpsertWithWhereUniqueWithoutUsers_departments_managerIdTousersInput[]
    createMany?: departmentsCreateManyUsers_departments_managerIdTousersInputEnvelope
    set?: departmentsWhereUniqueInput | departmentsWhereUniqueInput[]
    disconnect?: departmentsWhereUniqueInput | departmentsWhereUniqueInput[]
    delete?: departmentsWhereUniqueInput | departmentsWhereUniqueInput[]
    connect?: departmentsWhereUniqueInput | departmentsWhereUniqueInput[]
    update?: departmentsUpdateWithWhereUniqueWithoutUsers_departments_managerIdTousersInput | departmentsUpdateWithWhereUniqueWithoutUsers_departments_managerIdTousersInput[]
    updateMany?: departmentsUpdateManyWithWhereWithoutUsers_departments_managerIdTousersInput | departmentsUpdateManyWithWhereWithoutUsers_departments_managerIdTousersInput[]
    deleteMany?: departmentsScalarWhereInput | departmentsScalarWhereInput[]
  }

  export type frd_documentsUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput = {
    create?: XOR<frd_documentsCreateWithoutUsers_frd_documents_approvedByTousersInput, frd_documentsUncheckedCreateWithoutUsers_frd_documents_approvedByTousersInput> | frd_documentsCreateWithoutUsers_frd_documents_approvedByTousersInput[] | frd_documentsUncheckedCreateWithoutUsers_frd_documents_approvedByTousersInput[]
    connectOrCreate?: frd_documentsCreateOrConnectWithoutUsers_frd_documents_approvedByTousersInput | frd_documentsCreateOrConnectWithoutUsers_frd_documents_approvedByTousersInput[]
    upsert?: frd_documentsUpsertWithWhereUniqueWithoutUsers_frd_documents_approvedByTousersInput | frd_documentsUpsertWithWhereUniqueWithoutUsers_frd_documents_approvedByTousersInput[]
    createMany?: frd_documentsCreateManyUsers_frd_documents_approvedByTousersInputEnvelope
    set?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    disconnect?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    delete?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    connect?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    update?: frd_documentsUpdateWithWhereUniqueWithoutUsers_frd_documents_approvedByTousersInput | frd_documentsUpdateWithWhereUniqueWithoutUsers_frd_documents_approvedByTousersInput[]
    updateMany?: frd_documentsUpdateManyWithWhereWithoutUsers_frd_documents_approvedByTousersInput | frd_documentsUpdateManyWithWhereWithoutUsers_frd_documents_approvedByTousersInput[]
    deleteMany?: frd_documentsScalarWhereInput | frd_documentsScalarWhereInput[]
  }

  export type frd_documentsUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput = {
    create?: XOR<frd_documentsCreateWithoutUsers_frd_documents_createdByTousersInput, frd_documentsUncheckedCreateWithoutUsers_frd_documents_createdByTousersInput> | frd_documentsCreateWithoutUsers_frd_documents_createdByTousersInput[] | frd_documentsUncheckedCreateWithoutUsers_frd_documents_createdByTousersInput[]
    connectOrCreate?: frd_documentsCreateOrConnectWithoutUsers_frd_documents_createdByTousersInput | frd_documentsCreateOrConnectWithoutUsers_frd_documents_createdByTousersInput[]
    upsert?: frd_documentsUpsertWithWhereUniqueWithoutUsers_frd_documents_createdByTousersInput | frd_documentsUpsertWithWhereUniqueWithoutUsers_frd_documents_createdByTousersInput[]
    createMany?: frd_documentsCreateManyUsers_frd_documents_createdByTousersInputEnvelope
    set?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    disconnect?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    delete?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    connect?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    update?: frd_documentsUpdateWithWhereUniqueWithoutUsers_frd_documents_createdByTousersInput | frd_documentsUpdateWithWhereUniqueWithoutUsers_frd_documents_createdByTousersInput[]
    updateMany?: frd_documentsUpdateManyWithWhereWithoutUsers_frd_documents_createdByTousersInput | frd_documentsUpdateManyWithWhereWithoutUsers_frd_documents_createdByTousersInput[]
    deleteMany?: frd_documentsScalarWhereInput | frd_documentsScalarWhereInput[]
  }

  export type ideasUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ideasCreateWithoutUsersInput, ideasUncheckedCreateWithoutUsersInput> | ideasCreateWithoutUsersInput[] | ideasUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ideasCreateOrConnectWithoutUsersInput | ideasCreateOrConnectWithoutUsersInput[]
    upsert?: ideasUpsertWithWhereUniqueWithoutUsersInput | ideasUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ideasCreateManyUsersInputEnvelope
    set?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    disconnect?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    delete?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    connect?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    update?: ideasUpdateWithWhereUniqueWithoutUsersInput | ideasUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ideasUpdateManyWithWhereWithoutUsersInput | ideasUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ideasScalarWhereInput | ideasScalarWhereInput[]
  }

  export type initiativesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<initiativesCreateWithoutUsersInput, initiativesUncheckedCreateWithoutUsersInput> | initiativesCreateWithoutUsersInput[] | initiativesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: initiativesCreateOrConnectWithoutUsersInput | initiativesCreateOrConnectWithoutUsersInput[]
    upsert?: initiativesUpsertWithWhereUniqueWithoutUsersInput | initiativesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: initiativesCreateManyUsersInputEnvelope
    set?: initiativesWhereUniqueInput | initiativesWhereUniqueInput[]
    disconnect?: initiativesWhereUniqueInput | initiativesWhereUniqueInput[]
    delete?: initiativesWhereUniqueInput | initiativesWhereUniqueInput[]
    connect?: initiativesWhereUniqueInput | initiativesWhereUniqueInput[]
    update?: initiativesUpdateWithWhereUniqueWithoutUsersInput | initiativesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: initiativesUpdateManyWithWhereWithoutUsersInput | initiativesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: initiativesScalarWhereInput | initiativesScalarWhereInput[]
  }

  export type input_groupsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<input_groupsCreateWithoutUsersInput, input_groupsUncheckedCreateWithoutUsersInput> | input_groupsCreateWithoutUsersInput[] | input_groupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: input_groupsCreateOrConnectWithoutUsersInput | input_groupsCreateOrConnectWithoutUsersInput[]
    upsert?: input_groupsUpsertWithWhereUniqueWithoutUsersInput | input_groupsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: input_groupsCreateManyUsersInputEnvelope
    set?: input_groupsWhereUniqueInput | input_groupsWhereUniqueInput[]
    disconnect?: input_groupsWhereUniqueInput | input_groupsWhereUniqueInput[]
    delete?: input_groupsWhereUniqueInput | input_groupsWhereUniqueInput[]
    connect?: input_groupsWhereUniqueInput | input_groupsWhereUniqueInput[]
    update?: input_groupsUpdateWithWhereUniqueWithoutUsersInput | input_groupsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: input_groupsUpdateManyWithWhereWithoutUsersInput | input_groupsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: input_groupsScalarWhereInput | input_groupsScalarWhereInput[]
  }

  export type inputsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<inputsCreateWithoutUsersInput, inputsUncheckedCreateWithoutUsersInput> | inputsCreateWithoutUsersInput[] | inputsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: inputsCreateOrConnectWithoutUsersInput | inputsCreateOrConnectWithoutUsersInput[]
    upsert?: inputsUpsertWithWhereUniqueWithoutUsersInput | inputsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: inputsCreateManyUsersInputEnvelope
    set?: inputsWhereUniqueInput | inputsWhereUniqueInput[]
    disconnect?: inputsWhereUniqueInput | inputsWhereUniqueInput[]
    delete?: inputsWhereUniqueInput | inputsWhereUniqueInput[]
    connect?: inputsWhereUniqueInput | inputsWhereUniqueInput[]
    update?: inputsUpdateWithWhereUniqueWithoutUsersInput | inputsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: inputsUpdateManyWithWhereWithoutUsersInput | inputsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: inputsScalarWhereInput | inputsScalarWhereInput[]
  }

  export type requirementsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<requirementsCreateWithoutUsersInput, requirementsUncheckedCreateWithoutUsersInput> | requirementsCreateWithoutUsersInput[] | requirementsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: requirementsCreateOrConnectWithoutUsersInput | requirementsCreateOrConnectWithoutUsersInput[]
    upsert?: requirementsUpsertWithWhereUniqueWithoutUsersInput | requirementsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: requirementsCreateManyUsersInputEnvelope
    set?: requirementsWhereUniqueInput | requirementsWhereUniqueInput[]
    disconnect?: requirementsWhereUniqueInput | requirementsWhereUniqueInput[]
    delete?: requirementsWhereUniqueInput | requirementsWhereUniqueInput[]
    connect?: requirementsWhereUniqueInput | requirementsWhereUniqueInput[]
    update?: requirementsUpdateWithWhereUniqueWithoutUsersInput | requirementsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: requirementsUpdateManyWithWhereWithoutUsersInput | requirementsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: requirementsScalarWhereInput | requirementsScalarWhereInput[]
  }

  export type signalsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<signalsCreateWithoutUsersInput, signalsUncheckedCreateWithoutUsersInput> | signalsCreateWithoutUsersInput[] | signalsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: signalsCreateOrConnectWithoutUsersInput | signalsCreateOrConnectWithoutUsersInput[]
    upsert?: signalsUpsertWithWhereUniqueWithoutUsersInput | signalsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: signalsCreateManyUsersInputEnvelope
    set?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    disconnect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    delete?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    connect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    update?: signalsUpdateWithWhereUniqueWithoutUsersInput | signalsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: signalsUpdateManyWithWhereWithoutUsersInput | signalsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: signalsScalarWhereInput | signalsScalarWhereInput[]
  }

  export type solutionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<solutionsCreateWithoutUsersInput, solutionsUncheckedCreateWithoutUsersInput> | solutionsCreateWithoutUsersInput[] | solutionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: solutionsCreateOrConnectWithoutUsersInput | solutionsCreateOrConnectWithoutUsersInput[]
    upsert?: solutionsUpsertWithWhereUniqueWithoutUsersInput | solutionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: solutionsCreateManyUsersInputEnvelope
    set?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    disconnect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    delete?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    connect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    update?: solutionsUpdateWithWhereUniqueWithoutUsersInput | solutionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: solutionsUpdateManyWithWhereWithoutUsersInput | solutionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: solutionsScalarWhereInput | solutionsScalarWhereInput[]
  }

  export type teamsUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput = {
    create?: XOR<teamsCreateWithoutUsers_teams_leaderIdTousersInput, teamsUncheckedCreateWithoutUsers_teams_leaderIdTousersInput> | teamsCreateWithoutUsers_teams_leaderIdTousersInput[] | teamsUncheckedCreateWithoutUsers_teams_leaderIdTousersInput[]
    connectOrCreate?: teamsCreateOrConnectWithoutUsers_teams_leaderIdTousersInput | teamsCreateOrConnectWithoutUsers_teams_leaderIdTousersInput[]
    upsert?: teamsUpsertWithWhereUniqueWithoutUsers_teams_leaderIdTousersInput | teamsUpsertWithWhereUniqueWithoutUsers_teams_leaderIdTousersInput[]
    createMany?: teamsCreateManyUsers_teams_leaderIdTousersInputEnvelope
    set?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    disconnect?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    delete?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    connect?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    update?: teamsUpdateWithWhereUniqueWithoutUsers_teams_leaderIdTousersInput | teamsUpdateWithWhereUniqueWithoutUsers_teams_leaderIdTousersInput[]
    updateMany?: teamsUpdateManyWithWhereWithoutUsers_teams_leaderIdTousersInput | teamsUpdateManyWithWhereWithoutUsers_teams_leaderIdTousersInput[]
    deleteMany?: teamsScalarWhereInput | teamsScalarWhereInput[]
  }

  export type departmentsUpdateOneWithoutUsers_users_departmentObjIdTodepartmentsNestedInput = {
    create?: XOR<departmentsCreateWithoutUsers_users_departmentObjIdTodepartmentsInput, departmentsUncheckedCreateWithoutUsers_users_departmentObjIdTodepartmentsInput>
    connectOrCreate?: departmentsCreateOrConnectWithoutUsers_users_departmentObjIdTodepartmentsInput
    upsert?: departmentsUpsertWithoutUsers_users_departmentObjIdTodepartmentsInput
    disconnect?: departmentsWhereInput | boolean
    delete?: departmentsWhereInput | boolean
    connect?: departmentsWhereUniqueInput
    update?: XOR<XOR<departmentsUpdateToOneWithWhereWithoutUsers_users_departmentObjIdTodepartmentsInput, departmentsUpdateWithoutUsers_users_departmentObjIdTodepartmentsInput>, departmentsUncheckedUpdateWithoutUsers_users_departmentObjIdTodepartmentsInput>
  }

  export type usersUpdateOneWithoutOther_usersNestedInput = {
    create?: XOR<usersCreateWithoutOther_usersInput, usersUncheckedCreateWithoutOther_usersInput>
    connectOrCreate?: usersCreateOrConnectWithoutOther_usersInput
    upsert?: usersUpsertWithoutOther_usersInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutOther_usersInput, usersUpdateWithoutOther_usersInput>, usersUncheckedUpdateWithoutOther_usersInput>
  }

  export type usersUpdateManyWithoutUsersNestedInput = {
    create?: XOR<usersCreateWithoutUsersInput, usersUncheckedCreateWithoutUsersInput> | usersCreateWithoutUsersInput[] | usersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: usersCreateOrConnectWithoutUsersInput | usersCreateOrConnectWithoutUsersInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutUsersInput | usersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: usersCreateManyUsersInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutUsersInput | usersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: usersUpdateManyWithWhereWithoutUsersInput | usersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type votesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<votesCreateWithoutUsersInput, votesUncheckedCreateWithoutUsersInput> | votesCreateWithoutUsersInput[] | votesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: votesCreateOrConnectWithoutUsersInput | votesCreateOrConnectWithoutUsersInput[]
    upsert?: votesUpsertWithWhereUniqueWithoutUsersInput | votesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: votesCreateManyUsersInputEnvelope
    set?: votesWhereUniqueInput | votesWhereUniqueInput[]
    disconnect?: votesWhereUniqueInput | votesWhereUniqueInput[]
    delete?: votesWhereUniqueInput | votesWhereUniqueInput[]
    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]
    update?: votesUpdateWithWhereUniqueWithoutUsersInput | votesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: votesUpdateManyWithWhereWithoutUsersInput | votesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: votesScalarWhereInput | votesScalarWhereInput[]
  }

  export type teamsUpdateManyWithoutUsers_TeamMembersNestedInput = {
    create?: XOR<teamsCreateWithoutUsers_TeamMembersInput, teamsUncheckedCreateWithoutUsers_TeamMembersInput> | teamsCreateWithoutUsers_TeamMembersInput[] | teamsUncheckedCreateWithoutUsers_TeamMembersInput[]
    connectOrCreate?: teamsCreateOrConnectWithoutUsers_TeamMembersInput | teamsCreateOrConnectWithoutUsers_TeamMembersInput[]
    upsert?: teamsUpsertWithWhereUniqueWithoutUsers_TeamMembersInput | teamsUpsertWithWhereUniqueWithoutUsers_TeamMembersInput[]
    set?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    disconnect?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    delete?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    connect?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    update?: teamsUpdateWithWhereUniqueWithoutUsers_TeamMembersInput | teamsUpdateWithWhereUniqueWithoutUsers_TeamMembersInput[]
    updateMany?: teamsUpdateManyWithWhereWithoutUsers_TeamMembersInput | teamsUpdateManyWithWhereWithoutUsers_TeamMembersInput[]
    deleteMany?: teamsScalarWhereInput | teamsScalarWhereInput[]
  }

  export type ai_analysis_auditUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ai_analysis_auditCreateWithoutUsersInput, ai_analysis_auditUncheckedCreateWithoutUsersInput> | ai_analysis_auditCreateWithoutUsersInput[] | ai_analysis_auditUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_analysis_auditCreateOrConnectWithoutUsersInput | ai_analysis_auditCreateOrConnectWithoutUsersInput[]
    upsert?: ai_analysis_auditUpsertWithWhereUniqueWithoutUsersInput | ai_analysis_auditUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ai_analysis_auditCreateManyUsersInputEnvelope
    set?: ai_analysis_auditWhereUniqueInput | ai_analysis_auditWhereUniqueInput[]
    disconnect?: ai_analysis_auditWhereUniqueInput | ai_analysis_auditWhereUniqueInput[]
    delete?: ai_analysis_auditWhereUniqueInput | ai_analysis_auditWhereUniqueInput[]
    connect?: ai_analysis_auditWhereUniqueInput | ai_analysis_auditWhereUniqueInput[]
    update?: ai_analysis_auditUpdateWithWhereUniqueWithoutUsersInput | ai_analysis_auditUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ai_analysis_auditUpdateManyWithWhereWithoutUsersInput | ai_analysis_auditUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ai_analysis_auditScalarWhereInput | ai_analysis_auditScalarWhereInput[]
  }

  export type ai_insight_overridesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ai_insight_overridesCreateWithoutUsersInput, ai_insight_overridesUncheckedCreateWithoutUsersInput> | ai_insight_overridesCreateWithoutUsersInput[] | ai_insight_overridesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_insight_overridesCreateOrConnectWithoutUsersInput | ai_insight_overridesCreateOrConnectWithoutUsersInput[]
    upsert?: ai_insight_overridesUpsertWithWhereUniqueWithoutUsersInput | ai_insight_overridesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ai_insight_overridesCreateManyUsersInputEnvelope
    set?: ai_insight_overridesWhereUniqueInput | ai_insight_overridesWhereUniqueInput[]
    disconnect?: ai_insight_overridesWhereUniqueInput | ai_insight_overridesWhereUniqueInput[]
    delete?: ai_insight_overridesWhereUniqueInput | ai_insight_overridesWhereUniqueInput[]
    connect?: ai_insight_overridesWhereUniqueInput | ai_insight_overridesWhereUniqueInput[]
    update?: ai_insight_overridesUpdateWithWhereUniqueWithoutUsersInput | ai_insight_overridesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ai_insight_overridesUpdateManyWithWhereWithoutUsersInput | ai_insight_overridesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ai_insight_overridesScalarWhereInput | ai_insight_overridesScalarWhereInput[]
  }

  export type audit_logsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput> | audit_logsCreateWithoutUsersInput[] | audit_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: audit_logsCreateOrConnectWithoutUsersInput | audit_logsCreateOrConnectWithoutUsersInput[]
    upsert?: audit_logsUpsertWithWhereUniqueWithoutUsersInput | audit_logsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: audit_logsCreateManyUsersInputEnvelope
    set?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    disconnect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    delete?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    connect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    update?: audit_logsUpdateWithWhereUniqueWithoutUsersInput | audit_logsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: audit_logsUpdateManyWithWhereWithoutUsersInput | audit_logsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: audit_logsScalarWhereInput | audit_logsScalarWhereInput[]
  }

  export type commentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput> | commentsCreateWithoutUsersInput[] | commentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutUsersInput | commentsCreateOrConnectWithoutUsersInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutUsersInput | commentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: commentsCreateManyUsersInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutUsersInput | commentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutUsersInput | commentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersNestedInput = {
    create?: XOR<departmentsCreateWithoutUsers_departments_managerIdTousersInput, departmentsUncheckedCreateWithoutUsers_departments_managerIdTousersInput> | departmentsCreateWithoutUsers_departments_managerIdTousersInput[] | departmentsUncheckedCreateWithoutUsers_departments_managerIdTousersInput[]
    connectOrCreate?: departmentsCreateOrConnectWithoutUsers_departments_managerIdTousersInput | departmentsCreateOrConnectWithoutUsers_departments_managerIdTousersInput[]
    upsert?: departmentsUpsertWithWhereUniqueWithoutUsers_departments_managerIdTousersInput | departmentsUpsertWithWhereUniqueWithoutUsers_departments_managerIdTousersInput[]
    createMany?: departmentsCreateManyUsers_departments_managerIdTousersInputEnvelope
    set?: departmentsWhereUniqueInput | departmentsWhereUniqueInput[]
    disconnect?: departmentsWhereUniqueInput | departmentsWhereUniqueInput[]
    delete?: departmentsWhereUniqueInput | departmentsWhereUniqueInput[]
    connect?: departmentsWhereUniqueInput | departmentsWhereUniqueInput[]
    update?: departmentsUpdateWithWhereUniqueWithoutUsers_departments_managerIdTousersInput | departmentsUpdateWithWhereUniqueWithoutUsers_departments_managerIdTousersInput[]
    updateMany?: departmentsUpdateManyWithWhereWithoutUsers_departments_managerIdTousersInput | departmentsUpdateManyWithWhereWithoutUsers_departments_managerIdTousersInput[]
    deleteMany?: departmentsScalarWhereInput | departmentsScalarWhereInput[]
  }

  export type frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput = {
    create?: XOR<frd_documentsCreateWithoutUsers_frd_documents_approvedByTousersInput, frd_documentsUncheckedCreateWithoutUsers_frd_documents_approvedByTousersInput> | frd_documentsCreateWithoutUsers_frd_documents_approvedByTousersInput[] | frd_documentsUncheckedCreateWithoutUsers_frd_documents_approvedByTousersInput[]
    connectOrCreate?: frd_documentsCreateOrConnectWithoutUsers_frd_documents_approvedByTousersInput | frd_documentsCreateOrConnectWithoutUsers_frd_documents_approvedByTousersInput[]
    upsert?: frd_documentsUpsertWithWhereUniqueWithoutUsers_frd_documents_approvedByTousersInput | frd_documentsUpsertWithWhereUniqueWithoutUsers_frd_documents_approvedByTousersInput[]
    createMany?: frd_documentsCreateManyUsers_frd_documents_approvedByTousersInputEnvelope
    set?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    disconnect?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    delete?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    connect?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    update?: frd_documentsUpdateWithWhereUniqueWithoutUsers_frd_documents_approvedByTousersInput | frd_documentsUpdateWithWhereUniqueWithoutUsers_frd_documents_approvedByTousersInput[]
    updateMany?: frd_documentsUpdateManyWithWhereWithoutUsers_frd_documents_approvedByTousersInput | frd_documentsUpdateManyWithWhereWithoutUsers_frd_documents_approvedByTousersInput[]
    deleteMany?: frd_documentsScalarWhereInput | frd_documentsScalarWhereInput[]
  }

  export type frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput = {
    create?: XOR<frd_documentsCreateWithoutUsers_frd_documents_createdByTousersInput, frd_documentsUncheckedCreateWithoutUsers_frd_documents_createdByTousersInput> | frd_documentsCreateWithoutUsers_frd_documents_createdByTousersInput[] | frd_documentsUncheckedCreateWithoutUsers_frd_documents_createdByTousersInput[]
    connectOrCreate?: frd_documentsCreateOrConnectWithoutUsers_frd_documents_createdByTousersInput | frd_documentsCreateOrConnectWithoutUsers_frd_documents_createdByTousersInput[]
    upsert?: frd_documentsUpsertWithWhereUniqueWithoutUsers_frd_documents_createdByTousersInput | frd_documentsUpsertWithWhereUniqueWithoutUsers_frd_documents_createdByTousersInput[]
    createMany?: frd_documentsCreateManyUsers_frd_documents_createdByTousersInputEnvelope
    set?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    disconnect?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    delete?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    connect?: frd_documentsWhereUniqueInput | frd_documentsWhereUniqueInput[]
    update?: frd_documentsUpdateWithWhereUniqueWithoutUsers_frd_documents_createdByTousersInput | frd_documentsUpdateWithWhereUniqueWithoutUsers_frd_documents_createdByTousersInput[]
    updateMany?: frd_documentsUpdateManyWithWhereWithoutUsers_frd_documents_createdByTousersInput | frd_documentsUpdateManyWithWhereWithoutUsers_frd_documents_createdByTousersInput[]
    deleteMany?: frd_documentsScalarWhereInput | frd_documentsScalarWhereInput[]
  }

  export type ideasUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ideasCreateWithoutUsersInput, ideasUncheckedCreateWithoutUsersInput> | ideasCreateWithoutUsersInput[] | ideasUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ideasCreateOrConnectWithoutUsersInput | ideasCreateOrConnectWithoutUsersInput[]
    upsert?: ideasUpsertWithWhereUniqueWithoutUsersInput | ideasUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ideasCreateManyUsersInputEnvelope
    set?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    disconnect?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    delete?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    connect?: ideasWhereUniqueInput | ideasWhereUniqueInput[]
    update?: ideasUpdateWithWhereUniqueWithoutUsersInput | ideasUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ideasUpdateManyWithWhereWithoutUsersInput | ideasUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ideasScalarWhereInput | ideasScalarWhereInput[]
  }

  export type initiativesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<initiativesCreateWithoutUsersInput, initiativesUncheckedCreateWithoutUsersInput> | initiativesCreateWithoutUsersInput[] | initiativesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: initiativesCreateOrConnectWithoutUsersInput | initiativesCreateOrConnectWithoutUsersInput[]
    upsert?: initiativesUpsertWithWhereUniqueWithoutUsersInput | initiativesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: initiativesCreateManyUsersInputEnvelope
    set?: initiativesWhereUniqueInput | initiativesWhereUniqueInput[]
    disconnect?: initiativesWhereUniqueInput | initiativesWhereUniqueInput[]
    delete?: initiativesWhereUniqueInput | initiativesWhereUniqueInput[]
    connect?: initiativesWhereUniqueInput | initiativesWhereUniqueInput[]
    update?: initiativesUpdateWithWhereUniqueWithoutUsersInput | initiativesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: initiativesUpdateManyWithWhereWithoutUsersInput | initiativesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: initiativesScalarWhereInput | initiativesScalarWhereInput[]
  }

  export type input_groupsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<input_groupsCreateWithoutUsersInput, input_groupsUncheckedCreateWithoutUsersInput> | input_groupsCreateWithoutUsersInput[] | input_groupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: input_groupsCreateOrConnectWithoutUsersInput | input_groupsCreateOrConnectWithoutUsersInput[]
    upsert?: input_groupsUpsertWithWhereUniqueWithoutUsersInput | input_groupsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: input_groupsCreateManyUsersInputEnvelope
    set?: input_groupsWhereUniqueInput | input_groupsWhereUniqueInput[]
    disconnect?: input_groupsWhereUniqueInput | input_groupsWhereUniqueInput[]
    delete?: input_groupsWhereUniqueInput | input_groupsWhereUniqueInput[]
    connect?: input_groupsWhereUniqueInput | input_groupsWhereUniqueInput[]
    update?: input_groupsUpdateWithWhereUniqueWithoutUsersInput | input_groupsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: input_groupsUpdateManyWithWhereWithoutUsersInput | input_groupsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: input_groupsScalarWhereInput | input_groupsScalarWhereInput[]
  }

  export type inputsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<inputsCreateWithoutUsersInput, inputsUncheckedCreateWithoutUsersInput> | inputsCreateWithoutUsersInput[] | inputsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: inputsCreateOrConnectWithoutUsersInput | inputsCreateOrConnectWithoutUsersInput[]
    upsert?: inputsUpsertWithWhereUniqueWithoutUsersInput | inputsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: inputsCreateManyUsersInputEnvelope
    set?: inputsWhereUniqueInput | inputsWhereUniqueInput[]
    disconnect?: inputsWhereUniqueInput | inputsWhereUniqueInput[]
    delete?: inputsWhereUniqueInput | inputsWhereUniqueInput[]
    connect?: inputsWhereUniqueInput | inputsWhereUniqueInput[]
    update?: inputsUpdateWithWhereUniqueWithoutUsersInput | inputsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: inputsUpdateManyWithWhereWithoutUsersInput | inputsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: inputsScalarWhereInput | inputsScalarWhereInput[]
  }

  export type requirementsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<requirementsCreateWithoutUsersInput, requirementsUncheckedCreateWithoutUsersInput> | requirementsCreateWithoutUsersInput[] | requirementsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: requirementsCreateOrConnectWithoutUsersInput | requirementsCreateOrConnectWithoutUsersInput[]
    upsert?: requirementsUpsertWithWhereUniqueWithoutUsersInput | requirementsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: requirementsCreateManyUsersInputEnvelope
    set?: requirementsWhereUniqueInput | requirementsWhereUniqueInput[]
    disconnect?: requirementsWhereUniqueInput | requirementsWhereUniqueInput[]
    delete?: requirementsWhereUniqueInput | requirementsWhereUniqueInput[]
    connect?: requirementsWhereUniqueInput | requirementsWhereUniqueInput[]
    update?: requirementsUpdateWithWhereUniqueWithoutUsersInput | requirementsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: requirementsUpdateManyWithWhereWithoutUsersInput | requirementsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: requirementsScalarWhereInput | requirementsScalarWhereInput[]
  }

  export type signalsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<signalsCreateWithoutUsersInput, signalsUncheckedCreateWithoutUsersInput> | signalsCreateWithoutUsersInput[] | signalsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: signalsCreateOrConnectWithoutUsersInput | signalsCreateOrConnectWithoutUsersInput[]
    upsert?: signalsUpsertWithWhereUniqueWithoutUsersInput | signalsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: signalsCreateManyUsersInputEnvelope
    set?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    disconnect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    delete?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    connect?: signalsWhereUniqueInput | signalsWhereUniqueInput[]
    update?: signalsUpdateWithWhereUniqueWithoutUsersInput | signalsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: signalsUpdateManyWithWhereWithoutUsersInput | signalsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: signalsScalarWhereInput | signalsScalarWhereInput[]
  }

  export type solutionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<solutionsCreateWithoutUsersInput, solutionsUncheckedCreateWithoutUsersInput> | solutionsCreateWithoutUsersInput[] | solutionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: solutionsCreateOrConnectWithoutUsersInput | solutionsCreateOrConnectWithoutUsersInput[]
    upsert?: solutionsUpsertWithWhereUniqueWithoutUsersInput | solutionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: solutionsCreateManyUsersInputEnvelope
    set?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    disconnect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    delete?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    connect?: solutionsWhereUniqueInput | solutionsWhereUniqueInput[]
    update?: solutionsUpdateWithWhereUniqueWithoutUsersInput | solutionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: solutionsUpdateManyWithWhereWithoutUsersInput | solutionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: solutionsScalarWhereInput | solutionsScalarWhereInput[]
  }

  export type teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput = {
    create?: XOR<teamsCreateWithoutUsers_teams_leaderIdTousersInput, teamsUncheckedCreateWithoutUsers_teams_leaderIdTousersInput> | teamsCreateWithoutUsers_teams_leaderIdTousersInput[] | teamsUncheckedCreateWithoutUsers_teams_leaderIdTousersInput[]
    connectOrCreate?: teamsCreateOrConnectWithoutUsers_teams_leaderIdTousersInput | teamsCreateOrConnectWithoutUsers_teams_leaderIdTousersInput[]
    upsert?: teamsUpsertWithWhereUniqueWithoutUsers_teams_leaderIdTousersInput | teamsUpsertWithWhereUniqueWithoutUsers_teams_leaderIdTousersInput[]
    createMany?: teamsCreateManyUsers_teams_leaderIdTousersInputEnvelope
    set?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    disconnect?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    delete?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    connect?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    update?: teamsUpdateWithWhereUniqueWithoutUsers_teams_leaderIdTousersInput | teamsUpdateWithWhereUniqueWithoutUsers_teams_leaderIdTousersInput[]
    updateMany?: teamsUpdateManyWithWhereWithoutUsers_teams_leaderIdTousersInput | teamsUpdateManyWithWhereWithoutUsers_teams_leaderIdTousersInput[]
    deleteMany?: teamsScalarWhereInput | teamsScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<usersCreateWithoutUsersInput, usersUncheckedCreateWithoutUsersInput> | usersCreateWithoutUsersInput[] | usersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: usersCreateOrConnectWithoutUsersInput | usersCreateOrConnectWithoutUsersInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutUsersInput | usersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: usersCreateManyUsersInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutUsersInput | usersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: usersUpdateManyWithWhereWithoutUsersInput | usersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type votesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<votesCreateWithoutUsersInput, votesUncheckedCreateWithoutUsersInput> | votesCreateWithoutUsersInput[] | votesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: votesCreateOrConnectWithoutUsersInput | votesCreateOrConnectWithoutUsersInput[]
    upsert?: votesUpsertWithWhereUniqueWithoutUsersInput | votesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: votesCreateManyUsersInputEnvelope
    set?: votesWhereUniqueInput | votesWhereUniqueInput[]
    disconnect?: votesWhereUniqueInput | votesWhereUniqueInput[]
    delete?: votesWhereUniqueInput | votesWhereUniqueInput[]
    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]
    update?: votesUpdateWithWhereUniqueWithoutUsersInput | votesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: votesUpdateManyWithWhereWithoutUsersInput | votesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: votesScalarWhereInput | votesScalarWhereInput[]
  }

  export type teamsUncheckedUpdateManyWithoutUsers_TeamMembersNestedInput = {
    create?: XOR<teamsCreateWithoutUsers_TeamMembersInput, teamsUncheckedCreateWithoutUsers_TeamMembersInput> | teamsCreateWithoutUsers_TeamMembersInput[] | teamsUncheckedCreateWithoutUsers_TeamMembersInput[]
    connectOrCreate?: teamsCreateOrConnectWithoutUsers_TeamMembersInput | teamsCreateOrConnectWithoutUsers_TeamMembersInput[]
    upsert?: teamsUpsertWithWhereUniqueWithoutUsers_TeamMembersInput | teamsUpsertWithWhereUniqueWithoutUsers_TeamMembersInput[]
    set?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    disconnect?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    delete?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    connect?: teamsWhereUniqueInput | teamsWhereUniqueInput[]
    update?: teamsUpdateWithWhereUniqueWithoutUsers_TeamMembersInput | teamsUpdateWithWhereUniqueWithoutUsers_TeamMembersInput[]
    updateMany?: teamsUpdateManyWithWhereWithoutUsers_TeamMembersInput | teamsUpdateManyWithWhereWithoutUsers_TeamMembersInput[]
    deleteMany?: teamsScalarWhereInput | teamsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutVotesInput = {
    create?: XOR<usersCreateWithoutVotesInput, usersUncheckedCreateWithoutVotesInput>
    connectOrCreate?: usersCreateOrConnectWithoutVotesInput
    connect?: usersWhereUniqueInput
  }

  export type EnumVoteValueFieldUpdateOperationsInput = {
    set?: $Enums.VoteValue
  }

  export type usersUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<usersCreateWithoutVotesInput, usersUncheckedCreateWithoutVotesInput>
    connectOrCreate?: usersCreateOrConnectWithoutVotesInput
    upsert?: usersUpsertWithoutVotesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutVotesInput, usersUpdateWithoutVotesInput>, usersUncheckedUpdateWithoutVotesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityTypeFilter<$PrismaModel> | $Enums.EntityType
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.EntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumEntityTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumFRDStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FRDStatus | EnumFRDStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFRDStatusFilter<$PrismaModel> | $Enums.FRDStatus
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumFRDStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FRDStatus | EnumFRDStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFRDStatusWithAggregatesFilter<$PrismaModel> | $Enums.FRDStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFRDStatusFilter<$PrismaModel>
    _max?: NestedEnumFRDStatusFilter<$PrismaModel>
  }

  export type NestedEnumHotspotStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HotspotStatus | EnumHotspotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HotspotStatus[] | ListEnumHotspotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HotspotStatus[] | ListEnumHotspotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHotspotStatusFilter<$PrismaModel> | $Enums.HotspotStatus
  }

  export type NestedEnumHotspotStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HotspotStatus | EnumHotspotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HotspotStatus[] | ListEnumHotspotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HotspotStatus[] | ListEnumHotspotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHotspotStatusWithAggregatesFilter<$PrismaModel> | $Enums.HotspotStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHotspotStatusFilter<$PrismaModel>
    _max?: NestedEnumHotspotStatusFilter<$PrismaModel>
  }

  export type NestedEnuminitiative_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.initiative_status | Enuminitiative_statusFieldRefInput<$PrismaModel>
    in?: $Enums.initiative_status[] | ListEnuminitiative_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.initiative_status[] | ListEnuminitiative_statusFieldRefInput<$PrismaModel>
    not?: NestedEnuminitiative_statusFilter<$PrismaModel> | $Enums.initiative_status
  }

  export type NestedEnumpriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.priority | EnumpriorityFieldRefInput<$PrismaModel>
    in?: $Enums.priority[] | ListEnumpriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.priority[] | ListEnumpriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumpriorityFilter<$PrismaModel> | $Enums.priority
  }

  export type NestedEnumrisk_levelFilter<$PrismaModel = never> = {
    equals?: $Enums.risk_level | Enumrisk_levelFieldRefInput<$PrismaModel>
    in?: $Enums.risk_level[] | ListEnumrisk_levelFieldRefInput<$PrismaModel>
    notIn?: $Enums.risk_level[] | ListEnumrisk_levelFieldRefInput<$PrismaModel>
    not?: NestedEnumrisk_levelFilter<$PrismaModel> | $Enums.risk_level
  }

  export type NestedEnuminitiative_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.initiative_status | Enuminitiative_statusFieldRefInput<$PrismaModel>
    in?: $Enums.initiative_status[] | ListEnuminitiative_statusFieldRefInput<$PrismaModel>
    notIn?: $Enums.initiative_status[] | ListEnuminitiative_statusFieldRefInput<$PrismaModel>
    not?: NestedEnuminitiative_statusWithAggregatesFilter<$PrismaModel> | $Enums.initiative_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminitiative_statusFilter<$PrismaModel>
    _max?: NestedEnuminitiative_statusFilter<$PrismaModel>
  }

  export type NestedEnumpriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.priority | EnumpriorityFieldRefInput<$PrismaModel>
    in?: $Enums.priority[] | ListEnumpriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.priority[] | ListEnumpriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumpriorityWithAggregatesFilter<$PrismaModel> | $Enums.priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpriorityFilter<$PrismaModel>
    _max?: NestedEnumpriorityFilter<$PrismaModel>
  }

  export type NestedEnumrisk_levelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.risk_level | Enumrisk_levelFieldRefInput<$PrismaModel>
    in?: $Enums.risk_level[] | ListEnumrisk_levelFieldRefInput<$PrismaModel>
    notIn?: $Enums.risk_level[] | ListEnumrisk_levelFieldRefInput<$PrismaModel>
    not?: NestedEnumrisk_levelWithAggregatesFilter<$PrismaModel> | $Enums.risk_level
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrisk_levelFilter<$PrismaModel>
    _max?: NestedEnumrisk_levelFilter<$PrismaModel>
  }

  export type NestedEnumInputTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InputType | EnumInputTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInputTypeFilter<$PrismaModel> | $Enums.InputType
  }

  export type NestedEnumInputStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InputStatus | EnumInputStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InputStatus[] | ListEnumInputStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InputStatus[] | ListEnumInputStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInputStatusFilter<$PrismaModel> | $Enums.InputStatus
  }

  export type NestedEnumInputTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InputType | EnumInputTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInputTypeWithAggregatesFilter<$PrismaModel> | $Enums.InputType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInputTypeFilter<$PrismaModel>
    _max?: NestedEnumInputTypeFilter<$PrismaModel>
  }

  export type NestedEnumInputStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InputStatus | EnumInputStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InputStatus[] | ListEnumInputStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InputStatus[] | ListEnumInputStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInputStatusWithAggregatesFilter<$PrismaModel> | $Enums.InputStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInputStatusFilter<$PrismaModel>
    _max?: NestedEnumInputStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumEntityTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEntityTypeNullableFilter<$PrismaModel> | $Enums.EntityType | null
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumEntityTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEntityTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EntityType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEntityTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumEntityTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumRequirementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementStatus | EnumRequirementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementStatusFilter<$PrismaModel> | $Enums.RequirementStatus
  }

  export type NestedEnumRequirementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementStatus | EnumRequirementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequirementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequirementStatusFilter<$PrismaModel>
    _max?: NestedEnumRequirementStatusFilter<$PrismaModel>
  }

  export type NestedEnumSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSeverityFilter<$PrismaModel> | $Enums.Severity
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type NestedEnumSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSeverityWithAggregatesFilter<$PrismaModel> | $Enums.Severity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeverityFilter<$PrismaModel>
    _max?: NestedEnumSeverityFilter<$PrismaModel>
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedEnumSolutionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SolutionStatus | EnumSolutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SolutionStatus[] | ListEnumSolutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SolutionStatus[] | ListEnumSolutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSolutionStatusFilter<$PrismaModel> | $Enums.SolutionStatus
  }

  export type NestedEnumSolutionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SolutionStatus | EnumSolutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SolutionStatus[] | ListEnumSolutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SolutionStatus[] | ListEnumSolutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSolutionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SolutionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSolutionStatusFilter<$PrismaModel>
    _max?: NestedEnumSolutionStatusFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumVoteValueFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteValue | EnumVoteValueFieldRefInput<$PrismaModel>
    in?: $Enums.VoteValue[] | ListEnumVoteValueFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteValue[] | ListEnumVoteValueFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteValueFilter<$PrismaModel> | $Enums.VoteValue
  }

  export type NestedEnumVoteValueWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteValue | EnumVoteValueFieldRefInput<$PrismaModel>
    in?: $Enums.VoteValue[] | ListEnumVoteValueFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteValue[] | ListEnumVoteValueFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteValueWithAggregatesFilter<$PrismaModel> | $Enums.VoteValue
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoteValueFilter<$PrismaModel>
    _max?: NestedEnumVoteValueFilter<$PrismaModel>
  }

  export type inputsCreateWithoutInputToInputGroupInput = {
    id: string
    title: string
    description: string
    type?: $Enums.InputType
    status?: $Enums.InputStatus
    createdAt?: Date | string
    updatedAt: Date | string
    department?: string | null
    rootCause?: string | null
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: number | null
    issueType?: string | null
    priority?: $Enums.priority
    users: usersCreateNestedOneWithoutInputsInput
    solutions?: solutionsCreateNestedManyWithoutInputsInput
  }

  export type inputsUncheckedCreateWithoutInputToInputGroupInput = {
    id: string
    title: string
    description: string
    type?: $Enums.InputType
    status?: $Enums.InputStatus
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
    department?: string | null
    rootCause?: string | null
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: number | null
    issueType?: string | null
    priority?: $Enums.priority
    solutions?: solutionsUncheckedCreateNestedManyWithoutInputsInput
  }

  export type inputsCreateOrConnectWithoutInputToInputGroupInput = {
    where: inputsWhereUniqueInput
    create: XOR<inputsCreateWithoutInputToInputGroupInput, inputsUncheckedCreateWithoutInputToInputGroupInput>
  }

  export type input_groupsCreateWithoutInputToInputGroupInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    aiSuggested?: boolean
    aiConfidence?: number | null
    aiReasoning?: string | null
    avgPriority?: number | null
    color?: string | null
    inputCount?: number
    lastActivity?: Date | string | null
    users: usersCreateNestedOneWithoutInput_groupsInput
  }

  export type input_groupsUncheckedCreateWithoutInputToInputGroupInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    aiSuggested?: boolean
    aiConfidence?: number | null
    aiReasoning?: string | null
    avgPriority?: number | null
    color?: string | null
    createdBy: string
    inputCount?: number
    lastActivity?: Date | string | null
  }

  export type input_groupsCreateOrConnectWithoutInputToInputGroupInput = {
    where: input_groupsWhereUniqueInput
    create: XOR<input_groupsCreateWithoutInputToInputGroupInput, input_groupsUncheckedCreateWithoutInputToInputGroupInput>
  }

  export type inputsUpsertWithoutInputToInputGroupInput = {
    update: XOR<inputsUpdateWithoutInputToInputGroupInput, inputsUncheckedUpdateWithoutInputToInputGroupInput>
    create: XOR<inputsCreateWithoutInputToInputGroupInput, inputsUncheckedCreateWithoutInputToInputGroupInput>
    where?: inputsWhereInput
  }

  export type inputsUpdateToOneWithWhereWithoutInputToInputGroupInput = {
    where?: inputsWhereInput
    data: XOR<inputsUpdateWithoutInputToInputGroupInput, inputsUncheckedUpdateWithoutInputToInputGroupInput>
  }

  export type inputsUpdateWithoutInputToInputGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    users?: usersUpdateOneRequiredWithoutInputsNestedInput
    solutions?: solutionsUpdateManyWithoutInputsNestedInput
  }

  export type inputsUncheckedUpdateWithoutInputToInputGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    solutions?: solutionsUncheckedUpdateManyWithoutInputsNestedInput
  }

  export type input_groupsUpsertWithoutInputToInputGroupInput = {
    update: XOR<input_groupsUpdateWithoutInputToInputGroupInput, input_groupsUncheckedUpdateWithoutInputToInputGroupInput>
    create: XOR<input_groupsCreateWithoutInputToInputGroupInput, input_groupsUncheckedCreateWithoutInputToInputGroupInput>
    where?: input_groupsWhereInput
  }

  export type input_groupsUpdateToOneWithWhereWithoutInputToInputGroupInput = {
    where?: input_groupsWhereInput
    data: XOR<input_groupsUpdateWithoutInputToInputGroupInput, input_groupsUncheckedUpdateWithoutInputToInputGroupInput>
  }

  export type input_groupsUpdateWithoutInputToInputGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    avgPriority?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    inputCount?: IntFieldUpdateOperationsInput | number
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutInput_groupsNestedInput
  }

  export type input_groupsUncheckedUpdateWithoutInputToInputGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    avgPriority?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    inputCount?: IntFieldUpdateOperationsInput | number
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateWithoutAi_analysis_auditInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasCreateNestedManyWithoutUsersInput
    initiatives?: initiativesCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsCreateNestedManyWithoutUsersInput
    inputs?: inputsCreateNestedManyWithoutUsersInput
    requirements?: requirementsCreateNestedManyWithoutUsersInput
    signals?: signalsCreateNestedManyWithoutUsersInput
    solutions?: solutionsCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    departments_users_departmentObjIdTodepartments?: departmentsCreateNestedOneWithoutUsers_users_departmentObjIdTodepartmentsInput
    users?: usersCreateNestedOneWithoutOther_usersInput
    other_users?: usersCreateNestedManyWithoutUsersInput
    votes?: votesCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersUncheckedCreateWithoutAi_analysis_auditInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    managerId?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    departmentObjId?: string | null
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsUncheckedCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasUncheckedCreateNestedManyWithoutUsersInput
    initiatives?: initiativesUncheckedCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsUncheckedCreateNestedManyWithoutUsersInput
    inputs?: inputsUncheckedCreateNestedManyWithoutUsersInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutUsersInput
    signals?: signalsUncheckedCreateNestedManyWithoutUsersInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsUncheckedCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    other_users?: usersUncheckedCreateNestedManyWithoutUsersInput
    votes?: votesUncheckedCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsUncheckedCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersCreateOrConnectWithoutAi_analysis_auditInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAi_analysis_auditInput, usersUncheckedCreateWithoutAi_analysis_auditInput>
  }

  export type usersUpsertWithoutAi_analysis_auditInput = {
    update: XOR<usersUpdateWithoutAi_analysis_auditInput, usersUncheckedUpdateWithoutAi_analysis_auditInput>
    create: XOR<usersCreateWithoutAi_analysis_auditInput, usersUncheckedCreateWithoutAi_analysis_auditInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAi_analysis_auditInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAi_analysis_auditInput, usersUncheckedUpdateWithoutAi_analysis_auditInput>
  }

  export type usersUpdateWithoutAi_analysis_auditInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUpdateManyWithoutUsersNestedInput
    inputs?: inputsUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUpdateManyWithoutUsersNestedInput
    signals?: signalsUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    departments_users_departmentObjIdTodepartments?: departmentsUpdateOneWithoutUsers_users_departmentObjIdTodepartmentsNestedInput
    users?: usersUpdateOneWithoutOther_usersNestedInput
    other_users?: usersUpdateManyWithoutUsersNestedInput
    votes?: votesUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUncheckedUpdateWithoutAi_analysis_auditInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUncheckedUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUncheckedUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUncheckedUpdateManyWithoutUsersNestedInput
    inputs?: inputsUncheckedUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutUsersNestedInput
    signals?: signalsUncheckedUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    other_users?: usersUncheckedUpdateManyWithoutUsersNestedInput
    votes?: votesUncheckedUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUncheckedUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersCreateWithoutAi_insight_overridesInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    ai_analysis_audit?: ai_analysis_auditCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasCreateNestedManyWithoutUsersInput
    initiatives?: initiativesCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsCreateNestedManyWithoutUsersInput
    inputs?: inputsCreateNestedManyWithoutUsersInput
    requirements?: requirementsCreateNestedManyWithoutUsersInput
    signals?: signalsCreateNestedManyWithoutUsersInput
    solutions?: solutionsCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    departments_users_departmentObjIdTodepartments?: departmentsCreateNestedOneWithoutUsers_users_departmentObjIdTodepartmentsInput
    users?: usersCreateNestedOneWithoutOther_usersInput
    other_users?: usersCreateNestedManyWithoutUsersInput
    votes?: votesCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersUncheckedCreateWithoutAi_insight_overridesInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    managerId?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    departmentObjId?: string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsUncheckedCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasUncheckedCreateNestedManyWithoutUsersInput
    initiatives?: initiativesUncheckedCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsUncheckedCreateNestedManyWithoutUsersInput
    inputs?: inputsUncheckedCreateNestedManyWithoutUsersInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutUsersInput
    signals?: signalsUncheckedCreateNestedManyWithoutUsersInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsUncheckedCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    other_users?: usersUncheckedCreateNestedManyWithoutUsersInput
    votes?: votesUncheckedCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsUncheckedCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersCreateOrConnectWithoutAi_insight_overridesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAi_insight_overridesInput, usersUncheckedCreateWithoutAi_insight_overridesInput>
  }

  export type signalsCreateWithoutAi_insight_overridesInput = {
    id: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: number | null
    featuresVersion?: string | null
    lastFeaturesGeneratedAt?: Date | string | null
    hotspot_signals?: hotspot_signalsCreateNestedManyWithoutSignalsInput
    categories?: categoriesCreateNestedOneWithoutSignalsInput
    users?: usersCreateNestedOneWithoutSignalsInput
    departments?: departmentsCreateNestedOneWithoutSignalsInput
    teams?: teamsCreateNestedOneWithoutSignalsInput
  }

  export type signalsUncheckedCreateWithoutAi_insight_overridesInput = {
    id: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    departmentId?: string | null
    teamId?: string | null
    categoryId?: string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: number | null
    featuresVersion?: string | null
    lastFeaturesGeneratedAt?: Date | string | null
    hotspot_signals?: hotspot_signalsUncheckedCreateNestedManyWithoutSignalsInput
  }

  export type signalsCreateOrConnectWithoutAi_insight_overridesInput = {
    where: signalsWhereUniqueInput
    create: XOR<signalsCreateWithoutAi_insight_overridesInput, signalsUncheckedCreateWithoutAi_insight_overridesInput>
  }

  export type usersUpsertWithoutAi_insight_overridesInput = {
    update: XOR<usersUpdateWithoutAi_insight_overridesInput, usersUncheckedUpdateWithoutAi_insight_overridesInput>
    create: XOR<usersCreateWithoutAi_insight_overridesInput, usersUncheckedCreateWithoutAi_insight_overridesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAi_insight_overridesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAi_insight_overridesInput, usersUncheckedUpdateWithoutAi_insight_overridesInput>
  }

  export type usersUpdateWithoutAi_insight_overridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    ai_analysis_audit?: ai_analysis_auditUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUpdateManyWithoutUsersNestedInput
    inputs?: inputsUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUpdateManyWithoutUsersNestedInput
    signals?: signalsUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    departments_users_departmentObjIdTodepartments?: departmentsUpdateOneWithoutUsers_users_departmentObjIdTodepartmentsNestedInput
    users?: usersUpdateOneWithoutOther_usersNestedInput
    other_users?: usersUpdateManyWithoutUsersNestedInput
    votes?: votesUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUncheckedUpdateWithoutAi_insight_overridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUncheckedUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUncheckedUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUncheckedUpdateManyWithoutUsersNestedInput
    inputs?: inputsUncheckedUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutUsersNestedInput
    signals?: signalsUncheckedUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    other_users?: usersUncheckedUpdateManyWithoutUsersNestedInput
    votes?: votesUncheckedUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUncheckedUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type signalsUpsertWithoutAi_insight_overridesInput = {
    update: XOR<signalsUpdateWithoutAi_insight_overridesInput, signalsUncheckedUpdateWithoutAi_insight_overridesInput>
    create: XOR<signalsCreateWithoutAi_insight_overridesInput, signalsUncheckedCreateWithoutAi_insight_overridesInput>
    where?: signalsWhereInput
  }

  export type signalsUpdateToOneWithWhereWithoutAi_insight_overridesInput = {
    where?: signalsWhereInput
    data: XOR<signalsUpdateWithoutAi_insight_overridesInput, signalsUncheckedUpdateWithoutAi_insight_overridesInput>
  }

  export type signalsUpdateWithoutAi_insight_overridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    featuresVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastFeaturesGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotspot_signals?: hotspot_signalsUpdateManyWithoutSignalsNestedInput
    categories?: categoriesUpdateOneWithoutSignalsNestedInput
    users?: usersUpdateOneWithoutSignalsNestedInput
    departments?: departmentsUpdateOneWithoutSignalsNestedInput
    teams?: teamsUpdateOneWithoutSignalsNestedInput
  }

  export type signalsUncheckedUpdateWithoutAi_insight_overridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    featuresVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastFeaturesGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotspot_signals?: hotspot_signalsUncheckedUpdateManyWithoutSignalsNestedInput
  }

  export type usersCreateWithoutAudit_logsInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    ai_analysis_audit?: ai_analysis_auditCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasCreateNestedManyWithoutUsersInput
    initiatives?: initiativesCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsCreateNestedManyWithoutUsersInput
    inputs?: inputsCreateNestedManyWithoutUsersInput
    requirements?: requirementsCreateNestedManyWithoutUsersInput
    signals?: signalsCreateNestedManyWithoutUsersInput
    solutions?: solutionsCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    departments_users_departmentObjIdTodepartments?: departmentsCreateNestedOneWithoutUsers_users_departmentObjIdTodepartmentsInput
    users?: usersCreateNestedOneWithoutOther_usersInput
    other_users?: usersCreateNestedManyWithoutUsersInput
    votes?: votesCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersUncheckedCreateWithoutAudit_logsInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    managerId?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    departmentObjId?: string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsUncheckedCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasUncheckedCreateNestedManyWithoutUsersInput
    initiatives?: initiativesUncheckedCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsUncheckedCreateNestedManyWithoutUsersInput
    inputs?: inputsUncheckedCreateNestedManyWithoutUsersInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutUsersInput
    signals?: signalsUncheckedCreateNestedManyWithoutUsersInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsUncheckedCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    other_users?: usersUncheckedCreateNestedManyWithoutUsersInput
    votes?: votesUncheckedCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsUncheckedCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersCreateOrConnectWithoutAudit_logsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAudit_logsInput, usersUncheckedCreateWithoutAudit_logsInput>
  }

  export type usersUpsertWithoutAudit_logsInput = {
    update: XOR<usersUpdateWithoutAudit_logsInput, usersUncheckedUpdateWithoutAudit_logsInput>
    create: XOR<usersCreateWithoutAudit_logsInput, usersUncheckedCreateWithoutAudit_logsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAudit_logsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAudit_logsInput, usersUncheckedUpdateWithoutAudit_logsInput>
  }

  export type usersUpdateWithoutAudit_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    ai_analysis_audit?: ai_analysis_auditUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUpdateManyWithoutUsersNestedInput
    inputs?: inputsUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUpdateManyWithoutUsersNestedInput
    signals?: signalsUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    departments_users_departmentObjIdTodepartments?: departmentsUpdateOneWithoutUsers_users_departmentObjIdTodepartmentsNestedInput
    users?: usersUpdateOneWithoutOther_usersNestedInput
    other_users?: usersUpdateManyWithoutUsersNestedInput
    votes?: votesUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUncheckedUpdateWithoutAudit_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUncheckedUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUncheckedUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUncheckedUpdateManyWithoutUsersNestedInput
    inputs?: inputsUncheckedUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutUsersNestedInput
    signals?: signalsUncheckedUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    other_users?: usersUncheckedUpdateManyWithoutUsersNestedInput
    votes?: votesUncheckedUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUncheckedUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type categoriesCreateWithoutOther_categoriesInput = {
    id: string
    name: string
    description?: string | null
    color?: string | null
    icon?: string | null
    isActive?: boolean
    sortOrder?: number
    usageCount?: number
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    categories?: categoriesCreateNestedOneWithoutOther_categoriesInput
    signals?: signalsCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateWithoutOther_categoriesInput = {
    id: string
    name: string
    description?: string | null
    color?: string | null
    icon?: string | null
    parentId?: string | null
    isActive?: boolean
    sortOrder?: number
    usageCount?: number
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    signals?: signalsUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesCreateOrConnectWithoutOther_categoriesInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutOther_categoriesInput, categoriesUncheckedCreateWithoutOther_categoriesInput>
  }

  export type categoriesCreateWithoutCategoriesInput = {
    id: string
    name: string
    description?: string | null
    color?: string | null
    icon?: string | null
    isActive?: boolean
    sortOrder?: number
    usageCount?: number
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    other_categories?: categoriesCreateNestedManyWithoutCategoriesInput
    signals?: signalsCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateWithoutCategoriesInput = {
    id: string
    name: string
    description?: string | null
    color?: string | null
    icon?: string | null
    isActive?: boolean
    sortOrder?: number
    usageCount?: number
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    other_categories?: categoriesUncheckedCreateNestedManyWithoutCategoriesInput
    signals?: signalsUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesCreateOrConnectWithoutCategoriesInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutCategoriesInput, categoriesUncheckedCreateWithoutCategoriesInput>
  }

  export type categoriesCreateManyCategoriesInputEnvelope = {
    data: categoriesCreateManyCategoriesInput | categoriesCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type signalsCreateWithoutCategoriesInput = {
    id: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: number | null
    featuresVersion?: string | null
    lastFeaturesGeneratedAt?: Date | string | null
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutSignalsInput
    hotspot_signals?: hotspot_signalsCreateNestedManyWithoutSignalsInput
    users?: usersCreateNestedOneWithoutSignalsInput
    departments?: departmentsCreateNestedOneWithoutSignalsInput
    teams?: teamsCreateNestedOneWithoutSignalsInput
  }

  export type signalsUncheckedCreateWithoutCategoriesInput = {
    id: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    departmentId?: string | null
    teamId?: string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: number | null
    featuresVersion?: string | null
    lastFeaturesGeneratedAt?: Date | string | null
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutSignalsInput
    hotspot_signals?: hotspot_signalsUncheckedCreateNestedManyWithoutSignalsInput
  }

  export type signalsCreateOrConnectWithoutCategoriesInput = {
    where: signalsWhereUniqueInput
    create: XOR<signalsCreateWithoutCategoriesInput, signalsUncheckedCreateWithoutCategoriesInput>
  }

  export type signalsCreateManyCategoriesInputEnvelope = {
    data: signalsCreateManyCategoriesInput | signalsCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type categoriesUpsertWithoutOther_categoriesInput = {
    update: XOR<categoriesUpdateWithoutOther_categoriesInput, categoriesUncheckedUpdateWithoutOther_categoriesInput>
    create: XOR<categoriesCreateWithoutOther_categoriesInput, categoriesUncheckedCreateWithoutOther_categoriesInput>
    where?: categoriesWhereInput
  }

  export type categoriesUpdateToOneWithWhereWithoutOther_categoriesInput = {
    where?: categoriesWhereInput
    data: XOR<categoriesUpdateWithoutOther_categoriesInput, categoriesUncheckedUpdateWithoutOther_categoriesInput>
  }

  export type categoriesUpdateWithoutOther_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: categoriesUpdateOneWithoutOther_categoriesNestedInput
    signals?: signalsUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateWithoutOther_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: signalsUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: categoriesWhereUniqueInput
    update: XOR<categoriesUpdateWithoutCategoriesInput, categoriesUncheckedUpdateWithoutCategoriesInput>
    create: XOR<categoriesCreateWithoutCategoriesInput, categoriesUncheckedCreateWithoutCategoriesInput>
  }

  export type categoriesUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: categoriesWhereUniqueInput
    data: XOR<categoriesUpdateWithoutCategoriesInput, categoriesUncheckedUpdateWithoutCategoriesInput>
  }

  export type categoriesUpdateManyWithWhereWithoutCategoriesInput = {
    where: categoriesScalarWhereInput
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type categoriesScalarWhereInput = {
    AND?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
    OR?: categoriesScalarWhereInput[]
    NOT?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
    id?: StringFilter<"categories"> | string
    name?: StringFilter<"categories"> | string
    description?: StringNullableFilter<"categories"> | string | null
    color?: StringNullableFilter<"categories"> | string | null
    icon?: StringNullableFilter<"categories"> | string | null
    parentId?: StringNullableFilter<"categories"> | string | null
    isActive?: BoolFilter<"categories"> | boolean
    sortOrder?: IntFilter<"categories"> | number
    usageCount?: IntFilter<"categories"> | number
    isSystem?: BoolFilter<"categories"> | boolean
    createdAt?: DateTimeFilter<"categories"> | Date | string
    updatedAt?: DateTimeFilter<"categories"> | Date | string
  }

  export type signalsUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: signalsWhereUniqueInput
    update: XOR<signalsUpdateWithoutCategoriesInput, signalsUncheckedUpdateWithoutCategoriesInput>
    create: XOR<signalsCreateWithoutCategoriesInput, signalsUncheckedCreateWithoutCategoriesInput>
  }

  export type signalsUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: signalsWhereUniqueInput
    data: XOR<signalsUpdateWithoutCategoriesInput, signalsUncheckedUpdateWithoutCategoriesInput>
  }

  export type signalsUpdateManyWithWhereWithoutCategoriesInput = {
    where: signalsScalarWhereInput
    data: XOR<signalsUpdateManyMutationInput, signalsUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type signalsScalarWhereInput = {
    AND?: signalsScalarWhereInput | signalsScalarWhereInput[]
    OR?: signalsScalarWhereInput[]
    NOT?: signalsScalarWhereInput | signalsScalarWhereInput[]
    id?: StringFilter<"signals"> | string
    inputId?: StringFilter<"signals"> | string
    timestamp?: DateTimeFilter<"signals"> | Date | string
    receivedAt?: DateTimeFilter<"signals"> | Date | string
    schemaVersion?: StringFilter<"signals"> | string
    sourceJson?: JsonNullableFilter<"signals">
    confidence?: FloatNullableFilter<"signals"> | number | null
    attachmentsJson?: JsonNullableFilter<"signals">
    sourceType?: StringFilter<"signals"> | string
    sourceId?: StringNullableFilter<"signals"> | string | null
    systemName?: StringNullableFilter<"signals"> | string | null
    title?: StringNullableFilter<"signals"> | string | null
    description?: StringFilter<"signals"> | string
    severity?: EnumSeverityFilter<"signals"> | $Enums.Severity
    severityScore?: IntFilter<"signals"> | number
    departmentId?: StringNullableFilter<"signals"> | string | null
    teamId?: StringNullableFilter<"signals"> | string | null
    categoryId?: StringNullableFilter<"signals"> | string | null
    metricsJson?: JsonNullableFilter<"signals">
    baselineJson?: JsonNullableFilter<"signals">
    impactJson?: JsonNullableFilter<"signals">
    tagsJson?: JsonNullableFilter<"signals">
    entitiesJson?: JsonNullableFilter<"signals">
    privacyLevel?: StringNullableFilter<"signals"> | string | null
    dedupeKey?: StringNullableFilter<"signals"> | string | null
    embedding?: BytesNullableFilter<"signals"> | Uint8Array | null
    aiProcessed?: BoolFilter<"signals"> | boolean
    aiTagsJson?: JsonNullableFilter<"signals">
    lineageJson?: JsonNullableFilter<"signals">
    createdById?: StringNullableFilter<"signals"> | string | null
    createdAt?: DateTimeFilter<"signals"> | Date | string
    updatedAt?: DateTimeFilter<"signals"> | Date | string
    domainClassification?: JsonNullableFilter<"signals">
    enhancedTagsJson?: JsonNullableFilter<"signals">
    lastTaggedAt?: DateTimeNullableFilter<"signals"> | Date | string | null
    tagGenerationMeta?: JsonNullableFilter<"signals">
    tagModelVersion?: StringNullableFilter<"signals"> | string | null
    clusteringFeaturesJson?: JsonNullableFilter<"signals">
    featuresQualityScore?: FloatNullableFilter<"signals"> | number | null
    featuresVersion?: StringNullableFilter<"signals"> | string | null
    lastFeaturesGeneratedAt?: DateTimeNullableFilter<"signals"> | Date | string | null
  }

  export type usersCreateWithoutCommentsInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    ai_analysis_audit?: ai_analysis_auditCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasCreateNestedManyWithoutUsersInput
    initiatives?: initiativesCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsCreateNestedManyWithoutUsersInput
    inputs?: inputsCreateNestedManyWithoutUsersInput
    requirements?: requirementsCreateNestedManyWithoutUsersInput
    signals?: signalsCreateNestedManyWithoutUsersInput
    solutions?: solutionsCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    departments_users_departmentObjIdTodepartments?: departmentsCreateNestedOneWithoutUsers_users_departmentObjIdTodepartmentsInput
    users?: usersCreateNestedOneWithoutOther_usersInput
    other_users?: usersCreateNestedManyWithoutUsersInput
    votes?: votesCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersUncheckedCreateWithoutCommentsInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    managerId?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    departmentObjId?: string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsUncheckedCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasUncheckedCreateNestedManyWithoutUsersInput
    initiatives?: initiativesUncheckedCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsUncheckedCreateNestedManyWithoutUsersInput
    inputs?: inputsUncheckedCreateNestedManyWithoutUsersInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutUsersInput
    signals?: signalsUncheckedCreateNestedManyWithoutUsersInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsUncheckedCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    other_users?: usersUncheckedCreateNestedManyWithoutUsersInput
    votes?: votesUncheckedCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsUncheckedCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersCreateOrConnectWithoutCommentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>
  }

  export type commentsCreateWithoutOther_commentsInput = {
    id: string
    content: string
    createdAt?: Date | string
    updatedAt: Date | string
    edited?: boolean
    editedAt?: Date | string | null
    entityId: string
    entityType: $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
    users: usersCreateNestedOneWithoutCommentsInput
    comments?: commentsCreateNestedOneWithoutOther_commentsInput
  }

  export type commentsUncheckedCreateWithoutOther_commentsInput = {
    id: string
    content: string
    createdAt?: Date | string
    updatedAt: Date | string
    parentId?: string | null
    createdBy: string
    edited?: boolean
    editedAt?: Date | string | null
    entityId: string
    entityType: $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type commentsCreateOrConnectWithoutOther_commentsInput = {
    where: commentsWhereUniqueInput
    create: XOR<commentsCreateWithoutOther_commentsInput, commentsUncheckedCreateWithoutOther_commentsInput>
  }

  export type commentsCreateWithoutCommentsInput = {
    id: string
    content: string
    createdAt?: Date | string
    updatedAt: Date | string
    edited?: boolean
    editedAt?: Date | string | null
    entityId: string
    entityType: $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
    users: usersCreateNestedOneWithoutCommentsInput
    other_comments?: commentsCreateNestedManyWithoutCommentsInput
  }

  export type commentsUncheckedCreateWithoutCommentsInput = {
    id: string
    content: string
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy: string
    edited?: boolean
    editedAt?: Date | string | null
    entityId: string
    entityType: $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
    other_comments?: commentsUncheckedCreateNestedManyWithoutCommentsInput
  }

  export type commentsCreateOrConnectWithoutCommentsInput = {
    where: commentsWhereUniqueInput
    create: XOR<commentsCreateWithoutCommentsInput, commentsUncheckedCreateWithoutCommentsInput>
  }

  export type commentsCreateManyCommentsInputEnvelope = {
    data: commentsCreateManyCommentsInput | commentsCreateManyCommentsInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithoutCommentsInput = {
    update: XOR<usersUpdateWithoutCommentsInput, usersUncheckedUpdateWithoutCommentsInput>
    create: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCommentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCommentsInput, usersUncheckedUpdateWithoutCommentsInput>
  }

  export type usersUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    ai_analysis_audit?: ai_analysis_auditUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUpdateManyWithoutUsersNestedInput
    inputs?: inputsUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUpdateManyWithoutUsersNestedInput
    signals?: signalsUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    departments_users_departmentObjIdTodepartments?: departmentsUpdateOneWithoutUsers_users_departmentObjIdTodepartmentsNestedInput
    users?: usersUpdateOneWithoutOther_usersNestedInput
    other_users?: usersUpdateManyWithoutUsersNestedInput
    votes?: votesUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUncheckedUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUncheckedUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUncheckedUpdateManyWithoutUsersNestedInput
    inputs?: inputsUncheckedUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutUsersNestedInput
    signals?: signalsUncheckedUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    other_users?: usersUncheckedUpdateManyWithoutUsersNestedInput
    votes?: votesUncheckedUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUncheckedUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type commentsUpsertWithoutOther_commentsInput = {
    update: XOR<commentsUpdateWithoutOther_commentsInput, commentsUncheckedUpdateWithoutOther_commentsInput>
    create: XOR<commentsCreateWithoutOther_commentsInput, commentsUncheckedCreateWithoutOther_commentsInput>
    where?: commentsWhereInput
  }

  export type commentsUpdateToOneWithWhereWithoutOther_commentsInput = {
    where?: commentsWhereInput
    data: XOR<commentsUpdateWithoutOther_commentsInput, commentsUncheckedUpdateWithoutOther_commentsInput>
  }

  export type commentsUpdateWithoutOther_commentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
    users?: usersUpdateOneRequiredWithoutCommentsNestedInput
    comments?: commentsUpdateOneWithoutOther_commentsNestedInput
  }

  export type commentsUncheckedUpdateWithoutOther_commentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type commentsUpsertWithWhereUniqueWithoutCommentsInput = {
    where: commentsWhereUniqueInput
    update: XOR<commentsUpdateWithoutCommentsInput, commentsUncheckedUpdateWithoutCommentsInput>
    create: XOR<commentsCreateWithoutCommentsInput, commentsUncheckedCreateWithoutCommentsInput>
  }

  export type commentsUpdateWithWhereUniqueWithoutCommentsInput = {
    where: commentsWhereUniqueInput
    data: XOR<commentsUpdateWithoutCommentsInput, commentsUncheckedUpdateWithoutCommentsInput>
  }

  export type commentsUpdateManyWithWhereWithoutCommentsInput = {
    where: commentsScalarWhereInput
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyWithoutCommentsInput>
  }

  export type commentsScalarWhereInput = {
    AND?: commentsScalarWhereInput | commentsScalarWhereInput[]
    OR?: commentsScalarWhereInput[]
    NOT?: commentsScalarWhereInput | commentsScalarWhereInput[]
    id?: StringFilter<"comments"> | string
    content?: StringFilter<"comments"> | string
    createdAt?: DateTimeFilter<"comments"> | Date | string
    updatedAt?: DateTimeFilter<"comments"> | Date | string
    parentId?: StringNullableFilter<"comments"> | string | null
    createdBy?: StringFilter<"comments"> | string
    edited?: BoolFilter<"comments"> | boolean
    editedAt?: DateTimeNullableFilter<"comments"> | Date | string | null
    entityId?: StringFilter<"comments"> | string
    entityType?: EnumEntityTypeFilter<"comments"> | $Enums.EntityType
    mentions?: JsonNullableFilter<"comments">
  }

  export type usersCreateWithoutDepartments_departments_managerIdTousersInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    ai_analysis_audit?: ai_analysis_auditCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasCreateNestedManyWithoutUsersInput
    initiatives?: initiativesCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsCreateNestedManyWithoutUsersInput
    inputs?: inputsCreateNestedManyWithoutUsersInput
    requirements?: requirementsCreateNestedManyWithoutUsersInput
    signals?: signalsCreateNestedManyWithoutUsersInput
    solutions?: solutionsCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    departments_users_departmentObjIdTodepartments?: departmentsCreateNestedOneWithoutUsers_users_departmentObjIdTodepartmentsInput
    users?: usersCreateNestedOneWithoutOther_usersInput
    other_users?: usersCreateNestedManyWithoutUsersInput
    votes?: votesCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersUncheckedCreateWithoutDepartments_departments_managerIdTousersInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    managerId?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    departmentObjId?: string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasUncheckedCreateNestedManyWithoutUsersInput
    initiatives?: initiativesUncheckedCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsUncheckedCreateNestedManyWithoutUsersInput
    inputs?: inputsUncheckedCreateNestedManyWithoutUsersInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutUsersInput
    signals?: signalsUncheckedCreateNestedManyWithoutUsersInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsUncheckedCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    other_users?: usersUncheckedCreateNestedManyWithoutUsersInput
    votes?: votesUncheckedCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsUncheckedCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersCreateOrConnectWithoutDepartments_departments_managerIdTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutDepartments_departments_managerIdTousersInput, usersUncheckedCreateWithoutDepartments_departments_managerIdTousersInput>
  }

  export type signalsCreateWithoutDepartmentsInput = {
    id: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: number | null
    featuresVersion?: string | null
    lastFeaturesGeneratedAt?: Date | string | null
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutSignalsInput
    hotspot_signals?: hotspot_signalsCreateNestedManyWithoutSignalsInput
    categories?: categoriesCreateNestedOneWithoutSignalsInput
    users?: usersCreateNestedOneWithoutSignalsInput
    teams?: teamsCreateNestedOneWithoutSignalsInput
  }

  export type signalsUncheckedCreateWithoutDepartmentsInput = {
    id: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    teamId?: string | null
    categoryId?: string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: number | null
    featuresVersion?: string | null
    lastFeaturesGeneratedAt?: Date | string | null
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutSignalsInput
    hotspot_signals?: hotspot_signalsUncheckedCreateNestedManyWithoutSignalsInput
  }

  export type signalsCreateOrConnectWithoutDepartmentsInput = {
    where: signalsWhereUniqueInput
    create: XOR<signalsCreateWithoutDepartmentsInput, signalsUncheckedCreateWithoutDepartmentsInput>
  }

  export type signalsCreateManyDepartmentsInputEnvelope = {
    data: signalsCreateManyDepartmentsInput | signalsCreateManyDepartmentsInput[]
    skipDuplicates?: boolean
  }

  export type teamsCreateWithoutDepartmentsInput = {
    id: string
    name: string
    description?: string | null
    memberCount?: number
    maxCapacity?: number | null
    isActive?: boolean
    teamType?: string | null
    currentProjects?: number
    budgetAllocation?: number
    utilizationRate?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    signals?: signalsCreateNestedManyWithoutTeamsInput
    users_teams_leaderIdTousers?: usersCreateNestedOneWithoutTeams_teams_leaderIdTousersInput
    users_TeamMembers?: usersCreateNestedManyWithoutTeams_TeamMembersInput
  }

  export type teamsUncheckedCreateWithoutDepartmentsInput = {
    id: string
    name: string
    description?: string | null
    leaderId?: string | null
    memberCount?: number
    maxCapacity?: number | null
    isActive?: boolean
    teamType?: string | null
    currentProjects?: number
    budgetAllocation?: number
    utilizationRate?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    signals?: signalsUncheckedCreateNestedManyWithoutTeamsInput
    users_TeamMembers?: usersUncheckedCreateNestedManyWithoutTeams_TeamMembersInput
  }

  export type teamsCreateOrConnectWithoutDepartmentsInput = {
    where: teamsWhereUniqueInput
    create: XOR<teamsCreateWithoutDepartmentsInput, teamsUncheckedCreateWithoutDepartmentsInput>
  }

  export type teamsCreateManyDepartmentsInputEnvelope = {
    data: teamsCreateManyDepartmentsInput | teamsCreateManyDepartmentsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutDepartments_users_departmentObjIdTodepartmentsInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    ai_analysis_audit?: ai_analysis_auditCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasCreateNestedManyWithoutUsersInput
    initiatives?: initiativesCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsCreateNestedManyWithoutUsersInput
    inputs?: inputsCreateNestedManyWithoutUsersInput
    requirements?: requirementsCreateNestedManyWithoutUsersInput
    signals?: signalsCreateNestedManyWithoutUsersInput
    solutions?: solutionsCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    users?: usersCreateNestedOneWithoutOther_usersInput
    other_users?: usersCreateNestedManyWithoutUsersInput
    votes?: votesCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersUncheckedCreateWithoutDepartments_users_departmentObjIdTodepartmentsInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    managerId?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    ai_analysis_audit?: ai_analysis_auditUncheckedCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsUncheckedCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasUncheckedCreateNestedManyWithoutUsersInput
    initiatives?: initiativesUncheckedCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsUncheckedCreateNestedManyWithoutUsersInput
    inputs?: inputsUncheckedCreateNestedManyWithoutUsersInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutUsersInput
    signals?: signalsUncheckedCreateNestedManyWithoutUsersInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsUncheckedCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    other_users?: usersUncheckedCreateNestedManyWithoutUsersInput
    votes?: votesUncheckedCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsUncheckedCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersCreateOrConnectWithoutDepartments_users_departmentObjIdTodepartmentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutDepartments_users_departmentObjIdTodepartmentsInput, usersUncheckedCreateWithoutDepartments_users_departmentObjIdTodepartmentsInput>
  }

  export type usersCreateManyDepartments_users_departmentObjIdTodepartmentsInputEnvelope = {
    data: usersCreateManyDepartments_users_departmentObjIdTodepartmentsInput | usersCreateManyDepartments_users_departmentObjIdTodepartmentsInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithoutDepartments_departments_managerIdTousersInput = {
    update: XOR<usersUpdateWithoutDepartments_departments_managerIdTousersInput, usersUncheckedUpdateWithoutDepartments_departments_managerIdTousersInput>
    create: XOR<usersCreateWithoutDepartments_departments_managerIdTousersInput, usersUncheckedCreateWithoutDepartments_departments_managerIdTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutDepartments_departments_managerIdTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutDepartments_departments_managerIdTousersInput, usersUncheckedUpdateWithoutDepartments_departments_managerIdTousersInput>
  }

  export type usersUpdateWithoutDepartments_departments_managerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    ai_analysis_audit?: ai_analysis_auditUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUpdateManyWithoutUsersNestedInput
    inputs?: inputsUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUpdateManyWithoutUsersNestedInput
    signals?: signalsUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    departments_users_departmentObjIdTodepartments?: departmentsUpdateOneWithoutUsers_users_departmentObjIdTodepartmentsNestedInput
    users?: usersUpdateOneWithoutOther_usersNestedInput
    other_users?: usersUpdateManyWithoutUsersNestedInput
    votes?: votesUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUncheckedUpdateWithoutDepartments_departments_managerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUncheckedUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUncheckedUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUncheckedUpdateManyWithoutUsersNestedInput
    inputs?: inputsUncheckedUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutUsersNestedInput
    signals?: signalsUncheckedUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    other_users?: usersUncheckedUpdateManyWithoutUsersNestedInput
    votes?: votesUncheckedUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUncheckedUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type signalsUpsertWithWhereUniqueWithoutDepartmentsInput = {
    where: signalsWhereUniqueInput
    update: XOR<signalsUpdateWithoutDepartmentsInput, signalsUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<signalsCreateWithoutDepartmentsInput, signalsUncheckedCreateWithoutDepartmentsInput>
  }

  export type signalsUpdateWithWhereUniqueWithoutDepartmentsInput = {
    where: signalsWhereUniqueInput
    data: XOR<signalsUpdateWithoutDepartmentsInput, signalsUncheckedUpdateWithoutDepartmentsInput>
  }

  export type signalsUpdateManyWithWhereWithoutDepartmentsInput = {
    where: signalsScalarWhereInput
    data: XOR<signalsUpdateManyMutationInput, signalsUncheckedUpdateManyWithoutDepartmentsInput>
  }

  export type teamsUpsertWithWhereUniqueWithoutDepartmentsInput = {
    where: teamsWhereUniqueInput
    update: XOR<teamsUpdateWithoutDepartmentsInput, teamsUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<teamsCreateWithoutDepartmentsInput, teamsUncheckedCreateWithoutDepartmentsInput>
  }

  export type teamsUpdateWithWhereUniqueWithoutDepartmentsInput = {
    where: teamsWhereUniqueInput
    data: XOR<teamsUpdateWithoutDepartmentsInput, teamsUncheckedUpdateWithoutDepartmentsInput>
  }

  export type teamsUpdateManyWithWhereWithoutDepartmentsInput = {
    where: teamsScalarWhereInput
    data: XOR<teamsUpdateManyMutationInput, teamsUncheckedUpdateManyWithoutDepartmentsInput>
  }

  export type teamsScalarWhereInput = {
    AND?: teamsScalarWhereInput | teamsScalarWhereInput[]
    OR?: teamsScalarWhereInput[]
    NOT?: teamsScalarWhereInput | teamsScalarWhereInput[]
    id?: StringFilter<"teams"> | string
    name?: StringFilter<"teams"> | string
    description?: StringNullableFilter<"teams"> | string | null
    departmentId?: StringNullableFilter<"teams"> | string | null
    leaderId?: StringNullableFilter<"teams"> | string | null
    memberCount?: IntFilter<"teams"> | number
    maxCapacity?: IntNullableFilter<"teams"> | number | null
    isActive?: BoolFilter<"teams"> | boolean
    teamType?: StringNullableFilter<"teams"> | string | null
    currentProjects?: IntFilter<"teams"> | number
    budgetAllocation?: FloatFilter<"teams"> | number
    utilizationRate?: FloatNullableFilter<"teams"> | number | null
    createdAt?: DateTimeFilter<"teams"> | Date | string
    updatedAt?: DateTimeFilter<"teams"> | Date | string
  }

  export type usersUpsertWithWhereUniqueWithoutDepartments_users_departmentObjIdTodepartmentsInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutDepartments_users_departmentObjIdTodepartmentsInput, usersUncheckedUpdateWithoutDepartments_users_departmentObjIdTodepartmentsInput>
    create: XOR<usersCreateWithoutDepartments_users_departmentObjIdTodepartmentsInput, usersUncheckedCreateWithoutDepartments_users_departmentObjIdTodepartmentsInput>
  }

  export type usersUpdateWithWhereUniqueWithoutDepartments_users_departmentObjIdTodepartmentsInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutDepartments_users_departmentObjIdTodepartmentsInput, usersUncheckedUpdateWithoutDepartments_users_departmentObjIdTodepartmentsInput>
  }

  export type usersUpdateManyWithWhereWithoutDepartments_users_departmentObjIdTodepartmentsInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutDepartments_users_departmentObjIdTodepartmentsInput>
  }

  export type usersScalarWhereInput = {
    AND?: usersScalarWhereInput | usersScalarWhereInput[]
    OR?: usersScalarWhereInput[]
    NOT?: usersScalarWhereInput | usersScalarWhereInput[]
    id?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    name?: StringFilter<"users"> | string
    role?: EnumUserRoleFilter<"users"> | $Enums.UserRole
    department?: StringNullableFilter<"users"> | string | null
    avatar?: StringNullableFilter<"users"> | string | null
    passwordHash?: StringNullableFilter<"users"> | string | null
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    title?: StringNullableFilter<"users"> | string | null
    managerId?: StringNullableFilter<"users"> | string | null
    billableRate?: FloatNullableFilter<"users"> | number | null
    costCenter?: StringNullableFilter<"users"> | string | null
    location?: StringNullableFilter<"users"> | string | null
    isActive?: BoolFilter<"users"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"users"> | Date | string | null
    profileJson?: JsonNullableFilter<"users">
    targetUtilization?: FloatNullableFilter<"users"> | number | null
    utilizationRate?: FloatNullableFilter<"users"> | number | null
    departmentObjId?: StringNullableFilter<"users"> | string | null
  }

  export type usersCreateWithoutFrd_documents_frd_documents_approvedByTousersInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    ai_analysis_audit?: ai_analysis_auditCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasCreateNestedManyWithoutUsersInput
    initiatives?: initiativesCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsCreateNestedManyWithoutUsersInput
    inputs?: inputsCreateNestedManyWithoutUsersInput
    requirements?: requirementsCreateNestedManyWithoutUsersInput
    signals?: signalsCreateNestedManyWithoutUsersInput
    solutions?: solutionsCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    departments_users_departmentObjIdTodepartments?: departmentsCreateNestedOneWithoutUsers_users_departmentObjIdTodepartmentsInput
    users?: usersCreateNestedOneWithoutOther_usersInput
    other_users?: usersCreateNestedManyWithoutUsersInput
    votes?: votesCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersUncheckedCreateWithoutFrd_documents_frd_documents_approvedByTousersInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    managerId?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    departmentObjId?: string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsUncheckedCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasUncheckedCreateNestedManyWithoutUsersInput
    initiatives?: initiativesUncheckedCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsUncheckedCreateNestedManyWithoutUsersInput
    inputs?: inputsUncheckedCreateNestedManyWithoutUsersInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutUsersInput
    signals?: signalsUncheckedCreateNestedManyWithoutUsersInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsUncheckedCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    other_users?: usersUncheckedCreateNestedManyWithoutUsersInput
    votes?: votesUncheckedCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsUncheckedCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersCreateOrConnectWithoutFrd_documents_frd_documents_approvedByTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutFrd_documents_frd_documents_approvedByTousersInput, usersUncheckedCreateWithoutFrd_documents_frd_documents_approvedByTousersInput>
  }

  export type usersCreateWithoutFrd_documents_frd_documents_createdByTousersInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    ai_analysis_audit?: ai_analysis_auditCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    ideas?: ideasCreateNestedManyWithoutUsersInput
    initiatives?: initiativesCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsCreateNestedManyWithoutUsersInput
    inputs?: inputsCreateNestedManyWithoutUsersInput
    requirements?: requirementsCreateNestedManyWithoutUsersInput
    signals?: signalsCreateNestedManyWithoutUsersInput
    solutions?: solutionsCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    departments_users_departmentObjIdTodepartments?: departmentsCreateNestedOneWithoutUsers_users_departmentObjIdTodepartmentsInput
    users?: usersCreateNestedOneWithoutOther_usersInput
    other_users?: usersCreateNestedManyWithoutUsersInput
    votes?: votesCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersUncheckedCreateWithoutFrd_documents_frd_documents_createdByTousersInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    managerId?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    departmentObjId?: string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsUncheckedCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    ideas?: ideasUncheckedCreateNestedManyWithoutUsersInput
    initiatives?: initiativesUncheckedCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsUncheckedCreateNestedManyWithoutUsersInput
    inputs?: inputsUncheckedCreateNestedManyWithoutUsersInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutUsersInput
    signals?: signalsUncheckedCreateNestedManyWithoutUsersInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsUncheckedCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    other_users?: usersUncheckedCreateNestedManyWithoutUsersInput
    votes?: votesUncheckedCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsUncheckedCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersCreateOrConnectWithoutFrd_documents_frd_documents_createdByTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutFrd_documents_frd_documents_createdByTousersInput, usersUncheckedCreateWithoutFrd_documents_frd_documents_createdByTousersInput>
  }

  export type solutionsCreateWithoutFrd_documentsInput = {
    id: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    createdAt?: Date | string
    updatedAt: Date | string
    estimatedEffort?: string | null
    actualCompletionDate?: Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    requirements?: requirementsCreateNestedManyWithoutSolutionsInput
    users: usersCreateNestedOneWithoutSolutionsInput
    hotspots?: hotspotsCreateNestedOneWithoutSolutionsInput
    ideas?: ideasCreateNestedOneWithoutSolutionsInput
    initiatives?: initiativesCreateNestedOneWithoutSolutionsInput
    inputs?: inputsCreateNestedOneWithoutSolutionsInput
  }

  export type solutionsUncheckedCreateWithoutFrd_documentsInput = {
    id: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    createdAt?: Date | string
    updatedAt: Date | string
    estimatedEffort?: string | null
    actualCompletionDate?: Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    createdBy: string
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    hotspotId?: string | null
    ideaId?: string | null
    initiativeId?: string | null
    inputId?: string | null
    progress?: number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    requirements?: requirementsUncheckedCreateNestedManyWithoutSolutionsInput
  }

  export type solutionsCreateOrConnectWithoutFrd_documentsInput = {
    where: solutionsWhereUniqueInput
    create: XOR<solutionsCreateWithoutFrd_documentsInput, solutionsUncheckedCreateWithoutFrd_documentsInput>
  }

  export type usersUpsertWithoutFrd_documents_frd_documents_approvedByTousersInput = {
    update: XOR<usersUpdateWithoutFrd_documents_frd_documents_approvedByTousersInput, usersUncheckedUpdateWithoutFrd_documents_frd_documents_approvedByTousersInput>
    create: XOR<usersCreateWithoutFrd_documents_frd_documents_approvedByTousersInput, usersUncheckedCreateWithoutFrd_documents_frd_documents_approvedByTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutFrd_documents_frd_documents_approvedByTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutFrd_documents_frd_documents_approvedByTousersInput, usersUncheckedUpdateWithoutFrd_documents_frd_documents_approvedByTousersInput>
  }

  export type usersUpdateWithoutFrd_documents_frd_documents_approvedByTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    ai_analysis_audit?: ai_analysis_auditUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUpdateManyWithoutUsersNestedInput
    inputs?: inputsUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUpdateManyWithoutUsersNestedInput
    signals?: signalsUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    departments_users_departmentObjIdTodepartments?: departmentsUpdateOneWithoutUsers_users_departmentObjIdTodepartmentsNestedInput
    users?: usersUpdateOneWithoutOther_usersNestedInput
    other_users?: usersUpdateManyWithoutUsersNestedInput
    votes?: votesUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUncheckedUpdateWithoutFrd_documents_frd_documents_approvedByTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUncheckedUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUncheckedUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUncheckedUpdateManyWithoutUsersNestedInput
    inputs?: inputsUncheckedUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutUsersNestedInput
    signals?: signalsUncheckedUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    other_users?: usersUncheckedUpdateManyWithoutUsersNestedInput
    votes?: votesUncheckedUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUncheckedUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUpsertWithoutFrd_documents_frd_documents_createdByTousersInput = {
    update: XOR<usersUpdateWithoutFrd_documents_frd_documents_createdByTousersInput, usersUncheckedUpdateWithoutFrd_documents_frd_documents_createdByTousersInput>
    create: XOR<usersCreateWithoutFrd_documents_frd_documents_createdByTousersInput, usersUncheckedCreateWithoutFrd_documents_frd_documents_createdByTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutFrd_documents_frd_documents_createdByTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutFrd_documents_frd_documents_createdByTousersInput, usersUncheckedUpdateWithoutFrd_documents_frd_documents_createdByTousersInput>
  }

  export type usersUpdateWithoutFrd_documents_frd_documents_createdByTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    ai_analysis_audit?: ai_analysis_auditUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    ideas?: ideasUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUpdateManyWithoutUsersNestedInput
    inputs?: inputsUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUpdateManyWithoutUsersNestedInput
    signals?: signalsUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    departments_users_departmentObjIdTodepartments?: departmentsUpdateOneWithoutUsers_users_departmentObjIdTodepartmentsNestedInput
    users?: usersUpdateOneWithoutOther_usersNestedInput
    other_users?: usersUpdateManyWithoutUsersNestedInput
    votes?: votesUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUncheckedUpdateWithoutFrd_documents_frd_documents_createdByTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    ideas?: ideasUncheckedUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUncheckedUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUncheckedUpdateManyWithoutUsersNestedInput
    inputs?: inputsUncheckedUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutUsersNestedInput
    signals?: signalsUncheckedUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    other_users?: usersUncheckedUpdateManyWithoutUsersNestedInput
    votes?: votesUncheckedUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUncheckedUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type solutionsUpsertWithoutFrd_documentsInput = {
    update: XOR<solutionsUpdateWithoutFrd_documentsInput, solutionsUncheckedUpdateWithoutFrd_documentsInput>
    create: XOR<solutionsCreateWithoutFrd_documentsInput, solutionsUncheckedCreateWithoutFrd_documentsInput>
    where?: solutionsWhereInput
  }

  export type solutionsUpdateToOneWithWhereWithoutFrd_documentsInput = {
    where?: solutionsWhereInput
    data: XOR<solutionsUpdateWithoutFrd_documentsInput, solutionsUncheckedUpdateWithoutFrd_documentsInput>
  }

  export type solutionsUpdateWithoutFrd_documentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    requirements?: requirementsUpdateManyWithoutSolutionsNestedInput
    users?: usersUpdateOneRequiredWithoutSolutionsNestedInput
    hotspots?: hotspotsUpdateOneWithoutSolutionsNestedInput
    ideas?: ideasUpdateOneWithoutSolutionsNestedInput
    initiatives?: initiativesUpdateOneWithoutSolutionsNestedInput
    inputs?: inputsUpdateOneWithoutSolutionsNestedInput
  }

  export type solutionsUncheckedUpdateWithoutFrd_documentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    hotspotId?: NullableStringFieldUpdateOperationsInput | string | null
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    inputId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    requirements?: requirementsUncheckedUpdateManyWithoutSolutionsNestedInput
  }

  export type hotspotsCreateWithoutHotspot_signalsInput = {
    id: string
    title: string
    summary: string
    status?: $Enums.HotspotStatus
    rankScore?: number
    confidence?: number
    primaryCategoryId?: string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: string | null
    similarityThreshold?: number | null
    rcaBreakdownJson?: NullableJsonNullValueInput | InputJsonValue
    solutionSuggestionsJson?: NullableJsonNullValueInput | InputJsonValue
    decisionMatrixJson?: NullableJsonNullValueInput | InputJsonValue
    crossFunctionalImpactJson?: NullableJsonNullValueInput | InputJsonValue
    lastAnalysisAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    clusteringQualityScore?: number | null
    clusteringResults?: NullableJsonNullValueInput | InputJsonValue
    clusteringVersion?: string | null
    lastClusteredAt?: Date | string | null
    ideas?: ideasCreateNestedManyWithoutHotspotsInput
    solutions?: solutionsCreateNestedManyWithoutHotspotsInput
  }

  export type hotspotsUncheckedCreateWithoutHotspot_signalsInput = {
    id: string
    title: string
    summary: string
    status?: $Enums.HotspotStatus
    rankScore?: number
    confidence?: number
    primaryCategoryId?: string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: string | null
    similarityThreshold?: number | null
    rcaBreakdownJson?: NullableJsonNullValueInput | InputJsonValue
    solutionSuggestionsJson?: NullableJsonNullValueInput | InputJsonValue
    decisionMatrixJson?: NullableJsonNullValueInput | InputJsonValue
    crossFunctionalImpactJson?: NullableJsonNullValueInput | InputJsonValue
    lastAnalysisAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    clusteringQualityScore?: number | null
    clusteringResults?: NullableJsonNullValueInput | InputJsonValue
    clusteringVersion?: string | null
    lastClusteredAt?: Date | string | null
    ideas?: ideasUncheckedCreateNestedManyWithoutHotspotsInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutHotspotsInput
  }

  export type hotspotsCreateOrConnectWithoutHotspot_signalsInput = {
    where: hotspotsWhereUniqueInput
    create: XOR<hotspotsCreateWithoutHotspot_signalsInput, hotspotsUncheckedCreateWithoutHotspot_signalsInput>
  }

  export type signalsCreateWithoutHotspot_signalsInput = {
    id: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: number | null
    featuresVersion?: string | null
    lastFeaturesGeneratedAt?: Date | string | null
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutSignalsInput
    categories?: categoriesCreateNestedOneWithoutSignalsInput
    users?: usersCreateNestedOneWithoutSignalsInput
    departments?: departmentsCreateNestedOneWithoutSignalsInput
    teams?: teamsCreateNestedOneWithoutSignalsInput
  }

  export type signalsUncheckedCreateWithoutHotspot_signalsInput = {
    id: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    departmentId?: string | null
    teamId?: string | null
    categoryId?: string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: number | null
    featuresVersion?: string | null
    lastFeaturesGeneratedAt?: Date | string | null
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutSignalsInput
  }

  export type signalsCreateOrConnectWithoutHotspot_signalsInput = {
    where: signalsWhereUniqueInput
    create: XOR<signalsCreateWithoutHotspot_signalsInput, signalsUncheckedCreateWithoutHotspot_signalsInput>
  }

  export type hotspotsUpsertWithoutHotspot_signalsInput = {
    update: XOR<hotspotsUpdateWithoutHotspot_signalsInput, hotspotsUncheckedUpdateWithoutHotspot_signalsInput>
    create: XOR<hotspotsCreateWithoutHotspot_signalsInput, hotspotsUncheckedCreateWithoutHotspot_signalsInput>
    where?: hotspotsWhereInput
  }

  export type hotspotsUpdateToOneWithWhereWithoutHotspot_signalsInput = {
    where?: hotspotsWhereInput
    data: XOR<hotspotsUpdateWithoutHotspot_signalsInput, hotspotsUncheckedUpdateWithoutHotspot_signalsInput>
  }

  export type hotspotsUpdateWithoutHotspot_signalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumHotspotStatusFieldUpdateOperationsInput | $Enums.HotspotStatus
    rankScore?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    primaryCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: NullableStringFieldUpdateOperationsInput | string | null
    similarityThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    rcaBreakdownJson?: NullableJsonNullValueInput | InputJsonValue
    solutionSuggestionsJson?: NullableJsonNullValueInput | InputJsonValue
    decisionMatrixJson?: NullableJsonNullValueInput | InputJsonValue
    crossFunctionalImpactJson?: NullableJsonNullValueInput | InputJsonValue
    lastAnalysisAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clusteringQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    clusteringResults?: NullableJsonNullValueInput | InputJsonValue
    clusteringVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastClusteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: ideasUpdateManyWithoutHotspotsNestedInput
    solutions?: solutionsUpdateManyWithoutHotspotsNestedInput
  }

  export type hotspotsUncheckedUpdateWithoutHotspot_signalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumHotspotStatusFieldUpdateOperationsInput | $Enums.HotspotStatus
    rankScore?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    primaryCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: NullableStringFieldUpdateOperationsInput | string | null
    similarityThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    rcaBreakdownJson?: NullableJsonNullValueInput | InputJsonValue
    solutionSuggestionsJson?: NullableJsonNullValueInput | InputJsonValue
    decisionMatrixJson?: NullableJsonNullValueInput | InputJsonValue
    crossFunctionalImpactJson?: NullableJsonNullValueInput | InputJsonValue
    lastAnalysisAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clusteringQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    clusteringResults?: NullableJsonNullValueInput | InputJsonValue
    clusteringVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastClusteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: ideasUncheckedUpdateManyWithoutHotspotsNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutHotspotsNestedInput
  }

  export type signalsUpsertWithoutHotspot_signalsInput = {
    update: XOR<signalsUpdateWithoutHotspot_signalsInput, signalsUncheckedUpdateWithoutHotspot_signalsInput>
    create: XOR<signalsCreateWithoutHotspot_signalsInput, signalsUncheckedCreateWithoutHotspot_signalsInput>
    where?: signalsWhereInput
  }

  export type signalsUpdateToOneWithWhereWithoutHotspot_signalsInput = {
    where?: signalsWhereInput
    data: XOR<signalsUpdateWithoutHotspot_signalsInput, signalsUncheckedUpdateWithoutHotspot_signalsInput>
  }

  export type signalsUpdateWithoutHotspot_signalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    featuresVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastFeaturesGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutSignalsNestedInput
    categories?: categoriesUpdateOneWithoutSignalsNestedInput
    users?: usersUpdateOneWithoutSignalsNestedInput
    departments?: departmentsUpdateOneWithoutSignalsNestedInput
    teams?: teamsUpdateOneWithoutSignalsNestedInput
  }

  export type signalsUncheckedUpdateWithoutHotspot_signalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    featuresVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastFeaturesGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutSignalsNestedInput
  }

  export type hotspot_signalsCreateWithoutHotspotsInput = {
    membershipStrength?: number
    isOutlier?: boolean
    addedAt?: Date | string
    signals: signalsCreateNestedOneWithoutHotspot_signalsInput
  }

  export type hotspot_signalsUncheckedCreateWithoutHotspotsInput = {
    signalId: string
    membershipStrength?: number
    isOutlier?: boolean
    addedAt?: Date | string
  }

  export type hotspot_signalsCreateOrConnectWithoutHotspotsInput = {
    where: hotspot_signalsWhereUniqueInput
    create: XOR<hotspot_signalsCreateWithoutHotspotsInput, hotspot_signalsUncheckedCreateWithoutHotspotsInput>
  }

  export type hotspot_signalsCreateManyHotspotsInputEnvelope = {
    data: hotspot_signalsCreateManyHotspotsInput | hotspot_signalsCreateManyHotspotsInput[]
    skipDuplicates?: boolean
  }

  export type ideasCreateWithoutHotspotsInput = {
    id: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    users?: usersCreateNestedOneWithoutIdeasInput
    initiatives?: initiativesCreateNestedOneWithoutIdeasInput
    solutions?: solutionsCreateNestedOneWithoutIdeasInput
  }

  export type ideasUncheckedCreateWithoutHotspotsInput = {
    id: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdById?: string | null
    initiativeId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    solutions?: solutionsUncheckedCreateNestedOneWithoutIdeasInput
  }

  export type ideasCreateOrConnectWithoutHotspotsInput = {
    where: ideasWhereUniqueInput
    create: XOR<ideasCreateWithoutHotspotsInput, ideasUncheckedCreateWithoutHotspotsInput>
  }

  export type ideasCreateManyHotspotsInputEnvelope = {
    data: ideasCreateManyHotspotsInput | ideasCreateManyHotspotsInput[]
    skipDuplicates?: boolean
  }

  export type solutionsCreateWithoutHotspotsInput = {
    id: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    createdAt?: Date | string
    updatedAt: Date | string
    estimatedEffort?: string | null
    actualCompletionDate?: Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsCreateNestedManyWithoutSolutionsInput
    requirements?: requirementsCreateNestedManyWithoutSolutionsInput
    users: usersCreateNestedOneWithoutSolutionsInput
    ideas?: ideasCreateNestedOneWithoutSolutionsInput
    initiatives?: initiativesCreateNestedOneWithoutSolutionsInput
    inputs?: inputsCreateNestedOneWithoutSolutionsInput
  }

  export type solutionsUncheckedCreateWithoutHotspotsInput = {
    id: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    createdAt?: Date | string
    updatedAt: Date | string
    estimatedEffort?: string | null
    actualCompletionDate?: Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    createdBy: string
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    ideaId?: string | null
    initiativeId?: string | null
    inputId?: string | null
    progress?: number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsUncheckedCreateNestedManyWithoutSolutionsInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutSolutionsInput
  }

  export type solutionsCreateOrConnectWithoutHotspotsInput = {
    where: solutionsWhereUniqueInput
    create: XOR<solutionsCreateWithoutHotspotsInput, solutionsUncheckedCreateWithoutHotspotsInput>
  }

  export type solutionsCreateManyHotspotsInputEnvelope = {
    data: solutionsCreateManyHotspotsInput | solutionsCreateManyHotspotsInput[]
    skipDuplicates?: boolean
  }

  export type hotspot_signalsUpsertWithWhereUniqueWithoutHotspotsInput = {
    where: hotspot_signalsWhereUniqueInput
    update: XOR<hotspot_signalsUpdateWithoutHotspotsInput, hotspot_signalsUncheckedUpdateWithoutHotspotsInput>
    create: XOR<hotspot_signalsCreateWithoutHotspotsInput, hotspot_signalsUncheckedCreateWithoutHotspotsInput>
  }

  export type hotspot_signalsUpdateWithWhereUniqueWithoutHotspotsInput = {
    where: hotspot_signalsWhereUniqueInput
    data: XOR<hotspot_signalsUpdateWithoutHotspotsInput, hotspot_signalsUncheckedUpdateWithoutHotspotsInput>
  }

  export type hotspot_signalsUpdateManyWithWhereWithoutHotspotsInput = {
    where: hotspot_signalsScalarWhereInput
    data: XOR<hotspot_signalsUpdateManyMutationInput, hotspot_signalsUncheckedUpdateManyWithoutHotspotsInput>
  }

  export type hotspot_signalsScalarWhereInput = {
    AND?: hotspot_signalsScalarWhereInput | hotspot_signalsScalarWhereInput[]
    OR?: hotspot_signalsScalarWhereInput[]
    NOT?: hotspot_signalsScalarWhereInput | hotspot_signalsScalarWhereInput[]
    hotspotId?: StringFilter<"hotspot_signals"> | string
    signalId?: StringFilter<"hotspot_signals"> | string
    membershipStrength?: FloatFilter<"hotspot_signals"> | number
    isOutlier?: BoolFilter<"hotspot_signals"> | boolean
    addedAt?: DateTimeFilter<"hotspot_signals"> | Date | string
  }

  export type ideasUpsertWithWhereUniqueWithoutHotspotsInput = {
    where: ideasWhereUniqueInput
    update: XOR<ideasUpdateWithoutHotspotsInput, ideasUncheckedUpdateWithoutHotspotsInput>
    create: XOR<ideasCreateWithoutHotspotsInput, ideasUncheckedCreateWithoutHotspotsInput>
  }

  export type ideasUpdateWithWhereUniqueWithoutHotspotsInput = {
    where: ideasWhereUniqueInput
    data: XOR<ideasUpdateWithoutHotspotsInput, ideasUncheckedUpdateWithoutHotspotsInput>
  }

  export type ideasUpdateManyWithWhereWithoutHotspotsInput = {
    where: ideasScalarWhereInput
    data: XOR<ideasUpdateManyMutationInput, ideasUncheckedUpdateManyWithoutHotspotsInput>
  }

  export type ideasScalarWhereInput = {
    AND?: ideasScalarWhereInput | ideasScalarWhereInput[]
    OR?: ideasScalarWhereInput[]
    NOT?: ideasScalarWhereInput | ideasScalarWhereInput[]
    id?: StringFilter<"ideas"> | string
    hotspotId?: StringFilter<"ideas"> | string
    title?: StringNullableFilter<"ideas"> | string | null
    description?: StringFilter<"ideas"> | string
    origin?: StringFilter<"ideas"> | string
    votes?: IntFilter<"ideas"> | number
    status?: StringFilter<"ideas"> | string
    evidenceJson?: JsonNullableFilter<"ideas">
    tagsJson?: JsonNullableFilter<"ideas">
    confidence?: FloatNullableFilter<"ideas"> | number | null
    createdById?: StringNullableFilter<"ideas"> | string | null
    initiativeId?: StringNullableFilter<"ideas"> | string | null
    createdAt?: DateTimeFilter<"ideas"> | Date | string
    updatedAt?: DateTimeFilter<"ideas"> | Date | string
  }

  export type solutionsUpsertWithWhereUniqueWithoutHotspotsInput = {
    where: solutionsWhereUniqueInput
    update: XOR<solutionsUpdateWithoutHotspotsInput, solutionsUncheckedUpdateWithoutHotspotsInput>
    create: XOR<solutionsCreateWithoutHotspotsInput, solutionsUncheckedCreateWithoutHotspotsInput>
  }

  export type solutionsUpdateWithWhereUniqueWithoutHotspotsInput = {
    where: solutionsWhereUniqueInput
    data: XOR<solutionsUpdateWithoutHotspotsInput, solutionsUncheckedUpdateWithoutHotspotsInput>
  }

  export type solutionsUpdateManyWithWhereWithoutHotspotsInput = {
    where: solutionsScalarWhereInput
    data: XOR<solutionsUpdateManyMutationInput, solutionsUncheckedUpdateManyWithoutHotspotsInput>
  }

  export type solutionsScalarWhereInput = {
    AND?: solutionsScalarWhereInput | solutionsScalarWhereInput[]
    OR?: solutionsScalarWhereInput[]
    NOT?: solutionsScalarWhereInput | solutionsScalarWhereInput[]
    id?: StringFilter<"solutions"> | string
    title?: StringFilter<"solutions"> | string
    description?: StringFilter<"solutions"> | string
    status?: EnumSolutionStatusFilter<"solutions"> | $Enums.SolutionStatus
    createdAt?: DateTimeFilter<"solutions"> | Date | string
    updatedAt?: DateTimeFilter<"solutions"> | Date | string
    estimatedEffort?: StringNullableFilter<"solutions"> | string | null
    actualCompletionDate?: DateTimeNullableFilter<"solutions"> | Date | string | null
    actualImpactJson?: JsonNullableFilter<"solutions">
    businessValue?: StringNullableFilter<"solutions"> | string | null
    createdBy?: StringFilter<"solutions"> | string
    expectedImpactJson?: JsonNullableFilter<"solutions">
    hotspotId?: StringNullableFilter<"solutions"> | string | null
    ideaId?: StringNullableFilter<"solutions"> | string | null
    initiativeId?: StringNullableFilter<"solutions"> | string | null
    inputId?: StringNullableFilter<"solutions"> | string | null
    progress?: FloatFilter<"solutions"> | number
    successMetrics?: JsonNullableFilter<"solutions">
    targetDate?: DateTimeNullableFilter<"solutions"> | Date | string | null
    tasks?: JsonNullableFilter<"solutions">
  }

  export type usersCreateWithoutIdeasInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    ai_analysis_audit?: ai_analysis_auditCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    initiatives?: initiativesCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsCreateNestedManyWithoutUsersInput
    inputs?: inputsCreateNestedManyWithoutUsersInput
    requirements?: requirementsCreateNestedManyWithoutUsersInput
    signals?: signalsCreateNestedManyWithoutUsersInput
    solutions?: solutionsCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    departments_users_departmentObjIdTodepartments?: departmentsCreateNestedOneWithoutUsers_users_departmentObjIdTodepartmentsInput
    users?: usersCreateNestedOneWithoutOther_usersInput
    other_users?: usersCreateNestedManyWithoutUsersInput
    votes?: votesCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersUncheckedCreateWithoutIdeasInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    managerId?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    departmentObjId?: string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsUncheckedCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    initiatives?: initiativesUncheckedCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsUncheckedCreateNestedManyWithoutUsersInput
    inputs?: inputsUncheckedCreateNestedManyWithoutUsersInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutUsersInput
    signals?: signalsUncheckedCreateNestedManyWithoutUsersInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsUncheckedCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    other_users?: usersUncheckedCreateNestedManyWithoutUsersInput
    votes?: votesUncheckedCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsUncheckedCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersCreateOrConnectWithoutIdeasInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutIdeasInput, usersUncheckedCreateWithoutIdeasInput>
  }

  export type hotspotsCreateWithoutIdeasInput = {
    id: string
    title: string
    summary: string
    status?: $Enums.HotspotStatus
    rankScore?: number
    confidence?: number
    primaryCategoryId?: string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: string | null
    similarityThreshold?: number | null
    rcaBreakdownJson?: NullableJsonNullValueInput | InputJsonValue
    solutionSuggestionsJson?: NullableJsonNullValueInput | InputJsonValue
    decisionMatrixJson?: NullableJsonNullValueInput | InputJsonValue
    crossFunctionalImpactJson?: NullableJsonNullValueInput | InputJsonValue
    lastAnalysisAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    clusteringQualityScore?: number | null
    clusteringResults?: NullableJsonNullValueInput | InputJsonValue
    clusteringVersion?: string | null
    lastClusteredAt?: Date | string | null
    hotspot_signals?: hotspot_signalsCreateNestedManyWithoutHotspotsInput
    solutions?: solutionsCreateNestedManyWithoutHotspotsInput
  }

  export type hotspotsUncheckedCreateWithoutIdeasInput = {
    id: string
    title: string
    summary: string
    status?: $Enums.HotspotStatus
    rankScore?: number
    confidence?: number
    primaryCategoryId?: string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: string | null
    similarityThreshold?: number | null
    rcaBreakdownJson?: NullableJsonNullValueInput | InputJsonValue
    solutionSuggestionsJson?: NullableJsonNullValueInput | InputJsonValue
    decisionMatrixJson?: NullableJsonNullValueInput | InputJsonValue
    crossFunctionalImpactJson?: NullableJsonNullValueInput | InputJsonValue
    lastAnalysisAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    clusteringQualityScore?: number | null
    clusteringResults?: NullableJsonNullValueInput | InputJsonValue
    clusteringVersion?: string | null
    lastClusteredAt?: Date | string | null
    hotspot_signals?: hotspot_signalsUncheckedCreateNestedManyWithoutHotspotsInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutHotspotsInput
  }

  export type hotspotsCreateOrConnectWithoutIdeasInput = {
    where: hotspotsWhereUniqueInput
    create: XOR<hotspotsCreateWithoutIdeasInput, hotspotsUncheckedCreateWithoutIdeasInput>
  }

  export type initiativesCreateWithoutIdeasInput = {
    id: string
    name: string
    description?: string | null
    status?: $Enums.initiative_status
    priority?: $Enums.priority
    budget?: number
    actualSpend?: number
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completionDate?: Date | string | null
    expectedROI?: number | null
    actualROI?: number | null
    riskLevel?: $Enums.risk_level
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    milestonesJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    users?: usersCreateNestedOneWithoutInitiativesInput
    solutions?: solutionsCreateNestedManyWithoutInitiativesInput
  }

  export type initiativesUncheckedCreateWithoutIdeasInput = {
    id: string
    name: string
    description?: string | null
    status?: $Enums.initiative_status
    priority?: $Enums.priority
    ownerId?: string | null
    budget?: number
    actualSpend?: number
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completionDate?: Date | string | null
    expectedROI?: number | null
    actualROI?: number | null
    riskLevel?: $Enums.risk_level
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    milestonesJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    solutions?: solutionsUncheckedCreateNestedManyWithoutInitiativesInput
  }

  export type initiativesCreateOrConnectWithoutIdeasInput = {
    where: initiativesWhereUniqueInput
    create: XOR<initiativesCreateWithoutIdeasInput, initiativesUncheckedCreateWithoutIdeasInput>
  }

  export type solutionsCreateWithoutIdeasInput = {
    id: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    createdAt?: Date | string
    updatedAt: Date | string
    estimatedEffort?: string | null
    actualCompletionDate?: Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsCreateNestedManyWithoutSolutionsInput
    requirements?: requirementsCreateNestedManyWithoutSolutionsInput
    users: usersCreateNestedOneWithoutSolutionsInput
    hotspots?: hotspotsCreateNestedOneWithoutSolutionsInput
    initiatives?: initiativesCreateNestedOneWithoutSolutionsInput
    inputs?: inputsCreateNestedOneWithoutSolutionsInput
  }

  export type solutionsUncheckedCreateWithoutIdeasInput = {
    id: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    createdAt?: Date | string
    updatedAt: Date | string
    estimatedEffort?: string | null
    actualCompletionDate?: Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    createdBy: string
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    hotspotId?: string | null
    initiativeId?: string | null
    inputId?: string | null
    progress?: number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsUncheckedCreateNestedManyWithoutSolutionsInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutSolutionsInput
  }

  export type solutionsCreateOrConnectWithoutIdeasInput = {
    where: solutionsWhereUniqueInput
    create: XOR<solutionsCreateWithoutIdeasInput, solutionsUncheckedCreateWithoutIdeasInput>
  }

  export type usersUpsertWithoutIdeasInput = {
    update: XOR<usersUpdateWithoutIdeasInput, usersUncheckedUpdateWithoutIdeasInput>
    create: XOR<usersCreateWithoutIdeasInput, usersUncheckedCreateWithoutIdeasInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutIdeasInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutIdeasInput, usersUncheckedUpdateWithoutIdeasInput>
  }

  export type usersUpdateWithoutIdeasInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    ai_analysis_audit?: ai_analysis_auditUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    initiatives?: initiativesUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUpdateManyWithoutUsersNestedInput
    inputs?: inputsUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUpdateManyWithoutUsersNestedInput
    signals?: signalsUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    departments_users_departmentObjIdTodepartments?: departmentsUpdateOneWithoutUsers_users_departmentObjIdTodepartmentsNestedInput
    users?: usersUpdateOneWithoutOther_usersNestedInput
    other_users?: usersUpdateManyWithoutUsersNestedInput
    votes?: votesUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUncheckedUpdateWithoutIdeasInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    initiatives?: initiativesUncheckedUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUncheckedUpdateManyWithoutUsersNestedInput
    inputs?: inputsUncheckedUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutUsersNestedInput
    signals?: signalsUncheckedUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    other_users?: usersUncheckedUpdateManyWithoutUsersNestedInput
    votes?: votesUncheckedUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUncheckedUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type hotspotsUpsertWithoutIdeasInput = {
    update: XOR<hotspotsUpdateWithoutIdeasInput, hotspotsUncheckedUpdateWithoutIdeasInput>
    create: XOR<hotspotsCreateWithoutIdeasInput, hotspotsUncheckedCreateWithoutIdeasInput>
    where?: hotspotsWhereInput
  }

  export type hotspotsUpdateToOneWithWhereWithoutIdeasInput = {
    where?: hotspotsWhereInput
    data: XOR<hotspotsUpdateWithoutIdeasInput, hotspotsUncheckedUpdateWithoutIdeasInput>
  }

  export type hotspotsUpdateWithoutIdeasInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumHotspotStatusFieldUpdateOperationsInput | $Enums.HotspotStatus
    rankScore?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    primaryCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: NullableStringFieldUpdateOperationsInput | string | null
    similarityThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    rcaBreakdownJson?: NullableJsonNullValueInput | InputJsonValue
    solutionSuggestionsJson?: NullableJsonNullValueInput | InputJsonValue
    decisionMatrixJson?: NullableJsonNullValueInput | InputJsonValue
    crossFunctionalImpactJson?: NullableJsonNullValueInput | InputJsonValue
    lastAnalysisAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clusteringQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    clusteringResults?: NullableJsonNullValueInput | InputJsonValue
    clusteringVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastClusteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotspot_signals?: hotspot_signalsUpdateManyWithoutHotspotsNestedInput
    solutions?: solutionsUpdateManyWithoutHotspotsNestedInput
  }

  export type hotspotsUncheckedUpdateWithoutIdeasInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumHotspotStatusFieldUpdateOperationsInput | $Enums.HotspotStatus
    rankScore?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    primaryCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: NullableStringFieldUpdateOperationsInput | string | null
    similarityThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    rcaBreakdownJson?: NullableJsonNullValueInput | InputJsonValue
    solutionSuggestionsJson?: NullableJsonNullValueInput | InputJsonValue
    decisionMatrixJson?: NullableJsonNullValueInput | InputJsonValue
    crossFunctionalImpactJson?: NullableJsonNullValueInput | InputJsonValue
    lastAnalysisAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clusteringQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    clusteringResults?: NullableJsonNullValueInput | InputJsonValue
    clusteringVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastClusteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotspot_signals?: hotspot_signalsUncheckedUpdateManyWithoutHotspotsNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutHotspotsNestedInput
  }

  export type initiativesUpsertWithoutIdeasInput = {
    update: XOR<initiativesUpdateWithoutIdeasInput, initiativesUncheckedUpdateWithoutIdeasInput>
    create: XOR<initiativesCreateWithoutIdeasInput, initiativesUncheckedCreateWithoutIdeasInput>
    where?: initiativesWhereInput
  }

  export type initiativesUpdateToOneWithWhereWithoutIdeasInput = {
    where?: initiativesWhereInput
    data: XOR<initiativesUpdateWithoutIdeasInput, initiativesUncheckedUpdateWithoutIdeasInput>
  }

  export type initiativesUpdateWithoutIdeasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enuminitiative_statusFieldUpdateOperationsInput | $Enums.initiative_status
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    budget?: FloatFieldUpdateOperationsInput | number
    actualSpend?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedROI?: NullableFloatFieldUpdateOperationsInput | number | null
    actualROI?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: Enumrisk_levelFieldUpdateOperationsInput | $Enums.risk_level
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    milestonesJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutInitiativesNestedInput
    solutions?: solutionsUpdateManyWithoutInitiativesNestedInput
  }

  export type initiativesUncheckedUpdateWithoutIdeasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enuminitiative_statusFieldUpdateOperationsInput | $Enums.initiative_status
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    actualSpend?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedROI?: NullableFloatFieldUpdateOperationsInput | number | null
    actualROI?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: Enumrisk_levelFieldUpdateOperationsInput | $Enums.risk_level
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    milestonesJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solutions?: solutionsUncheckedUpdateManyWithoutInitiativesNestedInput
  }

  export type solutionsUpsertWithoutIdeasInput = {
    update: XOR<solutionsUpdateWithoutIdeasInput, solutionsUncheckedUpdateWithoutIdeasInput>
    create: XOR<solutionsCreateWithoutIdeasInput, solutionsUncheckedCreateWithoutIdeasInput>
    where?: solutionsWhereInput
  }

  export type solutionsUpdateToOneWithWhereWithoutIdeasInput = {
    where?: solutionsWhereInput
    data: XOR<solutionsUpdateWithoutIdeasInput, solutionsUncheckedUpdateWithoutIdeasInput>
  }

  export type solutionsUpdateWithoutIdeasInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsUpdateManyWithoutSolutionsNestedInput
    requirements?: requirementsUpdateManyWithoutSolutionsNestedInput
    users?: usersUpdateOneRequiredWithoutSolutionsNestedInput
    hotspots?: hotspotsUpdateOneWithoutSolutionsNestedInput
    initiatives?: initiativesUpdateOneWithoutSolutionsNestedInput
    inputs?: inputsUpdateOneWithoutSolutionsNestedInput
  }

  export type solutionsUncheckedUpdateWithoutIdeasInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    hotspotId?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    inputId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsUncheckedUpdateManyWithoutSolutionsNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutSolutionsNestedInput
  }

  export type ideasCreateWithoutInitiativesInput = {
    id: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    users?: usersCreateNestedOneWithoutIdeasInput
    hotspots: hotspotsCreateNestedOneWithoutIdeasInput
    solutions?: solutionsCreateNestedOneWithoutIdeasInput
  }

  export type ideasUncheckedCreateWithoutInitiativesInput = {
    id: string
    hotspotId: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    solutions?: solutionsUncheckedCreateNestedOneWithoutIdeasInput
  }

  export type ideasCreateOrConnectWithoutInitiativesInput = {
    where: ideasWhereUniqueInput
    create: XOR<ideasCreateWithoutInitiativesInput, ideasUncheckedCreateWithoutInitiativesInput>
  }

  export type ideasCreateManyInitiativesInputEnvelope = {
    data: ideasCreateManyInitiativesInput | ideasCreateManyInitiativesInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutInitiativesInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    ai_analysis_audit?: ai_analysis_auditCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsCreateNestedManyWithoutUsersInput
    inputs?: inputsCreateNestedManyWithoutUsersInput
    requirements?: requirementsCreateNestedManyWithoutUsersInput
    signals?: signalsCreateNestedManyWithoutUsersInput
    solutions?: solutionsCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    departments_users_departmentObjIdTodepartments?: departmentsCreateNestedOneWithoutUsers_users_departmentObjIdTodepartmentsInput
    users?: usersCreateNestedOneWithoutOther_usersInput
    other_users?: usersCreateNestedManyWithoutUsersInput
    votes?: votesCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersUncheckedCreateWithoutInitiativesInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    managerId?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    departmentObjId?: string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsUncheckedCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasUncheckedCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsUncheckedCreateNestedManyWithoutUsersInput
    inputs?: inputsUncheckedCreateNestedManyWithoutUsersInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutUsersInput
    signals?: signalsUncheckedCreateNestedManyWithoutUsersInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsUncheckedCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    other_users?: usersUncheckedCreateNestedManyWithoutUsersInput
    votes?: votesUncheckedCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsUncheckedCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersCreateOrConnectWithoutInitiativesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutInitiativesInput, usersUncheckedCreateWithoutInitiativesInput>
  }

  export type solutionsCreateWithoutInitiativesInput = {
    id: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    createdAt?: Date | string
    updatedAt: Date | string
    estimatedEffort?: string | null
    actualCompletionDate?: Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsCreateNestedManyWithoutSolutionsInput
    requirements?: requirementsCreateNestedManyWithoutSolutionsInput
    users: usersCreateNestedOneWithoutSolutionsInput
    hotspots?: hotspotsCreateNestedOneWithoutSolutionsInput
    ideas?: ideasCreateNestedOneWithoutSolutionsInput
    inputs?: inputsCreateNestedOneWithoutSolutionsInput
  }

  export type solutionsUncheckedCreateWithoutInitiativesInput = {
    id: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    createdAt?: Date | string
    updatedAt: Date | string
    estimatedEffort?: string | null
    actualCompletionDate?: Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    createdBy: string
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    hotspotId?: string | null
    ideaId?: string | null
    inputId?: string | null
    progress?: number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsUncheckedCreateNestedManyWithoutSolutionsInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutSolutionsInput
  }

  export type solutionsCreateOrConnectWithoutInitiativesInput = {
    where: solutionsWhereUniqueInput
    create: XOR<solutionsCreateWithoutInitiativesInput, solutionsUncheckedCreateWithoutInitiativesInput>
  }

  export type solutionsCreateManyInitiativesInputEnvelope = {
    data: solutionsCreateManyInitiativesInput | solutionsCreateManyInitiativesInput[]
    skipDuplicates?: boolean
  }

  export type ideasUpsertWithWhereUniqueWithoutInitiativesInput = {
    where: ideasWhereUniqueInput
    update: XOR<ideasUpdateWithoutInitiativesInput, ideasUncheckedUpdateWithoutInitiativesInput>
    create: XOR<ideasCreateWithoutInitiativesInput, ideasUncheckedCreateWithoutInitiativesInput>
  }

  export type ideasUpdateWithWhereUniqueWithoutInitiativesInput = {
    where: ideasWhereUniqueInput
    data: XOR<ideasUpdateWithoutInitiativesInput, ideasUncheckedUpdateWithoutInitiativesInput>
  }

  export type ideasUpdateManyWithWhereWithoutInitiativesInput = {
    where: ideasScalarWhereInput
    data: XOR<ideasUpdateManyMutationInput, ideasUncheckedUpdateManyWithoutInitiativesInput>
  }

  export type usersUpsertWithoutInitiativesInput = {
    update: XOR<usersUpdateWithoutInitiativesInput, usersUncheckedUpdateWithoutInitiativesInput>
    create: XOR<usersCreateWithoutInitiativesInput, usersUncheckedCreateWithoutInitiativesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutInitiativesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutInitiativesInput, usersUncheckedUpdateWithoutInitiativesInput>
  }

  export type usersUpdateWithoutInitiativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    ai_analysis_audit?: ai_analysis_auditUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUpdateManyWithoutUsersNestedInput
    inputs?: inputsUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUpdateManyWithoutUsersNestedInput
    signals?: signalsUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    departments_users_departmentObjIdTodepartments?: departmentsUpdateOneWithoutUsers_users_departmentObjIdTodepartmentsNestedInput
    users?: usersUpdateOneWithoutOther_usersNestedInput
    other_users?: usersUpdateManyWithoutUsersNestedInput
    votes?: votesUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUncheckedUpdateWithoutInitiativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUncheckedUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUncheckedUpdateManyWithoutUsersNestedInput
    inputs?: inputsUncheckedUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutUsersNestedInput
    signals?: signalsUncheckedUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    other_users?: usersUncheckedUpdateManyWithoutUsersNestedInput
    votes?: votesUncheckedUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUncheckedUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type solutionsUpsertWithWhereUniqueWithoutInitiativesInput = {
    where: solutionsWhereUniqueInput
    update: XOR<solutionsUpdateWithoutInitiativesInput, solutionsUncheckedUpdateWithoutInitiativesInput>
    create: XOR<solutionsCreateWithoutInitiativesInput, solutionsUncheckedCreateWithoutInitiativesInput>
  }

  export type solutionsUpdateWithWhereUniqueWithoutInitiativesInput = {
    where: solutionsWhereUniqueInput
    data: XOR<solutionsUpdateWithoutInitiativesInput, solutionsUncheckedUpdateWithoutInitiativesInput>
  }

  export type solutionsUpdateManyWithWhereWithoutInitiativesInput = {
    where: solutionsScalarWhereInput
    data: XOR<solutionsUpdateManyMutationInput, solutionsUncheckedUpdateManyWithoutInitiativesInput>
  }

  export type InputToInputGroupCreateWithoutInput_groupsInput = {
    inputs: inputsCreateNestedOneWithoutInputToInputGroupInput
  }

  export type InputToInputGroupUncheckedCreateWithoutInput_groupsInput = {
    A: string
  }

  export type InputToInputGroupCreateOrConnectWithoutInput_groupsInput = {
    where: InputToInputGroupWhereUniqueInput
    create: XOR<InputToInputGroupCreateWithoutInput_groupsInput, InputToInputGroupUncheckedCreateWithoutInput_groupsInput>
  }

  export type InputToInputGroupCreateManyInput_groupsInputEnvelope = {
    data: InputToInputGroupCreateManyInput_groupsInput | InputToInputGroupCreateManyInput_groupsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutInput_groupsInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    ai_analysis_audit?: ai_analysis_auditCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasCreateNestedManyWithoutUsersInput
    initiatives?: initiativesCreateNestedManyWithoutUsersInput
    inputs?: inputsCreateNestedManyWithoutUsersInput
    requirements?: requirementsCreateNestedManyWithoutUsersInput
    signals?: signalsCreateNestedManyWithoutUsersInput
    solutions?: solutionsCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    departments_users_departmentObjIdTodepartments?: departmentsCreateNestedOneWithoutUsers_users_departmentObjIdTodepartmentsInput
    users?: usersCreateNestedOneWithoutOther_usersInput
    other_users?: usersCreateNestedManyWithoutUsersInput
    votes?: votesCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersUncheckedCreateWithoutInput_groupsInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    managerId?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    departmentObjId?: string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsUncheckedCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasUncheckedCreateNestedManyWithoutUsersInput
    initiatives?: initiativesUncheckedCreateNestedManyWithoutUsersInput
    inputs?: inputsUncheckedCreateNestedManyWithoutUsersInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutUsersInput
    signals?: signalsUncheckedCreateNestedManyWithoutUsersInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsUncheckedCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    other_users?: usersUncheckedCreateNestedManyWithoutUsersInput
    votes?: votesUncheckedCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsUncheckedCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersCreateOrConnectWithoutInput_groupsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutInput_groupsInput, usersUncheckedCreateWithoutInput_groupsInput>
  }

  export type InputToInputGroupUpsertWithWhereUniqueWithoutInput_groupsInput = {
    where: InputToInputGroupWhereUniqueInput
    update: XOR<InputToInputGroupUpdateWithoutInput_groupsInput, InputToInputGroupUncheckedUpdateWithoutInput_groupsInput>
    create: XOR<InputToInputGroupCreateWithoutInput_groupsInput, InputToInputGroupUncheckedCreateWithoutInput_groupsInput>
  }

  export type InputToInputGroupUpdateWithWhereUniqueWithoutInput_groupsInput = {
    where: InputToInputGroupWhereUniqueInput
    data: XOR<InputToInputGroupUpdateWithoutInput_groupsInput, InputToInputGroupUncheckedUpdateWithoutInput_groupsInput>
  }

  export type InputToInputGroupUpdateManyWithWhereWithoutInput_groupsInput = {
    where: InputToInputGroupScalarWhereInput
    data: XOR<InputToInputGroupUpdateManyMutationInput, InputToInputGroupUncheckedUpdateManyWithoutInput_groupsInput>
  }

  export type InputToInputGroupScalarWhereInput = {
    AND?: InputToInputGroupScalarWhereInput | InputToInputGroupScalarWhereInput[]
    OR?: InputToInputGroupScalarWhereInput[]
    NOT?: InputToInputGroupScalarWhereInput | InputToInputGroupScalarWhereInput[]
    A?: StringFilter<"InputToInputGroup"> | string
    B?: StringFilter<"InputToInputGroup"> | string
  }

  export type usersUpsertWithoutInput_groupsInput = {
    update: XOR<usersUpdateWithoutInput_groupsInput, usersUncheckedUpdateWithoutInput_groupsInput>
    create: XOR<usersCreateWithoutInput_groupsInput, usersUncheckedCreateWithoutInput_groupsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutInput_groupsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutInput_groupsInput, usersUncheckedUpdateWithoutInput_groupsInput>
  }

  export type usersUpdateWithoutInput_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    ai_analysis_audit?: ai_analysis_auditUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUpdateManyWithoutUsersNestedInput
    inputs?: inputsUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUpdateManyWithoutUsersNestedInput
    signals?: signalsUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    departments_users_departmentObjIdTodepartments?: departmentsUpdateOneWithoutUsers_users_departmentObjIdTodepartmentsNestedInput
    users?: usersUpdateOneWithoutOther_usersNestedInput
    other_users?: usersUpdateManyWithoutUsersNestedInput
    votes?: votesUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUncheckedUpdateWithoutInput_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUncheckedUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUncheckedUpdateManyWithoutUsersNestedInput
    inputs?: inputsUncheckedUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutUsersNestedInput
    signals?: signalsUncheckedUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    other_users?: usersUncheckedUpdateManyWithoutUsersNestedInput
    votes?: votesUncheckedUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUncheckedUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type InputToInputGroupCreateWithoutInputsInput = {
    input_groups: input_groupsCreateNestedOneWithoutInputToInputGroupInput
  }

  export type InputToInputGroupUncheckedCreateWithoutInputsInput = {
    B: string
  }

  export type InputToInputGroupCreateOrConnectWithoutInputsInput = {
    where: InputToInputGroupWhereUniqueInput
    create: XOR<InputToInputGroupCreateWithoutInputsInput, InputToInputGroupUncheckedCreateWithoutInputsInput>
  }

  export type InputToInputGroupCreateManyInputsInputEnvelope = {
    data: InputToInputGroupCreateManyInputsInput | InputToInputGroupCreateManyInputsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutInputsInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    ai_analysis_audit?: ai_analysis_auditCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasCreateNestedManyWithoutUsersInput
    initiatives?: initiativesCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsCreateNestedManyWithoutUsersInput
    requirements?: requirementsCreateNestedManyWithoutUsersInput
    signals?: signalsCreateNestedManyWithoutUsersInput
    solutions?: solutionsCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    departments_users_departmentObjIdTodepartments?: departmentsCreateNestedOneWithoutUsers_users_departmentObjIdTodepartmentsInput
    users?: usersCreateNestedOneWithoutOther_usersInput
    other_users?: usersCreateNestedManyWithoutUsersInput
    votes?: votesCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersUncheckedCreateWithoutInputsInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    managerId?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    departmentObjId?: string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsUncheckedCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasUncheckedCreateNestedManyWithoutUsersInput
    initiatives?: initiativesUncheckedCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsUncheckedCreateNestedManyWithoutUsersInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutUsersInput
    signals?: signalsUncheckedCreateNestedManyWithoutUsersInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsUncheckedCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    other_users?: usersUncheckedCreateNestedManyWithoutUsersInput
    votes?: votesUncheckedCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsUncheckedCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersCreateOrConnectWithoutInputsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutInputsInput, usersUncheckedCreateWithoutInputsInput>
  }

  export type solutionsCreateWithoutInputsInput = {
    id: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    createdAt?: Date | string
    updatedAt: Date | string
    estimatedEffort?: string | null
    actualCompletionDate?: Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsCreateNestedManyWithoutSolutionsInput
    requirements?: requirementsCreateNestedManyWithoutSolutionsInput
    users: usersCreateNestedOneWithoutSolutionsInput
    hotspots?: hotspotsCreateNestedOneWithoutSolutionsInput
    ideas?: ideasCreateNestedOneWithoutSolutionsInput
    initiatives?: initiativesCreateNestedOneWithoutSolutionsInput
  }

  export type solutionsUncheckedCreateWithoutInputsInput = {
    id: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    createdAt?: Date | string
    updatedAt: Date | string
    estimatedEffort?: string | null
    actualCompletionDate?: Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    createdBy: string
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    hotspotId?: string | null
    ideaId?: string | null
    initiativeId?: string | null
    progress?: number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsUncheckedCreateNestedManyWithoutSolutionsInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutSolutionsInput
  }

  export type solutionsCreateOrConnectWithoutInputsInput = {
    where: solutionsWhereUniqueInput
    create: XOR<solutionsCreateWithoutInputsInput, solutionsUncheckedCreateWithoutInputsInput>
  }

  export type solutionsCreateManyInputsInputEnvelope = {
    data: solutionsCreateManyInputsInput | solutionsCreateManyInputsInput[]
    skipDuplicates?: boolean
  }

  export type InputToInputGroupUpsertWithWhereUniqueWithoutInputsInput = {
    where: InputToInputGroupWhereUniqueInput
    update: XOR<InputToInputGroupUpdateWithoutInputsInput, InputToInputGroupUncheckedUpdateWithoutInputsInput>
    create: XOR<InputToInputGroupCreateWithoutInputsInput, InputToInputGroupUncheckedCreateWithoutInputsInput>
  }

  export type InputToInputGroupUpdateWithWhereUniqueWithoutInputsInput = {
    where: InputToInputGroupWhereUniqueInput
    data: XOR<InputToInputGroupUpdateWithoutInputsInput, InputToInputGroupUncheckedUpdateWithoutInputsInput>
  }

  export type InputToInputGroupUpdateManyWithWhereWithoutInputsInput = {
    where: InputToInputGroupScalarWhereInput
    data: XOR<InputToInputGroupUpdateManyMutationInput, InputToInputGroupUncheckedUpdateManyWithoutInputsInput>
  }

  export type usersUpsertWithoutInputsInput = {
    update: XOR<usersUpdateWithoutInputsInput, usersUncheckedUpdateWithoutInputsInput>
    create: XOR<usersCreateWithoutInputsInput, usersUncheckedCreateWithoutInputsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutInputsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutInputsInput, usersUncheckedUpdateWithoutInputsInput>
  }

  export type usersUpdateWithoutInputsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    ai_analysis_audit?: ai_analysis_auditUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUpdateManyWithoutUsersNestedInput
    signals?: signalsUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    departments_users_departmentObjIdTodepartments?: departmentsUpdateOneWithoutUsers_users_departmentObjIdTodepartmentsNestedInput
    users?: usersUpdateOneWithoutOther_usersNestedInput
    other_users?: usersUpdateManyWithoutUsersNestedInput
    votes?: votesUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUncheckedUpdateWithoutInputsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUncheckedUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUncheckedUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUncheckedUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutUsersNestedInput
    signals?: signalsUncheckedUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    other_users?: usersUncheckedUpdateManyWithoutUsersNestedInput
    votes?: votesUncheckedUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUncheckedUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type solutionsUpsertWithWhereUniqueWithoutInputsInput = {
    where: solutionsWhereUniqueInput
    update: XOR<solutionsUpdateWithoutInputsInput, solutionsUncheckedUpdateWithoutInputsInput>
    create: XOR<solutionsCreateWithoutInputsInput, solutionsUncheckedCreateWithoutInputsInput>
  }

  export type solutionsUpdateWithWhereUniqueWithoutInputsInput = {
    where: solutionsWhereUniqueInput
    data: XOR<solutionsUpdateWithoutInputsInput, solutionsUncheckedUpdateWithoutInputsInput>
  }

  export type solutionsUpdateManyWithWhereWithoutInputsInput = {
    where: solutionsScalarWhereInput
    data: XOR<solutionsUpdateManyMutationInput, solutionsUncheckedUpdateManyWithoutInputsInput>
  }

  export type usersCreateWithoutRequirementsInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    ai_analysis_audit?: ai_analysis_auditCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasCreateNestedManyWithoutUsersInput
    initiatives?: initiativesCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsCreateNestedManyWithoutUsersInput
    inputs?: inputsCreateNestedManyWithoutUsersInput
    signals?: signalsCreateNestedManyWithoutUsersInput
    solutions?: solutionsCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    departments_users_departmentObjIdTodepartments?: departmentsCreateNestedOneWithoutUsers_users_departmentObjIdTodepartmentsInput
    users?: usersCreateNestedOneWithoutOther_usersInput
    other_users?: usersCreateNestedManyWithoutUsersInput
    votes?: votesCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersUncheckedCreateWithoutRequirementsInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    managerId?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    departmentObjId?: string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsUncheckedCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasUncheckedCreateNestedManyWithoutUsersInput
    initiatives?: initiativesUncheckedCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsUncheckedCreateNestedManyWithoutUsersInput
    inputs?: inputsUncheckedCreateNestedManyWithoutUsersInput
    signals?: signalsUncheckedCreateNestedManyWithoutUsersInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsUncheckedCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    other_users?: usersUncheckedCreateNestedManyWithoutUsersInput
    votes?: votesUncheckedCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsUncheckedCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersCreateOrConnectWithoutRequirementsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutRequirementsInput, usersUncheckedCreateWithoutRequirementsInput>
  }

  export type solutionsCreateWithoutRequirementsInput = {
    id: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    createdAt?: Date | string
    updatedAt: Date | string
    estimatedEffort?: string | null
    actualCompletionDate?: Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsCreateNestedManyWithoutSolutionsInput
    users: usersCreateNestedOneWithoutSolutionsInput
    hotspots?: hotspotsCreateNestedOneWithoutSolutionsInput
    ideas?: ideasCreateNestedOneWithoutSolutionsInput
    initiatives?: initiativesCreateNestedOneWithoutSolutionsInput
    inputs?: inputsCreateNestedOneWithoutSolutionsInput
  }

  export type solutionsUncheckedCreateWithoutRequirementsInput = {
    id: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    createdAt?: Date | string
    updatedAt: Date | string
    estimatedEffort?: string | null
    actualCompletionDate?: Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    createdBy: string
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    hotspotId?: string | null
    ideaId?: string | null
    initiativeId?: string | null
    inputId?: string | null
    progress?: number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsUncheckedCreateNestedManyWithoutSolutionsInput
  }

  export type solutionsCreateOrConnectWithoutRequirementsInput = {
    where: solutionsWhereUniqueInput
    create: XOR<solutionsCreateWithoutRequirementsInput, solutionsUncheckedCreateWithoutRequirementsInput>
  }

  export type usersUpsertWithoutRequirementsInput = {
    update: XOR<usersUpdateWithoutRequirementsInput, usersUncheckedUpdateWithoutRequirementsInput>
    create: XOR<usersCreateWithoutRequirementsInput, usersUncheckedCreateWithoutRequirementsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutRequirementsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutRequirementsInput, usersUncheckedUpdateWithoutRequirementsInput>
  }

  export type usersUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    ai_analysis_audit?: ai_analysis_auditUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUpdateManyWithoutUsersNestedInput
    inputs?: inputsUpdateManyWithoutUsersNestedInput
    signals?: signalsUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    departments_users_departmentObjIdTodepartments?: departmentsUpdateOneWithoutUsers_users_departmentObjIdTodepartmentsNestedInput
    users?: usersUpdateOneWithoutOther_usersNestedInput
    other_users?: usersUpdateManyWithoutUsersNestedInput
    votes?: votesUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUncheckedUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUncheckedUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUncheckedUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUncheckedUpdateManyWithoutUsersNestedInput
    inputs?: inputsUncheckedUpdateManyWithoutUsersNestedInput
    signals?: signalsUncheckedUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    other_users?: usersUncheckedUpdateManyWithoutUsersNestedInput
    votes?: votesUncheckedUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUncheckedUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type solutionsUpsertWithoutRequirementsInput = {
    update: XOR<solutionsUpdateWithoutRequirementsInput, solutionsUncheckedUpdateWithoutRequirementsInput>
    create: XOR<solutionsCreateWithoutRequirementsInput, solutionsUncheckedCreateWithoutRequirementsInput>
    where?: solutionsWhereInput
  }

  export type solutionsUpdateToOneWithWhereWithoutRequirementsInput = {
    where?: solutionsWhereInput
    data: XOR<solutionsUpdateWithoutRequirementsInput, solutionsUncheckedUpdateWithoutRequirementsInput>
  }

  export type solutionsUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsUpdateManyWithoutSolutionsNestedInput
    users?: usersUpdateOneRequiredWithoutSolutionsNestedInput
    hotspots?: hotspotsUpdateOneWithoutSolutionsNestedInput
    ideas?: ideasUpdateOneWithoutSolutionsNestedInput
    initiatives?: initiativesUpdateOneWithoutSolutionsNestedInput
    inputs?: inputsUpdateOneWithoutSolutionsNestedInput
  }

  export type solutionsUncheckedUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    hotspotId?: NullableStringFieldUpdateOperationsInput | string | null
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    inputId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsUncheckedUpdateManyWithoutSolutionsNestedInput
  }

  export type ai_insight_overridesCreateWithoutSignalsInput = {
    id: string
    insightId: string
    insightType: string
    originalRecommendation?: NullableJsonNullValueInput | InputJsonValue
    overrideReason: string
    executiveJustification?: string | null
    newValue?: NullableJsonNullValueInput | InputJsonValue
    executiveName: string
    executiveEmail: string
    overriddenAt?: Date | string
    createdAt?: Date | string
    users: usersCreateNestedOneWithoutAi_insight_overridesInput
  }

  export type ai_insight_overridesUncheckedCreateWithoutSignalsInput = {
    id: string
    insightId: string
    insightType: string
    originalRecommendation?: NullableJsonNullValueInput | InputJsonValue
    overrideReason: string
    executiveJustification?: string | null
    newValue?: NullableJsonNullValueInput | InputJsonValue
    executiveId: string
    executiveName: string
    executiveEmail: string
    overriddenAt?: Date | string
    createdAt?: Date | string
  }

  export type ai_insight_overridesCreateOrConnectWithoutSignalsInput = {
    where: ai_insight_overridesWhereUniqueInput
    create: XOR<ai_insight_overridesCreateWithoutSignalsInput, ai_insight_overridesUncheckedCreateWithoutSignalsInput>
  }

  export type ai_insight_overridesCreateManySignalsInputEnvelope = {
    data: ai_insight_overridesCreateManySignalsInput | ai_insight_overridesCreateManySignalsInput[]
    skipDuplicates?: boolean
  }

  export type hotspot_signalsCreateWithoutSignalsInput = {
    membershipStrength?: number
    isOutlier?: boolean
    addedAt?: Date | string
    hotspots: hotspotsCreateNestedOneWithoutHotspot_signalsInput
  }

  export type hotspot_signalsUncheckedCreateWithoutSignalsInput = {
    hotspotId: string
    membershipStrength?: number
    isOutlier?: boolean
    addedAt?: Date | string
  }

  export type hotspot_signalsCreateOrConnectWithoutSignalsInput = {
    where: hotspot_signalsWhereUniqueInput
    create: XOR<hotspot_signalsCreateWithoutSignalsInput, hotspot_signalsUncheckedCreateWithoutSignalsInput>
  }

  export type hotspot_signalsCreateManySignalsInputEnvelope = {
    data: hotspot_signalsCreateManySignalsInput | hotspot_signalsCreateManySignalsInput[]
    skipDuplicates?: boolean
  }

  export type categoriesCreateWithoutSignalsInput = {
    id: string
    name: string
    description?: string | null
    color?: string | null
    icon?: string | null
    isActive?: boolean
    sortOrder?: number
    usageCount?: number
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    categories?: categoriesCreateNestedOneWithoutOther_categoriesInput
    other_categories?: categoriesCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateWithoutSignalsInput = {
    id: string
    name: string
    description?: string | null
    color?: string | null
    icon?: string | null
    parentId?: string | null
    isActive?: boolean
    sortOrder?: number
    usageCount?: number
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    other_categories?: categoriesUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesCreateOrConnectWithoutSignalsInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutSignalsInput, categoriesUncheckedCreateWithoutSignalsInput>
  }

  export type usersCreateWithoutSignalsInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    ai_analysis_audit?: ai_analysis_auditCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasCreateNestedManyWithoutUsersInput
    initiatives?: initiativesCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsCreateNestedManyWithoutUsersInput
    inputs?: inputsCreateNestedManyWithoutUsersInput
    requirements?: requirementsCreateNestedManyWithoutUsersInput
    solutions?: solutionsCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    departments_users_departmentObjIdTodepartments?: departmentsCreateNestedOneWithoutUsers_users_departmentObjIdTodepartmentsInput
    users?: usersCreateNestedOneWithoutOther_usersInput
    other_users?: usersCreateNestedManyWithoutUsersInput
    votes?: votesCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersUncheckedCreateWithoutSignalsInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    managerId?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    departmentObjId?: string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsUncheckedCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasUncheckedCreateNestedManyWithoutUsersInput
    initiatives?: initiativesUncheckedCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsUncheckedCreateNestedManyWithoutUsersInput
    inputs?: inputsUncheckedCreateNestedManyWithoutUsersInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutUsersInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsUncheckedCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    other_users?: usersUncheckedCreateNestedManyWithoutUsersInput
    votes?: votesUncheckedCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsUncheckedCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersCreateOrConnectWithoutSignalsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSignalsInput, usersUncheckedCreateWithoutSignalsInput>
  }

  export type departmentsCreateWithoutSignalsInput = {
    id: string
    name: string
    description?: string | null
    headCount?: number
    budgetAllocation?: number
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    utilizationTarget?: number | null
    actualUtilization?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    users_departments_managerIdTousers?: usersCreateNestedOneWithoutDepartments_departments_managerIdTousersInput
    teams?: teamsCreateNestedManyWithoutDepartmentsInput
    users_users_departmentObjIdTodepartments?: usersCreateNestedManyWithoutDepartments_users_departmentObjIdTodepartmentsInput
  }

  export type departmentsUncheckedCreateWithoutSignalsInput = {
    id: string
    name: string
    description?: string | null
    headCount?: number
    budgetAllocation?: number
    managerId?: string | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    utilizationTarget?: number | null
    actualUtilization?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    teams?: teamsUncheckedCreateNestedManyWithoutDepartmentsInput
    users_users_departmentObjIdTodepartments?: usersUncheckedCreateNestedManyWithoutDepartments_users_departmentObjIdTodepartmentsInput
  }

  export type departmentsCreateOrConnectWithoutSignalsInput = {
    where: departmentsWhereUniqueInput
    create: XOR<departmentsCreateWithoutSignalsInput, departmentsUncheckedCreateWithoutSignalsInput>
  }

  export type teamsCreateWithoutSignalsInput = {
    id: string
    name: string
    description?: string | null
    memberCount?: number
    maxCapacity?: number | null
    isActive?: boolean
    teamType?: string | null
    currentProjects?: number
    budgetAllocation?: number
    utilizationRate?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    departments?: departmentsCreateNestedOneWithoutTeamsInput
    users_teams_leaderIdTousers?: usersCreateNestedOneWithoutTeams_teams_leaderIdTousersInput
    users_TeamMembers?: usersCreateNestedManyWithoutTeams_TeamMembersInput
  }

  export type teamsUncheckedCreateWithoutSignalsInput = {
    id: string
    name: string
    description?: string | null
    departmentId?: string | null
    leaderId?: string | null
    memberCount?: number
    maxCapacity?: number | null
    isActive?: boolean
    teamType?: string | null
    currentProjects?: number
    budgetAllocation?: number
    utilizationRate?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    users_TeamMembers?: usersUncheckedCreateNestedManyWithoutTeams_TeamMembersInput
  }

  export type teamsCreateOrConnectWithoutSignalsInput = {
    where: teamsWhereUniqueInput
    create: XOR<teamsCreateWithoutSignalsInput, teamsUncheckedCreateWithoutSignalsInput>
  }

  export type ai_insight_overridesUpsertWithWhereUniqueWithoutSignalsInput = {
    where: ai_insight_overridesWhereUniqueInput
    update: XOR<ai_insight_overridesUpdateWithoutSignalsInput, ai_insight_overridesUncheckedUpdateWithoutSignalsInput>
    create: XOR<ai_insight_overridesCreateWithoutSignalsInput, ai_insight_overridesUncheckedCreateWithoutSignalsInput>
  }

  export type ai_insight_overridesUpdateWithWhereUniqueWithoutSignalsInput = {
    where: ai_insight_overridesWhereUniqueInput
    data: XOR<ai_insight_overridesUpdateWithoutSignalsInput, ai_insight_overridesUncheckedUpdateWithoutSignalsInput>
  }

  export type ai_insight_overridesUpdateManyWithWhereWithoutSignalsInput = {
    where: ai_insight_overridesScalarWhereInput
    data: XOR<ai_insight_overridesUpdateManyMutationInput, ai_insight_overridesUncheckedUpdateManyWithoutSignalsInput>
  }

  export type ai_insight_overridesScalarWhereInput = {
    AND?: ai_insight_overridesScalarWhereInput | ai_insight_overridesScalarWhereInput[]
    OR?: ai_insight_overridesScalarWhereInput[]
    NOT?: ai_insight_overridesScalarWhereInput | ai_insight_overridesScalarWhereInput[]
    id?: StringFilter<"ai_insight_overrides"> | string
    signalId?: StringFilter<"ai_insight_overrides"> | string
    insightId?: StringFilter<"ai_insight_overrides"> | string
    insightType?: StringFilter<"ai_insight_overrides"> | string
    originalRecommendation?: JsonNullableFilter<"ai_insight_overrides">
    overrideReason?: StringFilter<"ai_insight_overrides"> | string
    executiveJustification?: StringNullableFilter<"ai_insight_overrides"> | string | null
    newValue?: JsonNullableFilter<"ai_insight_overrides">
    executiveId?: StringFilter<"ai_insight_overrides"> | string
    executiveName?: StringFilter<"ai_insight_overrides"> | string
    executiveEmail?: StringFilter<"ai_insight_overrides"> | string
    overriddenAt?: DateTimeFilter<"ai_insight_overrides"> | Date | string
    createdAt?: DateTimeFilter<"ai_insight_overrides"> | Date | string
  }

  export type hotspot_signalsUpsertWithWhereUniqueWithoutSignalsInput = {
    where: hotspot_signalsWhereUniqueInput
    update: XOR<hotspot_signalsUpdateWithoutSignalsInput, hotspot_signalsUncheckedUpdateWithoutSignalsInput>
    create: XOR<hotspot_signalsCreateWithoutSignalsInput, hotspot_signalsUncheckedCreateWithoutSignalsInput>
  }

  export type hotspot_signalsUpdateWithWhereUniqueWithoutSignalsInput = {
    where: hotspot_signalsWhereUniqueInput
    data: XOR<hotspot_signalsUpdateWithoutSignalsInput, hotspot_signalsUncheckedUpdateWithoutSignalsInput>
  }

  export type hotspot_signalsUpdateManyWithWhereWithoutSignalsInput = {
    where: hotspot_signalsScalarWhereInput
    data: XOR<hotspot_signalsUpdateManyMutationInput, hotspot_signalsUncheckedUpdateManyWithoutSignalsInput>
  }

  export type categoriesUpsertWithoutSignalsInput = {
    update: XOR<categoriesUpdateWithoutSignalsInput, categoriesUncheckedUpdateWithoutSignalsInput>
    create: XOR<categoriesCreateWithoutSignalsInput, categoriesUncheckedCreateWithoutSignalsInput>
    where?: categoriesWhereInput
  }

  export type categoriesUpdateToOneWithWhereWithoutSignalsInput = {
    where?: categoriesWhereInput
    data: XOR<categoriesUpdateWithoutSignalsInput, categoriesUncheckedUpdateWithoutSignalsInput>
  }

  export type categoriesUpdateWithoutSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: categoriesUpdateOneWithoutOther_categoriesNestedInput
    other_categories?: categoriesUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateWithoutSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    other_categories?: categoriesUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type usersUpsertWithoutSignalsInput = {
    update: XOR<usersUpdateWithoutSignalsInput, usersUncheckedUpdateWithoutSignalsInput>
    create: XOR<usersCreateWithoutSignalsInput, usersUncheckedCreateWithoutSignalsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSignalsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSignalsInput, usersUncheckedUpdateWithoutSignalsInput>
  }

  export type usersUpdateWithoutSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    ai_analysis_audit?: ai_analysis_auditUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUpdateManyWithoutUsersNestedInput
    inputs?: inputsUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    departments_users_departmentObjIdTodepartments?: departmentsUpdateOneWithoutUsers_users_departmentObjIdTodepartmentsNestedInput
    users?: usersUpdateOneWithoutOther_usersNestedInput
    other_users?: usersUpdateManyWithoutUsersNestedInput
    votes?: votesUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUncheckedUpdateWithoutSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUncheckedUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUncheckedUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUncheckedUpdateManyWithoutUsersNestedInput
    inputs?: inputsUncheckedUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    other_users?: usersUncheckedUpdateManyWithoutUsersNestedInput
    votes?: votesUncheckedUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUncheckedUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type departmentsUpsertWithoutSignalsInput = {
    update: XOR<departmentsUpdateWithoutSignalsInput, departmentsUncheckedUpdateWithoutSignalsInput>
    create: XOR<departmentsCreateWithoutSignalsInput, departmentsUncheckedCreateWithoutSignalsInput>
    where?: departmentsWhereInput
  }

  export type departmentsUpdateToOneWithWhereWithoutSignalsInput = {
    where?: departmentsWhereInput
    data: XOR<departmentsUpdateWithoutSignalsInput, departmentsUncheckedUpdateWithoutSignalsInput>
  }

  export type departmentsUpdateWithoutSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headCount?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    utilizationTarget?: NullableFloatFieldUpdateOperationsInput | number | null
    actualUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_departments_managerIdTousers?: usersUpdateOneWithoutDepartments_departments_managerIdTousersNestedInput
    teams?: teamsUpdateManyWithoutDepartmentsNestedInput
    users_users_departmentObjIdTodepartments?: usersUpdateManyWithoutDepartments_users_departmentObjIdTodepartmentsNestedInput
  }

  export type departmentsUncheckedUpdateWithoutSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headCount?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    utilizationTarget?: NullableFloatFieldUpdateOperationsInput | number | null
    actualUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: teamsUncheckedUpdateManyWithoutDepartmentsNestedInput
    users_users_departmentObjIdTodepartments?: usersUncheckedUpdateManyWithoutDepartments_users_departmentObjIdTodepartmentsNestedInput
  }

  export type teamsUpsertWithoutSignalsInput = {
    update: XOR<teamsUpdateWithoutSignalsInput, teamsUncheckedUpdateWithoutSignalsInput>
    create: XOR<teamsCreateWithoutSignalsInput, teamsUncheckedCreateWithoutSignalsInput>
    where?: teamsWhereInput
  }

  export type teamsUpdateToOneWithWhereWithoutSignalsInput = {
    where?: teamsWhereInput
    data: XOR<teamsUpdateWithoutSignalsInput, teamsUncheckedUpdateWithoutSignalsInput>
  }

  export type teamsUpdateWithoutSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: IntFieldUpdateOperationsInput | number
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teamType?: NullableStringFieldUpdateOperationsInput | string | null
    currentProjects?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: departmentsUpdateOneWithoutTeamsNestedInput
    users_teams_leaderIdTousers?: usersUpdateOneWithoutTeams_teams_leaderIdTousersNestedInput
    users_TeamMembers?: usersUpdateManyWithoutTeams_TeamMembersNestedInput
  }

  export type teamsUncheckedUpdateWithoutSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: IntFieldUpdateOperationsInput | number
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teamType?: NullableStringFieldUpdateOperationsInput | string | null
    currentProjects?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_TeamMembers?: usersUncheckedUpdateManyWithoutTeams_TeamMembersNestedInput
  }

  export type frd_documentsCreateWithoutSolutionsInput = {
    id: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    users_frd_documents_approvedByTousers?: usersCreateNestedOneWithoutFrd_documents_frd_documents_approvedByTousersInput
    users_frd_documents_createdByTousers: usersCreateNestedOneWithoutFrd_documents_frd_documents_createdByTousersInput
  }

  export type frd_documentsUncheckedCreateWithoutSolutionsInput = {
    id: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type frd_documentsCreateOrConnectWithoutSolutionsInput = {
    where: frd_documentsWhereUniqueInput
    create: XOR<frd_documentsCreateWithoutSolutionsInput, frd_documentsUncheckedCreateWithoutSolutionsInput>
  }

  export type frd_documentsCreateManySolutionsInputEnvelope = {
    data: frd_documentsCreateManySolutionsInput | frd_documentsCreateManySolutionsInput[]
    skipDuplicates?: boolean
  }

  export type requirementsCreateWithoutSolutionsInput = {
    id: string
    title: string
    description: string
    acceptanceCriteria: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequirementStatus
    estimatedEffort?: string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    riskAssessment?: string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    priority?: $Enums.priority
    users: usersCreateNestedOneWithoutRequirementsInput
  }

  export type requirementsUncheckedCreateWithoutSolutionsInput = {
    id: string
    title: string
    description: string
    acceptanceCriteria: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequirementStatus
    estimatedEffort?: string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    riskAssessment?: string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
    priority?: $Enums.priority
  }

  export type requirementsCreateOrConnectWithoutSolutionsInput = {
    where: requirementsWhereUniqueInput
    create: XOR<requirementsCreateWithoutSolutionsInput, requirementsUncheckedCreateWithoutSolutionsInput>
  }

  export type requirementsCreateManySolutionsInputEnvelope = {
    data: requirementsCreateManySolutionsInput | requirementsCreateManySolutionsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutSolutionsInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    ai_analysis_audit?: ai_analysis_auditCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasCreateNestedManyWithoutUsersInput
    initiatives?: initiativesCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsCreateNestedManyWithoutUsersInput
    inputs?: inputsCreateNestedManyWithoutUsersInput
    requirements?: requirementsCreateNestedManyWithoutUsersInput
    signals?: signalsCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    departments_users_departmentObjIdTodepartments?: departmentsCreateNestedOneWithoutUsers_users_departmentObjIdTodepartmentsInput
    users?: usersCreateNestedOneWithoutOther_usersInput
    other_users?: usersCreateNestedManyWithoutUsersInput
    votes?: votesCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersUncheckedCreateWithoutSolutionsInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    managerId?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    departmentObjId?: string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsUncheckedCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasUncheckedCreateNestedManyWithoutUsersInput
    initiatives?: initiativesUncheckedCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsUncheckedCreateNestedManyWithoutUsersInput
    inputs?: inputsUncheckedCreateNestedManyWithoutUsersInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutUsersInput
    signals?: signalsUncheckedCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsUncheckedCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    other_users?: usersUncheckedCreateNestedManyWithoutUsersInput
    votes?: votesUncheckedCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsUncheckedCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersCreateOrConnectWithoutSolutionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSolutionsInput, usersUncheckedCreateWithoutSolutionsInput>
  }

  export type hotspotsCreateWithoutSolutionsInput = {
    id: string
    title: string
    summary: string
    status?: $Enums.HotspotStatus
    rankScore?: number
    confidence?: number
    primaryCategoryId?: string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: string | null
    similarityThreshold?: number | null
    rcaBreakdownJson?: NullableJsonNullValueInput | InputJsonValue
    solutionSuggestionsJson?: NullableJsonNullValueInput | InputJsonValue
    decisionMatrixJson?: NullableJsonNullValueInput | InputJsonValue
    crossFunctionalImpactJson?: NullableJsonNullValueInput | InputJsonValue
    lastAnalysisAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    clusteringQualityScore?: number | null
    clusteringResults?: NullableJsonNullValueInput | InputJsonValue
    clusteringVersion?: string | null
    lastClusteredAt?: Date | string | null
    hotspot_signals?: hotspot_signalsCreateNestedManyWithoutHotspotsInput
    ideas?: ideasCreateNestedManyWithoutHotspotsInput
  }

  export type hotspotsUncheckedCreateWithoutSolutionsInput = {
    id: string
    title: string
    summary: string
    status?: $Enums.HotspotStatus
    rankScore?: number
    confidence?: number
    primaryCategoryId?: string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: string | null
    similarityThreshold?: number | null
    rcaBreakdownJson?: NullableJsonNullValueInput | InputJsonValue
    solutionSuggestionsJson?: NullableJsonNullValueInput | InputJsonValue
    decisionMatrixJson?: NullableJsonNullValueInput | InputJsonValue
    crossFunctionalImpactJson?: NullableJsonNullValueInput | InputJsonValue
    lastAnalysisAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    clusteringQualityScore?: number | null
    clusteringResults?: NullableJsonNullValueInput | InputJsonValue
    clusteringVersion?: string | null
    lastClusteredAt?: Date | string | null
    hotspot_signals?: hotspot_signalsUncheckedCreateNestedManyWithoutHotspotsInput
    ideas?: ideasUncheckedCreateNestedManyWithoutHotspotsInput
  }

  export type hotspotsCreateOrConnectWithoutSolutionsInput = {
    where: hotspotsWhereUniqueInput
    create: XOR<hotspotsCreateWithoutSolutionsInput, hotspotsUncheckedCreateWithoutSolutionsInput>
  }

  export type ideasCreateWithoutSolutionsInput = {
    id: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    users?: usersCreateNestedOneWithoutIdeasInput
    hotspots: hotspotsCreateNestedOneWithoutIdeasInput
    initiatives?: initiativesCreateNestedOneWithoutIdeasInput
  }

  export type ideasUncheckedCreateWithoutSolutionsInput = {
    id: string
    hotspotId: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdById?: string | null
    initiativeId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ideasCreateOrConnectWithoutSolutionsInput = {
    where: ideasWhereUniqueInput
    create: XOR<ideasCreateWithoutSolutionsInput, ideasUncheckedCreateWithoutSolutionsInput>
  }

  export type initiativesCreateWithoutSolutionsInput = {
    id: string
    name: string
    description?: string | null
    status?: $Enums.initiative_status
    priority?: $Enums.priority
    budget?: number
    actualSpend?: number
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completionDate?: Date | string | null
    expectedROI?: number | null
    actualROI?: number | null
    riskLevel?: $Enums.risk_level
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    milestonesJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    ideas?: ideasCreateNestedManyWithoutInitiativesInput
    users?: usersCreateNestedOneWithoutInitiativesInput
  }

  export type initiativesUncheckedCreateWithoutSolutionsInput = {
    id: string
    name: string
    description?: string | null
    status?: $Enums.initiative_status
    priority?: $Enums.priority
    ownerId?: string | null
    budget?: number
    actualSpend?: number
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completionDate?: Date | string | null
    expectedROI?: number | null
    actualROI?: number | null
    riskLevel?: $Enums.risk_level
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    milestonesJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    ideas?: ideasUncheckedCreateNestedManyWithoutInitiativesInput
  }

  export type initiativesCreateOrConnectWithoutSolutionsInput = {
    where: initiativesWhereUniqueInput
    create: XOR<initiativesCreateWithoutSolutionsInput, initiativesUncheckedCreateWithoutSolutionsInput>
  }

  export type inputsCreateWithoutSolutionsInput = {
    id: string
    title: string
    description: string
    type?: $Enums.InputType
    status?: $Enums.InputStatus
    createdAt?: Date | string
    updatedAt: Date | string
    department?: string | null
    rootCause?: string | null
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: number | null
    issueType?: string | null
    priority?: $Enums.priority
    InputToInputGroup?: InputToInputGroupCreateNestedManyWithoutInputsInput
    users: usersCreateNestedOneWithoutInputsInput
  }

  export type inputsUncheckedCreateWithoutSolutionsInput = {
    id: string
    title: string
    description: string
    type?: $Enums.InputType
    status?: $Enums.InputStatus
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
    department?: string | null
    rootCause?: string | null
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: number | null
    issueType?: string | null
    priority?: $Enums.priority
    InputToInputGroup?: InputToInputGroupUncheckedCreateNestedManyWithoutInputsInput
  }

  export type inputsCreateOrConnectWithoutSolutionsInput = {
    where: inputsWhereUniqueInput
    create: XOR<inputsCreateWithoutSolutionsInput, inputsUncheckedCreateWithoutSolutionsInput>
  }

  export type frd_documentsUpsertWithWhereUniqueWithoutSolutionsInput = {
    where: frd_documentsWhereUniqueInput
    update: XOR<frd_documentsUpdateWithoutSolutionsInput, frd_documentsUncheckedUpdateWithoutSolutionsInput>
    create: XOR<frd_documentsCreateWithoutSolutionsInput, frd_documentsUncheckedCreateWithoutSolutionsInput>
  }

  export type frd_documentsUpdateWithWhereUniqueWithoutSolutionsInput = {
    where: frd_documentsWhereUniqueInput
    data: XOR<frd_documentsUpdateWithoutSolutionsInput, frd_documentsUncheckedUpdateWithoutSolutionsInput>
  }

  export type frd_documentsUpdateManyWithWhereWithoutSolutionsInput = {
    where: frd_documentsScalarWhereInput
    data: XOR<frd_documentsUpdateManyMutationInput, frd_documentsUncheckedUpdateManyWithoutSolutionsInput>
  }

  export type frd_documentsScalarWhereInput = {
    AND?: frd_documentsScalarWhereInput | frd_documentsScalarWhereInput[]
    OR?: frd_documentsScalarWhereInput[]
    NOT?: frd_documentsScalarWhereInput | frd_documentsScalarWhereInput[]
    id?: StringFilter<"frd_documents"> | string
    title?: StringFilter<"frd_documents"> | string
    content?: JsonFilter<"frd_documents">
    aiGenerated?: BoolFilter<"frd_documents"> | boolean
    aiConfidence?: FloatNullableFilter<"frd_documents"> | number | null
    aiPromptUsed?: StringNullableFilter<"frd_documents"> | string | null
    version?: StringFilter<"frd_documents"> | string
    status?: EnumFRDStatusFilter<"frd_documents"> | $Enums.FRDStatus
    executiveApproved?: BoolFilter<"frd_documents"> | boolean
    exportFormats?: JsonNullableFilter<"frd_documents">
    templateUsed?: StringNullableFilter<"frd_documents"> | string | null
    generationTime?: FloatNullableFilter<"frd_documents"> | number | null
    wordCount?: IntNullableFilter<"frd_documents"> | number | null
    lastExportedAt?: DateTimeNullableFilter<"frd_documents"> | Date | string | null
    solutionId?: StringFilter<"frd_documents"> | string
    createdBy?: StringFilter<"frd_documents"> | string
    approvedBy?: StringNullableFilter<"frd_documents"> | string | null
    createdAt?: DateTimeFilter<"frd_documents"> | Date | string
    updatedAt?: DateTimeFilter<"frd_documents"> | Date | string
  }

  export type requirementsUpsertWithWhereUniqueWithoutSolutionsInput = {
    where: requirementsWhereUniqueInput
    update: XOR<requirementsUpdateWithoutSolutionsInput, requirementsUncheckedUpdateWithoutSolutionsInput>
    create: XOR<requirementsCreateWithoutSolutionsInput, requirementsUncheckedCreateWithoutSolutionsInput>
  }

  export type requirementsUpdateWithWhereUniqueWithoutSolutionsInput = {
    where: requirementsWhereUniqueInput
    data: XOR<requirementsUpdateWithoutSolutionsInput, requirementsUncheckedUpdateWithoutSolutionsInput>
  }

  export type requirementsUpdateManyWithWhereWithoutSolutionsInput = {
    where: requirementsScalarWhereInput
    data: XOR<requirementsUpdateManyMutationInput, requirementsUncheckedUpdateManyWithoutSolutionsInput>
  }

  export type requirementsScalarWhereInput = {
    AND?: requirementsScalarWhereInput | requirementsScalarWhereInput[]
    OR?: requirementsScalarWhereInput[]
    NOT?: requirementsScalarWhereInput | requirementsScalarWhereInput[]
    id?: StringFilter<"requirements"> | string
    title?: StringFilter<"requirements"> | string
    description?: StringFilter<"requirements"> | string
    acceptanceCriteria?: JsonFilter<"requirements">
    status?: EnumRequirementStatusFilter<"requirements"> | $Enums.RequirementStatus
    estimatedEffort?: StringNullableFilter<"requirements"> | string | null
    dependencies?: JsonNullableFilter<"requirements">
    businessValue?: StringNullableFilter<"requirements"> | string | null
    riskAssessment?: StringNullableFilter<"requirements"> | string | null
    stakeholders?: JsonNullableFilter<"requirements">
    approvedBy?: StringNullableFilter<"requirements"> | string | null
    approvedAt?: DateTimeNullableFilter<"requirements"> | Date | string | null
    rejectionReason?: StringNullableFilter<"requirements"> | string | null
    solutionId?: StringFilter<"requirements"> | string
    createdBy?: StringFilter<"requirements"> | string
    createdAt?: DateTimeFilter<"requirements"> | Date | string
    updatedAt?: DateTimeFilter<"requirements"> | Date | string
    priority?: EnumpriorityFilter<"requirements"> | $Enums.priority
  }

  export type usersUpsertWithoutSolutionsInput = {
    update: XOR<usersUpdateWithoutSolutionsInput, usersUncheckedUpdateWithoutSolutionsInput>
    create: XOR<usersCreateWithoutSolutionsInput, usersUncheckedCreateWithoutSolutionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSolutionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSolutionsInput, usersUncheckedUpdateWithoutSolutionsInput>
  }

  export type usersUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    ai_analysis_audit?: ai_analysis_auditUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUpdateManyWithoutUsersNestedInput
    inputs?: inputsUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUpdateManyWithoutUsersNestedInput
    signals?: signalsUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    departments_users_departmentObjIdTodepartments?: departmentsUpdateOneWithoutUsers_users_departmentObjIdTodepartmentsNestedInput
    users?: usersUpdateOneWithoutOther_usersNestedInput
    other_users?: usersUpdateManyWithoutUsersNestedInput
    votes?: votesUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUncheckedUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUncheckedUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUncheckedUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUncheckedUpdateManyWithoutUsersNestedInput
    inputs?: inputsUncheckedUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutUsersNestedInput
    signals?: signalsUncheckedUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    other_users?: usersUncheckedUpdateManyWithoutUsersNestedInput
    votes?: votesUncheckedUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUncheckedUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type hotspotsUpsertWithoutSolutionsInput = {
    update: XOR<hotspotsUpdateWithoutSolutionsInput, hotspotsUncheckedUpdateWithoutSolutionsInput>
    create: XOR<hotspotsCreateWithoutSolutionsInput, hotspotsUncheckedCreateWithoutSolutionsInput>
    where?: hotspotsWhereInput
  }

  export type hotspotsUpdateToOneWithWhereWithoutSolutionsInput = {
    where?: hotspotsWhereInput
    data: XOR<hotspotsUpdateWithoutSolutionsInput, hotspotsUncheckedUpdateWithoutSolutionsInput>
  }

  export type hotspotsUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumHotspotStatusFieldUpdateOperationsInput | $Enums.HotspotStatus
    rankScore?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    primaryCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: NullableStringFieldUpdateOperationsInput | string | null
    similarityThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    rcaBreakdownJson?: NullableJsonNullValueInput | InputJsonValue
    solutionSuggestionsJson?: NullableJsonNullValueInput | InputJsonValue
    decisionMatrixJson?: NullableJsonNullValueInput | InputJsonValue
    crossFunctionalImpactJson?: NullableJsonNullValueInput | InputJsonValue
    lastAnalysisAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clusteringQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    clusteringResults?: NullableJsonNullValueInput | InputJsonValue
    clusteringVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastClusteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotspot_signals?: hotspot_signalsUpdateManyWithoutHotspotsNestedInput
    ideas?: ideasUpdateManyWithoutHotspotsNestedInput
  }

  export type hotspotsUncheckedUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumHotspotStatusFieldUpdateOperationsInput | $Enums.HotspotStatus
    rankScore?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    primaryCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: NullableStringFieldUpdateOperationsInput | string | null
    similarityThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    rcaBreakdownJson?: NullableJsonNullValueInput | InputJsonValue
    solutionSuggestionsJson?: NullableJsonNullValueInput | InputJsonValue
    decisionMatrixJson?: NullableJsonNullValueInput | InputJsonValue
    crossFunctionalImpactJson?: NullableJsonNullValueInput | InputJsonValue
    lastAnalysisAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clusteringQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    clusteringResults?: NullableJsonNullValueInput | InputJsonValue
    clusteringVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastClusteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotspot_signals?: hotspot_signalsUncheckedUpdateManyWithoutHotspotsNestedInput
    ideas?: ideasUncheckedUpdateManyWithoutHotspotsNestedInput
  }

  export type ideasUpsertWithoutSolutionsInput = {
    update: XOR<ideasUpdateWithoutSolutionsInput, ideasUncheckedUpdateWithoutSolutionsInput>
    create: XOR<ideasCreateWithoutSolutionsInput, ideasUncheckedCreateWithoutSolutionsInput>
    where?: ideasWhereInput
  }

  export type ideasUpdateToOneWithWhereWithoutSolutionsInput = {
    where?: ideasWhereInput
    data: XOR<ideasUpdateWithoutSolutionsInput, ideasUncheckedUpdateWithoutSolutionsInput>
  }

  export type ideasUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutIdeasNestedInput
    hotspots?: hotspotsUpdateOneRequiredWithoutIdeasNestedInput
    initiatives?: initiativesUpdateOneWithoutIdeasNestedInput
  }

  export type ideasUncheckedUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotspotId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type initiativesUpsertWithoutSolutionsInput = {
    update: XOR<initiativesUpdateWithoutSolutionsInput, initiativesUncheckedUpdateWithoutSolutionsInput>
    create: XOR<initiativesCreateWithoutSolutionsInput, initiativesUncheckedCreateWithoutSolutionsInput>
    where?: initiativesWhereInput
  }

  export type initiativesUpdateToOneWithWhereWithoutSolutionsInput = {
    where?: initiativesWhereInput
    data: XOR<initiativesUpdateWithoutSolutionsInput, initiativesUncheckedUpdateWithoutSolutionsInput>
  }

  export type initiativesUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enuminitiative_statusFieldUpdateOperationsInput | $Enums.initiative_status
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    budget?: FloatFieldUpdateOperationsInput | number
    actualSpend?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedROI?: NullableFloatFieldUpdateOperationsInput | number | null
    actualROI?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: Enumrisk_levelFieldUpdateOperationsInput | $Enums.risk_level
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    milestonesJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ideas?: ideasUpdateManyWithoutInitiativesNestedInput
    users?: usersUpdateOneWithoutInitiativesNestedInput
  }

  export type initiativesUncheckedUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enuminitiative_statusFieldUpdateOperationsInput | $Enums.initiative_status
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    actualSpend?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedROI?: NullableFloatFieldUpdateOperationsInput | number | null
    actualROI?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: Enumrisk_levelFieldUpdateOperationsInput | $Enums.risk_level
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    milestonesJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ideas?: ideasUncheckedUpdateManyWithoutInitiativesNestedInput
  }

  export type inputsUpsertWithoutSolutionsInput = {
    update: XOR<inputsUpdateWithoutSolutionsInput, inputsUncheckedUpdateWithoutSolutionsInput>
    create: XOR<inputsCreateWithoutSolutionsInput, inputsUncheckedCreateWithoutSolutionsInput>
    where?: inputsWhereInput
  }

  export type inputsUpdateToOneWithWhereWithoutSolutionsInput = {
    where?: inputsWhereInput
    data: XOR<inputsUpdateWithoutSolutionsInput, inputsUncheckedUpdateWithoutSolutionsInput>
  }

  export type inputsUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    InputToInputGroup?: InputToInputGroupUpdateManyWithoutInputsNestedInput
    users?: usersUpdateOneRequiredWithoutInputsNestedInput
  }

  export type inputsUncheckedUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    InputToInputGroup?: InputToInputGroupUncheckedUpdateManyWithoutInputsNestedInput
  }

  export type signalsCreateWithoutTeamsInput = {
    id: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: number | null
    featuresVersion?: string | null
    lastFeaturesGeneratedAt?: Date | string | null
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutSignalsInput
    hotspot_signals?: hotspot_signalsCreateNestedManyWithoutSignalsInput
    categories?: categoriesCreateNestedOneWithoutSignalsInput
    users?: usersCreateNestedOneWithoutSignalsInput
    departments?: departmentsCreateNestedOneWithoutSignalsInput
  }

  export type signalsUncheckedCreateWithoutTeamsInput = {
    id: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    departmentId?: string | null
    categoryId?: string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: number | null
    featuresVersion?: string | null
    lastFeaturesGeneratedAt?: Date | string | null
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutSignalsInput
    hotspot_signals?: hotspot_signalsUncheckedCreateNestedManyWithoutSignalsInput
  }

  export type signalsCreateOrConnectWithoutTeamsInput = {
    where: signalsWhereUniqueInput
    create: XOR<signalsCreateWithoutTeamsInput, signalsUncheckedCreateWithoutTeamsInput>
  }

  export type signalsCreateManyTeamsInputEnvelope = {
    data: signalsCreateManyTeamsInput | signalsCreateManyTeamsInput[]
    skipDuplicates?: boolean
  }

  export type departmentsCreateWithoutTeamsInput = {
    id: string
    name: string
    description?: string | null
    headCount?: number
    budgetAllocation?: number
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    utilizationTarget?: number | null
    actualUtilization?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    users_departments_managerIdTousers?: usersCreateNestedOneWithoutDepartments_departments_managerIdTousersInput
    signals?: signalsCreateNestedManyWithoutDepartmentsInput
    users_users_departmentObjIdTodepartments?: usersCreateNestedManyWithoutDepartments_users_departmentObjIdTodepartmentsInput
  }

  export type departmentsUncheckedCreateWithoutTeamsInput = {
    id: string
    name: string
    description?: string | null
    headCount?: number
    budgetAllocation?: number
    managerId?: string | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    utilizationTarget?: number | null
    actualUtilization?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    signals?: signalsUncheckedCreateNestedManyWithoutDepartmentsInput
    users_users_departmentObjIdTodepartments?: usersUncheckedCreateNestedManyWithoutDepartments_users_departmentObjIdTodepartmentsInput
  }

  export type departmentsCreateOrConnectWithoutTeamsInput = {
    where: departmentsWhereUniqueInput
    create: XOR<departmentsCreateWithoutTeamsInput, departmentsUncheckedCreateWithoutTeamsInput>
  }

  export type usersCreateWithoutTeams_teams_leaderIdTousersInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    ai_analysis_audit?: ai_analysis_auditCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasCreateNestedManyWithoutUsersInput
    initiatives?: initiativesCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsCreateNestedManyWithoutUsersInput
    inputs?: inputsCreateNestedManyWithoutUsersInput
    requirements?: requirementsCreateNestedManyWithoutUsersInput
    signals?: signalsCreateNestedManyWithoutUsersInput
    solutions?: solutionsCreateNestedManyWithoutUsersInput
    departments_users_departmentObjIdTodepartments?: departmentsCreateNestedOneWithoutUsers_users_departmentObjIdTodepartmentsInput
    users?: usersCreateNestedOneWithoutOther_usersInput
    other_users?: usersCreateNestedManyWithoutUsersInput
    votes?: votesCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersUncheckedCreateWithoutTeams_teams_leaderIdTousersInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    managerId?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    departmentObjId?: string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsUncheckedCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasUncheckedCreateNestedManyWithoutUsersInput
    initiatives?: initiativesUncheckedCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsUncheckedCreateNestedManyWithoutUsersInput
    inputs?: inputsUncheckedCreateNestedManyWithoutUsersInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutUsersInput
    signals?: signalsUncheckedCreateNestedManyWithoutUsersInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutUsersInput
    other_users?: usersUncheckedCreateNestedManyWithoutUsersInput
    votes?: votesUncheckedCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsUncheckedCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersCreateOrConnectWithoutTeams_teams_leaderIdTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTeams_teams_leaderIdTousersInput, usersUncheckedCreateWithoutTeams_teams_leaderIdTousersInput>
  }

  export type usersCreateWithoutTeams_TeamMembersInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    ai_analysis_audit?: ai_analysis_auditCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasCreateNestedManyWithoutUsersInput
    initiatives?: initiativesCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsCreateNestedManyWithoutUsersInput
    inputs?: inputsCreateNestedManyWithoutUsersInput
    requirements?: requirementsCreateNestedManyWithoutUsersInput
    signals?: signalsCreateNestedManyWithoutUsersInput
    solutions?: solutionsCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    departments_users_departmentObjIdTodepartments?: departmentsCreateNestedOneWithoutUsers_users_departmentObjIdTodepartmentsInput
    users?: usersCreateNestedOneWithoutOther_usersInput
    other_users?: usersCreateNestedManyWithoutUsersInput
    votes?: votesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutTeams_TeamMembersInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    managerId?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    departmentObjId?: string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsUncheckedCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasUncheckedCreateNestedManyWithoutUsersInput
    initiatives?: initiativesUncheckedCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsUncheckedCreateNestedManyWithoutUsersInput
    inputs?: inputsUncheckedCreateNestedManyWithoutUsersInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutUsersInput
    signals?: signalsUncheckedCreateNestedManyWithoutUsersInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsUncheckedCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    other_users?: usersUncheckedCreateNestedManyWithoutUsersInput
    votes?: votesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutTeams_TeamMembersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTeams_TeamMembersInput, usersUncheckedCreateWithoutTeams_TeamMembersInput>
  }

  export type signalsUpsertWithWhereUniqueWithoutTeamsInput = {
    where: signalsWhereUniqueInput
    update: XOR<signalsUpdateWithoutTeamsInput, signalsUncheckedUpdateWithoutTeamsInput>
    create: XOR<signalsCreateWithoutTeamsInput, signalsUncheckedCreateWithoutTeamsInput>
  }

  export type signalsUpdateWithWhereUniqueWithoutTeamsInput = {
    where: signalsWhereUniqueInput
    data: XOR<signalsUpdateWithoutTeamsInput, signalsUncheckedUpdateWithoutTeamsInput>
  }

  export type signalsUpdateManyWithWhereWithoutTeamsInput = {
    where: signalsScalarWhereInput
    data: XOR<signalsUpdateManyMutationInput, signalsUncheckedUpdateManyWithoutTeamsInput>
  }

  export type departmentsUpsertWithoutTeamsInput = {
    update: XOR<departmentsUpdateWithoutTeamsInput, departmentsUncheckedUpdateWithoutTeamsInput>
    create: XOR<departmentsCreateWithoutTeamsInput, departmentsUncheckedCreateWithoutTeamsInput>
    where?: departmentsWhereInput
  }

  export type departmentsUpdateToOneWithWhereWithoutTeamsInput = {
    where?: departmentsWhereInput
    data: XOR<departmentsUpdateWithoutTeamsInput, departmentsUncheckedUpdateWithoutTeamsInput>
  }

  export type departmentsUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headCount?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    utilizationTarget?: NullableFloatFieldUpdateOperationsInput | number | null
    actualUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_departments_managerIdTousers?: usersUpdateOneWithoutDepartments_departments_managerIdTousersNestedInput
    signals?: signalsUpdateManyWithoutDepartmentsNestedInput
    users_users_departmentObjIdTodepartments?: usersUpdateManyWithoutDepartments_users_departmentObjIdTodepartmentsNestedInput
  }

  export type departmentsUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headCount?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    utilizationTarget?: NullableFloatFieldUpdateOperationsInput | number | null
    actualUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: signalsUncheckedUpdateManyWithoutDepartmentsNestedInput
    users_users_departmentObjIdTodepartments?: usersUncheckedUpdateManyWithoutDepartments_users_departmentObjIdTodepartmentsNestedInput
  }

  export type usersUpsertWithoutTeams_teams_leaderIdTousersInput = {
    update: XOR<usersUpdateWithoutTeams_teams_leaderIdTousersInput, usersUncheckedUpdateWithoutTeams_teams_leaderIdTousersInput>
    create: XOR<usersCreateWithoutTeams_teams_leaderIdTousersInput, usersUncheckedCreateWithoutTeams_teams_leaderIdTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTeams_teams_leaderIdTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTeams_teams_leaderIdTousersInput, usersUncheckedUpdateWithoutTeams_teams_leaderIdTousersInput>
  }

  export type usersUpdateWithoutTeams_teams_leaderIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    ai_analysis_audit?: ai_analysis_auditUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUpdateManyWithoutUsersNestedInput
    inputs?: inputsUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUpdateManyWithoutUsersNestedInput
    signals?: signalsUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUpdateManyWithoutUsersNestedInput
    departments_users_departmentObjIdTodepartments?: departmentsUpdateOneWithoutUsers_users_departmentObjIdTodepartmentsNestedInput
    users?: usersUpdateOneWithoutOther_usersNestedInput
    other_users?: usersUpdateManyWithoutUsersNestedInput
    votes?: votesUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUncheckedUpdateWithoutTeams_teams_leaderIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUncheckedUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUncheckedUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUncheckedUpdateManyWithoutUsersNestedInput
    inputs?: inputsUncheckedUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutUsersNestedInput
    signals?: signalsUncheckedUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutUsersNestedInput
    other_users?: usersUncheckedUpdateManyWithoutUsersNestedInput
    votes?: votesUncheckedUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUncheckedUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUpsertWithWhereUniqueWithoutTeams_TeamMembersInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutTeams_TeamMembersInput, usersUncheckedUpdateWithoutTeams_TeamMembersInput>
    create: XOR<usersCreateWithoutTeams_TeamMembersInput, usersUncheckedCreateWithoutTeams_TeamMembersInput>
  }

  export type usersUpdateWithWhereUniqueWithoutTeams_TeamMembersInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutTeams_TeamMembersInput, usersUncheckedUpdateWithoutTeams_TeamMembersInput>
  }

  export type usersUpdateManyWithWhereWithoutTeams_TeamMembersInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutTeams_TeamMembersInput>
  }

  export type ai_analysis_auditCreateWithoutUsersInput = {
    id: string
    hotspotId: string
    analysisType: string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: number | null
    confidence?: number | null
    status: string
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type ai_analysis_auditUncheckedCreateWithoutUsersInput = {
    id: string
    hotspotId: string
    analysisType: string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: number | null
    confidence?: number | null
    status: string
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type ai_analysis_auditCreateOrConnectWithoutUsersInput = {
    where: ai_analysis_auditWhereUniqueInput
    create: XOR<ai_analysis_auditCreateWithoutUsersInput, ai_analysis_auditUncheckedCreateWithoutUsersInput>
  }

  export type ai_analysis_auditCreateManyUsersInputEnvelope = {
    data: ai_analysis_auditCreateManyUsersInput | ai_analysis_auditCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ai_insight_overridesCreateWithoutUsersInput = {
    id: string
    insightId: string
    insightType: string
    originalRecommendation?: NullableJsonNullValueInput | InputJsonValue
    overrideReason: string
    executiveJustification?: string | null
    newValue?: NullableJsonNullValueInput | InputJsonValue
    executiveName: string
    executiveEmail: string
    overriddenAt?: Date | string
    createdAt?: Date | string
    signals: signalsCreateNestedOneWithoutAi_insight_overridesInput
  }

  export type ai_insight_overridesUncheckedCreateWithoutUsersInput = {
    id: string
    signalId: string
    insightId: string
    insightType: string
    originalRecommendation?: NullableJsonNullValueInput | InputJsonValue
    overrideReason: string
    executiveJustification?: string | null
    newValue?: NullableJsonNullValueInput | InputJsonValue
    executiveName: string
    executiveEmail: string
    overriddenAt?: Date | string
    createdAt?: Date | string
  }

  export type ai_insight_overridesCreateOrConnectWithoutUsersInput = {
    where: ai_insight_overridesWhereUniqueInput
    create: XOR<ai_insight_overridesCreateWithoutUsersInput, ai_insight_overridesUncheckedCreateWithoutUsersInput>
  }

  export type ai_insight_overridesCreateManyUsersInputEnvelope = {
    data: ai_insight_overridesCreateManyUsersInput | ai_insight_overridesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type audit_logsCreateWithoutUsersInput = {
    id: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    sessionId?: string | null
  }

  export type audit_logsUncheckedCreateWithoutUsersInput = {
    id: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    sessionId?: string | null
  }

  export type audit_logsCreateOrConnectWithoutUsersInput = {
    where: audit_logsWhereUniqueInput
    create: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput>
  }

  export type audit_logsCreateManyUsersInputEnvelope = {
    data: audit_logsCreateManyUsersInput | audit_logsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type commentsCreateWithoutUsersInput = {
    id: string
    content: string
    createdAt?: Date | string
    updatedAt: Date | string
    edited?: boolean
    editedAt?: Date | string | null
    entityId: string
    entityType: $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
    comments?: commentsCreateNestedOneWithoutOther_commentsInput
    other_comments?: commentsCreateNestedManyWithoutCommentsInput
  }

  export type commentsUncheckedCreateWithoutUsersInput = {
    id: string
    content: string
    createdAt?: Date | string
    updatedAt: Date | string
    parentId?: string | null
    edited?: boolean
    editedAt?: Date | string | null
    entityId: string
    entityType: $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
    other_comments?: commentsUncheckedCreateNestedManyWithoutCommentsInput
  }

  export type commentsCreateOrConnectWithoutUsersInput = {
    where: commentsWhereUniqueInput
    create: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput>
  }

  export type commentsCreateManyUsersInputEnvelope = {
    data: commentsCreateManyUsersInput | commentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type departmentsCreateWithoutUsers_departments_managerIdTousersInput = {
    id: string
    name: string
    description?: string | null
    headCount?: number
    budgetAllocation?: number
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    utilizationTarget?: number | null
    actualUtilization?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    signals?: signalsCreateNestedManyWithoutDepartmentsInput
    teams?: teamsCreateNestedManyWithoutDepartmentsInput
    users_users_departmentObjIdTodepartments?: usersCreateNestedManyWithoutDepartments_users_departmentObjIdTodepartmentsInput
  }

  export type departmentsUncheckedCreateWithoutUsers_departments_managerIdTousersInput = {
    id: string
    name: string
    description?: string | null
    headCount?: number
    budgetAllocation?: number
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    utilizationTarget?: number | null
    actualUtilization?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    signals?: signalsUncheckedCreateNestedManyWithoutDepartmentsInput
    teams?: teamsUncheckedCreateNestedManyWithoutDepartmentsInput
    users_users_departmentObjIdTodepartments?: usersUncheckedCreateNestedManyWithoutDepartments_users_departmentObjIdTodepartmentsInput
  }

  export type departmentsCreateOrConnectWithoutUsers_departments_managerIdTousersInput = {
    where: departmentsWhereUniqueInput
    create: XOR<departmentsCreateWithoutUsers_departments_managerIdTousersInput, departmentsUncheckedCreateWithoutUsers_departments_managerIdTousersInput>
  }

  export type departmentsCreateManyUsers_departments_managerIdTousersInputEnvelope = {
    data: departmentsCreateManyUsers_departments_managerIdTousersInput | departmentsCreateManyUsers_departments_managerIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type frd_documentsCreateWithoutUsers_frd_documents_approvedByTousersInput = {
    id: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    users_frd_documents_createdByTousers: usersCreateNestedOneWithoutFrd_documents_frd_documents_createdByTousersInput
    solutions: solutionsCreateNestedOneWithoutFrd_documentsInput
  }

  export type frd_documentsUncheckedCreateWithoutUsers_frd_documents_approvedByTousersInput = {
    id: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    solutionId: string
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type frd_documentsCreateOrConnectWithoutUsers_frd_documents_approvedByTousersInput = {
    where: frd_documentsWhereUniqueInput
    create: XOR<frd_documentsCreateWithoutUsers_frd_documents_approvedByTousersInput, frd_documentsUncheckedCreateWithoutUsers_frd_documents_approvedByTousersInput>
  }

  export type frd_documentsCreateManyUsers_frd_documents_approvedByTousersInputEnvelope = {
    data: frd_documentsCreateManyUsers_frd_documents_approvedByTousersInput | frd_documentsCreateManyUsers_frd_documents_approvedByTousersInput[]
    skipDuplicates?: boolean
  }

  export type frd_documentsCreateWithoutUsers_frd_documents_createdByTousersInput = {
    id: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    users_frd_documents_approvedByTousers?: usersCreateNestedOneWithoutFrd_documents_frd_documents_approvedByTousersInput
    solutions: solutionsCreateNestedOneWithoutFrd_documentsInput
  }

  export type frd_documentsUncheckedCreateWithoutUsers_frd_documents_createdByTousersInput = {
    id: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    solutionId: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type frd_documentsCreateOrConnectWithoutUsers_frd_documents_createdByTousersInput = {
    where: frd_documentsWhereUniqueInput
    create: XOR<frd_documentsCreateWithoutUsers_frd_documents_createdByTousersInput, frd_documentsUncheckedCreateWithoutUsers_frd_documents_createdByTousersInput>
  }

  export type frd_documentsCreateManyUsers_frd_documents_createdByTousersInputEnvelope = {
    data: frd_documentsCreateManyUsers_frd_documents_createdByTousersInput | frd_documentsCreateManyUsers_frd_documents_createdByTousersInput[]
    skipDuplicates?: boolean
  }

  export type ideasCreateWithoutUsersInput = {
    id: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    hotspots: hotspotsCreateNestedOneWithoutIdeasInput
    initiatives?: initiativesCreateNestedOneWithoutIdeasInput
    solutions?: solutionsCreateNestedOneWithoutIdeasInput
  }

  export type ideasUncheckedCreateWithoutUsersInput = {
    id: string
    hotspotId: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    initiativeId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    solutions?: solutionsUncheckedCreateNestedOneWithoutIdeasInput
  }

  export type ideasCreateOrConnectWithoutUsersInput = {
    where: ideasWhereUniqueInput
    create: XOR<ideasCreateWithoutUsersInput, ideasUncheckedCreateWithoutUsersInput>
  }

  export type ideasCreateManyUsersInputEnvelope = {
    data: ideasCreateManyUsersInput | ideasCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type initiativesCreateWithoutUsersInput = {
    id: string
    name: string
    description?: string | null
    status?: $Enums.initiative_status
    priority?: $Enums.priority
    budget?: number
    actualSpend?: number
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completionDate?: Date | string | null
    expectedROI?: number | null
    actualROI?: number | null
    riskLevel?: $Enums.risk_level
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    milestonesJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    ideas?: ideasCreateNestedManyWithoutInitiativesInput
    solutions?: solutionsCreateNestedManyWithoutInitiativesInput
  }

  export type initiativesUncheckedCreateWithoutUsersInput = {
    id: string
    name: string
    description?: string | null
    status?: $Enums.initiative_status
    priority?: $Enums.priority
    budget?: number
    actualSpend?: number
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completionDate?: Date | string | null
    expectedROI?: number | null
    actualROI?: number | null
    riskLevel?: $Enums.risk_level
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    milestonesJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    ideas?: ideasUncheckedCreateNestedManyWithoutInitiativesInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutInitiativesInput
  }

  export type initiativesCreateOrConnectWithoutUsersInput = {
    where: initiativesWhereUniqueInput
    create: XOR<initiativesCreateWithoutUsersInput, initiativesUncheckedCreateWithoutUsersInput>
  }

  export type initiativesCreateManyUsersInputEnvelope = {
    data: initiativesCreateManyUsersInput | initiativesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type input_groupsCreateWithoutUsersInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    aiSuggested?: boolean
    aiConfidence?: number | null
    aiReasoning?: string | null
    avgPriority?: number | null
    color?: string | null
    inputCount?: number
    lastActivity?: Date | string | null
    InputToInputGroup?: InputToInputGroupCreateNestedManyWithoutInput_groupsInput
  }

  export type input_groupsUncheckedCreateWithoutUsersInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    aiSuggested?: boolean
    aiConfidence?: number | null
    aiReasoning?: string | null
    avgPriority?: number | null
    color?: string | null
    inputCount?: number
    lastActivity?: Date | string | null
    InputToInputGroup?: InputToInputGroupUncheckedCreateNestedManyWithoutInput_groupsInput
  }

  export type input_groupsCreateOrConnectWithoutUsersInput = {
    where: input_groupsWhereUniqueInput
    create: XOR<input_groupsCreateWithoutUsersInput, input_groupsUncheckedCreateWithoutUsersInput>
  }

  export type input_groupsCreateManyUsersInputEnvelope = {
    data: input_groupsCreateManyUsersInput | input_groupsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type inputsCreateWithoutUsersInput = {
    id: string
    title: string
    description: string
    type?: $Enums.InputType
    status?: $Enums.InputStatus
    createdAt?: Date | string
    updatedAt: Date | string
    department?: string | null
    rootCause?: string | null
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: number | null
    issueType?: string | null
    priority?: $Enums.priority
    InputToInputGroup?: InputToInputGroupCreateNestedManyWithoutInputsInput
    solutions?: solutionsCreateNestedManyWithoutInputsInput
  }

  export type inputsUncheckedCreateWithoutUsersInput = {
    id: string
    title: string
    description: string
    type?: $Enums.InputType
    status?: $Enums.InputStatus
    createdAt?: Date | string
    updatedAt: Date | string
    department?: string | null
    rootCause?: string | null
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: number | null
    issueType?: string | null
    priority?: $Enums.priority
    InputToInputGroup?: InputToInputGroupUncheckedCreateNestedManyWithoutInputsInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutInputsInput
  }

  export type inputsCreateOrConnectWithoutUsersInput = {
    where: inputsWhereUniqueInput
    create: XOR<inputsCreateWithoutUsersInput, inputsUncheckedCreateWithoutUsersInput>
  }

  export type inputsCreateManyUsersInputEnvelope = {
    data: inputsCreateManyUsersInput | inputsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type requirementsCreateWithoutUsersInput = {
    id: string
    title: string
    description: string
    acceptanceCriteria: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequirementStatus
    estimatedEffort?: string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    riskAssessment?: string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    priority?: $Enums.priority
    solutions: solutionsCreateNestedOneWithoutRequirementsInput
  }

  export type requirementsUncheckedCreateWithoutUsersInput = {
    id: string
    title: string
    description: string
    acceptanceCriteria: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequirementStatus
    estimatedEffort?: string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    riskAssessment?: string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    solutionId: string
    createdAt?: Date | string
    updatedAt: Date | string
    priority?: $Enums.priority
  }

  export type requirementsCreateOrConnectWithoutUsersInput = {
    where: requirementsWhereUniqueInput
    create: XOR<requirementsCreateWithoutUsersInput, requirementsUncheckedCreateWithoutUsersInput>
  }

  export type requirementsCreateManyUsersInputEnvelope = {
    data: requirementsCreateManyUsersInput | requirementsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type signalsCreateWithoutUsersInput = {
    id: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: number | null
    featuresVersion?: string | null
    lastFeaturesGeneratedAt?: Date | string | null
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutSignalsInput
    hotspot_signals?: hotspot_signalsCreateNestedManyWithoutSignalsInput
    categories?: categoriesCreateNestedOneWithoutSignalsInput
    departments?: departmentsCreateNestedOneWithoutSignalsInput
    teams?: teamsCreateNestedOneWithoutSignalsInput
  }

  export type signalsUncheckedCreateWithoutUsersInput = {
    id: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    departmentId?: string | null
    teamId?: string | null
    categoryId?: string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: number | null
    featuresVersion?: string | null
    lastFeaturesGeneratedAt?: Date | string | null
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutSignalsInput
    hotspot_signals?: hotspot_signalsUncheckedCreateNestedManyWithoutSignalsInput
  }

  export type signalsCreateOrConnectWithoutUsersInput = {
    where: signalsWhereUniqueInput
    create: XOR<signalsCreateWithoutUsersInput, signalsUncheckedCreateWithoutUsersInput>
  }

  export type signalsCreateManyUsersInputEnvelope = {
    data: signalsCreateManyUsersInput | signalsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type solutionsCreateWithoutUsersInput = {
    id: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    createdAt?: Date | string
    updatedAt: Date | string
    estimatedEffort?: string | null
    actualCompletionDate?: Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsCreateNestedManyWithoutSolutionsInput
    requirements?: requirementsCreateNestedManyWithoutSolutionsInput
    hotspots?: hotspotsCreateNestedOneWithoutSolutionsInput
    ideas?: ideasCreateNestedOneWithoutSolutionsInput
    initiatives?: initiativesCreateNestedOneWithoutSolutionsInput
    inputs?: inputsCreateNestedOneWithoutSolutionsInput
  }

  export type solutionsUncheckedCreateWithoutUsersInput = {
    id: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    createdAt?: Date | string
    updatedAt: Date | string
    estimatedEffort?: string | null
    actualCompletionDate?: Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    hotspotId?: string | null
    ideaId?: string | null
    initiativeId?: string | null
    inputId?: string | null
    progress?: number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsUncheckedCreateNestedManyWithoutSolutionsInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutSolutionsInput
  }

  export type solutionsCreateOrConnectWithoutUsersInput = {
    where: solutionsWhereUniqueInput
    create: XOR<solutionsCreateWithoutUsersInput, solutionsUncheckedCreateWithoutUsersInput>
  }

  export type solutionsCreateManyUsersInputEnvelope = {
    data: solutionsCreateManyUsersInput | solutionsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type teamsCreateWithoutUsers_teams_leaderIdTousersInput = {
    id: string
    name: string
    description?: string | null
    memberCount?: number
    maxCapacity?: number | null
    isActive?: boolean
    teamType?: string | null
    currentProjects?: number
    budgetAllocation?: number
    utilizationRate?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    signals?: signalsCreateNestedManyWithoutTeamsInput
    departments?: departmentsCreateNestedOneWithoutTeamsInput
    users_TeamMembers?: usersCreateNestedManyWithoutTeams_TeamMembersInput
  }

  export type teamsUncheckedCreateWithoutUsers_teams_leaderIdTousersInput = {
    id: string
    name: string
    description?: string | null
    departmentId?: string | null
    memberCount?: number
    maxCapacity?: number | null
    isActive?: boolean
    teamType?: string | null
    currentProjects?: number
    budgetAllocation?: number
    utilizationRate?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    signals?: signalsUncheckedCreateNestedManyWithoutTeamsInput
    users_TeamMembers?: usersUncheckedCreateNestedManyWithoutTeams_TeamMembersInput
  }

  export type teamsCreateOrConnectWithoutUsers_teams_leaderIdTousersInput = {
    where: teamsWhereUniqueInput
    create: XOR<teamsCreateWithoutUsers_teams_leaderIdTousersInput, teamsUncheckedCreateWithoutUsers_teams_leaderIdTousersInput>
  }

  export type teamsCreateManyUsers_teams_leaderIdTousersInputEnvelope = {
    data: teamsCreateManyUsers_teams_leaderIdTousersInput | teamsCreateManyUsers_teams_leaderIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type departmentsCreateWithoutUsers_users_departmentObjIdTodepartmentsInput = {
    id: string
    name: string
    description?: string | null
    headCount?: number
    budgetAllocation?: number
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    utilizationTarget?: number | null
    actualUtilization?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    users_departments_managerIdTousers?: usersCreateNestedOneWithoutDepartments_departments_managerIdTousersInput
    signals?: signalsCreateNestedManyWithoutDepartmentsInput
    teams?: teamsCreateNestedManyWithoutDepartmentsInput
  }

  export type departmentsUncheckedCreateWithoutUsers_users_departmentObjIdTodepartmentsInput = {
    id: string
    name: string
    description?: string | null
    headCount?: number
    budgetAllocation?: number
    managerId?: string | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    utilizationTarget?: number | null
    actualUtilization?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    signals?: signalsUncheckedCreateNestedManyWithoutDepartmentsInput
    teams?: teamsUncheckedCreateNestedManyWithoutDepartmentsInput
  }

  export type departmentsCreateOrConnectWithoutUsers_users_departmentObjIdTodepartmentsInput = {
    where: departmentsWhereUniqueInput
    create: XOR<departmentsCreateWithoutUsers_users_departmentObjIdTodepartmentsInput, departmentsUncheckedCreateWithoutUsers_users_departmentObjIdTodepartmentsInput>
  }

  export type usersCreateWithoutOther_usersInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    ai_analysis_audit?: ai_analysis_auditCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasCreateNestedManyWithoutUsersInput
    initiatives?: initiativesCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsCreateNestedManyWithoutUsersInput
    inputs?: inputsCreateNestedManyWithoutUsersInput
    requirements?: requirementsCreateNestedManyWithoutUsersInput
    signals?: signalsCreateNestedManyWithoutUsersInput
    solutions?: solutionsCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    departments_users_departmentObjIdTodepartments?: departmentsCreateNestedOneWithoutUsers_users_departmentObjIdTodepartmentsInput
    users?: usersCreateNestedOneWithoutOther_usersInput
    votes?: votesCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersUncheckedCreateWithoutOther_usersInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    managerId?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    departmentObjId?: string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsUncheckedCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasUncheckedCreateNestedManyWithoutUsersInput
    initiatives?: initiativesUncheckedCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsUncheckedCreateNestedManyWithoutUsersInput
    inputs?: inputsUncheckedCreateNestedManyWithoutUsersInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutUsersInput
    signals?: signalsUncheckedCreateNestedManyWithoutUsersInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsUncheckedCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    votes?: votesUncheckedCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsUncheckedCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersCreateOrConnectWithoutOther_usersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutOther_usersInput, usersUncheckedCreateWithoutOther_usersInput>
  }

  export type usersCreateWithoutUsersInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    ai_analysis_audit?: ai_analysis_auditCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasCreateNestedManyWithoutUsersInput
    initiatives?: initiativesCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsCreateNestedManyWithoutUsersInput
    inputs?: inputsCreateNestedManyWithoutUsersInput
    requirements?: requirementsCreateNestedManyWithoutUsersInput
    signals?: signalsCreateNestedManyWithoutUsersInput
    solutions?: solutionsCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    departments_users_departmentObjIdTodepartments?: departmentsCreateNestedOneWithoutUsers_users_departmentObjIdTodepartmentsInput
    other_users?: usersCreateNestedManyWithoutUsersInput
    votes?: votesCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersUncheckedCreateWithoutUsersInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    departmentObjId?: string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsUncheckedCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasUncheckedCreateNestedManyWithoutUsersInput
    initiatives?: initiativesUncheckedCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsUncheckedCreateNestedManyWithoutUsersInput
    inputs?: inputsUncheckedCreateNestedManyWithoutUsersInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutUsersInput
    signals?: signalsUncheckedCreateNestedManyWithoutUsersInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsUncheckedCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    other_users?: usersUncheckedCreateNestedManyWithoutUsersInput
    votes?: votesUncheckedCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsUncheckedCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersCreateOrConnectWithoutUsersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUsersInput, usersUncheckedCreateWithoutUsersInput>
  }

  export type usersCreateManyUsersInputEnvelope = {
    data: usersCreateManyUsersInput | usersCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type votesCreateWithoutUsersInput = {
    id: string
    createdAt?: Date | string
    entityId: string
    entityType: $Enums.EntityType
    value: $Enums.VoteValue
  }

  export type votesUncheckedCreateWithoutUsersInput = {
    id: string
    createdAt?: Date | string
    entityId: string
    entityType: $Enums.EntityType
    value: $Enums.VoteValue
  }

  export type votesCreateOrConnectWithoutUsersInput = {
    where: votesWhereUniqueInput
    create: XOR<votesCreateWithoutUsersInput, votesUncheckedCreateWithoutUsersInput>
  }

  export type votesCreateManyUsersInputEnvelope = {
    data: votesCreateManyUsersInput | votesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type teamsCreateWithoutUsers_TeamMembersInput = {
    id: string
    name: string
    description?: string | null
    memberCount?: number
    maxCapacity?: number | null
    isActive?: boolean
    teamType?: string | null
    currentProjects?: number
    budgetAllocation?: number
    utilizationRate?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    signals?: signalsCreateNestedManyWithoutTeamsInput
    departments?: departmentsCreateNestedOneWithoutTeamsInput
    users_teams_leaderIdTousers?: usersCreateNestedOneWithoutTeams_teams_leaderIdTousersInput
  }

  export type teamsUncheckedCreateWithoutUsers_TeamMembersInput = {
    id: string
    name: string
    description?: string | null
    departmentId?: string | null
    leaderId?: string | null
    memberCount?: number
    maxCapacity?: number | null
    isActive?: boolean
    teamType?: string | null
    currentProjects?: number
    budgetAllocation?: number
    utilizationRate?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    signals?: signalsUncheckedCreateNestedManyWithoutTeamsInput
  }

  export type teamsCreateOrConnectWithoutUsers_TeamMembersInput = {
    where: teamsWhereUniqueInput
    create: XOR<teamsCreateWithoutUsers_TeamMembersInput, teamsUncheckedCreateWithoutUsers_TeamMembersInput>
  }

  export type ai_analysis_auditUpsertWithWhereUniqueWithoutUsersInput = {
    where: ai_analysis_auditWhereUniqueInput
    update: XOR<ai_analysis_auditUpdateWithoutUsersInput, ai_analysis_auditUncheckedUpdateWithoutUsersInput>
    create: XOR<ai_analysis_auditCreateWithoutUsersInput, ai_analysis_auditUncheckedCreateWithoutUsersInput>
  }

  export type ai_analysis_auditUpdateWithWhereUniqueWithoutUsersInput = {
    where: ai_analysis_auditWhereUniqueInput
    data: XOR<ai_analysis_auditUpdateWithoutUsersInput, ai_analysis_auditUncheckedUpdateWithoutUsersInput>
  }

  export type ai_analysis_auditUpdateManyWithWhereWithoutUsersInput = {
    where: ai_analysis_auditScalarWhereInput
    data: XOR<ai_analysis_auditUpdateManyMutationInput, ai_analysis_auditUncheckedUpdateManyWithoutUsersInput>
  }

  export type ai_analysis_auditScalarWhereInput = {
    AND?: ai_analysis_auditScalarWhereInput | ai_analysis_auditScalarWhereInput[]
    OR?: ai_analysis_auditScalarWhereInput[]
    NOT?: ai_analysis_auditScalarWhereInput | ai_analysis_auditScalarWhereInput[]
    id?: StringFilter<"ai_analysis_audit"> | string
    hotspotId?: StringFilter<"ai_analysis_audit"> | string
    analysisType?: StringFilter<"ai_analysis_audit"> | string
    userId?: StringFilter<"ai_analysis_audit"> | string
    requestData?: JsonNullableFilter<"ai_analysis_audit">
    responseData?: JsonNullableFilter<"ai_analysis_audit">
    processingTime?: IntNullableFilter<"ai_analysis_audit"> | number | null
    confidence?: FloatNullableFilter<"ai_analysis_audit"> | number | null
    status?: StringFilter<"ai_analysis_audit"> | string
    errorMessage?: StringNullableFilter<"ai_analysis_audit"> | string | null
    createdAt?: DateTimeFilter<"ai_analysis_audit"> | Date | string
  }

  export type ai_insight_overridesUpsertWithWhereUniqueWithoutUsersInput = {
    where: ai_insight_overridesWhereUniqueInput
    update: XOR<ai_insight_overridesUpdateWithoutUsersInput, ai_insight_overridesUncheckedUpdateWithoutUsersInput>
    create: XOR<ai_insight_overridesCreateWithoutUsersInput, ai_insight_overridesUncheckedCreateWithoutUsersInput>
  }

  export type ai_insight_overridesUpdateWithWhereUniqueWithoutUsersInput = {
    where: ai_insight_overridesWhereUniqueInput
    data: XOR<ai_insight_overridesUpdateWithoutUsersInput, ai_insight_overridesUncheckedUpdateWithoutUsersInput>
  }

  export type ai_insight_overridesUpdateManyWithWhereWithoutUsersInput = {
    where: ai_insight_overridesScalarWhereInput
    data: XOR<ai_insight_overridesUpdateManyMutationInput, ai_insight_overridesUncheckedUpdateManyWithoutUsersInput>
  }

  export type audit_logsUpsertWithWhereUniqueWithoutUsersInput = {
    where: audit_logsWhereUniqueInput
    update: XOR<audit_logsUpdateWithoutUsersInput, audit_logsUncheckedUpdateWithoutUsersInput>
    create: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput>
  }

  export type audit_logsUpdateWithWhereUniqueWithoutUsersInput = {
    where: audit_logsWhereUniqueInput
    data: XOR<audit_logsUpdateWithoutUsersInput, audit_logsUncheckedUpdateWithoutUsersInput>
  }

  export type audit_logsUpdateManyWithWhereWithoutUsersInput = {
    where: audit_logsScalarWhereInput
    data: XOR<audit_logsUpdateManyMutationInput, audit_logsUncheckedUpdateManyWithoutUsersInput>
  }

  export type audit_logsScalarWhereInput = {
    AND?: audit_logsScalarWhereInput | audit_logsScalarWhereInput[]
    OR?: audit_logsScalarWhereInput[]
    NOT?: audit_logsScalarWhereInput | audit_logsScalarWhereInput[]
    id?: StringFilter<"audit_logs"> | string
    userId?: StringFilter<"audit_logs"> | string
    action?: StringFilter<"audit_logs"> | string
    entityType?: StringFilter<"audit_logs"> | string
    entityId?: StringFilter<"audit_logs"> | string
    changes?: JsonNullableFilter<"audit_logs">
    ipAddress?: StringNullableFilter<"audit_logs"> | string | null
    userAgent?: StringNullableFilter<"audit_logs"> | string | null
    createdAt?: DateTimeFilter<"audit_logs"> | Date | string
    sessionId?: StringNullableFilter<"audit_logs"> | string | null
  }

  export type commentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: commentsWhereUniqueInput
    update: XOR<commentsUpdateWithoutUsersInput, commentsUncheckedUpdateWithoutUsersInput>
    create: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput>
  }

  export type commentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: commentsWhereUniqueInput
    data: XOR<commentsUpdateWithoutUsersInput, commentsUncheckedUpdateWithoutUsersInput>
  }

  export type commentsUpdateManyWithWhereWithoutUsersInput = {
    where: commentsScalarWhereInput
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type departmentsUpsertWithWhereUniqueWithoutUsers_departments_managerIdTousersInput = {
    where: departmentsWhereUniqueInput
    update: XOR<departmentsUpdateWithoutUsers_departments_managerIdTousersInput, departmentsUncheckedUpdateWithoutUsers_departments_managerIdTousersInput>
    create: XOR<departmentsCreateWithoutUsers_departments_managerIdTousersInput, departmentsUncheckedCreateWithoutUsers_departments_managerIdTousersInput>
  }

  export type departmentsUpdateWithWhereUniqueWithoutUsers_departments_managerIdTousersInput = {
    where: departmentsWhereUniqueInput
    data: XOR<departmentsUpdateWithoutUsers_departments_managerIdTousersInput, departmentsUncheckedUpdateWithoutUsers_departments_managerIdTousersInput>
  }

  export type departmentsUpdateManyWithWhereWithoutUsers_departments_managerIdTousersInput = {
    where: departmentsScalarWhereInput
    data: XOR<departmentsUpdateManyMutationInput, departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersInput>
  }

  export type departmentsScalarWhereInput = {
    AND?: departmentsScalarWhereInput | departmentsScalarWhereInput[]
    OR?: departmentsScalarWhereInput[]
    NOT?: departmentsScalarWhereInput | departmentsScalarWhereInput[]
    id?: StringFilter<"departments"> | string
    name?: StringFilter<"departments"> | string
    description?: StringNullableFilter<"departments"> | string | null
    headCount?: IntFilter<"departments"> | number
    budgetAllocation?: FloatFilter<"departments"> | number
    managerId?: StringNullableFilter<"departments"> | string | null
    costCenter?: StringNullableFilter<"departments"> | string | null
    location?: StringNullableFilter<"departments"> | string | null
    isActive?: BoolFilter<"departments"> | boolean
    utilizationTarget?: FloatNullableFilter<"departments"> | number | null
    actualUtilization?: FloatNullableFilter<"departments"> | number | null
    createdAt?: DateTimeFilter<"departments"> | Date | string
    updatedAt?: DateTimeFilter<"departments"> | Date | string
  }

  export type frd_documentsUpsertWithWhereUniqueWithoutUsers_frd_documents_approvedByTousersInput = {
    where: frd_documentsWhereUniqueInput
    update: XOR<frd_documentsUpdateWithoutUsers_frd_documents_approvedByTousersInput, frd_documentsUncheckedUpdateWithoutUsers_frd_documents_approvedByTousersInput>
    create: XOR<frd_documentsCreateWithoutUsers_frd_documents_approvedByTousersInput, frd_documentsUncheckedCreateWithoutUsers_frd_documents_approvedByTousersInput>
  }

  export type frd_documentsUpdateWithWhereUniqueWithoutUsers_frd_documents_approvedByTousersInput = {
    where: frd_documentsWhereUniqueInput
    data: XOR<frd_documentsUpdateWithoutUsers_frd_documents_approvedByTousersInput, frd_documentsUncheckedUpdateWithoutUsers_frd_documents_approvedByTousersInput>
  }

  export type frd_documentsUpdateManyWithWhereWithoutUsers_frd_documents_approvedByTousersInput = {
    where: frd_documentsScalarWhereInput
    data: XOR<frd_documentsUpdateManyMutationInput, frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersInput>
  }

  export type frd_documentsUpsertWithWhereUniqueWithoutUsers_frd_documents_createdByTousersInput = {
    where: frd_documentsWhereUniqueInput
    update: XOR<frd_documentsUpdateWithoutUsers_frd_documents_createdByTousersInput, frd_documentsUncheckedUpdateWithoutUsers_frd_documents_createdByTousersInput>
    create: XOR<frd_documentsCreateWithoutUsers_frd_documents_createdByTousersInput, frd_documentsUncheckedCreateWithoutUsers_frd_documents_createdByTousersInput>
  }

  export type frd_documentsUpdateWithWhereUniqueWithoutUsers_frd_documents_createdByTousersInput = {
    where: frd_documentsWhereUniqueInput
    data: XOR<frd_documentsUpdateWithoutUsers_frd_documents_createdByTousersInput, frd_documentsUncheckedUpdateWithoutUsers_frd_documents_createdByTousersInput>
  }

  export type frd_documentsUpdateManyWithWhereWithoutUsers_frd_documents_createdByTousersInput = {
    where: frd_documentsScalarWhereInput
    data: XOR<frd_documentsUpdateManyMutationInput, frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersInput>
  }

  export type ideasUpsertWithWhereUniqueWithoutUsersInput = {
    where: ideasWhereUniqueInput
    update: XOR<ideasUpdateWithoutUsersInput, ideasUncheckedUpdateWithoutUsersInput>
    create: XOR<ideasCreateWithoutUsersInput, ideasUncheckedCreateWithoutUsersInput>
  }

  export type ideasUpdateWithWhereUniqueWithoutUsersInput = {
    where: ideasWhereUniqueInput
    data: XOR<ideasUpdateWithoutUsersInput, ideasUncheckedUpdateWithoutUsersInput>
  }

  export type ideasUpdateManyWithWhereWithoutUsersInput = {
    where: ideasScalarWhereInput
    data: XOR<ideasUpdateManyMutationInput, ideasUncheckedUpdateManyWithoutUsersInput>
  }

  export type initiativesUpsertWithWhereUniqueWithoutUsersInput = {
    where: initiativesWhereUniqueInput
    update: XOR<initiativesUpdateWithoutUsersInput, initiativesUncheckedUpdateWithoutUsersInput>
    create: XOR<initiativesCreateWithoutUsersInput, initiativesUncheckedCreateWithoutUsersInput>
  }

  export type initiativesUpdateWithWhereUniqueWithoutUsersInput = {
    where: initiativesWhereUniqueInput
    data: XOR<initiativesUpdateWithoutUsersInput, initiativesUncheckedUpdateWithoutUsersInput>
  }

  export type initiativesUpdateManyWithWhereWithoutUsersInput = {
    where: initiativesScalarWhereInput
    data: XOR<initiativesUpdateManyMutationInput, initiativesUncheckedUpdateManyWithoutUsersInput>
  }

  export type initiativesScalarWhereInput = {
    AND?: initiativesScalarWhereInput | initiativesScalarWhereInput[]
    OR?: initiativesScalarWhereInput[]
    NOT?: initiativesScalarWhereInput | initiativesScalarWhereInput[]
    id?: StringFilter<"initiatives"> | string
    name?: StringFilter<"initiatives"> | string
    description?: StringNullableFilter<"initiatives"> | string | null
    status?: Enuminitiative_statusFilter<"initiatives"> | $Enums.initiative_status
    priority?: EnumpriorityFilter<"initiatives"> | $Enums.priority
    ownerId?: StringNullableFilter<"initiatives"> | string | null
    budget?: FloatFilter<"initiatives"> | number
    actualSpend?: FloatFilter<"initiatives"> | number
    startDate?: DateTimeNullableFilter<"initiatives"> | Date | string | null
    targetDate?: DateTimeNullableFilter<"initiatives"> | Date | string | null
    completionDate?: DateTimeNullableFilter<"initiatives"> | Date | string | null
    expectedROI?: FloatNullableFilter<"initiatives"> | number | null
    actualROI?: FloatNullableFilter<"initiatives"> | number | null
    riskLevel?: Enumrisk_levelFilter<"initiatives"> | $Enums.risk_level
    goalJson?: JsonNullableFilter<"initiatives">
    roiJson?: JsonNullableFilter<"initiatives">
    milestonesJson?: JsonNullableFilter<"initiatives">
    createdAt?: DateTimeFilter<"initiatives"> | Date | string
    updatedAt?: DateTimeFilter<"initiatives"> | Date | string
  }

  export type input_groupsUpsertWithWhereUniqueWithoutUsersInput = {
    where: input_groupsWhereUniqueInput
    update: XOR<input_groupsUpdateWithoutUsersInput, input_groupsUncheckedUpdateWithoutUsersInput>
    create: XOR<input_groupsCreateWithoutUsersInput, input_groupsUncheckedCreateWithoutUsersInput>
  }

  export type input_groupsUpdateWithWhereUniqueWithoutUsersInput = {
    where: input_groupsWhereUniqueInput
    data: XOR<input_groupsUpdateWithoutUsersInput, input_groupsUncheckedUpdateWithoutUsersInput>
  }

  export type input_groupsUpdateManyWithWhereWithoutUsersInput = {
    where: input_groupsScalarWhereInput
    data: XOR<input_groupsUpdateManyMutationInput, input_groupsUncheckedUpdateManyWithoutUsersInput>
  }

  export type input_groupsScalarWhereInput = {
    AND?: input_groupsScalarWhereInput | input_groupsScalarWhereInput[]
    OR?: input_groupsScalarWhereInput[]
    NOT?: input_groupsScalarWhereInput | input_groupsScalarWhereInput[]
    id?: StringFilter<"input_groups"> | string
    name?: StringFilter<"input_groups"> | string
    description?: StringNullableFilter<"input_groups"> | string | null
    createdAt?: DateTimeFilter<"input_groups"> | Date | string
    updatedAt?: DateTimeFilter<"input_groups"> | Date | string
    aiSuggested?: BoolFilter<"input_groups"> | boolean
    aiConfidence?: FloatNullableFilter<"input_groups"> | number | null
    aiReasoning?: StringNullableFilter<"input_groups"> | string | null
    avgPriority?: FloatNullableFilter<"input_groups"> | number | null
    color?: StringNullableFilter<"input_groups"> | string | null
    createdBy?: StringFilter<"input_groups"> | string
    inputCount?: IntFilter<"input_groups"> | number
    lastActivity?: DateTimeNullableFilter<"input_groups"> | Date | string | null
  }

  export type inputsUpsertWithWhereUniqueWithoutUsersInput = {
    where: inputsWhereUniqueInput
    update: XOR<inputsUpdateWithoutUsersInput, inputsUncheckedUpdateWithoutUsersInput>
    create: XOR<inputsCreateWithoutUsersInput, inputsUncheckedCreateWithoutUsersInput>
  }

  export type inputsUpdateWithWhereUniqueWithoutUsersInput = {
    where: inputsWhereUniqueInput
    data: XOR<inputsUpdateWithoutUsersInput, inputsUncheckedUpdateWithoutUsersInput>
  }

  export type inputsUpdateManyWithWhereWithoutUsersInput = {
    where: inputsScalarWhereInput
    data: XOR<inputsUpdateManyMutationInput, inputsUncheckedUpdateManyWithoutUsersInput>
  }

  export type inputsScalarWhereInput = {
    AND?: inputsScalarWhereInput | inputsScalarWhereInput[]
    OR?: inputsScalarWhereInput[]
    NOT?: inputsScalarWhereInput | inputsScalarWhereInput[]
    id?: StringFilter<"inputs"> | string
    title?: StringFilter<"inputs"> | string
    description?: StringFilter<"inputs"> | string
    type?: EnumInputTypeFilter<"inputs"> | $Enums.InputType
    status?: EnumInputStatusFilter<"inputs"> | $Enums.InputStatus
    createdBy?: StringFilter<"inputs"> | string
    createdAt?: DateTimeFilter<"inputs"> | Date | string
    updatedAt?: DateTimeFilter<"inputs"> | Date | string
    department?: StringNullableFilter<"inputs"> | string | null
    rootCause?: StringNullableFilter<"inputs"> | string | null
    aiTags?: JsonNullableFilter<"inputs">
    aiSuggestions?: JsonNullableFilter<"inputs">
    aiConfidence?: FloatNullableFilter<"inputs"> | number | null
    issueType?: StringNullableFilter<"inputs"> | string | null
    priority?: EnumpriorityFilter<"inputs"> | $Enums.priority
  }

  export type requirementsUpsertWithWhereUniqueWithoutUsersInput = {
    where: requirementsWhereUniqueInput
    update: XOR<requirementsUpdateWithoutUsersInput, requirementsUncheckedUpdateWithoutUsersInput>
    create: XOR<requirementsCreateWithoutUsersInput, requirementsUncheckedCreateWithoutUsersInput>
  }

  export type requirementsUpdateWithWhereUniqueWithoutUsersInput = {
    where: requirementsWhereUniqueInput
    data: XOR<requirementsUpdateWithoutUsersInput, requirementsUncheckedUpdateWithoutUsersInput>
  }

  export type requirementsUpdateManyWithWhereWithoutUsersInput = {
    where: requirementsScalarWhereInput
    data: XOR<requirementsUpdateManyMutationInput, requirementsUncheckedUpdateManyWithoutUsersInput>
  }

  export type signalsUpsertWithWhereUniqueWithoutUsersInput = {
    where: signalsWhereUniqueInput
    update: XOR<signalsUpdateWithoutUsersInput, signalsUncheckedUpdateWithoutUsersInput>
    create: XOR<signalsCreateWithoutUsersInput, signalsUncheckedCreateWithoutUsersInput>
  }

  export type signalsUpdateWithWhereUniqueWithoutUsersInput = {
    where: signalsWhereUniqueInput
    data: XOR<signalsUpdateWithoutUsersInput, signalsUncheckedUpdateWithoutUsersInput>
  }

  export type signalsUpdateManyWithWhereWithoutUsersInput = {
    where: signalsScalarWhereInput
    data: XOR<signalsUpdateManyMutationInput, signalsUncheckedUpdateManyWithoutUsersInput>
  }

  export type solutionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: solutionsWhereUniqueInput
    update: XOR<solutionsUpdateWithoutUsersInput, solutionsUncheckedUpdateWithoutUsersInput>
    create: XOR<solutionsCreateWithoutUsersInput, solutionsUncheckedCreateWithoutUsersInput>
  }

  export type solutionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: solutionsWhereUniqueInput
    data: XOR<solutionsUpdateWithoutUsersInput, solutionsUncheckedUpdateWithoutUsersInput>
  }

  export type solutionsUpdateManyWithWhereWithoutUsersInput = {
    where: solutionsScalarWhereInput
    data: XOR<solutionsUpdateManyMutationInput, solutionsUncheckedUpdateManyWithoutUsersInput>
  }

  export type teamsUpsertWithWhereUniqueWithoutUsers_teams_leaderIdTousersInput = {
    where: teamsWhereUniqueInput
    update: XOR<teamsUpdateWithoutUsers_teams_leaderIdTousersInput, teamsUncheckedUpdateWithoutUsers_teams_leaderIdTousersInput>
    create: XOR<teamsCreateWithoutUsers_teams_leaderIdTousersInput, teamsUncheckedCreateWithoutUsers_teams_leaderIdTousersInput>
  }

  export type teamsUpdateWithWhereUniqueWithoutUsers_teams_leaderIdTousersInput = {
    where: teamsWhereUniqueInput
    data: XOR<teamsUpdateWithoutUsers_teams_leaderIdTousersInput, teamsUncheckedUpdateWithoutUsers_teams_leaderIdTousersInput>
  }

  export type teamsUpdateManyWithWhereWithoutUsers_teams_leaderIdTousersInput = {
    where: teamsScalarWhereInput
    data: XOR<teamsUpdateManyMutationInput, teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersInput>
  }

  export type departmentsUpsertWithoutUsers_users_departmentObjIdTodepartmentsInput = {
    update: XOR<departmentsUpdateWithoutUsers_users_departmentObjIdTodepartmentsInput, departmentsUncheckedUpdateWithoutUsers_users_departmentObjIdTodepartmentsInput>
    create: XOR<departmentsCreateWithoutUsers_users_departmentObjIdTodepartmentsInput, departmentsUncheckedCreateWithoutUsers_users_departmentObjIdTodepartmentsInput>
    where?: departmentsWhereInput
  }

  export type departmentsUpdateToOneWithWhereWithoutUsers_users_departmentObjIdTodepartmentsInput = {
    where?: departmentsWhereInput
    data: XOR<departmentsUpdateWithoutUsers_users_departmentObjIdTodepartmentsInput, departmentsUncheckedUpdateWithoutUsers_users_departmentObjIdTodepartmentsInput>
  }

  export type departmentsUpdateWithoutUsers_users_departmentObjIdTodepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headCount?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    utilizationTarget?: NullableFloatFieldUpdateOperationsInput | number | null
    actualUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_departments_managerIdTousers?: usersUpdateOneWithoutDepartments_departments_managerIdTousersNestedInput
    signals?: signalsUpdateManyWithoutDepartmentsNestedInput
    teams?: teamsUpdateManyWithoutDepartmentsNestedInput
  }

  export type departmentsUncheckedUpdateWithoutUsers_users_departmentObjIdTodepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headCount?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    utilizationTarget?: NullableFloatFieldUpdateOperationsInput | number | null
    actualUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: signalsUncheckedUpdateManyWithoutDepartmentsNestedInput
    teams?: teamsUncheckedUpdateManyWithoutDepartmentsNestedInput
  }

  export type usersUpsertWithoutOther_usersInput = {
    update: XOR<usersUpdateWithoutOther_usersInput, usersUncheckedUpdateWithoutOther_usersInput>
    create: XOR<usersCreateWithoutOther_usersInput, usersUncheckedCreateWithoutOther_usersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutOther_usersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutOther_usersInput, usersUncheckedUpdateWithoutOther_usersInput>
  }

  export type usersUpdateWithoutOther_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    ai_analysis_audit?: ai_analysis_auditUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUpdateManyWithoutUsersNestedInput
    inputs?: inputsUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUpdateManyWithoutUsersNestedInput
    signals?: signalsUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    departments_users_departmentObjIdTodepartments?: departmentsUpdateOneWithoutUsers_users_departmentObjIdTodepartmentsNestedInput
    users?: usersUpdateOneWithoutOther_usersNestedInput
    votes?: votesUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUncheckedUpdateWithoutOther_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUncheckedUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUncheckedUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUncheckedUpdateManyWithoutUsersNestedInput
    inputs?: inputsUncheckedUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutUsersNestedInput
    signals?: signalsUncheckedUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    votes?: votesUncheckedUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUncheckedUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUpsertWithWhereUniqueWithoutUsersInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutUsersInput, usersUncheckedUpdateWithoutUsersInput>
    create: XOR<usersCreateWithoutUsersInput, usersUncheckedCreateWithoutUsersInput>
  }

  export type usersUpdateWithWhereUniqueWithoutUsersInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutUsersInput, usersUncheckedUpdateWithoutUsersInput>
  }

  export type usersUpdateManyWithWhereWithoutUsersInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutUsersInput>
  }

  export type votesUpsertWithWhereUniqueWithoutUsersInput = {
    where: votesWhereUniqueInput
    update: XOR<votesUpdateWithoutUsersInput, votesUncheckedUpdateWithoutUsersInput>
    create: XOR<votesCreateWithoutUsersInput, votesUncheckedCreateWithoutUsersInput>
  }

  export type votesUpdateWithWhereUniqueWithoutUsersInput = {
    where: votesWhereUniqueInput
    data: XOR<votesUpdateWithoutUsersInput, votesUncheckedUpdateWithoutUsersInput>
  }

  export type votesUpdateManyWithWhereWithoutUsersInput = {
    where: votesScalarWhereInput
    data: XOR<votesUpdateManyMutationInput, votesUncheckedUpdateManyWithoutUsersInput>
  }

  export type votesScalarWhereInput = {
    AND?: votesScalarWhereInput | votesScalarWhereInput[]
    OR?: votesScalarWhereInput[]
    NOT?: votesScalarWhereInput | votesScalarWhereInput[]
    id?: StringFilter<"votes"> | string
    createdAt?: DateTimeFilter<"votes"> | Date | string
    createdBy?: StringFilter<"votes"> | string
    entityId?: StringFilter<"votes"> | string
    entityType?: EnumEntityTypeFilter<"votes"> | $Enums.EntityType
    value?: EnumVoteValueFilter<"votes"> | $Enums.VoteValue
  }

  export type teamsUpsertWithWhereUniqueWithoutUsers_TeamMembersInput = {
    where: teamsWhereUniqueInput
    update: XOR<teamsUpdateWithoutUsers_TeamMembersInput, teamsUncheckedUpdateWithoutUsers_TeamMembersInput>
    create: XOR<teamsCreateWithoutUsers_TeamMembersInput, teamsUncheckedCreateWithoutUsers_TeamMembersInput>
  }

  export type teamsUpdateWithWhereUniqueWithoutUsers_TeamMembersInput = {
    where: teamsWhereUniqueInput
    data: XOR<teamsUpdateWithoutUsers_TeamMembersInput, teamsUncheckedUpdateWithoutUsers_TeamMembersInput>
  }

  export type teamsUpdateManyWithWhereWithoutUsers_TeamMembersInput = {
    where: teamsScalarWhereInput
    data: XOR<teamsUpdateManyMutationInput, teamsUncheckedUpdateManyWithoutUsers_TeamMembersInput>
  }

  export type usersCreateWithoutVotesInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    ai_analysis_audit?: ai_analysis_auditCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasCreateNestedManyWithoutUsersInput
    initiatives?: initiativesCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsCreateNestedManyWithoutUsersInput
    inputs?: inputsCreateNestedManyWithoutUsersInput
    requirements?: requirementsCreateNestedManyWithoutUsersInput
    signals?: signalsCreateNestedManyWithoutUsersInput
    solutions?: solutionsCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    departments_users_departmentObjIdTodepartments?: departmentsCreateNestedOneWithoutUsers_users_departmentObjIdTodepartmentsInput
    users?: usersCreateNestedOneWithoutOther_usersInput
    other_users?: usersCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersUncheckedCreateWithoutVotesInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    managerId?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    departmentObjId?: string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedCreateNestedManyWithoutUsersInput
    ai_insight_overrides?: ai_insight_overridesUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    departments_departments_managerIdTousers?: departmentsUncheckedCreateNestedManyWithoutUsers_departments_managerIdTousersInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_approvedByTousersInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedCreateNestedManyWithoutUsers_frd_documents_createdByTousersInput
    ideas?: ideasUncheckedCreateNestedManyWithoutUsersInput
    initiatives?: initiativesUncheckedCreateNestedManyWithoutUsersInput
    input_groups?: input_groupsUncheckedCreateNestedManyWithoutUsersInput
    inputs?: inputsUncheckedCreateNestedManyWithoutUsersInput
    requirements?: requirementsUncheckedCreateNestedManyWithoutUsersInput
    signals?: signalsUncheckedCreateNestedManyWithoutUsersInput
    solutions?: solutionsUncheckedCreateNestedManyWithoutUsersInput
    teams_teams_leaderIdTousers?: teamsUncheckedCreateNestedManyWithoutUsers_teams_leaderIdTousersInput
    other_users?: usersUncheckedCreateNestedManyWithoutUsersInput
    teams_TeamMembers?: teamsUncheckedCreateNestedManyWithoutUsers_TeamMembersInput
  }

  export type usersCreateOrConnectWithoutVotesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutVotesInput, usersUncheckedCreateWithoutVotesInput>
  }

  export type usersUpsertWithoutVotesInput = {
    update: XOR<usersUpdateWithoutVotesInput, usersUncheckedUpdateWithoutVotesInput>
    create: XOR<usersCreateWithoutVotesInput, usersUncheckedCreateWithoutVotesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutVotesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutVotesInput, usersUncheckedUpdateWithoutVotesInput>
  }

  export type usersUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    ai_analysis_audit?: ai_analysis_auditUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUpdateManyWithoutUsersNestedInput
    inputs?: inputsUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUpdateManyWithoutUsersNestedInput
    signals?: signalsUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    departments_users_departmentObjIdTodepartments?: departmentsUpdateOneWithoutUsers_users_departmentObjIdTodepartmentsNestedInput
    users?: usersUpdateOneWithoutOther_usersNestedInput
    other_users?: usersUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUncheckedUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUncheckedUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUncheckedUpdateManyWithoutUsersNestedInput
    inputs?: inputsUncheckedUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutUsersNestedInput
    signals?: signalsUncheckedUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    other_users?: usersUncheckedUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUncheckedUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type categoriesCreateManyCategoriesInput = {
    id: string
    name: string
    description?: string | null
    color?: string | null
    icon?: string | null
    isActive?: boolean
    sortOrder?: number
    usageCount?: number
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type signalsCreateManyCategoriesInput = {
    id: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    departmentId?: string | null
    teamId?: string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: number | null
    featuresVersion?: string | null
    lastFeaturesGeneratedAt?: Date | string | null
  }

  export type categoriesUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    other_categories?: categoriesUpdateManyWithoutCategoriesNestedInput
    signals?: signalsUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    other_categories?: categoriesUncheckedUpdateManyWithoutCategoriesNestedInput
    signals?: signalsUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type signalsUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    featuresVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastFeaturesGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutSignalsNestedInput
    hotspot_signals?: hotspot_signalsUpdateManyWithoutSignalsNestedInput
    users?: usersUpdateOneWithoutSignalsNestedInput
    departments?: departmentsUpdateOneWithoutSignalsNestedInput
    teams?: teamsUpdateOneWithoutSignalsNestedInput
  }

  export type signalsUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    featuresVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastFeaturesGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutSignalsNestedInput
    hotspot_signals?: hotspot_signalsUncheckedUpdateManyWithoutSignalsNestedInput
  }

  export type signalsUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    featuresVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastFeaturesGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type commentsCreateManyCommentsInput = {
    id: string
    content: string
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy: string
    edited?: boolean
    editedAt?: Date | string | null
    entityId: string
    entityType: $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type commentsUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
    users?: usersUpdateOneRequiredWithoutCommentsNestedInput
    other_comments?: commentsUpdateManyWithoutCommentsNestedInput
  }

  export type commentsUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
    other_comments?: commentsUncheckedUpdateManyWithoutCommentsNestedInput
  }

  export type commentsUncheckedUpdateManyWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type signalsCreateManyDepartmentsInput = {
    id: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    teamId?: string | null
    categoryId?: string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: number | null
    featuresVersion?: string | null
    lastFeaturesGeneratedAt?: Date | string | null
  }

  export type teamsCreateManyDepartmentsInput = {
    id: string
    name: string
    description?: string | null
    leaderId?: string | null
    memberCount?: number
    maxCapacity?: number | null
    isActive?: boolean
    teamType?: string | null
    currentProjects?: number
    budgetAllocation?: number
    utilizationRate?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type usersCreateManyDepartments_users_departmentObjIdTodepartmentsInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    managerId?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
  }

  export type signalsUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    featuresVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastFeaturesGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutSignalsNestedInput
    hotspot_signals?: hotspot_signalsUpdateManyWithoutSignalsNestedInput
    categories?: categoriesUpdateOneWithoutSignalsNestedInput
    users?: usersUpdateOneWithoutSignalsNestedInput
    teams?: teamsUpdateOneWithoutSignalsNestedInput
  }

  export type signalsUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    featuresVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastFeaturesGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutSignalsNestedInput
    hotspot_signals?: hotspot_signalsUncheckedUpdateManyWithoutSignalsNestedInput
  }

  export type signalsUncheckedUpdateManyWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    featuresVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastFeaturesGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type teamsUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: IntFieldUpdateOperationsInput | number
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teamType?: NullableStringFieldUpdateOperationsInput | string | null
    currentProjects?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: signalsUpdateManyWithoutTeamsNestedInput
    users_teams_leaderIdTousers?: usersUpdateOneWithoutTeams_teams_leaderIdTousersNestedInput
    users_TeamMembers?: usersUpdateManyWithoutTeams_TeamMembersNestedInput
  }

  export type teamsUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: IntFieldUpdateOperationsInput | number
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teamType?: NullableStringFieldUpdateOperationsInput | string | null
    currentProjects?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: signalsUncheckedUpdateManyWithoutTeamsNestedInput
    users_TeamMembers?: usersUncheckedUpdateManyWithoutTeams_TeamMembersNestedInput
  }

  export type teamsUncheckedUpdateManyWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: IntFieldUpdateOperationsInput | number
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teamType?: NullableStringFieldUpdateOperationsInput | string | null
    currentProjects?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpdateWithoutDepartments_users_departmentObjIdTodepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    ai_analysis_audit?: ai_analysis_auditUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUpdateManyWithoutUsersNestedInput
    inputs?: inputsUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUpdateManyWithoutUsersNestedInput
    signals?: signalsUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    users?: usersUpdateOneWithoutOther_usersNestedInput
    other_users?: usersUpdateManyWithoutUsersNestedInput
    votes?: votesUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUncheckedUpdateWithoutDepartments_users_departmentObjIdTodepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    ai_analysis_audit?: ai_analysis_auditUncheckedUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUncheckedUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUncheckedUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUncheckedUpdateManyWithoutUsersNestedInput
    inputs?: inputsUncheckedUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutUsersNestedInput
    signals?: signalsUncheckedUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    other_users?: usersUncheckedUpdateManyWithoutUsersNestedInput
    votes?: votesUncheckedUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUncheckedUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutDepartments_users_departmentObjIdTodepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type hotspot_signalsCreateManyHotspotsInput = {
    signalId: string
    membershipStrength?: number
    isOutlier?: boolean
    addedAt?: Date | string
  }

  export type ideasCreateManyHotspotsInput = {
    id: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdById?: string | null
    initiativeId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type solutionsCreateManyHotspotsInput = {
    id: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    createdAt?: Date | string
    updatedAt: Date | string
    estimatedEffort?: string | null
    actualCompletionDate?: Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    createdBy: string
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    ideaId?: string | null
    initiativeId?: string | null
    inputId?: string | null
    progress?: number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
  }

  export type hotspot_signalsUpdateWithoutHotspotsInput = {
    membershipStrength?: FloatFieldUpdateOperationsInput | number
    isOutlier?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: signalsUpdateOneRequiredWithoutHotspot_signalsNestedInput
  }

  export type hotspot_signalsUncheckedUpdateWithoutHotspotsInput = {
    signalId?: StringFieldUpdateOperationsInput | string
    membershipStrength?: FloatFieldUpdateOperationsInput | number
    isOutlier?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type hotspot_signalsUncheckedUpdateManyWithoutHotspotsInput = {
    signalId?: StringFieldUpdateOperationsInput | string
    membershipStrength?: FloatFieldUpdateOperationsInput | number
    isOutlier?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ideasUpdateWithoutHotspotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutIdeasNestedInput
    initiatives?: initiativesUpdateOneWithoutIdeasNestedInput
    solutions?: solutionsUpdateOneWithoutIdeasNestedInput
  }

  export type ideasUncheckedUpdateWithoutHotspotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solutions?: solutionsUncheckedUpdateOneWithoutIdeasNestedInput
  }

  export type ideasUncheckedUpdateManyWithoutHotspotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type solutionsUpdateWithoutHotspotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsUpdateManyWithoutSolutionsNestedInput
    requirements?: requirementsUpdateManyWithoutSolutionsNestedInput
    users?: usersUpdateOneRequiredWithoutSolutionsNestedInput
    ideas?: ideasUpdateOneWithoutSolutionsNestedInput
    initiatives?: initiativesUpdateOneWithoutSolutionsNestedInput
    inputs?: inputsUpdateOneWithoutSolutionsNestedInput
  }

  export type solutionsUncheckedUpdateWithoutHotspotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    inputId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsUncheckedUpdateManyWithoutSolutionsNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutSolutionsNestedInput
  }

  export type solutionsUncheckedUpdateManyWithoutHotspotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    inputId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ideasCreateManyInitiativesInput = {
    id: string
    hotspotId: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type solutionsCreateManyInitiativesInput = {
    id: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    createdAt?: Date | string
    updatedAt: Date | string
    estimatedEffort?: string | null
    actualCompletionDate?: Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    createdBy: string
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    hotspotId?: string | null
    ideaId?: string | null
    inputId?: string | null
    progress?: number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ideasUpdateWithoutInitiativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutIdeasNestedInput
    hotspots?: hotspotsUpdateOneRequiredWithoutIdeasNestedInput
    solutions?: solutionsUpdateOneWithoutIdeasNestedInput
  }

  export type ideasUncheckedUpdateWithoutInitiativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotspotId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solutions?: solutionsUncheckedUpdateOneWithoutIdeasNestedInput
  }

  export type ideasUncheckedUpdateManyWithoutInitiativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotspotId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type solutionsUpdateWithoutInitiativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsUpdateManyWithoutSolutionsNestedInput
    requirements?: requirementsUpdateManyWithoutSolutionsNestedInput
    users?: usersUpdateOneRequiredWithoutSolutionsNestedInput
    hotspots?: hotspotsUpdateOneWithoutSolutionsNestedInput
    ideas?: ideasUpdateOneWithoutSolutionsNestedInput
    inputs?: inputsUpdateOneWithoutSolutionsNestedInput
  }

  export type solutionsUncheckedUpdateWithoutInitiativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    hotspotId?: NullableStringFieldUpdateOperationsInput | string | null
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    inputId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsUncheckedUpdateManyWithoutSolutionsNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutSolutionsNestedInput
  }

  export type solutionsUncheckedUpdateManyWithoutInitiativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    hotspotId?: NullableStringFieldUpdateOperationsInput | string | null
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    inputId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InputToInputGroupCreateManyInput_groupsInput = {
    A: string
  }

  export type InputToInputGroupUpdateWithoutInput_groupsInput = {
    inputs?: inputsUpdateOneRequiredWithoutInputToInputGroupNestedInput
  }

  export type InputToInputGroupUncheckedUpdateWithoutInput_groupsInput = {
    A?: StringFieldUpdateOperationsInput | string
  }

  export type InputToInputGroupUncheckedUpdateManyWithoutInput_groupsInput = {
    A?: StringFieldUpdateOperationsInput | string
  }

  export type InputToInputGroupCreateManyInputsInput = {
    B: string
  }

  export type solutionsCreateManyInputsInput = {
    id: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    createdAt?: Date | string
    updatedAt: Date | string
    estimatedEffort?: string | null
    actualCompletionDate?: Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    createdBy: string
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    hotspotId?: string | null
    ideaId?: string | null
    initiativeId?: string | null
    progress?: number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InputToInputGroupUpdateWithoutInputsInput = {
    input_groups?: input_groupsUpdateOneRequiredWithoutInputToInputGroupNestedInput
  }

  export type InputToInputGroupUncheckedUpdateWithoutInputsInput = {
    B?: StringFieldUpdateOperationsInput | string
  }

  export type InputToInputGroupUncheckedUpdateManyWithoutInputsInput = {
    B?: StringFieldUpdateOperationsInput | string
  }

  export type solutionsUpdateWithoutInputsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsUpdateManyWithoutSolutionsNestedInput
    requirements?: requirementsUpdateManyWithoutSolutionsNestedInput
    users?: usersUpdateOneRequiredWithoutSolutionsNestedInput
    hotspots?: hotspotsUpdateOneWithoutSolutionsNestedInput
    ideas?: ideasUpdateOneWithoutSolutionsNestedInput
    initiatives?: initiativesUpdateOneWithoutSolutionsNestedInput
  }

  export type solutionsUncheckedUpdateWithoutInputsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    hotspotId?: NullableStringFieldUpdateOperationsInput | string | null
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsUncheckedUpdateManyWithoutSolutionsNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutSolutionsNestedInput
  }

  export type solutionsUncheckedUpdateManyWithoutInputsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    hotspotId?: NullableStringFieldUpdateOperationsInput | string | null
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ai_insight_overridesCreateManySignalsInput = {
    id: string
    insightId: string
    insightType: string
    originalRecommendation?: NullableJsonNullValueInput | InputJsonValue
    overrideReason: string
    executiveJustification?: string | null
    newValue?: NullableJsonNullValueInput | InputJsonValue
    executiveId: string
    executiveName: string
    executiveEmail: string
    overriddenAt?: Date | string
    createdAt?: Date | string
  }

  export type hotspot_signalsCreateManySignalsInput = {
    hotspotId: string
    membershipStrength?: number
    isOutlier?: boolean
    addedAt?: Date | string
  }

  export type ai_insight_overridesUpdateWithoutSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    originalRecommendation?: NullableJsonNullValueInput | InputJsonValue
    overrideReason?: StringFieldUpdateOperationsInput | string
    executiveJustification?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableJsonNullValueInput | InputJsonValue
    executiveName?: StringFieldUpdateOperationsInput | string
    executiveEmail?: StringFieldUpdateOperationsInput | string
    overriddenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutAi_insight_overridesNestedInput
  }

  export type ai_insight_overridesUncheckedUpdateWithoutSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    originalRecommendation?: NullableJsonNullValueInput | InputJsonValue
    overrideReason?: StringFieldUpdateOperationsInput | string
    executiveJustification?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableJsonNullValueInput | InputJsonValue
    executiveId?: StringFieldUpdateOperationsInput | string
    executiveName?: StringFieldUpdateOperationsInput | string
    executiveEmail?: StringFieldUpdateOperationsInput | string
    overriddenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_insight_overridesUncheckedUpdateManyWithoutSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    originalRecommendation?: NullableJsonNullValueInput | InputJsonValue
    overrideReason?: StringFieldUpdateOperationsInput | string
    executiveJustification?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableJsonNullValueInput | InputJsonValue
    executiveId?: StringFieldUpdateOperationsInput | string
    executiveName?: StringFieldUpdateOperationsInput | string
    executiveEmail?: StringFieldUpdateOperationsInput | string
    overriddenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type hotspot_signalsUpdateWithoutSignalsInput = {
    membershipStrength?: FloatFieldUpdateOperationsInput | number
    isOutlier?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotspots?: hotspotsUpdateOneRequiredWithoutHotspot_signalsNestedInput
  }

  export type hotspot_signalsUncheckedUpdateWithoutSignalsInput = {
    hotspotId?: StringFieldUpdateOperationsInput | string
    membershipStrength?: FloatFieldUpdateOperationsInput | number
    isOutlier?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type hotspot_signalsUncheckedUpdateManyWithoutSignalsInput = {
    hotspotId?: StringFieldUpdateOperationsInput | string
    membershipStrength?: FloatFieldUpdateOperationsInput | number
    isOutlier?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type frd_documentsCreateManySolutionsInput = {
    id: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type requirementsCreateManySolutionsInput = {
    id: string
    title: string
    description: string
    acceptanceCriteria: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequirementStatus
    estimatedEffort?: string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    riskAssessment?: string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
    priority?: $Enums.priority
  }

  export type frd_documentsUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_frd_documents_approvedByTousers?: usersUpdateOneWithoutFrd_documents_frd_documents_approvedByTousersNestedInput
    users_frd_documents_createdByTousers?: usersUpdateOneRequiredWithoutFrd_documents_frd_documents_createdByTousersNestedInput
  }

  export type frd_documentsUncheckedUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type frd_documentsUncheckedUpdateManyWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requirementsUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    users?: usersUpdateOneRequiredWithoutRequirementsNestedInput
  }

  export type requirementsUncheckedUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
  }

  export type requirementsUncheckedUpdateManyWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
  }

  export type signalsCreateManyTeamsInput = {
    id: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    departmentId?: string | null
    categoryId?: string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: number | null
    featuresVersion?: string | null
    lastFeaturesGeneratedAt?: Date | string | null
  }

  export type signalsUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    featuresVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastFeaturesGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutSignalsNestedInput
    hotspot_signals?: hotspot_signalsUpdateManyWithoutSignalsNestedInput
    categories?: categoriesUpdateOneWithoutSignalsNestedInput
    users?: usersUpdateOneWithoutSignalsNestedInput
    departments?: departmentsUpdateOneWithoutSignalsNestedInput
  }

  export type signalsUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    featuresVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastFeaturesGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutSignalsNestedInput
    hotspot_signals?: hotspot_signalsUncheckedUpdateManyWithoutSignalsNestedInput
  }

  export type signalsUncheckedUpdateManyWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    featuresVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastFeaturesGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUpdateWithoutTeams_TeamMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    ai_analysis_audit?: ai_analysis_auditUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUpdateManyWithoutUsersNestedInput
    inputs?: inputsUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUpdateManyWithoutUsersNestedInput
    signals?: signalsUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    departments_users_departmentObjIdTodepartments?: departmentsUpdateOneWithoutUsers_users_departmentObjIdTodepartmentsNestedInput
    users?: usersUpdateOneWithoutOther_usersNestedInput
    other_users?: usersUpdateManyWithoutUsersNestedInput
    votes?: votesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutTeams_TeamMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUncheckedUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUncheckedUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUncheckedUpdateManyWithoutUsersNestedInput
    inputs?: inputsUncheckedUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutUsersNestedInput
    signals?: signalsUncheckedUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    other_users?: usersUncheckedUpdateManyWithoutUsersNestedInput
    votes?: votesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutTeams_TeamMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ai_analysis_auditCreateManyUsersInput = {
    id: string
    hotspotId: string
    analysisType: string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: number | null
    confidence?: number | null
    status: string
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type ai_insight_overridesCreateManyUsersInput = {
    id: string
    signalId: string
    insightId: string
    insightType: string
    originalRecommendation?: NullableJsonNullValueInput | InputJsonValue
    overrideReason: string
    executiveJustification?: string | null
    newValue?: NullableJsonNullValueInput | InputJsonValue
    executiveName: string
    executiveEmail: string
    overriddenAt?: Date | string
    createdAt?: Date | string
  }

  export type audit_logsCreateManyUsersInput = {
    id: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    sessionId?: string | null
  }

  export type commentsCreateManyUsersInput = {
    id: string
    content: string
    createdAt?: Date | string
    updatedAt: Date | string
    parentId?: string | null
    edited?: boolean
    editedAt?: Date | string | null
    entityId: string
    entityType: $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type departmentsCreateManyUsers_departments_managerIdTousersInput = {
    id: string
    name: string
    description?: string | null
    headCount?: number
    budgetAllocation?: number
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    utilizationTarget?: number | null
    actualUtilization?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type frd_documentsCreateManyUsers_frd_documents_approvedByTousersInput = {
    id: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    solutionId: string
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type frd_documentsCreateManyUsers_frd_documents_createdByTousersInput = {
    id: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    solutionId: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ideasCreateManyUsersInput = {
    id: string
    hotspotId: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    initiativeId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type initiativesCreateManyUsersInput = {
    id: string
    name: string
    description?: string | null
    status?: $Enums.initiative_status
    priority?: $Enums.priority
    budget?: number
    actualSpend?: number
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completionDate?: Date | string | null
    expectedROI?: number | null
    actualROI?: number | null
    riskLevel?: $Enums.risk_level
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    milestonesJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type input_groupsCreateManyUsersInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    aiSuggested?: boolean
    aiConfidence?: number | null
    aiReasoning?: string | null
    avgPriority?: number | null
    color?: string | null
    inputCount?: number
    lastActivity?: Date | string | null
  }

  export type inputsCreateManyUsersInput = {
    id: string
    title: string
    description: string
    type?: $Enums.InputType
    status?: $Enums.InputStatus
    createdAt?: Date | string
    updatedAt: Date | string
    department?: string | null
    rootCause?: string | null
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: number | null
    issueType?: string | null
    priority?: $Enums.priority
  }

  export type requirementsCreateManyUsersInput = {
    id: string
    title: string
    description: string
    acceptanceCriteria: JsonNullValueInput | InputJsonValue
    status?: $Enums.RequirementStatus
    estimatedEffort?: string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    riskAssessment?: string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    solutionId: string
    createdAt?: Date | string
    updatedAt: Date | string
    priority?: $Enums.priority
  }

  export type signalsCreateManyUsersInput = {
    id: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    departmentId?: string | null
    teamId?: string | null
    categoryId?: string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: number | null
    featuresVersion?: string | null
    lastFeaturesGeneratedAt?: Date | string | null
  }

  export type solutionsCreateManyUsersInput = {
    id: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    createdAt?: Date | string
    updatedAt: Date | string
    estimatedEffort?: string | null
    actualCompletionDate?: Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    hotspotId?: string | null
    ideaId?: string | null
    initiativeId?: string | null
    inputId?: string | null
    progress?: number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
  }

  export type teamsCreateManyUsers_teams_leaderIdTousersInput = {
    id: string
    name: string
    description?: string | null
    departmentId?: string | null
    memberCount?: number
    maxCapacity?: number | null
    isActive?: boolean
    teamType?: string | null
    currentProjects?: number
    budgetAllocation?: number
    utilizationRate?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type usersCreateManyUsersInput = {
    id: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    title?: string | null
    billableRate?: number | null
    costCenter?: string | null
    location?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: number | null
    utilizationRate?: number | null
    departmentObjId?: string | null
  }

  export type votesCreateManyUsersInput = {
    id: string
    createdAt?: Date | string
    entityId: string
    entityType: $Enums.EntityType
    value: $Enums.VoteValue
  }

  export type ai_analysis_auditUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotspotId?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_analysis_auditUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotspotId?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_analysis_auditUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotspotId?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_insight_overridesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    originalRecommendation?: NullableJsonNullValueInput | InputJsonValue
    overrideReason?: StringFieldUpdateOperationsInput | string
    executiveJustification?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableJsonNullValueInput | InputJsonValue
    executiveName?: StringFieldUpdateOperationsInput | string
    executiveEmail?: StringFieldUpdateOperationsInput | string
    overriddenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: signalsUpdateOneRequiredWithoutAi_insight_overridesNestedInput
  }

  export type ai_insight_overridesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    signalId?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    originalRecommendation?: NullableJsonNullValueInput | InputJsonValue
    overrideReason?: StringFieldUpdateOperationsInput | string
    executiveJustification?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableJsonNullValueInput | InputJsonValue
    executiveName?: StringFieldUpdateOperationsInput | string
    executiveEmail?: StringFieldUpdateOperationsInput | string
    overriddenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_insight_overridesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    signalId?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    insightType?: StringFieldUpdateOperationsInput | string
    originalRecommendation?: NullableJsonNullValueInput | InputJsonValue
    overrideReason?: StringFieldUpdateOperationsInput | string
    executiveJustification?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableJsonNullValueInput | InputJsonValue
    executiveName?: StringFieldUpdateOperationsInput | string
    executiveEmail?: StringFieldUpdateOperationsInput | string
    overriddenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type audit_logsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type audit_logsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type audit_logsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
    comments?: commentsUpdateOneWithoutOther_commentsNestedInput
    other_comments?: commentsUpdateManyWithoutCommentsNestedInput
  }

  export type commentsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
    other_comments?: commentsUncheckedUpdateManyWithoutCommentsNestedInput
  }

  export type commentsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    mentions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type departmentsUpdateWithoutUsers_departments_managerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headCount?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    utilizationTarget?: NullableFloatFieldUpdateOperationsInput | number | null
    actualUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: signalsUpdateManyWithoutDepartmentsNestedInput
    teams?: teamsUpdateManyWithoutDepartmentsNestedInput
    users_users_departmentObjIdTodepartments?: usersUpdateManyWithoutDepartments_users_departmentObjIdTodepartmentsNestedInput
  }

  export type departmentsUncheckedUpdateWithoutUsers_departments_managerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headCount?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    utilizationTarget?: NullableFloatFieldUpdateOperationsInput | number | null
    actualUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: signalsUncheckedUpdateManyWithoutDepartmentsNestedInput
    teams?: teamsUncheckedUpdateManyWithoutDepartmentsNestedInput
    users_users_departmentObjIdTodepartments?: usersUncheckedUpdateManyWithoutDepartments_users_departmentObjIdTodepartmentsNestedInput
  }

  export type departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    headCount?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    utilizationTarget?: NullableFloatFieldUpdateOperationsInput | number | null
    actualUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type frd_documentsUpdateWithoutUsers_frd_documents_approvedByTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_frd_documents_createdByTousers?: usersUpdateOneRequiredWithoutFrd_documents_frd_documents_createdByTousersNestedInput
    solutions?: solutionsUpdateOneRequiredWithoutFrd_documentsNestedInput
  }

  export type frd_documentsUncheckedUpdateWithoutUsers_frd_documents_approvedByTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    solutionId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    solutionId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type frd_documentsUpdateWithoutUsers_frd_documents_createdByTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_frd_documents_approvedByTousers?: usersUpdateOneWithoutFrd_documents_frd_documents_approvedByTousersNestedInput
    solutions?: solutionsUpdateOneRequiredWithoutFrd_documentsNestedInput
  }

  export type frd_documentsUncheckedUpdateWithoutUsers_frd_documents_createdByTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    solutionId?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    solutionId?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ideasUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotspots?: hotspotsUpdateOneRequiredWithoutIdeasNestedInput
    initiatives?: initiativesUpdateOneWithoutIdeasNestedInput
    solutions?: solutionsUpdateOneWithoutIdeasNestedInput
  }

  export type ideasUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotspotId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solutions?: solutionsUncheckedUpdateOneWithoutIdeasNestedInput
  }

  export type ideasUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotspotId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type initiativesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enuminitiative_statusFieldUpdateOperationsInput | $Enums.initiative_status
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    budget?: FloatFieldUpdateOperationsInput | number
    actualSpend?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedROI?: NullableFloatFieldUpdateOperationsInput | number | null
    actualROI?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: Enumrisk_levelFieldUpdateOperationsInput | $Enums.risk_level
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    milestonesJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ideas?: ideasUpdateManyWithoutInitiativesNestedInput
    solutions?: solutionsUpdateManyWithoutInitiativesNestedInput
  }

  export type initiativesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enuminitiative_statusFieldUpdateOperationsInput | $Enums.initiative_status
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    budget?: FloatFieldUpdateOperationsInput | number
    actualSpend?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedROI?: NullableFloatFieldUpdateOperationsInput | number | null
    actualROI?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: Enumrisk_levelFieldUpdateOperationsInput | $Enums.risk_level
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    milestonesJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ideas?: ideasUncheckedUpdateManyWithoutInitiativesNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutInitiativesNestedInput
  }

  export type initiativesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enuminitiative_statusFieldUpdateOperationsInput | $Enums.initiative_status
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    budget?: FloatFieldUpdateOperationsInput | number
    actualSpend?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedROI?: NullableFloatFieldUpdateOperationsInput | number | null
    actualROI?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: Enumrisk_levelFieldUpdateOperationsInput | $Enums.risk_level
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    milestonesJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type input_groupsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    avgPriority?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    inputCount?: IntFieldUpdateOperationsInput | number
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    InputToInputGroup?: InputToInputGroupUpdateManyWithoutInput_groupsNestedInput
  }

  export type input_groupsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    avgPriority?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    inputCount?: IntFieldUpdateOperationsInput | number
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    InputToInputGroup?: InputToInputGroupUncheckedUpdateManyWithoutInput_groupsNestedInput
  }

  export type input_groupsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    avgPriority?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    inputCount?: IntFieldUpdateOperationsInput | number
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type inputsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    InputToInputGroup?: InputToInputGroupUpdateManyWithoutInputsNestedInput
    solutions?: solutionsUpdateManyWithoutInputsNestedInput
  }

  export type inputsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    InputToInputGroup?: InputToInputGroupUncheckedUpdateManyWithoutInputsNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutInputsNestedInput
  }

  export type inputsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
  }

  export type requirementsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    solutions?: solutionsUpdateOneRequiredWithoutRequirementsNestedInput
  }

  export type requirementsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
  }

  export type requirementsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
  }

  export type signalsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    featuresVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastFeaturesGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutSignalsNestedInput
    hotspot_signals?: hotspot_signalsUpdateManyWithoutSignalsNestedInput
    categories?: categoriesUpdateOneWithoutSignalsNestedInput
    departments?: departmentsUpdateOneWithoutSignalsNestedInput
    teams?: teamsUpdateOneWithoutSignalsNestedInput
  }

  export type signalsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    featuresVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastFeaturesGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutSignalsNestedInput
    hotspot_signals?: hotspot_signalsUncheckedUpdateManyWithoutSignalsNestedInput
  }

  export type signalsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainClassification?: NullableJsonNullValueInput | InputJsonValue
    enhancedTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lastTaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tagGenerationMeta?: NullableJsonNullValueInput | InputJsonValue
    tagModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    clusteringFeaturesJson?: NullableJsonNullValueInput | InputJsonValue
    featuresQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    featuresVersion?: NullableStringFieldUpdateOperationsInput | string | null
    lastFeaturesGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type solutionsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsUpdateManyWithoutSolutionsNestedInput
    requirements?: requirementsUpdateManyWithoutSolutionsNestedInput
    hotspots?: hotspotsUpdateOneWithoutSolutionsNestedInput
    ideas?: ideasUpdateOneWithoutSolutionsNestedInput
    initiatives?: initiativesUpdateOneWithoutSolutionsNestedInput
    inputs?: inputsUpdateOneWithoutSolutionsNestedInput
  }

  export type solutionsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    hotspotId?: NullableStringFieldUpdateOperationsInput | string | null
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    inputId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    frd_documents?: frd_documentsUncheckedUpdateManyWithoutSolutionsNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutSolutionsNestedInput
  }

  export type solutionsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    hotspotId?: NullableStringFieldUpdateOperationsInput | string | null
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    inputId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
  }

  export type teamsUpdateWithoutUsers_teams_leaderIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: IntFieldUpdateOperationsInput | number
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teamType?: NullableStringFieldUpdateOperationsInput | string | null
    currentProjects?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: signalsUpdateManyWithoutTeamsNestedInput
    departments?: departmentsUpdateOneWithoutTeamsNestedInput
    users_TeamMembers?: usersUpdateManyWithoutTeams_TeamMembersNestedInput
  }

  export type teamsUncheckedUpdateWithoutUsers_teams_leaderIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: IntFieldUpdateOperationsInput | number
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teamType?: NullableStringFieldUpdateOperationsInput | string | null
    currentProjects?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: signalsUncheckedUpdateManyWithoutTeamsNestedInput
    users_TeamMembers?: usersUncheckedUpdateManyWithoutTeams_TeamMembersNestedInput
  }

  export type teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: IntFieldUpdateOperationsInput | number
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teamType?: NullableStringFieldUpdateOperationsInput | string | null
    currentProjects?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    ai_analysis_audit?: ai_analysis_auditUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUpdateManyWithoutUsersNestedInput
    inputs?: inputsUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUpdateManyWithoutUsersNestedInput
    signals?: signalsUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    departments_users_departmentObjIdTodepartments?: departmentsUpdateOneWithoutUsers_users_departmentObjIdTodepartmentsNestedInput
    other_users?: usersUpdateManyWithoutUsersNestedInput
    votes?: votesUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
    ai_analysis_audit?: ai_analysis_auditUncheckedUpdateManyWithoutUsersNestedInput
    ai_insight_overrides?: ai_insight_overridesUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    departments_departments_managerIdTousers?: departmentsUncheckedUpdateManyWithoutUsers_departments_managerIdTousersNestedInput
    frd_documents_frd_documents_approvedByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_approvedByTousersNestedInput
    frd_documents_frd_documents_createdByTousers?: frd_documentsUncheckedUpdateManyWithoutUsers_frd_documents_createdByTousersNestedInput
    ideas?: ideasUncheckedUpdateManyWithoutUsersNestedInput
    initiatives?: initiativesUncheckedUpdateManyWithoutUsersNestedInput
    input_groups?: input_groupsUncheckedUpdateManyWithoutUsersNestedInput
    inputs?: inputsUncheckedUpdateManyWithoutUsersNestedInput
    requirements?: requirementsUncheckedUpdateManyWithoutUsersNestedInput
    signals?: signalsUncheckedUpdateManyWithoutUsersNestedInput
    solutions?: solutionsUncheckedUpdateManyWithoutUsersNestedInput
    teams_teams_leaderIdTousers?: teamsUncheckedUpdateManyWithoutUsers_teams_leaderIdTousersNestedInput
    other_users?: usersUncheckedUpdateManyWithoutUsersNestedInput
    votes?: votesUncheckedUpdateManyWithoutUsersNestedInput
    teams_TeamMembers?: teamsUncheckedUpdateManyWithoutUsers_TeamMembersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    billableRate?: NullableFloatFieldUpdateOperationsInput | number | null
    costCenter?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    targetUtilization?: NullableFloatFieldUpdateOperationsInput | number | null
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    departmentObjId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type votesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    value?: EnumVoteValueFieldUpdateOperationsInput | $Enums.VoteValue
  }

  export type votesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    value?: EnumVoteValueFieldUpdateOperationsInput | $Enums.VoteValue
  }

  export type votesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    value?: EnumVoteValueFieldUpdateOperationsInput | $Enums.VoteValue
  }

  export type teamsUpdateWithoutUsers_TeamMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: IntFieldUpdateOperationsInput | number
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teamType?: NullableStringFieldUpdateOperationsInput | string | null
    currentProjects?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: signalsUpdateManyWithoutTeamsNestedInput
    departments?: departmentsUpdateOneWithoutTeamsNestedInput
    users_teams_leaderIdTousers?: usersUpdateOneWithoutTeams_teams_leaderIdTousersNestedInput
  }

  export type teamsUncheckedUpdateWithoutUsers_TeamMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: IntFieldUpdateOperationsInput | number
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teamType?: NullableStringFieldUpdateOperationsInput | string | null
    currentProjects?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: signalsUncheckedUpdateManyWithoutTeamsNestedInput
  }

  export type teamsUncheckedUpdateManyWithoutUsers_TeamMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: IntFieldUpdateOperationsInput | number
    maxCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    teamType?: NullableStringFieldUpdateOperationsInput | string | null
    currentProjects?: IntFieldUpdateOperationsInput | number
    budgetAllocation?: FloatFieldUpdateOperationsInput | number
    utilizationRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}