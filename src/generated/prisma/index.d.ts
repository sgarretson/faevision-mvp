
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model Initiative
 * 
 */
export type Initiative = $Result.DefaultSelection<Prisma.$InitiativePayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Signal
 * 
 */
export type Signal = $Result.DefaultSelection<Prisma.$SignalPayload>
/**
 * Model Hotspot
 * 
 */
export type Hotspot = $Result.DefaultSelection<Prisma.$HotspotPayload>
/**
 * Model HotspotSignal
 * 
 */
export type HotspotSignal = $Result.DefaultSelection<Prisma.$HotspotSignalPayload>
/**
 * Model Idea
 * 
 */
export type Idea = $Result.DefaultSelection<Prisma.$IdeaPayload>
/**
 * Model Input
 * 
 */
export type Input = $Result.DefaultSelection<Prisma.$InputPayload>
/**
 * Model Solution
 * 
 */
export type Solution = $Result.DefaultSelection<Prisma.$SolutionPayload>
/**
 * Model Requirement
 * 
 */
export type Requirement = $Result.DefaultSelection<Prisma.$RequirementPayload>
/**
 * Model FRDDocument
 * 
 */
export type FRDDocument = $Result.DefaultSelection<Prisma.$FRDDocumentPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Vote
 * 
 */
export type Vote = $Result.DefaultSelection<Prisma.$VotePayload>
/**
 * Model InputGroup
 * 
 */
export type InputGroup = $Result.DefaultSelection<Prisma.$InputGroupPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  EXECUTIVE: 'EXECUTIVE',
  CONTRIBUTOR: 'CONTRIBUTOR'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const InputType: {
  PROBLEM: 'PROBLEM',
  OPPORTUNITY: 'OPPORTUNITY',
  GENERAL: 'GENERAL'
};

export type InputType = (typeof InputType)[keyof typeof InputType]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const InputStatus: {
  ACTIVE: 'ACTIVE',
  RESOLVED: 'RESOLVED',
  ARCHIVED: 'ARCHIVED',
  DUPLICATE: 'DUPLICATE'
};

export type InputStatus = (typeof InputStatus)[keyof typeof InputStatus]


export const SolutionStatus: {
  DRAFT: 'DRAFT',
  IN_PROGRESS: 'IN_PROGRESS',
  REVIEW: 'REVIEW',
  APPROVED: 'APPROVED',
  IMPLEMENTED: 'IMPLEMENTED',
  CANCELLED: 'CANCELLED',
  ON_HOLD: 'ON_HOLD'
};

export type SolutionStatus = (typeof SolutionStatus)[keyof typeof SolutionStatus]


export const RequirementStatus: {
  DRAFT: 'DRAFT',
  REVIEW: 'REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  IMPLEMENTED: 'IMPLEMENTED',
  OBSOLETE: 'OBSOLETE'
};

export type RequirementStatus = (typeof RequirementStatus)[keyof typeof RequirementStatus]


export const FRDStatus: {
  DRAFT: 'DRAFT',
  REVIEW: 'REVIEW',
  APPROVED: 'APPROVED',
  DELIVERED: 'DELIVERED',
  ARCHIVED: 'ARCHIVED'
};

export type FRDStatus = (typeof FRDStatus)[keyof typeof FRDStatus]


export const EntityType: {
  INPUT: 'INPUT',
  SIGNAL: 'SIGNAL',
  HOTSPOT: 'HOTSPOT',
  IDEA: 'IDEA',
  SOLUTION: 'SOLUTION',
  REQUIREMENT: 'REQUIREMENT',
  FRD_DOCUMENT: 'FRD_DOCUMENT'
};

export type EntityType = (typeof EntityType)[keyof typeof EntityType]


export const VoteValue: {
  UP: 'UP',
  DOWN: 'DOWN'
};

export type VoteValue = (typeof VoteValue)[keyof typeof VoteValue]


export const NotificationType: {
  MENTION: 'MENTION',
  VOTE: 'VOTE',
  COMMENT: 'COMMENT',
  STATUS_CHANGE: 'STATUS_CHANGE',
  APPROVAL_REQUEST: 'APPROVAL_REQUEST',
  ASSIGNMENT: 'ASSIGNMENT',
  DEADLINE_REMINDER: 'DEADLINE_REMINDER'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const Severity: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type Severity = (typeof Severity)[keyof typeof Severity]


export const HotspotStatus: {
  OPEN: 'OPEN',
  APPROVED: 'APPROVED',
  HANDED_OFF: 'HANDED_OFF',
  MONITORING: 'MONITORING',
  RESOLVED: 'RESOLVED',
  CLOSED_NO_ACTION: 'CLOSED_NO_ACTION'
};

export type HotspotStatus = (typeof HotspotStatus)[keyof typeof HotspotStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type InputType = $Enums.InputType

export const InputType: typeof $Enums.InputType

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type InputStatus = $Enums.InputStatus

export const InputStatus: typeof $Enums.InputStatus

export type SolutionStatus = $Enums.SolutionStatus

export const SolutionStatus: typeof $Enums.SolutionStatus

export type RequirementStatus = $Enums.RequirementStatus

export const RequirementStatus: typeof $Enums.RequirementStatus

export type FRDStatus = $Enums.FRDStatus

export const FRDStatus: typeof $Enums.FRDStatus

export type EntityType = $Enums.EntityType

export const EntityType: typeof $Enums.EntityType

export type VoteValue = $Enums.VoteValue

export const VoteValue: typeof $Enums.VoteValue

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type Severity = $Enums.Severity

export const Severity: typeof $Enums.Severity

export type HotspotStatus = $Enums.HotspotStatus

export const HotspotStatus: typeof $Enums.HotspotStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.initiative`: Exposes CRUD operations for the **Initiative** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Initiatives
    * const initiatives = await prisma.initiative.findMany()
    * ```
    */
  get initiative(): Prisma.InitiativeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.signal`: Exposes CRUD operations for the **Signal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Signals
    * const signals = await prisma.signal.findMany()
    * ```
    */
  get signal(): Prisma.SignalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotspot`: Exposes CRUD operations for the **Hotspot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hotspots
    * const hotspots = await prisma.hotspot.findMany()
    * ```
    */
  get hotspot(): Prisma.HotspotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotspotSignal`: Exposes CRUD operations for the **HotspotSignal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotspotSignals
    * const hotspotSignals = await prisma.hotspotSignal.findMany()
    * ```
    */
  get hotspotSignal(): Prisma.HotspotSignalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.idea`: Exposes CRUD operations for the **Idea** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ideas
    * const ideas = await prisma.idea.findMany()
    * ```
    */
  get idea(): Prisma.IdeaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.input`: Exposes CRUD operations for the **Input** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inputs
    * const inputs = await prisma.input.findMany()
    * ```
    */
  get input(): Prisma.InputDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.solution`: Exposes CRUD operations for the **Solution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Solutions
    * const solutions = await prisma.solution.findMany()
    * ```
    */
  get solution(): Prisma.SolutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requirement`: Exposes CRUD operations for the **Requirement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Requirements
    * const requirements = await prisma.requirement.findMany()
    * ```
    */
  get requirement(): Prisma.RequirementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fRDDocument`: Exposes CRUD operations for the **FRDDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FRDDocuments
    * const fRDDocuments = await prisma.fRDDocument.findMany()
    * ```
    */
  get fRDDocument(): Prisma.FRDDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vote`: Exposes CRUD operations for the **Vote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Votes
    * const votes = await prisma.vote.findMany()
    * ```
    */
  get vote(): Prisma.VoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inputGroup`: Exposes CRUD operations for the **InputGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InputGroups
    * const inputGroups = await prisma.inputGroup.findMany()
    * ```
    */
  get inputGroup(): Prisma.InputGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.1
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Department: 'Department',
    Team: 'Team',
    Initiative: 'Initiative',
    Category: 'Category',
    Signal: 'Signal',
    Hotspot: 'Hotspot',
    HotspotSignal: 'HotspotSignal',
    Idea: 'Idea',
    Input: 'Input',
    Solution: 'Solution',
    Requirement: 'Requirement',
    FRDDocument: 'FRDDocument',
    Comment: 'Comment',
    Vote: 'Vote',
    InputGroup: 'InputGroup',
    AuditLog: 'AuditLog',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "department" | "team" | "initiative" | "category" | "signal" | "hotspot" | "hotspotSignal" | "idea" | "input" | "solution" | "requirement" | "fRDDocument" | "comment" | "vote" | "inputGroup" | "auditLog" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      Initiative: {
        payload: Prisma.$InitiativePayload<ExtArgs>
        fields: Prisma.InitiativeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InitiativeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InitiativePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InitiativeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InitiativePayload>
          }
          findFirst: {
            args: Prisma.InitiativeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InitiativePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InitiativeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InitiativePayload>
          }
          findMany: {
            args: Prisma.InitiativeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InitiativePayload>[]
          }
          create: {
            args: Prisma.InitiativeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InitiativePayload>
          }
          createMany: {
            args: Prisma.InitiativeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InitiativeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InitiativePayload>[]
          }
          delete: {
            args: Prisma.InitiativeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InitiativePayload>
          }
          update: {
            args: Prisma.InitiativeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InitiativePayload>
          }
          deleteMany: {
            args: Prisma.InitiativeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InitiativeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InitiativeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InitiativePayload>[]
          }
          upsert: {
            args: Prisma.InitiativeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InitiativePayload>
          }
          aggregate: {
            args: Prisma.InitiativeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInitiative>
          }
          groupBy: {
            args: Prisma.InitiativeGroupByArgs<ExtArgs>
            result: $Utils.Optional<InitiativeGroupByOutputType>[]
          }
          count: {
            args: Prisma.InitiativeCountArgs<ExtArgs>
            result: $Utils.Optional<InitiativeCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Signal: {
        payload: Prisma.$SignalPayload<ExtArgs>
        fields: Prisma.SignalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SignalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SignalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          findFirst: {
            args: Prisma.SignalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SignalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          findMany: {
            args: Prisma.SignalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>[]
          }
          create: {
            args: Prisma.SignalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          createMany: {
            args: Prisma.SignalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SignalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>[]
          }
          delete: {
            args: Prisma.SignalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          update: {
            args: Prisma.SignalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          deleteMany: {
            args: Prisma.SignalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SignalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SignalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>[]
          }
          upsert: {
            args: Prisma.SignalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          aggregate: {
            args: Prisma.SignalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSignal>
          }
          groupBy: {
            args: Prisma.SignalGroupByArgs<ExtArgs>
            result: $Utils.Optional<SignalGroupByOutputType>[]
          }
          count: {
            args: Prisma.SignalCountArgs<ExtArgs>
            result: $Utils.Optional<SignalCountAggregateOutputType> | number
          }
        }
      }
      Hotspot: {
        payload: Prisma.$HotspotPayload<ExtArgs>
        fields: Prisma.HotspotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotspotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotspotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotspotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotspotPayload>
          }
          findFirst: {
            args: Prisma.HotspotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotspotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotspotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotspotPayload>
          }
          findMany: {
            args: Prisma.HotspotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotspotPayload>[]
          }
          create: {
            args: Prisma.HotspotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotspotPayload>
          }
          createMany: {
            args: Prisma.HotspotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotspotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotspotPayload>[]
          }
          delete: {
            args: Prisma.HotspotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotspotPayload>
          }
          update: {
            args: Prisma.HotspotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotspotPayload>
          }
          deleteMany: {
            args: Prisma.HotspotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotspotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HotspotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotspotPayload>[]
          }
          upsert: {
            args: Prisma.HotspotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotspotPayload>
          }
          aggregate: {
            args: Prisma.HotspotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotspot>
          }
          groupBy: {
            args: Prisma.HotspotGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotspotGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotspotCountArgs<ExtArgs>
            result: $Utils.Optional<HotspotCountAggregateOutputType> | number
          }
        }
      }
      HotspotSignal: {
        payload: Prisma.$HotspotSignalPayload<ExtArgs>
        fields: Prisma.HotspotSignalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotspotSignalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotspotSignalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotspotSignalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotspotSignalPayload>
          }
          findFirst: {
            args: Prisma.HotspotSignalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotspotSignalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotspotSignalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotspotSignalPayload>
          }
          findMany: {
            args: Prisma.HotspotSignalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotspotSignalPayload>[]
          }
          create: {
            args: Prisma.HotspotSignalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotspotSignalPayload>
          }
          createMany: {
            args: Prisma.HotspotSignalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotspotSignalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotspotSignalPayload>[]
          }
          delete: {
            args: Prisma.HotspotSignalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotspotSignalPayload>
          }
          update: {
            args: Prisma.HotspotSignalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotspotSignalPayload>
          }
          deleteMany: {
            args: Prisma.HotspotSignalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotspotSignalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HotspotSignalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotspotSignalPayload>[]
          }
          upsert: {
            args: Prisma.HotspotSignalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotspotSignalPayload>
          }
          aggregate: {
            args: Prisma.HotspotSignalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotspotSignal>
          }
          groupBy: {
            args: Prisma.HotspotSignalGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotspotSignalGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotspotSignalCountArgs<ExtArgs>
            result: $Utils.Optional<HotspotSignalCountAggregateOutputType> | number
          }
        }
      }
      Idea: {
        payload: Prisma.$IdeaPayload<ExtArgs>
        fields: Prisma.IdeaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IdeaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IdeaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaPayload>
          }
          findFirst: {
            args: Prisma.IdeaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IdeaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaPayload>
          }
          findMany: {
            args: Prisma.IdeaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaPayload>[]
          }
          create: {
            args: Prisma.IdeaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaPayload>
          }
          createMany: {
            args: Prisma.IdeaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IdeaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaPayload>[]
          }
          delete: {
            args: Prisma.IdeaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaPayload>
          }
          update: {
            args: Prisma.IdeaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaPayload>
          }
          deleteMany: {
            args: Prisma.IdeaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IdeaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IdeaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaPayload>[]
          }
          upsert: {
            args: Prisma.IdeaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaPayload>
          }
          aggregate: {
            args: Prisma.IdeaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIdea>
          }
          groupBy: {
            args: Prisma.IdeaGroupByArgs<ExtArgs>
            result: $Utils.Optional<IdeaGroupByOutputType>[]
          }
          count: {
            args: Prisma.IdeaCountArgs<ExtArgs>
            result: $Utils.Optional<IdeaCountAggregateOutputType> | number
          }
        }
      }
      Input: {
        payload: Prisma.$InputPayload<ExtArgs>
        fields: Prisma.InputFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InputFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InputFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputPayload>
          }
          findFirst: {
            args: Prisma.InputFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InputFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputPayload>
          }
          findMany: {
            args: Prisma.InputFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputPayload>[]
          }
          create: {
            args: Prisma.InputCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputPayload>
          }
          createMany: {
            args: Prisma.InputCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InputCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputPayload>[]
          }
          delete: {
            args: Prisma.InputDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputPayload>
          }
          update: {
            args: Prisma.InputUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputPayload>
          }
          deleteMany: {
            args: Prisma.InputDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InputUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InputUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputPayload>[]
          }
          upsert: {
            args: Prisma.InputUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputPayload>
          }
          aggregate: {
            args: Prisma.InputAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInput>
          }
          groupBy: {
            args: Prisma.InputGroupByArgs<ExtArgs>
            result: $Utils.Optional<InputGroupByOutputType>[]
          }
          count: {
            args: Prisma.InputCountArgs<ExtArgs>
            result: $Utils.Optional<InputCountAggregateOutputType> | number
          }
        }
      }
      Solution: {
        payload: Prisma.$SolutionPayload<ExtArgs>
        fields: Prisma.SolutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SolutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SolutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolutionPayload>
          }
          findFirst: {
            args: Prisma.SolutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SolutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolutionPayload>
          }
          findMany: {
            args: Prisma.SolutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolutionPayload>[]
          }
          create: {
            args: Prisma.SolutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolutionPayload>
          }
          createMany: {
            args: Prisma.SolutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SolutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolutionPayload>[]
          }
          delete: {
            args: Prisma.SolutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolutionPayload>
          }
          update: {
            args: Prisma.SolutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolutionPayload>
          }
          deleteMany: {
            args: Prisma.SolutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SolutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SolutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolutionPayload>[]
          }
          upsert: {
            args: Prisma.SolutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SolutionPayload>
          }
          aggregate: {
            args: Prisma.SolutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSolution>
          }
          groupBy: {
            args: Prisma.SolutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SolutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SolutionCountArgs<ExtArgs>
            result: $Utils.Optional<SolutionCountAggregateOutputType> | number
          }
        }
      }
      Requirement: {
        payload: Prisma.$RequirementPayload<ExtArgs>
        fields: Prisma.RequirementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequirementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequirementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          findFirst: {
            args: Prisma.RequirementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequirementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          findMany: {
            args: Prisma.RequirementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>[]
          }
          create: {
            args: Prisma.RequirementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          createMany: {
            args: Prisma.RequirementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequirementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>[]
          }
          delete: {
            args: Prisma.RequirementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          update: {
            args: Prisma.RequirementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          deleteMany: {
            args: Prisma.RequirementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequirementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequirementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>[]
          }
          upsert: {
            args: Prisma.RequirementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          aggregate: {
            args: Prisma.RequirementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequirement>
          }
          groupBy: {
            args: Prisma.RequirementGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequirementGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequirementCountArgs<ExtArgs>
            result: $Utils.Optional<RequirementCountAggregateOutputType> | number
          }
        }
      }
      FRDDocument: {
        payload: Prisma.$FRDDocumentPayload<ExtArgs>
        fields: Prisma.FRDDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FRDDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FRDDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FRDDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FRDDocumentPayload>
          }
          findFirst: {
            args: Prisma.FRDDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FRDDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FRDDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FRDDocumentPayload>
          }
          findMany: {
            args: Prisma.FRDDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FRDDocumentPayload>[]
          }
          create: {
            args: Prisma.FRDDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FRDDocumentPayload>
          }
          createMany: {
            args: Prisma.FRDDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FRDDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FRDDocumentPayload>[]
          }
          delete: {
            args: Prisma.FRDDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FRDDocumentPayload>
          }
          update: {
            args: Prisma.FRDDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FRDDocumentPayload>
          }
          deleteMany: {
            args: Prisma.FRDDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FRDDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FRDDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FRDDocumentPayload>[]
          }
          upsert: {
            args: Prisma.FRDDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FRDDocumentPayload>
          }
          aggregate: {
            args: Prisma.FRDDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFRDDocument>
          }
          groupBy: {
            args: Prisma.FRDDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<FRDDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.FRDDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<FRDDocumentCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Vote: {
        payload: Prisma.$VotePayload<ExtArgs>
        fields: Prisma.VoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          findFirst: {
            args: Prisma.VoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          findMany: {
            args: Prisma.VoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[]
          }
          create: {
            args: Prisma.VoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          createMany: {
            args: Prisma.VoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[]
          }
          delete: {
            args: Prisma.VoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          update: {
            args: Prisma.VoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          deleteMany: {
            args: Prisma.VoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[]
          }
          upsert: {
            args: Prisma.VoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          aggregate: {
            args: Prisma.VoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVote>
          }
          groupBy: {
            args: Prisma.VoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoteCountArgs<ExtArgs>
            result: $Utils.Optional<VoteCountAggregateOutputType> | number
          }
        }
      }
      InputGroup: {
        payload: Prisma.$InputGroupPayload<ExtArgs>
        fields: Prisma.InputGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InputGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InputGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputGroupPayload>
          }
          findFirst: {
            args: Prisma.InputGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InputGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputGroupPayload>
          }
          findMany: {
            args: Prisma.InputGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputGroupPayload>[]
          }
          create: {
            args: Prisma.InputGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputGroupPayload>
          }
          createMany: {
            args: Prisma.InputGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InputGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputGroupPayload>[]
          }
          delete: {
            args: Prisma.InputGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputGroupPayload>
          }
          update: {
            args: Prisma.InputGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputGroupPayload>
          }
          deleteMany: {
            args: Prisma.InputGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InputGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InputGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputGroupPayload>[]
          }
          upsert: {
            args: Prisma.InputGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InputGroupPayload>
          }
          aggregate: {
            args: Prisma.InputGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInputGroup>
          }
          groupBy: {
            args: Prisma.InputGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<InputGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.InputGroupCountArgs<ExtArgs>
            result: $Utils.Optional<InputGroupCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    department?: DepartmentOmit
    team?: TeamOmit
    initiative?: InitiativeOmit
    category?: CategoryOmit
    signal?: SignalOmit
    hotspot?: HotspotOmit
    hotspotSignal?: HotspotSignalOmit
    idea?: IdeaOmit
    input?: InputOmit
    solution?: SolutionOmit
    requirement?: RequirementOmit
    fRDDocument?: FRDDocumentOmit
    comment?: CommentOmit
    vote?: VoteOmit
    inputGroup?: InputGroupOmit
    auditLog?: AuditLogOmit
    notification?: NotificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    inputs: number
    signals: number
    initiatives: number
    ideas: number
    solutions: number
    comments: number
    votes: number
    requirements: number
    frdDocuments: number
    approvedFRDs: number
    auditLogs: number
    inputGroups: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inputs?: boolean | UserCountOutputTypeCountInputsArgs
    signals?: boolean | UserCountOutputTypeCountSignalsArgs
    initiatives?: boolean | UserCountOutputTypeCountInitiativesArgs
    ideas?: boolean | UserCountOutputTypeCountIdeasArgs
    solutions?: boolean | UserCountOutputTypeCountSolutionsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    votes?: boolean | UserCountOutputTypeCountVotesArgs
    requirements?: boolean | UserCountOutputTypeCountRequirementsArgs
    frdDocuments?: boolean | UserCountOutputTypeCountFrdDocumentsArgs
    approvedFRDs?: boolean | UserCountOutputTypeCountApprovedFRDsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    inputGroups?: boolean | UserCountOutputTypeCountInputGroupsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InputWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSignalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInitiativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InitiativeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIdeasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdeaWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SolutionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFrdDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FRDDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedFRDsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FRDDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInputGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InputGroupWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    teams: number
    signals: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teams?: boolean | DepartmentCountOutputTypeCountTeamsArgs
    signals?: boolean | DepartmentCountOutputTypeCountSignalsArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountSignalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignalWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    signals: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    signals?: boolean | TeamCountOutputTypeCountSignalsArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountSignalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignalWhereInput
  }


  /**
   * Count Type InitiativeCountOutputType
   */

  export type InitiativeCountOutputType = {
    solutions: number
  }

  export type InitiativeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    solutions?: boolean | InitiativeCountOutputTypeCountSolutionsArgs
  }

  // Custom InputTypes
  /**
   * InitiativeCountOutputType without action
   */
  export type InitiativeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InitiativeCountOutputType
     */
    select?: InitiativeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InitiativeCountOutputType without action
   */
  export type InitiativeCountOutputTypeCountSolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SolutionWhereInput
  }


  /**
   * Count Type SignalCountOutputType
   */

  export type SignalCountOutputType = {
    hotspots: number
  }

  export type SignalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotspots?: boolean | SignalCountOutputTypeCountHotspotsArgs
  }

  // Custom InputTypes
  /**
   * SignalCountOutputType without action
   */
  export type SignalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignalCountOutputType
     */
    select?: SignalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SignalCountOutputType without action
   */
  export type SignalCountOutputTypeCountHotspotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotspotSignalWhereInput
  }


  /**
   * Count Type HotspotCountOutputType
   */

  export type HotspotCountOutputType = {
    signals: number
    ideas: number
    solutions: number
  }

  export type HotspotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    signals?: boolean | HotspotCountOutputTypeCountSignalsArgs
    ideas?: boolean | HotspotCountOutputTypeCountIdeasArgs
    solutions?: boolean | HotspotCountOutputTypeCountSolutionsArgs
  }

  // Custom InputTypes
  /**
   * HotspotCountOutputType without action
   */
  export type HotspotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotspotCountOutputType
     */
    select?: HotspotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotspotCountOutputType without action
   */
  export type HotspotCountOutputTypeCountSignalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotspotSignalWhereInput
  }

  /**
   * HotspotCountOutputType without action
   */
  export type HotspotCountOutputTypeCountIdeasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdeaWhereInput
  }

  /**
   * HotspotCountOutputType without action
   */
  export type HotspotCountOutputTypeCountSolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SolutionWhereInput
  }


  /**
   * Count Type InputCountOutputType
   */

  export type InputCountOutputType = {
    solutions: number
    groups: number
  }

  export type InputCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    solutions?: boolean | InputCountOutputTypeCountSolutionsArgs
    groups?: boolean | InputCountOutputTypeCountGroupsArgs
  }

  // Custom InputTypes
  /**
   * InputCountOutputType without action
   */
  export type InputCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputCountOutputType
     */
    select?: InputCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InputCountOutputType without action
   */
  export type InputCountOutputTypeCountSolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SolutionWhereInput
  }

  /**
   * InputCountOutputType without action
   */
  export type InputCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InputGroupWhereInput
  }


  /**
   * Count Type SolutionCountOutputType
   */

  export type SolutionCountOutputType = {
    requirements: number
    frdDocuments: number
  }

  export type SolutionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requirements?: boolean | SolutionCountOutputTypeCountRequirementsArgs
    frdDocuments?: boolean | SolutionCountOutputTypeCountFrdDocumentsArgs
  }

  // Custom InputTypes
  /**
   * SolutionCountOutputType without action
   */
  export type SolutionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolutionCountOutputType
     */
    select?: SolutionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SolutionCountOutputType without action
   */
  export type SolutionCountOutputTypeCountRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementWhereInput
  }

  /**
   * SolutionCountOutputType without action
   */
  export type SolutionCountOutputTypeCountFrdDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FRDDocumentWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    replies: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type InputGroupCountOutputType
   */

  export type InputGroupCountOutputType = {
    inputs: number
  }

  export type InputGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inputs?: boolean | InputGroupCountOutputTypeCountInputsArgs
  }

  // Custom InputTypes
  /**
   * InputGroupCountOutputType without action
   */
  export type InputGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputGroupCountOutputType
     */
    select?: InputGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InputGroupCountOutputType without action
   */
  export type InputGroupCountOutputTypeCountInputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InputWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: $Enums.UserRole | null
    department: string | null
    avatar: string | null
    passwordHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: $Enums.UserRole | null
    department: string | null
    avatar: string | null
    passwordHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    role: number
    department: number
    avatar: number
    passwordHash: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    department?: true
    avatar?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    department?: true
    avatar?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    department?: true
    avatar?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    role: $Enums.UserRole
    department: string | null
    avatar: string | null
    passwordHash: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    department?: boolean
    avatar?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inputs?: boolean | User$inputsArgs<ExtArgs>
    signals?: boolean | User$signalsArgs<ExtArgs>
    initiatives?: boolean | User$initiativesArgs<ExtArgs>
    ideas?: boolean | User$ideasArgs<ExtArgs>
    solutions?: boolean | User$solutionsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    votes?: boolean | User$votesArgs<ExtArgs>
    requirements?: boolean | User$requirementsArgs<ExtArgs>
    frdDocuments?: boolean | User$frdDocumentsArgs<ExtArgs>
    approvedFRDs?: boolean | User$approvedFRDsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    inputGroups?: boolean | User$inputGroupsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    department?: boolean
    avatar?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    department?: boolean
    avatar?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    department?: boolean
    avatar?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "role" | "department" | "avatar" | "passwordHash" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inputs?: boolean | User$inputsArgs<ExtArgs>
    signals?: boolean | User$signalsArgs<ExtArgs>
    initiatives?: boolean | User$initiativesArgs<ExtArgs>
    ideas?: boolean | User$ideasArgs<ExtArgs>
    solutions?: boolean | User$solutionsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    votes?: boolean | User$votesArgs<ExtArgs>
    requirements?: boolean | User$requirementsArgs<ExtArgs>
    frdDocuments?: boolean | User$frdDocumentsArgs<ExtArgs>
    approvedFRDs?: boolean | User$approvedFRDsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    inputGroups?: boolean | User$inputGroupsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      inputs: Prisma.$InputPayload<ExtArgs>[]
      signals: Prisma.$SignalPayload<ExtArgs>[]
      initiatives: Prisma.$InitiativePayload<ExtArgs>[]
      ideas: Prisma.$IdeaPayload<ExtArgs>[]
      solutions: Prisma.$SolutionPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      votes: Prisma.$VotePayload<ExtArgs>[]
      requirements: Prisma.$RequirementPayload<ExtArgs>[]
      frdDocuments: Prisma.$FRDDocumentPayload<ExtArgs>[]
      approvedFRDs: Prisma.$FRDDocumentPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      inputGroups: Prisma.$InputGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      role: $Enums.UserRole
      department: string | null
      avatar: string | null
      passwordHash: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inputs<T extends User$inputsArgs<ExtArgs> = {}>(args?: Subset<T, User$inputsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InputPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    signals<T extends User$signalsArgs<ExtArgs> = {}>(args?: Subset<T, User$signalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    initiatives<T extends User$initiativesArgs<ExtArgs> = {}>(args?: Subset<T, User$initiativesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InitiativePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ideas<T extends User$ideasArgs<ExtArgs> = {}>(args?: Subset<T, User$ideasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    solutions<T extends User$solutionsArgs<ExtArgs> = {}>(args?: Subset<T, User$solutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SolutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    votes<T extends User$votesArgs<ExtArgs> = {}>(args?: Subset<T, User$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requirements<T extends User$requirementsArgs<ExtArgs> = {}>(args?: Subset<T, User$requirementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    frdDocuments<T extends User$frdDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$frdDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FRDDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedFRDs<T extends User$approvedFRDsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedFRDsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FRDDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inputGroups<T extends User$inputGroupsArgs<ExtArgs> = {}>(args?: Subset<T, User$inputGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InputGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly department: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.inputs
   */
  export type User$inputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null
    where?: InputWhereInput
    orderBy?: InputOrderByWithRelationInput | InputOrderByWithRelationInput[]
    cursor?: InputWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InputScalarFieldEnum | InputScalarFieldEnum[]
  }

  /**
   * User.signals
   */
  export type User$signalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    where?: SignalWhereInput
    orderBy?: SignalOrderByWithRelationInput | SignalOrderByWithRelationInput[]
    cursor?: SignalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SignalScalarFieldEnum | SignalScalarFieldEnum[]
  }

  /**
   * User.initiatives
   */
  export type User$initiativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Initiative
     */
    select?: InitiativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Initiative
     */
    omit?: InitiativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InitiativeInclude<ExtArgs> | null
    where?: InitiativeWhereInput
    orderBy?: InitiativeOrderByWithRelationInput | InitiativeOrderByWithRelationInput[]
    cursor?: InitiativeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InitiativeScalarFieldEnum | InitiativeScalarFieldEnum[]
  }

  /**
   * User.ideas
   */
  export type User$ideasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
    where?: IdeaWhereInput
    orderBy?: IdeaOrderByWithRelationInput | IdeaOrderByWithRelationInput[]
    cursor?: IdeaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IdeaScalarFieldEnum | IdeaScalarFieldEnum[]
  }

  /**
   * User.solutions
   */
  export type User$solutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null
    where?: SolutionWhereInput
    orderBy?: SolutionOrderByWithRelationInput | SolutionOrderByWithRelationInput[]
    cursor?: SolutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SolutionScalarFieldEnum | SolutionScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.votes
   */
  export type User$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    cursor?: VoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * User.requirements
   */
  export type User$requirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    where?: RequirementWhereInput
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    cursor?: RequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[]
  }

  /**
   * User.frdDocuments
   */
  export type User$frdDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null
    where?: FRDDocumentWhereInput
    orderBy?: FRDDocumentOrderByWithRelationInput | FRDDocumentOrderByWithRelationInput[]
    cursor?: FRDDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FRDDocumentScalarFieldEnum | FRDDocumentScalarFieldEnum[]
  }

  /**
   * User.approvedFRDs
   */
  export type User$approvedFRDsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null
    where?: FRDDocumentWhereInput
    orderBy?: FRDDocumentOrderByWithRelationInput | FRDDocumentOrderByWithRelationInput[]
    cursor?: FRDDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FRDDocumentScalarFieldEnum | FRDDocumentScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.inputGroups
   */
  export type User$inputGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null
    where?: InputGroupWhereInput
    orderBy?: InputGroupOrderByWithRelationInput | InputGroupOrderByWithRelationInput[]
    cursor?: InputGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InputGroupScalarFieldEnum | InputGroupScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teams?: boolean | Department$teamsArgs<ExtArgs>
    signals?: boolean | Department$signalsArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teams?: boolean | Department$teamsArgs<ExtArgs>
    signals?: boolean | Department$signalsArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      teams: Prisma.$TeamPayload<ExtArgs>[]
      signals: Prisma.$SignalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teams<T extends Department$teamsArgs<ExtArgs> = {}>(args?: Subset<T, Department$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    signals<T extends Department$signalsArgs<ExtArgs> = {}>(args?: Subset<T, Department$signalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.teams
   */
  export type Department$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Department.signals
   */
  export type Department$signalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    where?: SignalWhereInput
    orderBy?: SignalOrderByWithRelationInput | SignalOrderByWithRelationInput[]
    cursor?: SignalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SignalScalarFieldEnum | SignalScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
    departmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    departmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    departmentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    departmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    departmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    departmentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    name: string
    departmentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    departmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | Team$departmentArgs<ExtArgs>
    signals?: boolean | Team$signalsArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    departmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | Team$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    departmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | Team$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    departmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "departmentId" | "createdAt" | "updatedAt", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Team$departmentArgs<ExtArgs>
    signals?: boolean | Team$signalsArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Team$departmentArgs<ExtArgs>
  }
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Team$departmentArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      signals: Prisma.$SignalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      departmentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends Team$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Team$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    signals<T extends Team$signalsArgs<ExtArgs> = {}>(args?: Subset<T, Team$signalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly departmentId: FieldRef<"Team", 'String'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.department
   */
  export type Team$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Team.signals
   */
  export type Team$signalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    where?: SignalWhereInput
    orderBy?: SignalOrderByWithRelationInput | SignalOrderByWithRelationInput[]
    cursor?: SignalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SignalScalarFieldEnum | SignalScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model Initiative
   */

  export type AggregateInitiative = {
    _count: InitiativeCountAggregateOutputType | null
    _min: InitiativeMinAggregateOutputType | null
    _max: InitiativeMaxAggregateOutputType | null
  }

  export type InitiativeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InitiativeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InitiativeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    ownerId: number
    goalJson: number
    roiJson: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InitiativeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InitiativeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InitiativeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    goalJson?: true
    roiJson?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InitiativeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Initiative to aggregate.
     */
    where?: InitiativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Initiatives to fetch.
     */
    orderBy?: InitiativeOrderByWithRelationInput | InitiativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InitiativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Initiatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Initiatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Initiatives
    **/
    _count?: true | InitiativeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InitiativeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InitiativeMaxAggregateInputType
  }

  export type GetInitiativeAggregateType<T extends InitiativeAggregateArgs> = {
        [P in keyof T & keyof AggregateInitiative]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInitiative[P]>
      : GetScalarType<T[P], AggregateInitiative[P]>
  }




  export type InitiativeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InitiativeWhereInput
    orderBy?: InitiativeOrderByWithAggregationInput | InitiativeOrderByWithAggregationInput[]
    by: InitiativeScalarFieldEnum[] | InitiativeScalarFieldEnum
    having?: InitiativeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InitiativeCountAggregateInputType | true
    _min?: InitiativeMinAggregateInputType
    _max?: InitiativeMaxAggregateInputType
  }

  export type InitiativeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    ownerId: string | null
    goalJson: JsonValue | null
    roiJson: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: InitiativeCountAggregateOutputType | null
    _min: InitiativeMinAggregateOutputType | null
    _max: InitiativeMaxAggregateOutputType | null
  }

  type GetInitiativeGroupByPayload<T extends InitiativeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InitiativeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InitiativeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InitiativeGroupByOutputType[P]>
            : GetScalarType<T[P], InitiativeGroupByOutputType[P]>
        }
      >
    >


  export type InitiativeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    goalJson?: boolean
    roiJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | Initiative$ownerArgs<ExtArgs>
    solutions?: boolean | Initiative$solutionsArgs<ExtArgs>
    _count?: boolean | InitiativeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["initiative"]>

  export type InitiativeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    goalJson?: boolean
    roiJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | Initiative$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["initiative"]>

  export type InitiativeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    goalJson?: boolean
    roiJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | Initiative$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["initiative"]>

  export type InitiativeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    goalJson?: boolean
    roiJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InitiativeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "ownerId" | "goalJson" | "roiJson" | "createdAt" | "updatedAt", ExtArgs["result"]["initiative"]>
  export type InitiativeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | Initiative$ownerArgs<ExtArgs>
    solutions?: boolean | Initiative$solutionsArgs<ExtArgs>
    _count?: boolean | InitiativeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InitiativeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | Initiative$ownerArgs<ExtArgs>
  }
  export type InitiativeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | Initiative$ownerArgs<ExtArgs>
  }

  export type $InitiativePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Initiative"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs> | null
      solutions: Prisma.$SolutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      ownerId: string | null
      goalJson: Prisma.JsonValue | null
      roiJson: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["initiative"]>
    composites: {}
  }

  type InitiativeGetPayload<S extends boolean | null | undefined | InitiativeDefaultArgs> = $Result.GetResult<Prisma.$InitiativePayload, S>

  type InitiativeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InitiativeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InitiativeCountAggregateInputType | true
    }

  export interface InitiativeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Initiative'], meta: { name: 'Initiative' } }
    /**
     * Find zero or one Initiative that matches the filter.
     * @param {InitiativeFindUniqueArgs} args - Arguments to find a Initiative
     * @example
     * // Get one Initiative
     * const initiative = await prisma.initiative.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InitiativeFindUniqueArgs>(args: SelectSubset<T, InitiativeFindUniqueArgs<ExtArgs>>): Prisma__InitiativeClient<$Result.GetResult<Prisma.$InitiativePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Initiative that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InitiativeFindUniqueOrThrowArgs} args - Arguments to find a Initiative
     * @example
     * // Get one Initiative
     * const initiative = await prisma.initiative.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InitiativeFindUniqueOrThrowArgs>(args: SelectSubset<T, InitiativeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InitiativeClient<$Result.GetResult<Prisma.$InitiativePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Initiative that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InitiativeFindFirstArgs} args - Arguments to find a Initiative
     * @example
     * // Get one Initiative
     * const initiative = await prisma.initiative.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InitiativeFindFirstArgs>(args?: SelectSubset<T, InitiativeFindFirstArgs<ExtArgs>>): Prisma__InitiativeClient<$Result.GetResult<Prisma.$InitiativePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Initiative that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InitiativeFindFirstOrThrowArgs} args - Arguments to find a Initiative
     * @example
     * // Get one Initiative
     * const initiative = await prisma.initiative.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InitiativeFindFirstOrThrowArgs>(args?: SelectSubset<T, InitiativeFindFirstOrThrowArgs<ExtArgs>>): Prisma__InitiativeClient<$Result.GetResult<Prisma.$InitiativePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Initiatives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InitiativeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Initiatives
     * const initiatives = await prisma.initiative.findMany()
     * 
     * // Get first 10 Initiatives
     * const initiatives = await prisma.initiative.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const initiativeWithIdOnly = await prisma.initiative.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InitiativeFindManyArgs>(args?: SelectSubset<T, InitiativeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InitiativePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Initiative.
     * @param {InitiativeCreateArgs} args - Arguments to create a Initiative.
     * @example
     * // Create one Initiative
     * const Initiative = await prisma.initiative.create({
     *   data: {
     *     // ... data to create a Initiative
     *   }
     * })
     * 
     */
    create<T extends InitiativeCreateArgs>(args: SelectSubset<T, InitiativeCreateArgs<ExtArgs>>): Prisma__InitiativeClient<$Result.GetResult<Prisma.$InitiativePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Initiatives.
     * @param {InitiativeCreateManyArgs} args - Arguments to create many Initiatives.
     * @example
     * // Create many Initiatives
     * const initiative = await prisma.initiative.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InitiativeCreateManyArgs>(args?: SelectSubset<T, InitiativeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Initiatives and returns the data saved in the database.
     * @param {InitiativeCreateManyAndReturnArgs} args - Arguments to create many Initiatives.
     * @example
     * // Create many Initiatives
     * const initiative = await prisma.initiative.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Initiatives and only return the `id`
     * const initiativeWithIdOnly = await prisma.initiative.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InitiativeCreateManyAndReturnArgs>(args?: SelectSubset<T, InitiativeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InitiativePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Initiative.
     * @param {InitiativeDeleteArgs} args - Arguments to delete one Initiative.
     * @example
     * // Delete one Initiative
     * const Initiative = await prisma.initiative.delete({
     *   where: {
     *     // ... filter to delete one Initiative
     *   }
     * })
     * 
     */
    delete<T extends InitiativeDeleteArgs>(args: SelectSubset<T, InitiativeDeleteArgs<ExtArgs>>): Prisma__InitiativeClient<$Result.GetResult<Prisma.$InitiativePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Initiative.
     * @param {InitiativeUpdateArgs} args - Arguments to update one Initiative.
     * @example
     * // Update one Initiative
     * const initiative = await prisma.initiative.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InitiativeUpdateArgs>(args: SelectSubset<T, InitiativeUpdateArgs<ExtArgs>>): Prisma__InitiativeClient<$Result.GetResult<Prisma.$InitiativePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Initiatives.
     * @param {InitiativeDeleteManyArgs} args - Arguments to filter Initiatives to delete.
     * @example
     * // Delete a few Initiatives
     * const { count } = await prisma.initiative.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InitiativeDeleteManyArgs>(args?: SelectSubset<T, InitiativeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Initiatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InitiativeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Initiatives
     * const initiative = await prisma.initiative.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InitiativeUpdateManyArgs>(args: SelectSubset<T, InitiativeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Initiatives and returns the data updated in the database.
     * @param {InitiativeUpdateManyAndReturnArgs} args - Arguments to update many Initiatives.
     * @example
     * // Update many Initiatives
     * const initiative = await prisma.initiative.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Initiatives and only return the `id`
     * const initiativeWithIdOnly = await prisma.initiative.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InitiativeUpdateManyAndReturnArgs>(args: SelectSubset<T, InitiativeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InitiativePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Initiative.
     * @param {InitiativeUpsertArgs} args - Arguments to update or create a Initiative.
     * @example
     * // Update or create a Initiative
     * const initiative = await prisma.initiative.upsert({
     *   create: {
     *     // ... data to create a Initiative
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Initiative we want to update
     *   }
     * })
     */
    upsert<T extends InitiativeUpsertArgs>(args: SelectSubset<T, InitiativeUpsertArgs<ExtArgs>>): Prisma__InitiativeClient<$Result.GetResult<Prisma.$InitiativePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Initiatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InitiativeCountArgs} args - Arguments to filter Initiatives to count.
     * @example
     * // Count the number of Initiatives
     * const count = await prisma.initiative.count({
     *   where: {
     *     // ... the filter for the Initiatives we want to count
     *   }
     * })
    **/
    count<T extends InitiativeCountArgs>(
      args?: Subset<T, InitiativeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InitiativeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Initiative.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InitiativeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InitiativeAggregateArgs>(args: Subset<T, InitiativeAggregateArgs>): Prisma.PrismaPromise<GetInitiativeAggregateType<T>>

    /**
     * Group by Initiative.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InitiativeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InitiativeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InitiativeGroupByArgs['orderBy'] }
        : { orderBy?: InitiativeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InitiativeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInitiativeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Initiative model
   */
  readonly fields: InitiativeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Initiative.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InitiativeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends Initiative$ownerArgs<ExtArgs> = {}>(args?: Subset<T, Initiative$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    solutions<T extends Initiative$solutionsArgs<ExtArgs> = {}>(args?: Subset<T, Initiative$solutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SolutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Initiative model
   */
  interface InitiativeFieldRefs {
    readonly id: FieldRef<"Initiative", 'String'>
    readonly name: FieldRef<"Initiative", 'String'>
    readonly description: FieldRef<"Initiative", 'String'>
    readonly ownerId: FieldRef<"Initiative", 'String'>
    readonly goalJson: FieldRef<"Initiative", 'Json'>
    readonly roiJson: FieldRef<"Initiative", 'Json'>
    readonly createdAt: FieldRef<"Initiative", 'DateTime'>
    readonly updatedAt: FieldRef<"Initiative", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Initiative findUnique
   */
  export type InitiativeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Initiative
     */
    select?: InitiativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Initiative
     */
    omit?: InitiativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InitiativeInclude<ExtArgs> | null
    /**
     * Filter, which Initiative to fetch.
     */
    where: InitiativeWhereUniqueInput
  }

  /**
   * Initiative findUniqueOrThrow
   */
  export type InitiativeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Initiative
     */
    select?: InitiativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Initiative
     */
    omit?: InitiativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InitiativeInclude<ExtArgs> | null
    /**
     * Filter, which Initiative to fetch.
     */
    where: InitiativeWhereUniqueInput
  }

  /**
   * Initiative findFirst
   */
  export type InitiativeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Initiative
     */
    select?: InitiativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Initiative
     */
    omit?: InitiativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InitiativeInclude<ExtArgs> | null
    /**
     * Filter, which Initiative to fetch.
     */
    where?: InitiativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Initiatives to fetch.
     */
    orderBy?: InitiativeOrderByWithRelationInput | InitiativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Initiatives.
     */
    cursor?: InitiativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Initiatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Initiatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Initiatives.
     */
    distinct?: InitiativeScalarFieldEnum | InitiativeScalarFieldEnum[]
  }

  /**
   * Initiative findFirstOrThrow
   */
  export type InitiativeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Initiative
     */
    select?: InitiativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Initiative
     */
    omit?: InitiativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InitiativeInclude<ExtArgs> | null
    /**
     * Filter, which Initiative to fetch.
     */
    where?: InitiativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Initiatives to fetch.
     */
    orderBy?: InitiativeOrderByWithRelationInput | InitiativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Initiatives.
     */
    cursor?: InitiativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Initiatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Initiatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Initiatives.
     */
    distinct?: InitiativeScalarFieldEnum | InitiativeScalarFieldEnum[]
  }

  /**
   * Initiative findMany
   */
  export type InitiativeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Initiative
     */
    select?: InitiativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Initiative
     */
    omit?: InitiativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InitiativeInclude<ExtArgs> | null
    /**
     * Filter, which Initiatives to fetch.
     */
    where?: InitiativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Initiatives to fetch.
     */
    orderBy?: InitiativeOrderByWithRelationInput | InitiativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Initiatives.
     */
    cursor?: InitiativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Initiatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Initiatives.
     */
    skip?: number
    distinct?: InitiativeScalarFieldEnum | InitiativeScalarFieldEnum[]
  }

  /**
   * Initiative create
   */
  export type InitiativeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Initiative
     */
    select?: InitiativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Initiative
     */
    omit?: InitiativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InitiativeInclude<ExtArgs> | null
    /**
     * The data needed to create a Initiative.
     */
    data: XOR<InitiativeCreateInput, InitiativeUncheckedCreateInput>
  }

  /**
   * Initiative createMany
   */
  export type InitiativeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Initiatives.
     */
    data: InitiativeCreateManyInput | InitiativeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Initiative createManyAndReturn
   */
  export type InitiativeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Initiative
     */
    select?: InitiativeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Initiative
     */
    omit?: InitiativeOmit<ExtArgs> | null
    /**
     * The data used to create many Initiatives.
     */
    data: InitiativeCreateManyInput | InitiativeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InitiativeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Initiative update
   */
  export type InitiativeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Initiative
     */
    select?: InitiativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Initiative
     */
    omit?: InitiativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InitiativeInclude<ExtArgs> | null
    /**
     * The data needed to update a Initiative.
     */
    data: XOR<InitiativeUpdateInput, InitiativeUncheckedUpdateInput>
    /**
     * Choose, which Initiative to update.
     */
    where: InitiativeWhereUniqueInput
  }

  /**
   * Initiative updateMany
   */
  export type InitiativeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Initiatives.
     */
    data: XOR<InitiativeUpdateManyMutationInput, InitiativeUncheckedUpdateManyInput>
    /**
     * Filter which Initiatives to update
     */
    where?: InitiativeWhereInput
    /**
     * Limit how many Initiatives to update.
     */
    limit?: number
  }

  /**
   * Initiative updateManyAndReturn
   */
  export type InitiativeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Initiative
     */
    select?: InitiativeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Initiative
     */
    omit?: InitiativeOmit<ExtArgs> | null
    /**
     * The data used to update Initiatives.
     */
    data: XOR<InitiativeUpdateManyMutationInput, InitiativeUncheckedUpdateManyInput>
    /**
     * Filter which Initiatives to update
     */
    where?: InitiativeWhereInput
    /**
     * Limit how many Initiatives to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InitiativeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Initiative upsert
   */
  export type InitiativeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Initiative
     */
    select?: InitiativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Initiative
     */
    omit?: InitiativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InitiativeInclude<ExtArgs> | null
    /**
     * The filter to search for the Initiative to update in case it exists.
     */
    where: InitiativeWhereUniqueInput
    /**
     * In case the Initiative found by the `where` argument doesn't exist, create a new Initiative with this data.
     */
    create: XOR<InitiativeCreateInput, InitiativeUncheckedCreateInput>
    /**
     * In case the Initiative was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InitiativeUpdateInput, InitiativeUncheckedUpdateInput>
  }

  /**
   * Initiative delete
   */
  export type InitiativeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Initiative
     */
    select?: InitiativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Initiative
     */
    omit?: InitiativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InitiativeInclude<ExtArgs> | null
    /**
     * Filter which Initiative to delete.
     */
    where: InitiativeWhereUniqueInput
  }

  /**
   * Initiative deleteMany
   */
  export type InitiativeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Initiatives to delete
     */
    where?: InitiativeWhereInput
    /**
     * Limit how many Initiatives to delete.
     */
    limit?: number
  }

  /**
   * Initiative.owner
   */
  export type Initiative$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Initiative.solutions
   */
  export type Initiative$solutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null
    where?: SolutionWhereInput
    orderBy?: SolutionOrderByWithRelationInput | SolutionOrderByWithRelationInput[]
    cursor?: SolutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SolutionScalarFieldEnum | SolutionScalarFieldEnum[]
  }

  /**
   * Initiative without action
   */
  export type InitiativeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Initiative
     */
    select?: InitiativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Initiative
     */
    omit?: InitiativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InitiativeInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt", ExtArgs["result"]["category"]>

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
  }


  /**
   * Model Signal
   */

  export type AggregateSignal = {
    _count: SignalCountAggregateOutputType | null
    _avg: SignalAvgAggregateOutputType | null
    _sum: SignalSumAggregateOutputType | null
    _min: SignalMinAggregateOutputType | null
    _max: SignalMaxAggregateOutputType | null
  }

  export type SignalAvgAggregateOutputType = {
    confidence: number | null
    severityScore: number | null
  }

  export type SignalSumAggregateOutputType = {
    confidence: number | null
    severityScore: number | null
  }

  export type SignalMinAggregateOutputType = {
    id: string | null
    inputId: string | null
    timestamp: Date | null
    receivedAt: Date | null
    schemaVersion: string | null
    confidence: number | null
    sourceType: string | null
    sourceId: string | null
    systemName: string | null
    title: string | null
    description: string | null
    severity: $Enums.Severity | null
    severityScore: number | null
    departmentId: string | null
    teamId: string | null
    privacyLevel: string | null
    dedupeKey: string | null
    embedding: Uint8Array | null
    aiProcessed: boolean | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SignalMaxAggregateOutputType = {
    id: string | null
    inputId: string | null
    timestamp: Date | null
    receivedAt: Date | null
    schemaVersion: string | null
    confidence: number | null
    sourceType: string | null
    sourceId: string | null
    systemName: string | null
    title: string | null
    description: string | null
    severity: $Enums.Severity | null
    severityScore: number | null
    departmentId: string | null
    teamId: string | null
    privacyLevel: string | null
    dedupeKey: string | null
    embedding: Uint8Array | null
    aiProcessed: boolean | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SignalCountAggregateOutputType = {
    id: number
    inputId: number
    timestamp: number
    receivedAt: number
    schemaVersion: number
    sourceJson: number
    confidence: number
    attachmentsJson: number
    sourceType: number
    sourceId: number
    systemName: number
    title: number
    description: number
    severity: number
    severityScore: number
    departmentId: number
    teamId: number
    metricsJson: number
    baselineJson: number
    impactJson: number
    tagsJson: number
    entitiesJson: number
    privacyLevel: number
    dedupeKey: number
    embedding: number
    aiProcessed: number
    aiTagsJson: number
    lineageJson: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SignalAvgAggregateInputType = {
    confidence?: true
    severityScore?: true
  }

  export type SignalSumAggregateInputType = {
    confidence?: true
    severityScore?: true
  }

  export type SignalMinAggregateInputType = {
    id?: true
    inputId?: true
    timestamp?: true
    receivedAt?: true
    schemaVersion?: true
    confidence?: true
    sourceType?: true
    sourceId?: true
    systemName?: true
    title?: true
    description?: true
    severity?: true
    severityScore?: true
    departmentId?: true
    teamId?: true
    privacyLevel?: true
    dedupeKey?: true
    embedding?: true
    aiProcessed?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SignalMaxAggregateInputType = {
    id?: true
    inputId?: true
    timestamp?: true
    receivedAt?: true
    schemaVersion?: true
    confidence?: true
    sourceType?: true
    sourceId?: true
    systemName?: true
    title?: true
    description?: true
    severity?: true
    severityScore?: true
    departmentId?: true
    teamId?: true
    privacyLevel?: true
    dedupeKey?: true
    embedding?: true
    aiProcessed?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SignalCountAggregateInputType = {
    id?: true
    inputId?: true
    timestamp?: true
    receivedAt?: true
    schemaVersion?: true
    sourceJson?: true
    confidence?: true
    attachmentsJson?: true
    sourceType?: true
    sourceId?: true
    systemName?: true
    title?: true
    description?: true
    severity?: true
    severityScore?: true
    departmentId?: true
    teamId?: true
    metricsJson?: true
    baselineJson?: true
    impactJson?: true
    tagsJson?: true
    entitiesJson?: true
    privacyLevel?: true
    dedupeKey?: true
    embedding?: true
    aiProcessed?: true
    aiTagsJson?: true
    lineageJson?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SignalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Signal to aggregate.
     */
    where?: SignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signals to fetch.
     */
    orderBy?: SignalOrderByWithRelationInput | SignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Signals
    **/
    _count?: true | SignalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SignalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SignalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SignalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SignalMaxAggregateInputType
  }

  export type GetSignalAggregateType<T extends SignalAggregateArgs> = {
        [P in keyof T & keyof AggregateSignal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSignal[P]>
      : GetScalarType<T[P], AggregateSignal[P]>
  }




  export type SignalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignalWhereInput
    orderBy?: SignalOrderByWithAggregationInput | SignalOrderByWithAggregationInput[]
    by: SignalScalarFieldEnum[] | SignalScalarFieldEnum
    having?: SignalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SignalCountAggregateInputType | true
    _avg?: SignalAvgAggregateInputType
    _sum?: SignalSumAggregateInputType
    _min?: SignalMinAggregateInputType
    _max?: SignalMaxAggregateInputType
  }

  export type SignalGroupByOutputType = {
    id: string
    inputId: string
    timestamp: Date
    receivedAt: Date
    schemaVersion: string
    sourceJson: JsonValue | null
    confidence: number | null
    attachmentsJson: JsonValue | null
    sourceType: string
    sourceId: string | null
    systemName: string | null
    title: string | null
    description: string
    severity: $Enums.Severity
    severityScore: number
    departmentId: string | null
    teamId: string | null
    metricsJson: JsonValue | null
    baselineJson: JsonValue | null
    impactJson: JsonValue | null
    tagsJson: JsonValue | null
    entitiesJson: JsonValue | null
    privacyLevel: string | null
    dedupeKey: string | null
    embedding: Uint8Array | null
    aiProcessed: boolean
    aiTagsJson: JsonValue | null
    lineageJson: JsonValue | null
    createdById: string | null
    createdAt: Date
    updatedAt: Date
    _count: SignalCountAggregateOutputType | null
    _avg: SignalAvgAggregateOutputType | null
    _sum: SignalSumAggregateOutputType | null
    _min: SignalMinAggregateOutputType | null
    _max: SignalMaxAggregateOutputType | null
  }

  type GetSignalGroupByPayload<T extends SignalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SignalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SignalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SignalGroupByOutputType[P]>
            : GetScalarType<T[P], SignalGroupByOutputType[P]>
        }
      >
    >


  export type SignalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inputId?: boolean
    timestamp?: boolean
    receivedAt?: boolean
    schemaVersion?: boolean
    sourceJson?: boolean
    confidence?: boolean
    attachmentsJson?: boolean
    sourceType?: boolean
    sourceId?: boolean
    systemName?: boolean
    title?: boolean
    description?: boolean
    severity?: boolean
    severityScore?: boolean
    departmentId?: boolean
    teamId?: boolean
    metricsJson?: boolean
    baselineJson?: boolean
    impactJson?: boolean
    tagsJson?: boolean
    entitiesJson?: boolean
    privacyLevel?: boolean
    dedupeKey?: boolean
    embedding?: boolean
    aiProcessed?: boolean
    aiTagsJson?: boolean
    lineageJson?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | Signal$departmentArgs<ExtArgs>
    team?: boolean | Signal$teamArgs<ExtArgs>
    createdBy?: boolean | Signal$createdByArgs<ExtArgs>
    hotspots?: boolean | Signal$hotspotsArgs<ExtArgs>
    _count?: boolean | SignalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["signal"]>

  export type SignalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inputId?: boolean
    timestamp?: boolean
    receivedAt?: boolean
    schemaVersion?: boolean
    sourceJson?: boolean
    confidence?: boolean
    attachmentsJson?: boolean
    sourceType?: boolean
    sourceId?: boolean
    systemName?: boolean
    title?: boolean
    description?: boolean
    severity?: boolean
    severityScore?: boolean
    departmentId?: boolean
    teamId?: boolean
    metricsJson?: boolean
    baselineJson?: boolean
    impactJson?: boolean
    tagsJson?: boolean
    entitiesJson?: boolean
    privacyLevel?: boolean
    dedupeKey?: boolean
    embedding?: boolean
    aiProcessed?: boolean
    aiTagsJson?: boolean
    lineageJson?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | Signal$departmentArgs<ExtArgs>
    team?: boolean | Signal$teamArgs<ExtArgs>
    createdBy?: boolean | Signal$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["signal"]>

  export type SignalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inputId?: boolean
    timestamp?: boolean
    receivedAt?: boolean
    schemaVersion?: boolean
    sourceJson?: boolean
    confidence?: boolean
    attachmentsJson?: boolean
    sourceType?: boolean
    sourceId?: boolean
    systemName?: boolean
    title?: boolean
    description?: boolean
    severity?: boolean
    severityScore?: boolean
    departmentId?: boolean
    teamId?: boolean
    metricsJson?: boolean
    baselineJson?: boolean
    impactJson?: boolean
    tagsJson?: boolean
    entitiesJson?: boolean
    privacyLevel?: boolean
    dedupeKey?: boolean
    embedding?: boolean
    aiProcessed?: boolean
    aiTagsJson?: boolean
    lineageJson?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | Signal$departmentArgs<ExtArgs>
    team?: boolean | Signal$teamArgs<ExtArgs>
    createdBy?: boolean | Signal$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["signal"]>

  export type SignalSelectScalar = {
    id?: boolean
    inputId?: boolean
    timestamp?: boolean
    receivedAt?: boolean
    schemaVersion?: boolean
    sourceJson?: boolean
    confidence?: boolean
    attachmentsJson?: boolean
    sourceType?: boolean
    sourceId?: boolean
    systemName?: boolean
    title?: boolean
    description?: boolean
    severity?: boolean
    severityScore?: boolean
    departmentId?: boolean
    teamId?: boolean
    metricsJson?: boolean
    baselineJson?: boolean
    impactJson?: boolean
    tagsJson?: boolean
    entitiesJson?: boolean
    privacyLevel?: boolean
    dedupeKey?: boolean
    embedding?: boolean
    aiProcessed?: boolean
    aiTagsJson?: boolean
    lineageJson?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SignalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inputId" | "timestamp" | "receivedAt" | "schemaVersion" | "sourceJson" | "confidence" | "attachmentsJson" | "sourceType" | "sourceId" | "systemName" | "title" | "description" | "severity" | "severityScore" | "departmentId" | "teamId" | "metricsJson" | "baselineJson" | "impactJson" | "tagsJson" | "entitiesJson" | "privacyLevel" | "dedupeKey" | "embedding" | "aiProcessed" | "aiTagsJson" | "lineageJson" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["signal"]>
  export type SignalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Signal$departmentArgs<ExtArgs>
    team?: boolean | Signal$teamArgs<ExtArgs>
    createdBy?: boolean | Signal$createdByArgs<ExtArgs>
    hotspots?: boolean | Signal$hotspotsArgs<ExtArgs>
    _count?: boolean | SignalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SignalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Signal$departmentArgs<ExtArgs>
    team?: boolean | Signal$teamArgs<ExtArgs>
    createdBy?: boolean | Signal$createdByArgs<ExtArgs>
  }
  export type SignalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Signal$departmentArgs<ExtArgs>
    team?: boolean | Signal$teamArgs<ExtArgs>
    createdBy?: boolean | Signal$createdByArgs<ExtArgs>
  }

  export type $SignalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Signal"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      team: Prisma.$TeamPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      hotspots: Prisma.$HotspotSignalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inputId: string
      timestamp: Date
      receivedAt: Date
      schemaVersion: string
      sourceJson: Prisma.JsonValue | null
      confidence: number | null
      attachmentsJson: Prisma.JsonValue | null
      sourceType: string
      sourceId: string | null
      systemName: string | null
      title: string | null
      description: string
      severity: $Enums.Severity
      severityScore: number
      departmentId: string | null
      teamId: string | null
      metricsJson: Prisma.JsonValue | null
      baselineJson: Prisma.JsonValue | null
      impactJson: Prisma.JsonValue | null
      tagsJson: Prisma.JsonValue | null
      entitiesJson: Prisma.JsonValue | null
      privacyLevel: string | null
      dedupeKey: string | null
      embedding: Uint8Array | null
      aiProcessed: boolean
      aiTagsJson: Prisma.JsonValue | null
      lineageJson: Prisma.JsonValue | null
      createdById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["signal"]>
    composites: {}
  }

  type SignalGetPayload<S extends boolean | null | undefined | SignalDefaultArgs> = $Result.GetResult<Prisma.$SignalPayload, S>

  type SignalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SignalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SignalCountAggregateInputType | true
    }

  export interface SignalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Signal'], meta: { name: 'Signal' } }
    /**
     * Find zero or one Signal that matches the filter.
     * @param {SignalFindUniqueArgs} args - Arguments to find a Signal
     * @example
     * // Get one Signal
     * const signal = await prisma.signal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SignalFindUniqueArgs>(args: SelectSubset<T, SignalFindUniqueArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Signal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SignalFindUniqueOrThrowArgs} args - Arguments to find a Signal
     * @example
     * // Get one Signal
     * const signal = await prisma.signal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SignalFindUniqueOrThrowArgs>(args: SelectSubset<T, SignalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Signal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalFindFirstArgs} args - Arguments to find a Signal
     * @example
     * // Get one Signal
     * const signal = await prisma.signal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SignalFindFirstArgs>(args?: SelectSubset<T, SignalFindFirstArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Signal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalFindFirstOrThrowArgs} args - Arguments to find a Signal
     * @example
     * // Get one Signal
     * const signal = await prisma.signal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SignalFindFirstOrThrowArgs>(args?: SelectSubset<T, SignalFindFirstOrThrowArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Signals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Signals
     * const signals = await prisma.signal.findMany()
     * 
     * // Get first 10 Signals
     * const signals = await prisma.signal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const signalWithIdOnly = await prisma.signal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SignalFindManyArgs>(args?: SelectSubset<T, SignalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Signal.
     * @param {SignalCreateArgs} args - Arguments to create a Signal.
     * @example
     * // Create one Signal
     * const Signal = await prisma.signal.create({
     *   data: {
     *     // ... data to create a Signal
     *   }
     * })
     * 
     */
    create<T extends SignalCreateArgs>(args: SelectSubset<T, SignalCreateArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Signals.
     * @param {SignalCreateManyArgs} args - Arguments to create many Signals.
     * @example
     * // Create many Signals
     * const signal = await prisma.signal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SignalCreateManyArgs>(args?: SelectSubset<T, SignalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Signals and returns the data saved in the database.
     * @param {SignalCreateManyAndReturnArgs} args - Arguments to create many Signals.
     * @example
     * // Create many Signals
     * const signal = await prisma.signal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Signals and only return the `id`
     * const signalWithIdOnly = await prisma.signal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SignalCreateManyAndReturnArgs>(args?: SelectSubset<T, SignalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Signal.
     * @param {SignalDeleteArgs} args - Arguments to delete one Signal.
     * @example
     * // Delete one Signal
     * const Signal = await prisma.signal.delete({
     *   where: {
     *     // ... filter to delete one Signal
     *   }
     * })
     * 
     */
    delete<T extends SignalDeleteArgs>(args: SelectSubset<T, SignalDeleteArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Signal.
     * @param {SignalUpdateArgs} args - Arguments to update one Signal.
     * @example
     * // Update one Signal
     * const signal = await prisma.signal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SignalUpdateArgs>(args: SelectSubset<T, SignalUpdateArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Signals.
     * @param {SignalDeleteManyArgs} args - Arguments to filter Signals to delete.
     * @example
     * // Delete a few Signals
     * const { count } = await prisma.signal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SignalDeleteManyArgs>(args?: SelectSubset<T, SignalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Signals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Signals
     * const signal = await prisma.signal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SignalUpdateManyArgs>(args: SelectSubset<T, SignalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Signals and returns the data updated in the database.
     * @param {SignalUpdateManyAndReturnArgs} args - Arguments to update many Signals.
     * @example
     * // Update many Signals
     * const signal = await prisma.signal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Signals and only return the `id`
     * const signalWithIdOnly = await prisma.signal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SignalUpdateManyAndReturnArgs>(args: SelectSubset<T, SignalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Signal.
     * @param {SignalUpsertArgs} args - Arguments to update or create a Signal.
     * @example
     * // Update or create a Signal
     * const signal = await prisma.signal.upsert({
     *   create: {
     *     // ... data to create a Signal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Signal we want to update
     *   }
     * })
     */
    upsert<T extends SignalUpsertArgs>(args: SelectSubset<T, SignalUpsertArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Signals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalCountArgs} args - Arguments to filter Signals to count.
     * @example
     * // Count the number of Signals
     * const count = await prisma.signal.count({
     *   where: {
     *     // ... the filter for the Signals we want to count
     *   }
     * })
    **/
    count<T extends SignalCountArgs>(
      args?: Subset<T, SignalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SignalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Signal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SignalAggregateArgs>(args: Subset<T, SignalAggregateArgs>): Prisma.PrismaPromise<GetSignalAggregateType<T>>

    /**
     * Group by Signal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SignalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SignalGroupByArgs['orderBy'] }
        : { orderBy?: SignalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SignalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSignalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Signal model
   */
  readonly fields: SignalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Signal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SignalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends Signal$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Signal$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    team<T extends Signal$teamArgs<ExtArgs> = {}>(args?: Subset<T, Signal$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Signal$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Signal$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    hotspots<T extends Signal$hotspotsArgs<ExtArgs> = {}>(args?: Subset<T, Signal$hotspotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotspotSignalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Signal model
   */
  interface SignalFieldRefs {
    readonly id: FieldRef<"Signal", 'String'>
    readonly inputId: FieldRef<"Signal", 'String'>
    readonly timestamp: FieldRef<"Signal", 'DateTime'>
    readonly receivedAt: FieldRef<"Signal", 'DateTime'>
    readonly schemaVersion: FieldRef<"Signal", 'String'>
    readonly sourceJson: FieldRef<"Signal", 'Json'>
    readonly confidence: FieldRef<"Signal", 'Float'>
    readonly attachmentsJson: FieldRef<"Signal", 'Json'>
    readonly sourceType: FieldRef<"Signal", 'String'>
    readonly sourceId: FieldRef<"Signal", 'String'>
    readonly systemName: FieldRef<"Signal", 'String'>
    readonly title: FieldRef<"Signal", 'String'>
    readonly description: FieldRef<"Signal", 'String'>
    readonly severity: FieldRef<"Signal", 'Severity'>
    readonly severityScore: FieldRef<"Signal", 'Int'>
    readonly departmentId: FieldRef<"Signal", 'String'>
    readonly teamId: FieldRef<"Signal", 'String'>
    readonly metricsJson: FieldRef<"Signal", 'Json'>
    readonly baselineJson: FieldRef<"Signal", 'Json'>
    readonly impactJson: FieldRef<"Signal", 'Json'>
    readonly tagsJson: FieldRef<"Signal", 'Json'>
    readonly entitiesJson: FieldRef<"Signal", 'Json'>
    readonly privacyLevel: FieldRef<"Signal", 'String'>
    readonly dedupeKey: FieldRef<"Signal", 'String'>
    readonly embedding: FieldRef<"Signal", 'Bytes'>
    readonly aiProcessed: FieldRef<"Signal", 'Boolean'>
    readonly aiTagsJson: FieldRef<"Signal", 'Json'>
    readonly lineageJson: FieldRef<"Signal", 'Json'>
    readonly createdById: FieldRef<"Signal", 'String'>
    readonly createdAt: FieldRef<"Signal", 'DateTime'>
    readonly updatedAt: FieldRef<"Signal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Signal findUnique
   */
  export type SignalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * Filter, which Signal to fetch.
     */
    where: SignalWhereUniqueInput
  }

  /**
   * Signal findUniqueOrThrow
   */
  export type SignalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * Filter, which Signal to fetch.
     */
    where: SignalWhereUniqueInput
  }

  /**
   * Signal findFirst
   */
  export type SignalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * Filter, which Signal to fetch.
     */
    where?: SignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signals to fetch.
     */
    orderBy?: SignalOrderByWithRelationInput | SignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Signals.
     */
    cursor?: SignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Signals.
     */
    distinct?: SignalScalarFieldEnum | SignalScalarFieldEnum[]
  }

  /**
   * Signal findFirstOrThrow
   */
  export type SignalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * Filter, which Signal to fetch.
     */
    where?: SignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signals to fetch.
     */
    orderBy?: SignalOrderByWithRelationInput | SignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Signals.
     */
    cursor?: SignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Signals.
     */
    distinct?: SignalScalarFieldEnum | SignalScalarFieldEnum[]
  }

  /**
   * Signal findMany
   */
  export type SignalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * Filter, which Signals to fetch.
     */
    where?: SignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signals to fetch.
     */
    orderBy?: SignalOrderByWithRelationInput | SignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Signals.
     */
    cursor?: SignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signals.
     */
    skip?: number
    distinct?: SignalScalarFieldEnum | SignalScalarFieldEnum[]
  }

  /**
   * Signal create
   */
  export type SignalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * The data needed to create a Signal.
     */
    data: XOR<SignalCreateInput, SignalUncheckedCreateInput>
  }

  /**
   * Signal createMany
   */
  export type SignalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Signals.
     */
    data: SignalCreateManyInput | SignalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Signal createManyAndReturn
   */
  export type SignalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * The data used to create many Signals.
     */
    data: SignalCreateManyInput | SignalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Signal update
   */
  export type SignalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * The data needed to update a Signal.
     */
    data: XOR<SignalUpdateInput, SignalUncheckedUpdateInput>
    /**
     * Choose, which Signal to update.
     */
    where: SignalWhereUniqueInput
  }

  /**
   * Signal updateMany
   */
  export type SignalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Signals.
     */
    data: XOR<SignalUpdateManyMutationInput, SignalUncheckedUpdateManyInput>
    /**
     * Filter which Signals to update
     */
    where?: SignalWhereInput
    /**
     * Limit how many Signals to update.
     */
    limit?: number
  }

  /**
   * Signal updateManyAndReturn
   */
  export type SignalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * The data used to update Signals.
     */
    data: XOR<SignalUpdateManyMutationInput, SignalUncheckedUpdateManyInput>
    /**
     * Filter which Signals to update
     */
    where?: SignalWhereInput
    /**
     * Limit how many Signals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Signal upsert
   */
  export type SignalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * The filter to search for the Signal to update in case it exists.
     */
    where: SignalWhereUniqueInput
    /**
     * In case the Signal found by the `where` argument doesn't exist, create a new Signal with this data.
     */
    create: XOR<SignalCreateInput, SignalUncheckedCreateInput>
    /**
     * In case the Signal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SignalUpdateInput, SignalUncheckedUpdateInput>
  }

  /**
   * Signal delete
   */
  export type SignalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * Filter which Signal to delete.
     */
    where: SignalWhereUniqueInput
  }

  /**
   * Signal deleteMany
   */
  export type SignalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Signals to delete
     */
    where?: SignalWhereInput
    /**
     * Limit how many Signals to delete.
     */
    limit?: number
  }

  /**
   * Signal.department
   */
  export type Signal$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Signal.team
   */
  export type Signal$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * Signal.createdBy
   */
  export type Signal$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Signal.hotspots
   */
  export type Signal$hotspotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotspotSignal
     */
    select?: HotspotSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotspotSignal
     */
    omit?: HotspotSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotSignalInclude<ExtArgs> | null
    where?: HotspotSignalWhereInput
    orderBy?: HotspotSignalOrderByWithRelationInput | HotspotSignalOrderByWithRelationInput[]
    cursor?: HotspotSignalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotspotSignalScalarFieldEnum | HotspotSignalScalarFieldEnum[]
  }

  /**
   * Signal without action
   */
  export type SignalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
  }


  /**
   * Model Hotspot
   */

  export type AggregateHotspot = {
    _count: HotspotCountAggregateOutputType | null
    _avg: HotspotAvgAggregateOutputType | null
    _sum: HotspotSumAggregateOutputType | null
    _min: HotspotMinAggregateOutputType | null
    _max: HotspotMaxAggregateOutputType | null
  }

  export type HotspotAvgAggregateOutputType = {
    rankScore: number | null
    confidence: number | null
    similarityThreshold: number | null
  }

  export type HotspotSumAggregateOutputType = {
    rankScore: number | null
    confidence: number | null
    similarityThreshold: number | null
  }

  export type HotspotMinAggregateOutputType = {
    id: string | null
    title: string | null
    summary: string | null
    status: $Enums.HotspotStatus | null
    rankScore: number | null
    confidence: number | null
    primaryCategoryId: string | null
    clusteringMethod: string | null
    similarityThreshold: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotspotMaxAggregateOutputType = {
    id: string | null
    title: string | null
    summary: string | null
    status: $Enums.HotspotStatus | null
    rankScore: number | null
    confidence: number | null
    primaryCategoryId: string | null
    clusteringMethod: string | null
    similarityThreshold: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotspotCountAggregateOutputType = {
    id: number
    title: number
    summary: number
    status: number
    rankScore: number
    confidence: number
    primaryCategoryId: number
    linkedEntitiesJson: number
    clusteringMethod: number
    similarityThreshold: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HotspotAvgAggregateInputType = {
    rankScore?: true
    confidence?: true
    similarityThreshold?: true
  }

  export type HotspotSumAggregateInputType = {
    rankScore?: true
    confidence?: true
    similarityThreshold?: true
  }

  export type HotspotMinAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    status?: true
    rankScore?: true
    confidence?: true
    primaryCategoryId?: true
    clusteringMethod?: true
    similarityThreshold?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotspotMaxAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    status?: true
    rankScore?: true
    confidence?: true
    primaryCategoryId?: true
    clusteringMethod?: true
    similarityThreshold?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotspotCountAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    status?: true
    rankScore?: true
    confidence?: true
    primaryCategoryId?: true
    linkedEntitiesJson?: true
    clusteringMethod?: true
    similarityThreshold?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HotspotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hotspot to aggregate.
     */
    where?: HotspotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotspots to fetch.
     */
    orderBy?: HotspotOrderByWithRelationInput | HotspotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotspotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotspots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotspots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hotspots
    **/
    _count?: true | HotspotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotspotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotspotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotspotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotspotMaxAggregateInputType
  }

  export type GetHotspotAggregateType<T extends HotspotAggregateArgs> = {
        [P in keyof T & keyof AggregateHotspot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotspot[P]>
      : GetScalarType<T[P], AggregateHotspot[P]>
  }




  export type HotspotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotspotWhereInput
    orderBy?: HotspotOrderByWithAggregationInput | HotspotOrderByWithAggregationInput[]
    by: HotspotScalarFieldEnum[] | HotspotScalarFieldEnum
    having?: HotspotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotspotCountAggregateInputType | true
    _avg?: HotspotAvgAggregateInputType
    _sum?: HotspotSumAggregateInputType
    _min?: HotspotMinAggregateInputType
    _max?: HotspotMaxAggregateInputType
  }

  export type HotspotGroupByOutputType = {
    id: string
    title: string
    summary: string
    status: $Enums.HotspotStatus
    rankScore: number
    confidence: number
    primaryCategoryId: string | null
    linkedEntitiesJson: JsonValue | null
    clusteringMethod: string | null
    similarityThreshold: number | null
    createdAt: Date
    updatedAt: Date
    _count: HotspotCountAggregateOutputType | null
    _avg: HotspotAvgAggregateOutputType | null
    _sum: HotspotSumAggregateOutputType | null
    _min: HotspotMinAggregateOutputType | null
    _max: HotspotMaxAggregateOutputType | null
  }

  type GetHotspotGroupByPayload<T extends HotspotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotspotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotspotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotspotGroupByOutputType[P]>
            : GetScalarType<T[P], HotspotGroupByOutputType[P]>
        }
      >
    >


  export type HotspotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    summary?: boolean
    status?: boolean
    rankScore?: boolean
    confidence?: boolean
    primaryCategoryId?: boolean
    linkedEntitiesJson?: boolean
    clusteringMethod?: boolean
    similarityThreshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    signals?: boolean | Hotspot$signalsArgs<ExtArgs>
    ideas?: boolean | Hotspot$ideasArgs<ExtArgs>
    solutions?: boolean | Hotspot$solutionsArgs<ExtArgs>
    _count?: boolean | HotspotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotspot"]>

  export type HotspotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    summary?: boolean
    status?: boolean
    rankScore?: boolean
    confidence?: boolean
    primaryCategoryId?: boolean
    linkedEntitiesJson?: boolean
    clusteringMethod?: boolean
    similarityThreshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hotspot"]>

  export type HotspotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    summary?: boolean
    status?: boolean
    rankScore?: boolean
    confidence?: boolean
    primaryCategoryId?: boolean
    linkedEntitiesJson?: boolean
    clusteringMethod?: boolean
    similarityThreshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hotspot"]>

  export type HotspotSelectScalar = {
    id?: boolean
    title?: boolean
    summary?: boolean
    status?: boolean
    rankScore?: boolean
    confidence?: boolean
    primaryCategoryId?: boolean
    linkedEntitiesJson?: boolean
    clusteringMethod?: boolean
    similarityThreshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HotspotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "summary" | "status" | "rankScore" | "confidence" | "primaryCategoryId" | "linkedEntitiesJson" | "clusteringMethod" | "similarityThreshold" | "createdAt" | "updatedAt", ExtArgs["result"]["hotspot"]>
  export type HotspotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    signals?: boolean | Hotspot$signalsArgs<ExtArgs>
    ideas?: boolean | Hotspot$ideasArgs<ExtArgs>
    solutions?: boolean | Hotspot$solutionsArgs<ExtArgs>
    _count?: boolean | HotspotCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotspotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type HotspotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HotspotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hotspot"
    objects: {
      signals: Prisma.$HotspotSignalPayload<ExtArgs>[]
      ideas: Prisma.$IdeaPayload<ExtArgs>[]
      solutions: Prisma.$SolutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      summary: string
      status: $Enums.HotspotStatus
      rankScore: number
      confidence: number
      primaryCategoryId: string | null
      linkedEntitiesJson: Prisma.JsonValue | null
      clusteringMethod: string | null
      similarityThreshold: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hotspot"]>
    composites: {}
  }

  type HotspotGetPayload<S extends boolean | null | undefined | HotspotDefaultArgs> = $Result.GetResult<Prisma.$HotspotPayload, S>

  type HotspotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotspotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotspotCountAggregateInputType | true
    }

  export interface HotspotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hotspot'], meta: { name: 'Hotspot' } }
    /**
     * Find zero or one Hotspot that matches the filter.
     * @param {HotspotFindUniqueArgs} args - Arguments to find a Hotspot
     * @example
     * // Get one Hotspot
     * const hotspot = await prisma.hotspot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotspotFindUniqueArgs>(args: SelectSubset<T, HotspotFindUniqueArgs<ExtArgs>>): Prisma__HotspotClient<$Result.GetResult<Prisma.$HotspotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hotspot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotspotFindUniqueOrThrowArgs} args - Arguments to find a Hotspot
     * @example
     * // Get one Hotspot
     * const hotspot = await prisma.hotspot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotspotFindUniqueOrThrowArgs>(args: SelectSubset<T, HotspotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotspotClient<$Result.GetResult<Prisma.$HotspotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hotspot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotspotFindFirstArgs} args - Arguments to find a Hotspot
     * @example
     * // Get one Hotspot
     * const hotspot = await prisma.hotspot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotspotFindFirstArgs>(args?: SelectSubset<T, HotspotFindFirstArgs<ExtArgs>>): Prisma__HotspotClient<$Result.GetResult<Prisma.$HotspotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hotspot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotspotFindFirstOrThrowArgs} args - Arguments to find a Hotspot
     * @example
     * // Get one Hotspot
     * const hotspot = await prisma.hotspot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotspotFindFirstOrThrowArgs>(args?: SelectSubset<T, HotspotFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotspotClient<$Result.GetResult<Prisma.$HotspotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hotspots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotspotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hotspots
     * const hotspots = await prisma.hotspot.findMany()
     * 
     * // Get first 10 Hotspots
     * const hotspots = await prisma.hotspot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotspotWithIdOnly = await prisma.hotspot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotspotFindManyArgs>(args?: SelectSubset<T, HotspotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotspotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hotspot.
     * @param {HotspotCreateArgs} args - Arguments to create a Hotspot.
     * @example
     * // Create one Hotspot
     * const Hotspot = await prisma.hotspot.create({
     *   data: {
     *     // ... data to create a Hotspot
     *   }
     * })
     * 
     */
    create<T extends HotspotCreateArgs>(args: SelectSubset<T, HotspotCreateArgs<ExtArgs>>): Prisma__HotspotClient<$Result.GetResult<Prisma.$HotspotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hotspots.
     * @param {HotspotCreateManyArgs} args - Arguments to create many Hotspots.
     * @example
     * // Create many Hotspots
     * const hotspot = await prisma.hotspot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotspotCreateManyArgs>(args?: SelectSubset<T, HotspotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hotspots and returns the data saved in the database.
     * @param {HotspotCreateManyAndReturnArgs} args - Arguments to create many Hotspots.
     * @example
     * // Create many Hotspots
     * const hotspot = await prisma.hotspot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hotspots and only return the `id`
     * const hotspotWithIdOnly = await prisma.hotspot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotspotCreateManyAndReturnArgs>(args?: SelectSubset<T, HotspotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotspotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Hotspot.
     * @param {HotspotDeleteArgs} args - Arguments to delete one Hotspot.
     * @example
     * // Delete one Hotspot
     * const Hotspot = await prisma.hotspot.delete({
     *   where: {
     *     // ... filter to delete one Hotspot
     *   }
     * })
     * 
     */
    delete<T extends HotspotDeleteArgs>(args: SelectSubset<T, HotspotDeleteArgs<ExtArgs>>): Prisma__HotspotClient<$Result.GetResult<Prisma.$HotspotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hotspot.
     * @param {HotspotUpdateArgs} args - Arguments to update one Hotspot.
     * @example
     * // Update one Hotspot
     * const hotspot = await prisma.hotspot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotspotUpdateArgs>(args: SelectSubset<T, HotspotUpdateArgs<ExtArgs>>): Prisma__HotspotClient<$Result.GetResult<Prisma.$HotspotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hotspots.
     * @param {HotspotDeleteManyArgs} args - Arguments to filter Hotspots to delete.
     * @example
     * // Delete a few Hotspots
     * const { count } = await prisma.hotspot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotspotDeleteManyArgs>(args?: SelectSubset<T, HotspotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hotspots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotspotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hotspots
     * const hotspot = await prisma.hotspot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotspotUpdateManyArgs>(args: SelectSubset<T, HotspotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hotspots and returns the data updated in the database.
     * @param {HotspotUpdateManyAndReturnArgs} args - Arguments to update many Hotspots.
     * @example
     * // Update many Hotspots
     * const hotspot = await prisma.hotspot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Hotspots and only return the `id`
     * const hotspotWithIdOnly = await prisma.hotspot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HotspotUpdateManyAndReturnArgs>(args: SelectSubset<T, HotspotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotspotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Hotspot.
     * @param {HotspotUpsertArgs} args - Arguments to update or create a Hotspot.
     * @example
     * // Update or create a Hotspot
     * const hotspot = await prisma.hotspot.upsert({
     *   create: {
     *     // ... data to create a Hotspot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hotspot we want to update
     *   }
     * })
     */
    upsert<T extends HotspotUpsertArgs>(args: SelectSubset<T, HotspotUpsertArgs<ExtArgs>>): Prisma__HotspotClient<$Result.GetResult<Prisma.$HotspotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hotspots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotspotCountArgs} args - Arguments to filter Hotspots to count.
     * @example
     * // Count the number of Hotspots
     * const count = await prisma.hotspot.count({
     *   where: {
     *     // ... the filter for the Hotspots we want to count
     *   }
     * })
    **/
    count<T extends HotspotCountArgs>(
      args?: Subset<T, HotspotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotspotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hotspot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotspotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotspotAggregateArgs>(args: Subset<T, HotspotAggregateArgs>): Prisma.PrismaPromise<GetHotspotAggregateType<T>>

    /**
     * Group by Hotspot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotspotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotspotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotspotGroupByArgs['orderBy'] }
        : { orderBy?: HotspotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotspotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotspotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hotspot model
   */
  readonly fields: HotspotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hotspot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotspotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    signals<T extends Hotspot$signalsArgs<ExtArgs> = {}>(args?: Subset<T, Hotspot$signalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotspotSignalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ideas<T extends Hotspot$ideasArgs<ExtArgs> = {}>(args?: Subset<T, Hotspot$ideasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    solutions<T extends Hotspot$solutionsArgs<ExtArgs> = {}>(args?: Subset<T, Hotspot$solutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SolutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hotspot model
   */
  interface HotspotFieldRefs {
    readonly id: FieldRef<"Hotspot", 'String'>
    readonly title: FieldRef<"Hotspot", 'String'>
    readonly summary: FieldRef<"Hotspot", 'String'>
    readonly status: FieldRef<"Hotspot", 'HotspotStatus'>
    readonly rankScore: FieldRef<"Hotspot", 'Float'>
    readonly confidence: FieldRef<"Hotspot", 'Float'>
    readonly primaryCategoryId: FieldRef<"Hotspot", 'String'>
    readonly linkedEntitiesJson: FieldRef<"Hotspot", 'Json'>
    readonly clusteringMethod: FieldRef<"Hotspot", 'String'>
    readonly similarityThreshold: FieldRef<"Hotspot", 'Float'>
    readonly createdAt: FieldRef<"Hotspot", 'DateTime'>
    readonly updatedAt: FieldRef<"Hotspot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Hotspot findUnique
   */
  export type HotspotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotspot
     */
    select?: HotspotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotspot
     */
    omit?: HotspotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotInclude<ExtArgs> | null
    /**
     * Filter, which Hotspot to fetch.
     */
    where: HotspotWhereUniqueInput
  }

  /**
   * Hotspot findUniqueOrThrow
   */
  export type HotspotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotspot
     */
    select?: HotspotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotspot
     */
    omit?: HotspotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotInclude<ExtArgs> | null
    /**
     * Filter, which Hotspot to fetch.
     */
    where: HotspotWhereUniqueInput
  }

  /**
   * Hotspot findFirst
   */
  export type HotspotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotspot
     */
    select?: HotspotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotspot
     */
    omit?: HotspotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotInclude<ExtArgs> | null
    /**
     * Filter, which Hotspot to fetch.
     */
    where?: HotspotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotspots to fetch.
     */
    orderBy?: HotspotOrderByWithRelationInput | HotspotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hotspots.
     */
    cursor?: HotspotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotspots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotspots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hotspots.
     */
    distinct?: HotspotScalarFieldEnum | HotspotScalarFieldEnum[]
  }

  /**
   * Hotspot findFirstOrThrow
   */
  export type HotspotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotspot
     */
    select?: HotspotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotspot
     */
    omit?: HotspotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotInclude<ExtArgs> | null
    /**
     * Filter, which Hotspot to fetch.
     */
    where?: HotspotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotspots to fetch.
     */
    orderBy?: HotspotOrderByWithRelationInput | HotspotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hotspots.
     */
    cursor?: HotspotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotspots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotspots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hotspots.
     */
    distinct?: HotspotScalarFieldEnum | HotspotScalarFieldEnum[]
  }

  /**
   * Hotspot findMany
   */
  export type HotspotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotspot
     */
    select?: HotspotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotspot
     */
    omit?: HotspotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotInclude<ExtArgs> | null
    /**
     * Filter, which Hotspots to fetch.
     */
    where?: HotspotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotspots to fetch.
     */
    orderBy?: HotspotOrderByWithRelationInput | HotspotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hotspots.
     */
    cursor?: HotspotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotspots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotspots.
     */
    skip?: number
    distinct?: HotspotScalarFieldEnum | HotspotScalarFieldEnum[]
  }

  /**
   * Hotspot create
   */
  export type HotspotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotspot
     */
    select?: HotspotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotspot
     */
    omit?: HotspotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotInclude<ExtArgs> | null
    /**
     * The data needed to create a Hotspot.
     */
    data: XOR<HotspotCreateInput, HotspotUncheckedCreateInput>
  }

  /**
   * Hotspot createMany
   */
  export type HotspotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hotspots.
     */
    data: HotspotCreateManyInput | HotspotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hotspot createManyAndReturn
   */
  export type HotspotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotspot
     */
    select?: HotspotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hotspot
     */
    omit?: HotspotOmit<ExtArgs> | null
    /**
     * The data used to create many Hotspots.
     */
    data: HotspotCreateManyInput | HotspotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hotspot update
   */
  export type HotspotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotspot
     */
    select?: HotspotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotspot
     */
    omit?: HotspotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotInclude<ExtArgs> | null
    /**
     * The data needed to update a Hotspot.
     */
    data: XOR<HotspotUpdateInput, HotspotUncheckedUpdateInput>
    /**
     * Choose, which Hotspot to update.
     */
    where: HotspotWhereUniqueInput
  }

  /**
   * Hotspot updateMany
   */
  export type HotspotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hotspots.
     */
    data: XOR<HotspotUpdateManyMutationInput, HotspotUncheckedUpdateManyInput>
    /**
     * Filter which Hotspots to update
     */
    where?: HotspotWhereInput
    /**
     * Limit how many Hotspots to update.
     */
    limit?: number
  }

  /**
   * Hotspot updateManyAndReturn
   */
  export type HotspotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotspot
     */
    select?: HotspotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hotspot
     */
    omit?: HotspotOmit<ExtArgs> | null
    /**
     * The data used to update Hotspots.
     */
    data: XOR<HotspotUpdateManyMutationInput, HotspotUncheckedUpdateManyInput>
    /**
     * Filter which Hotspots to update
     */
    where?: HotspotWhereInput
    /**
     * Limit how many Hotspots to update.
     */
    limit?: number
  }

  /**
   * Hotspot upsert
   */
  export type HotspotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotspot
     */
    select?: HotspotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotspot
     */
    omit?: HotspotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotInclude<ExtArgs> | null
    /**
     * The filter to search for the Hotspot to update in case it exists.
     */
    where: HotspotWhereUniqueInput
    /**
     * In case the Hotspot found by the `where` argument doesn't exist, create a new Hotspot with this data.
     */
    create: XOR<HotspotCreateInput, HotspotUncheckedCreateInput>
    /**
     * In case the Hotspot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotspotUpdateInput, HotspotUncheckedUpdateInput>
  }

  /**
   * Hotspot delete
   */
  export type HotspotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotspot
     */
    select?: HotspotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotspot
     */
    omit?: HotspotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotInclude<ExtArgs> | null
    /**
     * Filter which Hotspot to delete.
     */
    where: HotspotWhereUniqueInput
  }

  /**
   * Hotspot deleteMany
   */
  export type HotspotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hotspots to delete
     */
    where?: HotspotWhereInput
    /**
     * Limit how many Hotspots to delete.
     */
    limit?: number
  }

  /**
   * Hotspot.signals
   */
  export type Hotspot$signalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotspotSignal
     */
    select?: HotspotSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotspotSignal
     */
    omit?: HotspotSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotSignalInclude<ExtArgs> | null
    where?: HotspotSignalWhereInput
    orderBy?: HotspotSignalOrderByWithRelationInput | HotspotSignalOrderByWithRelationInput[]
    cursor?: HotspotSignalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotspotSignalScalarFieldEnum | HotspotSignalScalarFieldEnum[]
  }

  /**
   * Hotspot.ideas
   */
  export type Hotspot$ideasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
    where?: IdeaWhereInput
    orderBy?: IdeaOrderByWithRelationInput | IdeaOrderByWithRelationInput[]
    cursor?: IdeaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IdeaScalarFieldEnum | IdeaScalarFieldEnum[]
  }

  /**
   * Hotspot.solutions
   */
  export type Hotspot$solutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null
    where?: SolutionWhereInput
    orderBy?: SolutionOrderByWithRelationInput | SolutionOrderByWithRelationInput[]
    cursor?: SolutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SolutionScalarFieldEnum | SolutionScalarFieldEnum[]
  }

  /**
   * Hotspot without action
   */
  export type HotspotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotspot
     */
    select?: HotspotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotspot
     */
    omit?: HotspotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotInclude<ExtArgs> | null
  }


  /**
   * Model HotspotSignal
   */

  export type AggregateHotspotSignal = {
    _count: HotspotSignalCountAggregateOutputType | null
    _avg: HotspotSignalAvgAggregateOutputType | null
    _sum: HotspotSignalSumAggregateOutputType | null
    _min: HotspotSignalMinAggregateOutputType | null
    _max: HotspotSignalMaxAggregateOutputType | null
  }

  export type HotspotSignalAvgAggregateOutputType = {
    membershipStrength: number | null
  }

  export type HotspotSignalSumAggregateOutputType = {
    membershipStrength: number | null
  }

  export type HotspotSignalMinAggregateOutputType = {
    hotspotId: string | null
    signalId: string | null
    membershipStrength: number | null
    isOutlier: boolean | null
    addedAt: Date | null
  }

  export type HotspotSignalMaxAggregateOutputType = {
    hotspotId: string | null
    signalId: string | null
    membershipStrength: number | null
    isOutlier: boolean | null
    addedAt: Date | null
  }

  export type HotspotSignalCountAggregateOutputType = {
    hotspotId: number
    signalId: number
    membershipStrength: number
    isOutlier: number
    addedAt: number
    _all: number
  }


  export type HotspotSignalAvgAggregateInputType = {
    membershipStrength?: true
  }

  export type HotspotSignalSumAggregateInputType = {
    membershipStrength?: true
  }

  export type HotspotSignalMinAggregateInputType = {
    hotspotId?: true
    signalId?: true
    membershipStrength?: true
    isOutlier?: true
    addedAt?: true
  }

  export type HotspotSignalMaxAggregateInputType = {
    hotspotId?: true
    signalId?: true
    membershipStrength?: true
    isOutlier?: true
    addedAt?: true
  }

  export type HotspotSignalCountAggregateInputType = {
    hotspotId?: true
    signalId?: true
    membershipStrength?: true
    isOutlier?: true
    addedAt?: true
    _all?: true
  }

  export type HotspotSignalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotspotSignal to aggregate.
     */
    where?: HotspotSignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotspotSignals to fetch.
     */
    orderBy?: HotspotSignalOrderByWithRelationInput | HotspotSignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotspotSignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotspotSignals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotspotSignals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotspotSignals
    **/
    _count?: true | HotspotSignalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotspotSignalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotspotSignalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotspotSignalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotspotSignalMaxAggregateInputType
  }

  export type GetHotspotSignalAggregateType<T extends HotspotSignalAggregateArgs> = {
        [P in keyof T & keyof AggregateHotspotSignal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotspotSignal[P]>
      : GetScalarType<T[P], AggregateHotspotSignal[P]>
  }




  export type HotspotSignalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotspotSignalWhereInput
    orderBy?: HotspotSignalOrderByWithAggregationInput | HotspotSignalOrderByWithAggregationInput[]
    by: HotspotSignalScalarFieldEnum[] | HotspotSignalScalarFieldEnum
    having?: HotspotSignalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotspotSignalCountAggregateInputType | true
    _avg?: HotspotSignalAvgAggregateInputType
    _sum?: HotspotSignalSumAggregateInputType
    _min?: HotspotSignalMinAggregateInputType
    _max?: HotspotSignalMaxAggregateInputType
  }

  export type HotspotSignalGroupByOutputType = {
    hotspotId: string
    signalId: string
    membershipStrength: number
    isOutlier: boolean
    addedAt: Date
    _count: HotspotSignalCountAggregateOutputType | null
    _avg: HotspotSignalAvgAggregateOutputType | null
    _sum: HotspotSignalSumAggregateOutputType | null
    _min: HotspotSignalMinAggregateOutputType | null
    _max: HotspotSignalMaxAggregateOutputType | null
  }

  type GetHotspotSignalGroupByPayload<T extends HotspotSignalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotspotSignalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotspotSignalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotspotSignalGroupByOutputType[P]>
            : GetScalarType<T[P], HotspotSignalGroupByOutputType[P]>
        }
      >
    >


  export type HotspotSignalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotspotId?: boolean
    signalId?: boolean
    membershipStrength?: boolean
    isOutlier?: boolean
    addedAt?: boolean
    hotspot?: boolean | HotspotDefaultArgs<ExtArgs>
    signal?: boolean | SignalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotspotSignal"]>

  export type HotspotSignalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotspotId?: boolean
    signalId?: boolean
    membershipStrength?: boolean
    isOutlier?: boolean
    addedAt?: boolean
    hotspot?: boolean | HotspotDefaultArgs<ExtArgs>
    signal?: boolean | SignalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotspotSignal"]>

  export type HotspotSignalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotspotId?: boolean
    signalId?: boolean
    membershipStrength?: boolean
    isOutlier?: boolean
    addedAt?: boolean
    hotspot?: boolean | HotspotDefaultArgs<ExtArgs>
    signal?: boolean | SignalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotspotSignal"]>

  export type HotspotSignalSelectScalar = {
    hotspotId?: boolean
    signalId?: boolean
    membershipStrength?: boolean
    isOutlier?: boolean
    addedAt?: boolean
  }

  export type HotspotSignalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"hotspotId" | "signalId" | "membershipStrength" | "isOutlier" | "addedAt", ExtArgs["result"]["hotspotSignal"]>
  export type HotspotSignalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotspot?: boolean | HotspotDefaultArgs<ExtArgs>
    signal?: boolean | SignalDefaultArgs<ExtArgs>
  }
  export type HotspotSignalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotspot?: boolean | HotspotDefaultArgs<ExtArgs>
    signal?: boolean | SignalDefaultArgs<ExtArgs>
  }
  export type HotspotSignalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotspot?: boolean | HotspotDefaultArgs<ExtArgs>
    signal?: boolean | SignalDefaultArgs<ExtArgs>
  }

  export type $HotspotSignalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotspotSignal"
    objects: {
      hotspot: Prisma.$HotspotPayload<ExtArgs>
      signal: Prisma.$SignalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      hotspotId: string
      signalId: string
      membershipStrength: number
      isOutlier: boolean
      addedAt: Date
    }, ExtArgs["result"]["hotspotSignal"]>
    composites: {}
  }

  type HotspotSignalGetPayload<S extends boolean | null | undefined | HotspotSignalDefaultArgs> = $Result.GetResult<Prisma.$HotspotSignalPayload, S>

  type HotspotSignalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotspotSignalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotspotSignalCountAggregateInputType | true
    }

  export interface HotspotSignalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotspotSignal'], meta: { name: 'HotspotSignal' } }
    /**
     * Find zero or one HotspotSignal that matches the filter.
     * @param {HotspotSignalFindUniqueArgs} args - Arguments to find a HotspotSignal
     * @example
     * // Get one HotspotSignal
     * const hotspotSignal = await prisma.hotspotSignal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotspotSignalFindUniqueArgs>(args: SelectSubset<T, HotspotSignalFindUniqueArgs<ExtArgs>>): Prisma__HotspotSignalClient<$Result.GetResult<Prisma.$HotspotSignalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HotspotSignal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotspotSignalFindUniqueOrThrowArgs} args - Arguments to find a HotspotSignal
     * @example
     * // Get one HotspotSignal
     * const hotspotSignal = await prisma.hotspotSignal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotspotSignalFindUniqueOrThrowArgs>(args: SelectSubset<T, HotspotSignalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotspotSignalClient<$Result.GetResult<Prisma.$HotspotSignalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotspotSignal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotspotSignalFindFirstArgs} args - Arguments to find a HotspotSignal
     * @example
     * // Get one HotspotSignal
     * const hotspotSignal = await prisma.hotspotSignal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotspotSignalFindFirstArgs>(args?: SelectSubset<T, HotspotSignalFindFirstArgs<ExtArgs>>): Prisma__HotspotSignalClient<$Result.GetResult<Prisma.$HotspotSignalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotspotSignal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotspotSignalFindFirstOrThrowArgs} args - Arguments to find a HotspotSignal
     * @example
     * // Get one HotspotSignal
     * const hotspotSignal = await prisma.hotspotSignal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotspotSignalFindFirstOrThrowArgs>(args?: SelectSubset<T, HotspotSignalFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotspotSignalClient<$Result.GetResult<Prisma.$HotspotSignalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HotspotSignals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotspotSignalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotspotSignals
     * const hotspotSignals = await prisma.hotspotSignal.findMany()
     * 
     * // Get first 10 HotspotSignals
     * const hotspotSignals = await prisma.hotspotSignal.findMany({ take: 10 })
     * 
     * // Only select the `hotspotId`
     * const hotspotSignalWithHotspotIdOnly = await prisma.hotspotSignal.findMany({ select: { hotspotId: true } })
     * 
     */
    findMany<T extends HotspotSignalFindManyArgs>(args?: SelectSubset<T, HotspotSignalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotspotSignalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HotspotSignal.
     * @param {HotspotSignalCreateArgs} args - Arguments to create a HotspotSignal.
     * @example
     * // Create one HotspotSignal
     * const HotspotSignal = await prisma.hotspotSignal.create({
     *   data: {
     *     // ... data to create a HotspotSignal
     *   }
     * })
     * 
     */
    create<T extends HotspotSignalCreateArgs>(args: SelectSubset<T, HotspotSignalCreateArgs<ExtArgs>>): Prisma__HotspotSignalClient<$Result.GetResult<Prisma.$HotspotSignalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HotspotSignals.
     * @param {HotspotSignalCreateManyArgs} args - Arguments to create many HotspotSignals.
     * @example
     * // Create many HotspotSignals
     * const hotspotSignal = await prisma.hotspotSignal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotspotSignalCreateManyArgs>(args?: SelectSubset<T, HotspotSignalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotspotSignals and returns the data saved in the database.
     * @param {HotspotSignalCreateManyAndReturnArgs} args - Arguments to create many HotspotSignals.
     * @example
     * // Create many HotspotSignals
     * const hotspotSignal = await prisma.hotspotSignal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotspotSignals and only return the `hotspotId`
     * const hotspotSignalWithHotspotIdOnly = await prisma.hotspotSignal.createManyAndReturn({
     *   select: { hotspotId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotspotSignalCreateManyAndReturnArgs>(args?: SelectSubset<T, HotspotSignalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotspotSignalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HotspotSignal.
     * @param {HotspotSignalDeleteArgs} args - Arguments to delete one HotspotSignal.
     * @example
     * // Delete one HotspotSignal
     * const HotspotSignal = await prisma.hotspotSignal.delete({
     *   where: {
     *     // ... filter to delete one HotspotSignal
     *   }
     * })
     * 
     */
    delete<T extends HotspotSignalDeleteArgs>(args: SelectSubset<T, HotspotSignalDeleteArgs<ExtArgs>>): Prisma__HotspotSignalClient<$Result.GetResult<Prisma.$HotspotSignalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HotspotSignal.
     * @param {HotspotSignalUpdateArgs} args - Arguments to update one HotspotSignal.
     * @example
     * // Update one HotspotSignal
     * const hotspotSignal = await prisma.hotspotSignal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotspotSignalUpdateArgs>(args: SelectSubset<T, HotspotSignalUpdateArgs<ExtArgs>>): Prisma__HotspotSignalClient<$Result.GetResult<Prisma.$HotspotSignalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HotspotSignals.
     * @param {HotspotSignalDeleteManyArgs} args - Arguments to filter HotspotSignals to delete.
     * @example
     * // Delete a few HotspotSignals
     * const { count } = await prisma.hotspotSignal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotspotSignalDeleteManyArgs>(args?: SelectSubset<T, HotspotSignalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotspotSignals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotspotSignalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotspotSignals
     * const hotspotSignal = await prisma.hotspotSignal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotspotSignalUpdateManyArgs>(args: SelectSubset<T, HotspotSignalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotspotSignals and returns the data updated in the database.
     * @param {HotspotSignalUpdateManyAndReturnArgs} args - Arguments to update many HotspotSignals.
     * @example
     * // Update many HotspotSignals
     * const hotspotSignal = await prisma.hotspotSignal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HotspotSignals and only return the `hotspotId`
     * const hotspotSignalWithHotspotIdOnly = await prisma.hotspotSignal.updateManyAndReturn({
     *   select: { hotspotId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HotspotSignalUpdateManyAndReturnArgs>(args: SelectSubset<T, HotspotSignalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotspotSignalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HotspotSignal.
     * @param {HotspotSignalUpsertArgs} args - Arguments to update or create a HotspotSignal.
     * @example
     * // Update or create a HotspotSignal
     * const hotspotSignal = await prisma.hotspotSignal.upsert({
     *   create: {
     *     // ... data to create a HotspotSignal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotspotSignal we want to update
     *   }
     * })
     */
    upsert<T extends HotspotSignalUpsertArgs>(args: SelectSubset<T, HotspotSignalUpsertArgs<ExtArgs>>): Prisma__HotspotSignalClient<$Result.GetResult<Prisma.$HotspotSignalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HotspotSignals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotspotSignalCountArgs} args - Arguments to filter HotspotSignals to count.
     * @example
     * // Count the number of HotspotSignals
     * const count = await prisma.hotspotSignal.count({
     *   where: {
     *     // ... the filter for the HotspotSignals we want to count
     *   }
     * })
    **/
    count<T extends HotspotSignalCountArgs>(
      args?: Subset<T, HotspotSignalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotspotSignalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotspotSignal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotspotSignalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotspotSignalAggregateArgs>(args: Subset<T, HotspotSignalAggregateArgs>): Prisma.PrismaPromise<GetHotspotSignalAggregateType<T>>

    /**
     * Group by HotspotSignal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotspotSignalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotspotSignalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotspotSignalGroupByArgs['orderBy'] }
        : { orderBy?: HotspotSignalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotspotSignalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotspotSignalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotspotSignal model
   */
  readonly fields: HotspotSignalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotspotSignal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotspotSignalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotspot<T extends HotspotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotspotDefaultArgs<ExtArgs>>): Prisma__HotspotClient<$Result.GetResult<Prisma.$HotspotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    signal<T extends SignalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SignalDefaultArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotspotSignal model
   */
  interface HotspotSignalFieldRefs {
    readonly hotspotId: FieldRef<"HotspotSignal", 'String'>
    readonly signalId: FieldRef<"HotspotSignal", 'String'>
    readonly membershipStrength: FieldRef<"HotspotSignal", 'Float'>
    readonly isOutlier: FieldRef<"HotspotSignal", 'Boolean'>
    readonly addedAt: FieldRef<"HotspotSignal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HotspotSignal findUnique
   */
  export type HotspotSignalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotspotSignal
     */
    select?: HotspotSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotspotSignal
     */
    omit?: HotspotSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotSignalInclude<ExtArgs> | null
    /**
     * Filter, which HotspotSignal to fetch.
     */
    where: HotspotSignalWhereUniqueInput
  }

  /**
   * HotspotSignal findUniqueOrThrow
   */
  export type HotspotSignalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotspotSignal
     */
    select?: HotspotSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotspotSignal
     */
    omit?: HotspotSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotSignalInclude<ExtArgs> | null
    /**
     * Filter, which HotspotSignal to fetch.
     */
    where: HotspotSignalWhereUniqueInput
  }

  /**
   * HotspotSignal findFirst
   */
  export type HotspotSignalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotspotSignal
     */
    select?: HotspotSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotspotSignal
     */
    omit?: HotspotSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotSignalInclude<ExtArgs> | null
    /**
     * Filter, which HotspotSignal to fetch.
     */
    where?: HotspotSignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotspotSignals to fetch.
     */
    orderBy?: HotspotSignalOrderByWithRelationInput | HotspotSignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotspotSignals.
     */
    cursor?: HotspotSignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotspotSignals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotspotSignals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotspotSignals.
     */
    distinct?: HotspotSignalScalarFieldEnum | HotspotSignalScalarFieldEnum[]
  }

  /**
   * HotspotSignal findFirstOrThrow
   */
  export type HotspotSignalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotspotSignal
     */
    select?: HotspotSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotspotSignal
     */
    omit?: HotspotSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotSignalInclude<ExtArgs> | null
    /**
     * Filter, which HotspotSignal to fetch.
     */
    where?: HotspotSignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotspotSignals to fetch.
     */
    orderBy?: HotspotSignalOrderByWithRelationInput | HotspotSignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotspotSignals.
     */
    cursor?: HotspotSignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotspotSignals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotspotSignals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotspotSignals.
     */
    distinct?: HotspotSignalScalarFieldEnum | HotspotSignalScalarFieldEnum[]
  }

  /**
   * HotspotSignal findMany
   */
  export type HotspotSignalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotspotSignal
     */
    select?: HotspotSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotspotSignal
     */
    omit?: HotspotSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotSignalInclude<ExtArgs> | null
    /**
     * Filter, which HotspotSignals to fetch.
     */
    where?: HotspotSignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotspotSignals to fetch.
     */
    orderBy?: HotspotSignalOrderByWithRelationInput | HotspotSignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotspotSignals.
     */
    cursor?: HotspotSignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotspotSignals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotspotSignals.
     */
    skip?: number
    distinct?: HotspotSignalScalarFieldEnum | HotspotSignalScalarFieldEnum[]
  }

  /**
   * HotspotSignal create
   */
  export type HotspotSignalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotspotSignal
     */
    select?: HotspotSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotspotSignal
     */
    omit?: HotspotSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotSignalInclude<ExtArgs> | null
    /**
     * The data needed to create a HotspotSignal.
     */
    data: XOR<HotspotSignalCreateInput, HotspotSignalUncheckedCreateInput>
  }

  /**
   * HotspotSignal createMany
   */
  export type HotspotSignalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotspotSignals.
     */
    data: HotspotSignalCreateManyInput | HotspotSignalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotspotSignal createManyAndReturn
   */
  export type HotspotSignalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotspotSignal
     */
    select?: HotspotSignalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotspotSignal
     */
    omit?: HotspotSignalOmit<ExtArgs> | null
    /**
     * The data used to create many HotspotSignals.
     */
    data: HotspotSignalCreateManyInput | HotspotSignalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotSignalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotspotSignal update
   */
  export type HotspotSignalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotspotSignal
     */
    select?: HotspotSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotspotSignal
     */
    omit?: HotspotSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotSignalInclude<ExtArgs> | null
    /**
     * The data needed to update a HotspotSignal.
     */
    data: XOR<HotspotSignalUpdateInput, HotspotSignalUncheckedUpdateInput>
    /**
     * Choose, which HotspotSignal to update.
     */
    where: HotspotSignalWhereUniqueInput
  }

  /**
   * HotspotSignal updateMany
   */
  export type HotspotSignalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotspotSignals.
     */
    data: XOR<HotspotSignalUpdateManyMutationInput, HotspotSignalUncheckedUpdateManyInput>
    /**
     * Filter which HotspotSignals to update
     */
    where?: HotspotSignalWhereInput
    /**
     * Limit how many HotspotSignals to update.
     */
    limit?: number
  }

  /**
   * HotspotSignal updateManyAndReturn
   */
  export type HotspotSignalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotspotSignal
     */
    select?: HotspotSignalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotspotSignal
     */
    omit?: HotspotSignalOmit<ExtArgs> | null
    /**
     * The data used to update HotspotSignals.
     */
    data: XOR<HotspotSignalUpdateManyMutationInput, HotspotSignalUncheckedUpdateManyInput>
    /**
     * Filter which HotspotSignals to update
     */
    where?: HotspotSignalWhereInput
    /**
     * Limit how many HotspotSignals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotSignalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotspotSignal upsert
   */
  export type HotspotSignalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotspotSignal
     */
    select?: HotspotSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotspotSignal
     */
    omit?: HotspotSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotSignalInclude<ExtArgs> | null
    /**
     * The filter to search for the HotspotSignal to update in case it exists.
     */
    where: HotspotSignalWhereUniqueInput
    /**
     * In case the HotspotSignal found by the `where` argument doesn't exist, create a new HotspotSignal with this data.
     */
    create: XOR<HotspotSignalCreateInput, HotspotSignalUncheckedCreateInput>
    /**
     * In case the HotspotSignal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotspotSignalUpdateInput, HotspotSignalUncheckedUpdateInput>
  }

  /**
   * HotspotSignal delete
   */
  export type HotspotSignalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotspotSignal
     */
    select?: HotspotSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotspotSignal
     */
    omit?: HotspotSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotSignalInclude<ExtArgs> | null
    /**
     * Filter which HotspotSignal to delete.
     */
    where: HotspotSignalWhereUniqueInput
  }

  /**
   * HotspotSignal deleteMany
   */
  export type HotspotSignalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotspotSignals to delete
     */
    where?: HotspotSignalWhereInput
    /**
     * Limit how many HotspotSignals to delete.
     */
    limit?: number
  }

  /**
   * HotspotSignal without action
   */
  export type HotspotSignalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotspotSignal
     */
    select?: HotspotSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotspotSignal
     */
    omit?: HotspotSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotSignalInclude<ExtArgs> | null
  }


  /**
   * Model Idea
   */

  export type AggregateIdea = {
    _count: IdeaCountAggregateOutputType | null
    _avg: IdeaAvgAggregateOutputType | null
    _sum: IdeaSumAggregateOutputType | null
    _min: IdeaMinAggregateOutputType | null
    _max: IdeaMaxAggregateOutputType | null
  }

  export type IdeaAvgAggregateOutputType = {
    votes: number | null
    confidence: number | null
  }

  export type IdeaSumAggregateOutputType = {
    votes: number | null
    confidence: number | null
  }

  export type IdeaMinAggregateOutputType = {
    id: string | null
    hotspotId: string | null
    title: string | null
    description: string | null
    origin: string | null
    votes: number | null
    status: string | null
    confidence: number | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IdeaMaxAggregateOutputType = {
    id: string | null
    hotspotId: string | null
    title: string | null
    description: string | null
    origin: string | null
    votes: number | null
    status: string | null
    confidence: number | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IdeaCountAggregateOutputType = {
    id: number
    hotspotId: number
    title: number
    description: number
    origin: number
    votes: number
    status: number
    evidenceJson: number
    tagsJson: number
    confidence: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IdeaAvgAggregateInputType = {
    votes?: true
    confidence?: true
  }

  export type IdeaSumAggregateInputType = {
    votes?: true
    confidence?: true
  }

  export type IdeaMinAggregateInputType = {
    id?: true
    hotspotId?: true
    title?: true
    description?: true
    origin?: true
    votes?: true
    status?: true
    confidence?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IdeaMaxAggregateInputType = {
    id?: true
    hotspotId?: true
    title?: true
    description?: true
    origin?: true
    votes?: true
    status?: true
    confidence?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IdeaCountAggregateInputType = {
    id?: true
    hotspotId?: true
    title?: true
    description?: true
    origin?: true
    votes?: true
    status?: true
    evidenceJson?: true
    tagsJson?: true
    confidence?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IdeaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Idea to aggregate.
     */
    where?: IdeaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ideas to fetch.
     */
    orderBy?: IdeaOrderByWithRelationInput | IdeaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IdeaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ideas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ideas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ideas
    **/
    _count?: true | IdeaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IdeaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IdeaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IdeaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IdeaMaxAggregateInputType
  }

  export type GetIdeaAggregateType<T extends IdeaAggregateArgs> = {
        [P in keyof T & keyof AggregateIdea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIdea[P]>
      : GetScalarType<T[P], AggregateIdea[P]>
  }




  export type IdeaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdeaWhereInput
    orderBy?: IdeaOrderByWithAggregationInput | IdeaOrderByWithAggregationInput[]
    by: IdeaScalarFieldEnum[] | IdeaScalarFieldEnum
    having?: IdeaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IdeaCountAggregateInputType | true
    _avg?: IdeaAvgAggregateInputType
    _sum?: IdeaSumAggregateInputType
    _min?: IdeaMinAggregateInputType
    _max?: IdeaMaxAggregateInputType
  }

  export type IdeaGroupByOutputType = {
    id: string
    hotspotId: string
    title: string | null
    description: string
    origin: string
    votes: number
    status: string
    evidenceJson: JsonValue | null
    tagsJson: JsonValue | null
    confidence: number | null
    createdById: string | null
    createdAt: Date
    updatedAt: Date
    _count: IdeaCountAggregateOutputType | null
    _avg: IdeaAvgAggregateOutputType | null
    _sum: IdeaSumAggregateOutputType | null
    _min: IdeaMinAggregateOutputType | null
    _max: IdeaMaxAggregateOutputType | null
  }

  type GetIdeaGroupByPayload<T extends IdeaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IdeaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IdeaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IdeaGroupByOutputType[P]>
            : GetScalarType<T[P], IdeaGroupByOutputType[P]>
        }
      >
    >


  export type IdeaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotspotId?: boolean
    title?: boolean
    description?: boolean
    origin?: boolean
    votes?: boolean
    status?: boolean
    evidenceJson?: boolean
    tagsJson?: boolean
    confidence?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | Idea$createdByArgs<ExtArgs>
    hotspot?: boolean | HotspotDefaultArgs<ExtArgs>
    solution?: boolean | Idea$solutionArgs<ExtArgs>
  }, ExtArgs["result"]["idea"]>

  export type IdeaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotspotId?: boolean
    title?: boolean
    description?: boolean
    origin?: boolean
    votes?: boolean
    status?: boolean
    evidenceJson?: boolean
    tagsJson?: boolean
    confidence?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | Idea$createdByArgs<ExtArgs>
    hotspot?: boolean | HotspotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["idea"]>

  export type IdeaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotspotId?: boolean
    title?: boolean
    description?: boolean
    origin?: boolean
    votes?: boolean
    status?: boolean
    evidenceJson?: boolean
    tagsJson?: boolean
    confidence?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | Idea$createdByArgs<ExtArgs>
    hotspot?: boolean | HotspotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["idea"]>

  export type IdeaSelectScalar = {
    id?: boolean
    hotspotId?: boolean
    title?: boolean
    description?: boolean
    origin?: boolean
    votes?: boolean
    status?: boolean
    evidenceJson?: boolean
    tagsJson?: boolean
    confidence?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IdeaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hotspotId" | "title" | "description" | "origin" | "votes" | "status" | "evidenceJson" | "tagsJson" | "confidence" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["idea"]>
  export type IdeaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Idea$createdByArgs<ExtArgs>
    hotspot?: boolean | HotspotDefaultArgs<ExtArgs>
    solution?: boolean | Idea$solutionArgs<ExtArgs>
  }
  export type IdeaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Idea$createdByArgs<ExtArgs>
    hotspot?: boolean | HotspotDefaultArgs<ExtArgs>
  }
  export type IdeaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Idea$createdByArgs<ExtArgs>
    hotspot?: boolean | HotspotDefaultArgs<ExtArgs>
  }

  export type $IdeaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Idea"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      hotspot: Prisma.$HotspotPayload<ExtArgs>
      solution: Prisma.$SolutionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hotspotId: string
      title: string | null
      description: string
      origin: string
      votes: number
      status: string
      evidenceJson: Prisma.JsonValue | null
      tagsJson: Prisma.JsonValue | null
      confidence: number | null
      createdById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["idea"]>
    composites: {}
  }

  type IdeaGetPayload<S extends boolean | null | undefined | IdeaDefaultArgs> = $Result.GetResult<Prisma.$IdeaPayload, S>

  type IdeaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IdeaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IdeaCountAggregateInputType | true
    }

  export interface IdeaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Idea'], meta: { name: 'Idea' } }
    /**
     * Find zero or one Idea that matches the filter.
     * @param {IdeaFindUniqueArgs} args - Arguments to find a Idea
     * @example
     * // Get one Idea
     * const idea = await prisma.idea.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IdeaFindUniqueArgs>(args: SelectSubset<T, IdeaFindUniqueArgs<ExtArgs>>): Prisma__IdeaClient<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Idea that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IdeaFindUniqueOrThrowArgs} args - Arguments to find a Idea
     * @example
     * // Get one Idea
     * const idea = await prisma.idea.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IdeaFindUniqueOrThrowArgs>(args: SelectSubset<T, IdeaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IdeaClient<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Idea that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaFindFirstArgs} args - Arguments to find a Idea
     * @example
     * // Get one Idea
     * const idea = await prisma.idea.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IdeaFindFirstArgs>(args?: SelectSubset<T, IdeaFindFirstArgs<ExtArgs>>): Prisma__IdeaClient<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Idea that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaFindFirstOrThrowArgs} args - Arguments to find a Idea
     * @example
     * // Get one Idea
     * const idea = await prisma.idea.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IdeaFindFirstOrThrowArgs>(args?: SelectSubset<T, IdeaFindFirstOrThrowArgs<ExtArgs>>): Prisma__IdeaClient<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ideas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ideas
     * const ideas = await prisma.idea.findMany()
     * 
     * // Get first 10 Ideas
     * const ideas = await prisma.idea.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ideaWithIdOnly = await prisma.idea.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IdeaFindManyArgs>(args?: SelectSubset<T, IdeaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Idea.
     * @param {IdeaCreateArgs} args - Arguments to create a Idea.
     * @example
     * // Create one Idea
     * const Idea = await prisma.idea.create({
     *   data: {
     *     // ... data to create a Idea
     *   }
     * })
     * 
     */
    create<T extends IdeaCreateArgs>(args: SelectSubset<T, IdeaCreateArgs<ExtArgs>>): Prisma__IdeaClient<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ideas.
     * @param {IdeaCreateManyArgs} args - Arguments to create many Ideas.
     * @example
     * // Create many Ideas
     * const idea = await prisma.idea.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IdeaCreateManyArgs>(args?: SelectSubset<T, IdeaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ideas and returns the data saved in the database.
     * @param {IdeaCreateManyAndReturnArgs} args - Arguments to create many Ideas.
     * @example
     * // Create many Ideas
     * const idea = await prisma.idea.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ideas and only return the `id`
     * const ideaWithIdOnly = await prisma.idea.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IdeaCreateManyAndReturnArgs>(args?: SelectSubset<T, IdeaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Idea.
     * @param {IdeaDeleteArgs} args - Arguments to delete one Idea.
     * @example
     * // Delete one Idea
     * const Idea = await prisma.idea.delete({
     *   where: {
     *     // ... filter to delete one Idea
     *   }
     * })
     * 
     */
    delete<T extends IdeaDeleteArgs>(args: SelectSubset<T, IdeaDeleteArgs<ExtArgs>>): Prisma__IdeaClient<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Idea.
     * @param {IdeaUpdateArgs} args - Arguments to update one Idea.
     * @example
     * // Update one Idea
     * const idea = await prisma.idea.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IdeaUpdateArgs>(args: SelectSubset<T, IdeaUpdateArgs<ExtArgs>>): Prisma__IdeaClient<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ideas.
     * @param {IdeaDeleteManyArgs} args - Arguments to filter Ideas to delete.
     * @example
     * // Delete a few Ideas
     * const { count } = await prisma.idea.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IdeaDeleteManyArgs>(args?: SelectSubset<T, IdeaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ideas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ideas
     * const idea = await prisma.idea.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IdeaUpdateManyArgs>(args: SelectSubset<T, IdeaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ideas and returns the data updated in the database.
     * @param {IdeaUpdateManyAndReturnArgs} args - Arguments to update many Ideas.
     * @example
     * // Update many Ideas
     * const idea = await prisma.idea.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ideas and only return the `id`
     * const ideaWithIdOnly = await prisma.idea.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IdeaUpdateManyAndReturnArgs>(args: SelectSubset<T, IdeaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Idea.
     * @param {IdeaUpsertArgs} args - Arguments to update or create a Idea.
     * @example
     * // Update or create a Idea
     * const idea = await prisma.idea.upsert({
     *   create: {
     *     // ... data to create a Idea
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Idea we want to update
     *   }
     * })
     */
    upsert<T extends IdeaUpsertArgs>(args: SelectSubset<T, IdeaUpsertArgs<ExtArgs>>): Prisma__IdeaClient<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ideas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaCountArgs} args - Arguments to filter Ideas to count.
     * @example
     * // Count the number of Ideas
     * const count = await prisma.idea.count({
     *   where: {
     *     // ... the filter for the Ideas we want to count
     *   }
     * })
    **/
    count<T extends IdeaCountArgs>(
      args?: Subset<T, IdeaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IdeaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Idea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IdeaAggregateArgs>(args: Subset<T, IdeaAggregateArgs>): Prisma.PrismaPromise<GetIdeaAggregateType<T>>

    /**
     * Group by Idea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IdeaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IdeaGroupByArgs['orderBy'] }
        : { orderBy?: IdeaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IdeaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIdeaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Idea model
   */
  readonly fields: IdeaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Idea.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IdeaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends Idea$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Idea$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    hotspot<T extends HotspotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotspotDefaultArgs<ExtArgs>>): Prisma__HotspotClient<$Result.GetResult<Prisma.$HotspotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    solution<T extends Idea$solutionArgs<ExtArgs> = {}>(args?: Subset<T, Idea$solutionArgs<ExtArgs>>): Prisma__SolutionClient<$Result.GetResult<Prisma.$SolutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Idea model
   */
  interface IdeaFieldRefs {
    readonly id: FieldRef<"Idea", 'String'>
    readonly hotspotId: FieldRef<"Idea", 'String'>
    readonly title: FieldRef<"Idea", 'String'>
    readonly description: FieldRef<"Idea", 'String'>
    readonly origin: FieldRef<"Idea", 'String'>
    readonly votes: FieldRef<"Idea", 'Int'>
    readonly status: FieldRef<"Idea", 'String'>
    readonly evidenceJson: FieldRef<"Idea", 'Json'>
    readonly tagsJson: FieldRef<"Idea", 'Json'>
    readonly confidence: FieldRef<"Idea", 'Float'>
    readonly createdById: FieldRef<"Idea", 'String'>
    readonly createdAt: FieldRef<"Idea", 'DateTime'>
    readonly updatedAt: FieldRef<"Idea", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Idea findUnique
   */
  export type IdeaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
    /**
     * Filter, which Idea to fetch.
     */
    where: IdeaWhereUniqueInput
  }

  /**
   * Idea findUniqueOrThrow
   */
  export type IdeaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
    /**
     * Filter, which Idea to fetch.
     */
    where: IdeaWhereUniqueInput
  }

  /**
   * Idea findFirst
   */
  export type IdeaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
    /**
     * Filter, which Idea to fetch.
     */
    where?: IdeaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ideas to fetch.
     */
    orderBy?: IdeaOrderByWithRelationInput | IdeaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ideas.
     */
    cursor?: IdeaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ideas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ideas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ideas.
     */
    distinct?: IdeaScalarFieldEnum | IdeaScalarFieldEnum[]
  }

  /**
   * Idea findFirstOrThrow
   */
  export type IdeaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
    /**
     * Filter, which Idea to fetch.
     */
    where?: IdeaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ideas to fetch.
     */
    orderBy?: IdeaOrderByWithRelationInput | IdeaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ideas.
     */
    cursor?: IdeaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ideas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ideas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ideas.
     */
    distinct?: IdeaScalarFieldEnum | IdeaScalarFieldEnum[]
  }

  /**
   * Idea findMany
   */
  export type IdeaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
    /**
     * Filter, which Ideas to fetch.
     */
    where?: IdeaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ideas to fetch.
     */
    orderBy?: IdeaOrderByWithRelationInput | IdeaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ideas.
     */
    cursor?: IdeaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ideas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ideas.
     */
    skip?: number
    distinct?: IdeaScalarFieldEnum | IdeaScalarFieldEnum[]
  }

  /**
   * Idea create
   */
  export type IdeaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
    /**
     * The data needed to create a Idea.
     */
    data: XOR<IdeaCreateInput, IdeaUncheckedCreateInput>
  }

  /**
   * Idea createMany
   */
  export type IdeaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ideas.
     */
    data: IdeaCreateManyInput | IdeaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Idea createManyAndReturn
   */
  export type IdeaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * The data used to create many Ideas.
     */
    data: IdeaCreateManyInput | IdeaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Idea update
   */
  export type IdeaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
    /**
     * The data needed to update a Idea.
     */
    data: XOR<IdeaUpdateInput, IdeaUncheckedUpdateInput>
    /**
     * Choose, which Idea to update.
     */
    where: IdeaWhereUniqueInput
  }

  /**
   * Idea updateMany
   */
  export type IdeaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ideas.
     */
    data: XOR<IdeaUpdateManyMutationInput, IdeaUncheckedUpdateManyInput>
    /**
     * Filter which Ideas to update
     */
    where?: IdeaWhereInput
    /**
     * Limit how many Ideas to update.
     */
    limit?: number
  }

  /**
   * Idea updateManyAndReturn
   */
  export type IdeaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * The data used to update Ideas.
     */
    data: XOR<IdeaUpdateManyMutationInput, IdeaUncheckedUpdateManyInput>
    /**
     * Filter which Ideas to update
     */
    where?: IdeaWhereInput
    /**
     * Limit how many Ideas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Idea upsert
   */
  export type IdeaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
    /**
     * The filter to search for the Idea to update in case it exists.
     */
    where: IdeaWhereUniqueInput
    /**
     * In case the Idea found by the `where` argument doesn't exist, create a new Idea with this data.
     */
    create: XOR<IdeaCreateInput, IdeaUncheckedCreateInput>
    /**
     * In case the Idea was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IdeaUpdateInput, IdeaUncheckedUpdateInput>
  }

  /**
   * Idea delete
   */
  export type IdeaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
    /**
     * Filter which Idea to delete.
     */
    where: IdeaWhereUniqueInput
  }

  /**
   * Idea deleteMany
   */
  export type IdeaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ideas to delete
     */
    where?: IdeaWhereInput
    /**
     * Limit how many Ideas to delete.
     */
    limit?: number
  }

  /**
   * Idea.createdBy
   */
  export type Idea$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Idea.solution
   */
  export type Idea$solutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null
    where?: SolutionWhereInput
  }

  /**
   * Idea without action
   */
  export type IdeaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
  }


  /**
   * Model Input
   */

  export type AggregateInput = {
    _count: InputCountAggregateOutputType | null
    _avg: InputAvgAggregateOutputType | null
    _sum: InputSumAggregateOutputType | null
    _min: InputMinAggregateOutputType | null
    _max: InputMaxAggregateOutputType | null
  }

  export type InputAvgAggregateOutputType = {
    aiConfidence: number | null
  }

  export type InputSumAggregateOutputType = {
    aiConfidence: number | null
  }

  export type InputMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: $Enums.InputType | null
    department: string | null
    issueType: string | null
    rootCause: string | null
    priority: $Enums.Priority | null
    aiConfidence: number | null
    status: $Enums.InputStatus | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InputMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: $Enums.InputType | null
    department: string | null
    issueType: string | null
    rootCause: string | null
    priority: $Enums.Priority | null
    aiConfidence: number | null
    status: $Enums.InputStatus | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InputCountAggregateOutputType = {
    id: number
    title: number
    description: number
    type: number
    department: number
    issueType: number
    rootCause: number
    priority: number
    aiTags: number
    aiConfidence: number
    aiSuggestions: number
    status: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InputAvgAggregateInputType = {
    aiConfidence?: true
  }

  export type InputSumAggregateInputType = {
    aiConfidence?: true
  }

  export type InputMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    department?: true
    issueType?: true
    rootCause?: true
    priority?: true
    aiConfidence?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InputMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    department?: true
    issueType?: true
    rootCause?: true
    priority?: true
    aiConfidence?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InputCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    department?: true
    issueType?: true
    rootCause?: true
    priority?: true
    aiTags?: true
    aiConfidence?: true
    aiSuggestions?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InputAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Input to aggregate.
     */
    where?: InputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inputs to fetch.
     */
    orderBy?: InputOrderByWithRelationInput | InputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inputs
    **/
    _count?: true | InputCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InputAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InputSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InputMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InputMaxAggregateInputType
  }

  export type GetInputAggregateType<T extends InputAggregateArgs> = {
        [P in keyof T & keyof AggregateInput]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInput[P]>
      : GetScalarType<T[P], AggregateInput[P]>
  }




  export type InputGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InputWhereInput
    orderBy?: InputOrderByWithAggregationInput | InputOrderByWithAggregationInput[]
    by: InputScalarFieldEnum[] | InputScalarFieldEnum
    having?: InputScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InputCountAggregateInputType | true
    _avg?: InputAvgAggregateInputType
    _sum?: InputSumAggregateInputType
    _min?: InputMinAggregateInputType
    _max?: InputMaxAggregateInputType
  }

  export type InputGroupByOutputType = {
    id: string
    title: string
    description: string
    type: $Enums.InputType
    department: string | null
    issueType: string | null
    rootCause: string | null
    priority: $Enums.Priority
    aiTags: JsonValue | null
    aiConfidence: number | null
    aiSuggestions: JsonValue | null
    status: $Enums.InputStatus
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: InputCountAggregateOutputType | null
    _avg: InputAvgAggregateOutputType | null
    _sum: InputSumAggregateOutputType | null
    _min: InputMinAggregateOutputType | null
    _max: InputMaxAggregateOutputType | null
  }

  type GetInputGroupByPayload<T extends InputGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InputGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InputGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InputGroupByOutputType[P]>
            : GetScalarType<T[P], InputGroupByOutputType[P]>
        }
      >
    >


  export type InputSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    department?: boolean
    issueType?: boolean
    rootCause?: boolean
    priority?: boolean
    aiTags?: boolean
    aiConfidence?: boolean
    aiSuggestions?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    solutions?: boolean | Input$solutionsArgs<ExtArgs>
    groups?: boolean | Input$groupsArgs<ExtArgs>
    _count?: boolean | InputCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["input"]>

  export type InputSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    department?: boolean
    issueType?: boolean
    rootCause?: boolean
    priority?: boolean
    aiTags?: boolean
    aiConfidence?: boolean
    aiSuggestions?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["input"]>

  export type InputSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    department?: boolean
    issueType?: boolean
    rootCause?: boolean
    priority?: boolean
    aiTags?: boolean
    aiConfidence?: boolean
    aiSuggestions?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["input"]>

  export type InputSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    department?: boolean
    issueType?: boolean
    rootCause?: boolean
    priority?: boolean
    aiTags?: boolean
    aiConfidence?: boolean
    aiSuggestions?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InputOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "type" | "department" | "issueType" | "rootCause" | "priority" | "aiTags" | "aiConfidence" | "aiSuggestions" | "status" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["input"]>
  export type InputInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    solutions?: boolean | Input$solutionsArgs<ExtArgs>
    groups?: boolean | Input$groupsArgs<ExtArgs>
    _count?: boolean | InputCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InputIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InputIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InputPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Input"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      solutions: Prisma.$SolutionPayload<ExtArgs>[]
      groups: Prisma.$InputGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      type: $Enums.InputType
      department: string | null
      issueType: string | null
      rootCause: string | null
      priority: $Enums.Priority
      aiTags: Prisma.JsonValue | null
      aiConfidence: number | null
      aiSuggestions: Prisma.JsonValue | null
      status: $Enums.InputStatus
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["input"]>
    composites: {}
  }

  type InputGetPayload<S extends boolean | null | undefined | InputDefaultArgs> = $Result.GetResult<Prisma.$InputPayload, S>

  type InputCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InputFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InputCountAggregateInputType | true
    }

  export interface InputDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Input'], meta: { name: 'Input' } }
    /**
     * Find zero or one Input that matches the filter.
     * @param {InputFindUniqueArgs} args - Arguments to find a Input
     * @example
     * // Get one Input
     * const input = await prisma.input.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InputFindUniqueArgs>(args: SelectSubset<T, InputFindUniqueArgs<ExtArgs>>): Prisma__InputClient<$Result.GetResult<Prisma.$InputPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Input that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InputFindUniqueOrThrowArgs} args - Arguments to find a Input
     * @example
     * // Get one Input
     * const input = await prisma.input.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InputFindUniqueOrThrowArgs>(args: SelectSubset<T, InputFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InputClient<$Result.GetResult<Prisma.$InputPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Input that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputFindFirstArgs} args - Arguments to find a Input
     * @example
     * // Get one Input
     * const input = await prisma.input.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InputFindFirstArgs>(args?: SelectSubset<T, InputFindFirstArgs<ExtArgs>>): Prisma__InputClient<$Result.GetResult<Prisma.$InputPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Input that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputFindFirstOrThrowArgs} args - Arguments to find a Input
     * @example
     * // Get one Input
     * const input = await prisma.input.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InputFindFirstOrThrowArgs>(args?: SelectSubset<T, InputFindFirstOrThrowArgs<ExtArgs>>): Prisma__InputClient<$Result.GetResult<Prisma.$InputPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inputs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inputs
     * const inputs = await prisma.input.findMany()
     * 
     * // Get first 10 Inputs
     * const inputs = await prisma.input.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inputWithIdOnly = await prisma.input.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InputFindManyArgs>(args?: SelectSubset<T, InputFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InputPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Input.
     * @param {InputCreateArgs} args - Arguments to create a Input.
     * @example
     * // Create one Input
     * const Input = await prisma.input.create({
     *   data: {
     *     // ... data to create a Input
     *   }
     * })
     * 
     */
    create<T extends InputCreateArgs>(args: SelectSubset<T, InputCreateArgs<ExtArgs>>): Prisma__InputClient<$Result.GetResult<Prisma.$InputPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inputs.
     * @param {InputCreateManyArgs} args - Arguments to create many Inputs.
     * @example
     * // Create many Inputs
     * const input = await prisma.input.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InputCreateManyArgs>(args?: SelectSubset<T, InputCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inputs and returns the data saved in the database.
     * @param {InputCreateManyAndReturnArgs} args - Arguments to create many Inputs.
     * @example
     * // Create many Inputs
     * const input = await prisma.input.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inputs and only return the `id`
     * const inputWithIdOnly = await prisma.input.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InputCreateManyAndReturnArgs>(args?: SelectSubset<T, InputCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InputPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Input.
     * @param {InputDeleteArgs} args - Arguments to delete one Input.
     * @example
     * // Delete one Input
     * const Input = await prisma.input.delete({
     *   where: {
     *     // ... filter to delete one Input
     *   }
     * })
     * 
     */
    delete<T extends InputDeleteArgs>(args: SelectSubset<T, InputDeleteArgs<ExtArgs>>): Prisma__InputClient<$Result.GetResult<Prisma.$InputPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Input.
     * @param {InputUpdateArgs} args - Arguments to update one Input.
     * @example
     * // Update one Input
     * const input = await prisma.input.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InputUpdateArgs>(args: SelectSubset<T, InputUpdateArgs<ExtArgs>>): Prisma__InputClient<$Result.GetResult<Prisma.$InputPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inputs.
     * @param {InputDeleteManyArgs} args - Arguments to filter Inputs to delete.
     * @example
     * // Delete a few Inputs
     * const { count } = await prisma.input.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InputDeleteManyArgs>(args?: SelectSubset<T, InputDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inputs
     * const input = await prisma.input.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InputUpdateManyArgs>(args: SelectSubset<T, InputUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inputs and returns the data updated in the database.
     * @param {InputUpdateManyAndReturnArgs} args - Arguments to update many Inputs.
     * @example
     * // Update many Inputs
     * const input = await prisma.input.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inputs and only return the `id`
     * const inputWithIdOnly = await prisma.input.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InputUpdateManyAndReturnArgs>(args: SelectSubset<T, InputUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InputPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Input.
     * @param {InputUpsertArgs} args - Arguments to update or create a Input.
     * @example
     * // Update or create a Input
     * const input = await prisma.input.upsert({
     *   create: {
     *     // ... data to create a Input
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Input we want to update
     *   }
     * })
     */
    upsert<T extends InputUpsertArgs>(args: SelectSubset<T, InputUpsertArgs<ExtArgs>>): Prisma__InputClient<$Result.GetResult<Prisma.$InputPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputCountArgs} args - Arguments to filter Inputs to count.
     * @example
     * // Count the number of Inputs
     * const count = await prisma.input.count({
     *   where: {
     *     // ... the filter for the Inputs we want to count
     *   }
     * })
    **/
    count<T extends InputCountArgs>(
      args?: Subset<T, InputCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InputCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Input.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InputAggregateArgs>(args: Subset<T, InputAggregateArgs>): Prisma.PrismaPromise<GetInputAggregateType<T>>

    /**
     * Group by Input.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InputGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InputGroupByArgs['orderBy'] }
        : { orderBy?: InputGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InputGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInputGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Input model
   */
  readonly fields: InputFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Input.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InputClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    solutions<T extends Input$solutionsArgs<ExtArgs> = {}>(args?: Subset<T, Input$solutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SolutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groups<T extends Input$groupsArgs<ExtArgs> = {}>(args?: Subset<T, Input$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InputGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Input model
   */
  interface InputFieldRefs {
    readonly id: FieldRef<"Input", 'String'>
    readonly title: FieldRef<"Input", 'String'>
    readonly description: FieldRef<"Input", 'String'>
    readonly type: FieldRef<"Input", 'InputType'>
    readonly department: FieldRef<"Input", 'String'>
    readonly issueType: FieldRef<"Input", 'String'>
    readonly rootCause: FieldRef<"Input", 'String'>
    readonly priority: FieldRef<"Input", 'Priority'>
    readonly aiTags: FieldRef<"Input", 'Json'>
    readonly aiConfidence: FieldRef<"Input", 'Float'>
    readonly aiSuggestions: FieldRef<"Input", 'Json'>
    readonly status: FieldRef<"Input", 'InputStatus'>
    readonly createdBy: FieldRef<"Input", 'String'>
    readonly createdAt: FieldRef<"Input", 'DateTime'>
    readonly updatedAt: FieldRef<"Input", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Input findUnique
   */
  export type InputFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null
    /**
     * Filter, which Input to fetch.
     */
    where: InputWhereUniqueInput
  }

  /**
   * Input findUniqueOrThrow
   */
  export type InputFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null
    /**
     * Filter, which Input to fetch.
     */
    where: InputWhereUniqueInput
  }

  /**
   * Input findFirst
   */
  export type InputFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null
    /**
     * Filter, which Input to fetch.
     */
    where?: InputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inputs to fetch.
     */
    orderBy?: InputOrderByWithRelationInput | InputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inputs.
     */
    cursor?: InputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inputs.
     */
    distinct?: InputScalarFieldEnum | InputScalarFieldEnum[]
  }

  /**
   * Input findFirstOrThrow
   */
  export type InputFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null
    /**
     * Filter, which Input to fetch.
     */
    where?: InputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inputs to fetch.
     */
    orderBy?: InputOrderByWithRelationInput | InputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inputs.
     */
    cursor?: InputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inputs.
     */
    distinct?: InputScalarFieldEnum | InputScalarFieldEnum[]
  }

  /**
   * Input findMany
   */
  export type InputFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null
    /**
     * Filter, which Inputs to fetch.
     */
    where?: InputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inputs to fetch.
     */
    orderBy?: InputOrderByWithRelationInput | InputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inputs.
     */
    cursor?: InputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inputs.
     */
    skip?: number
    distinct?: InputScalarFieldEnum | InputScalarFieldEnum[]
  }

  /**
   * Input create
   */
  export type InputCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null
    /**
     * The data needed to create a Input.
     */
    data: XOR<InputCreateInput, InputUncheckedCreateInput>
  }

  /**
   * Input createMany
   */
  export type InputCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inputs.
     */
    data: InputCreateManyInput | InputCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Input createManyAndReturn
   */
  export type InputCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null
    /**
     * The data used to create many Inputs.
     */
    data: InputCreateManyInput | InputCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Input update
   */
  export type InputUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null
    /**
     * The data needed to update a Input.
     */
    data: XOR<InputUpdateInput, InputUncheckedUpdateInput>
    /**
     * Choose, which Input to update.
     */
    where: InputWhereUniqueInput
  }

  /**
   * Input updateMany
   */
  export type InputUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inputs.
     */
    data: XOR<InputUpdateManyMutationInput, InputUncheckedUpdateManyInput>
    /**
     * Filter which Inputs to update
     */
    where?: InputWhereInput
    /**
     * Limit how many Inputs to update.
     */
    limit?: number
  }

  /**
   * Input updateManyAndReturn
   */
  export type InputUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null
    /**
     * The data used to update Inputs.
     */
    data: XOR<InputUpdateManyMutationInput, InputUncheckedUpdateManyInput>
    /**
     * Filter which Inputs to update
     */
    where?: InputWhereInput
    /**
     * Limit how many Inputs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Input upsert
   */
  export type InputUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null
    /**
     * The filter to search for the Input to update in case it exists.
     */
    where: InputWhereUniqueInput
    /**
     * In case the Input found by the `where` argument doesn't exist, create a new Input with this data.
     */
    create: XOR<InputCreateInput, InputUncheckedCreateInput>
    /**
     * In case the Input was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InputUpdateInput, InputUncheckedUpdateInput>
  }

  /**
   * Input delete
   */
  export type InputDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null
    /**
     * Filter which Input to delete.
     */
    where: InputWhereUniqueInput
  }

  /**
   * Input deleteMany
   */
  export type InputDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inputs to delete
     */
    where?: InputWhereInput
    /**
     * Limit how many Inputs to delete.
     */
    limit?: number
  }

  /**
   * Input.solutions
   */
  export type Input$solutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null
    where?: SolutionWhereInput
    orderBy?: SolutionOrderByWithRelationInput | SolutionOrderByWithRelationInput[]
    cursor?: SolutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SolutionScalarFieldEnum | SolutionScalarFieldEnum[]
  }

  /**
   * Input.groups
   */
  export type Input$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null
    where?: InputGroupWhereInput
    orderBy?: InputGroupOrderByWithRelationInput | InputGroupOrderByWithRelationInput[]
    cursor?: InputGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InputGroupScalarFieldEnum | InputGroupScalarFieldEnum[]
  }

  /**
   * Input without action
   */
  export type InputDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null
  }


  /**
   * Model Solution
   */

  export type AggregateSolution = {
    _count: SolutionCountAggregateOutputType | null
    _avg: SolutionAvgAggregateOutputType | null
    _sum: SolutionSumAggregateOutputType | null
    _min: SolutionMinAggregateOutputType | null
    _max: SolutionMaxAggregateOutputType | null
  }

  export type SolutionAvgAggregateOutputType = {
    progress: number | null
  }

  export type SolutionSumAggregateOutputType = {
    progress: number | null
  }

  export type SolutionMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.SolutionStatus | null
    hotspotId: string | null
    initiativeId: string | null
    ideaId: string | null
    progress: number | null
    targetDate: Date | null
    actualCompletionDate: Date | null
    estimatedEffort: string | null
    businessValue: string | null
    inputId: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SolutionMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.SolutionStatus | null
    hotspotId: string | null
    initiativeId: string | null
    ideaId: string | null
    progress: number | null
    targetDate: Date | null
    actualCompletionDate: Date | null
    estimatedEffort: string | null
    businessValue: string | null
    inputId: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SolutionCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    hotspotId: number
    initiativeId: number
    ideaId: number
    tasks: number
    progress: number
    targetDate: number
    actualCompletionDate: number
    estimatedEffort: number
    businessValue: number
    successMetrics: number
    expectedImpactJson: number
    actualImpactJson: number
    inputId: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SolutionAvgAggregateInputType = {
    progress?: true
  }

  export type SolutionSumAggregateInputType = {
    progress?: true
  }

  export type SolutionMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    hotspotId?: true
    initiativeId?: true
    ideaId?: true
    progress?: true
    targetDate?: true
    actualCompletionDate?: true
    estimatedEffort?: true
    businessValue?: true
    inputId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SolutionMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    hotspotId?: true
    initiativeId?: true
    ideaId?: true
    progress?: true
    targetDate?: true
    actualCompletionDate?: true
    estimatedEffort?: true
    businessValue?: true
    inputId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SolutionCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    hotspotId?: true
    initiativeId?: true
    ideaId?: true
    tasks?: true
    progress?: true
    targetDate?: true
    actualCompletionDate?: true
    estimatedEffort?: true
    businessValue?: true
    successMetrics?: true
    expectedImpactJson?: true
    actualImpactJson?: true
    inputId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SolutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Solution to aggregate.
     */
    where?: SolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Solutions to fetch.
     */
    orderBy?: SolutionOrderByWithRelationInput | SolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Solutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Solutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Solutions
    **/
    _count?: true | SolutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SolutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SolutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SolutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SolutionMaxAggregateInputType
  }

  export type GetSolutionAggregateType<T extends SolutionAggregateArgs> = {
        [P in keyof T & keyof AggregateSolution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSolution[P]>
      : GetScalarType<T[P], AggregateSolution[P]>
  }




  export type SolutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SolutionWhereInput
    orderBy?: SolutionOrderByWithAggregationInput | SolutionOrderByWithAggregationInput[]
    by: SolutionScalarFieldEnum[] | SolutionScalarFieldEnum
    having?: SolutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SolutionCountAggregateInputType | true
    _avg?: SolutionAvgAggregateInputType
    _sum?: SolutionSumAggregateInputType
    _min?: SolutionMinAggregateInputType
    _max?: SolutionMaxAggregateInputType
  }

  export type SolutionGroupByOutputType = {
    id: string
    title: string
    description: string
    status: $Enums.SolutionStatus
    hotspotId: string | null
    initiativeId: string | null
    ideaId: string | null
    tasks: JsonValue | null
    progress: number
    targetDate: Date | null
    actualCompletionDate: Date | null
    estimatedEffort: string | null
    businessValue: string | null
    successMetrics: JsonValue | null
    expectedImpactJson: JsonValue | null
    actualImpactJson: JsonValue | null
    inputId: string | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: SolutionCountAggregateOutputType | null
    _avg: SolutionAvgAggregateOutputType | null
    _sum: SolutionSumAggregateOutputType | null
    _min: SolutionMinAggregateOutputType | null
    _max: SolutionMaxAggregateOutputType | null
  }

  type GetSolutionGroupByPayload<T extends SolutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SolutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SolutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SolutionGroupByOutputType[P]>
            : GetScalarType<T[P], SolutionGroupByOutputType[P]>
        }
      >
    >


  export type SolutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    hotspotId?: boolean
    initiativeId?: boolean
    ideaId?: boolean
    tasks?: boolean
    progress?: boolean
    targetDate?: boolean
    actualCompletionDate?: boolean
    estimatedEffort?: boolean
    businessValue?: boolean
    successMetrics?: boolean
    expectedImpactJson?: boolean
    actualImpactJson?: boolean
    inputId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotspot?: boolean | Solution$hotspotArgs<ExtArgs>
    initiative?: boolean | Solution$initiativeArgs<ExtArgs>
    idea?: boolean | Solution$ideaArgs<ExtArgs>
    input?: boolean | Solution$inputArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    requirements?: boolean | Solution$requirementsArgs<ExtArgs>
    frdDocuments?: boolean | Solution$frdDocumentsArgs<ExtArgs>
    _count?: boolean | SolutionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["solution"]>

  export type SolutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    hotspotId?: boolean
    initiativeId?: boolean
    ideaId?: boolean
    tasks?: boolean
    progress?: boolean
    targetDate?: boolean
    actualCompletionDate?: boolean
    estimatedEffort?: boolean
    businessValue?: boolean
    successMetrics?: boolean
    expectedImpactJson?: boolean
    actualImpactJson?: boolean
    inputId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotspot?: boolean | Solution$hotspotArgs<ExtArgs>
    initiative?: boolean | Solution$initiativeArgs<ExtArgs>
    idea?: boolean | Solution$ideaArgs<ExtArgs>
    input?: boolean | Solution$inputArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["solution"]>

  export type SolutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    hotspotId?: boolean
    initiativeId?: boolean
    ideaId?: boolean
    tasks?: boolean
    progress?: boolean
    targetDate?: boolean
    actualCompletionDate?: boolean
    estimatedEffort?: boolean
    businessValue?: boolean
    successMetrics?: boolean
    expectedImpactJson?: boolean
    actualImpactJson?: boolean
    inputId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotspot?: boolean | Solution$hotspotArgs<ExtArgs>
    initiative?: boolean | Solution$initiativeArgs<ExtArgs>
    idea?: boolean | Solution$ideaArgs<ExtArgs>
    input?: boolean | Solution$inputArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["solution"]>

  export type SolutionSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    hotspotId?: boolean
    initiativeId?: boolean
    ideaId?: boolean
    tasks?: boolean
    progress?: boolean
    targetDate?: boolean
    actualCompletionDate?: boolean
    estimatedEffort?: boolean
    businessValue?: boolean
    successMetrics?: boolean
    expectedImpactJson?: boolean
    actualImpactJson?: boolean
    inputId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SolutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "status" | "hotspotId" | "initiativeId" | "ideaId" | "tasks" | "progress" | "targetDate" | "actualCompletionDate" | "estimatedEffort" | "businessValue" | "successMetrics" | "expectedImpactJson" | "actualImpactJson" | "inputId" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["solution"]>
  export type SolutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotspot?: boolean | Solution$hotspotArgs<ExtArgs>
    initiative?: boolean | Solution$initiativeArgs<ExtArgs>
    idea?: boolean | Solution$ideaArgs<ExtArgs>
    input?: boolean | Solution$inputArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    requirements?: boolean | Solution$requirementsArgs<ExtArgs>
    frdDocuments?: boolean | Solution$frdDocumentsArgs<ExtArgs>
    _count?: boolean | SolutionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SolutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotspot?: boolean | Solution$hotspotArgs<ExtArgs>
    initiative?: boolean | Solution$initiativeArgs<ExtArgs>
    idea?: boolean | Solution$ideaArgs<ExtArgs>
    input?: boolean | Solution$inputArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SolutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotspot?: boolean | Solution$hotspotArgs<ExtArgs>
    initiative?: boolean | Solution$initiativeArgs<ExtArgs>
    idea?: boolean | Solution$ideaArgs<ExtArgs>
    input?: boolean | Solution$inputArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SolutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Solution"
    objects: {
      hotspot: Prisma.$HotspotPayload<ExtArgs> | null
      initiative: Prisma.$InitiativePayload<ExtArgs> | null
      idea: Prisma.$IdeaPayload<ExtArgs> | null
      input: Prisma.$InputPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs>
      requirements: Prisma.$RequirementPayload<ExtArgs>[]
      frdDocuments: Prisma.$FRDDocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      status: $Enums.SolutionStatus
      hotspotId: string | null
      initiativeId: string | null
      ideaId: string | null
      tasks: Prisma.JsonValue | null
      progress: number
      targetDate: Date | null
      actualCompletionDate: Date | null
      estimatedEffort: string | null
      businessValue: string | null
      successMetrics: Prisma.JsonValue | null
      expectedImpactJson: Prisma.JsonValue | null
      actualImpactJson: Prisma.JsonValue | null
      inputId: string | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["solution"]>
    composites: {}
  }

  type SolutionGetPayload<S extends boolean | null | undefined | SolutionDefaultArgs> = $Result.GetResult<Prisma.$SolutionPayload, S>

  type SolutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SolutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SolutionCountAggregateInputType | true
    }

  export interface SolutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Solution'], meta: { name: 'Solution' } }
    /**
     * Find zero or one Solution that matches the filter.
     * @param {SolutionFindUniqueArgs} args - Arguments to find a Solution
     * @example
     * // Get one Solution
     * const solution = await prisma.solution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SolutionFindUniqueArgs>(args: SelectSubset<T, SolutionFindUniqueArgs<ExtArgs>>): Prisma__SolutionClient<$Result.GetResult<Prisma.$SolutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Solution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SolutionFindUniqueOrThrowArgs} args - Arguments to find a Solution
     * @example
     * // Get one Solution
     * const solution = await prisma.solution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SolutionFindUniqueOrThrowArgs>(args: SelectSubset<T, SolutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SolutionClient<$Result.GetResult<Prisma.$SolutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Solution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolutionFindFirstArgs} args - Arguments to find a Solution
     * @example
     * // Get one Solution
     * const solution = await prisma.solution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SolutionFindFirstArgs>(args?: SelectSubset<T, SolutionFindFirstArgs<ExtArgs>>): Prisma__SolutionClient<$Result.GetResult<Prisma.$SolutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Solution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolutionFindFirstOrThrowArgs} args - Arguments to find a Solution
     * @example
     * // Get one Solution
     * const solution = await prisma.solution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SolutionFindFirstOrThrowArgs>(args?: SelectSubset<T, SolutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SolutionClient<$Result.GetResult<Prisma.$SolutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Solutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Solutions
     * const solutions = await prisma.solution.findMany()
     * 
     * // Get first 10 Solutions
     * const solutions = await prisma.solution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const solutionWithIdOnly = await prisma.solution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SolutionFindManyArgs>(args?: SelectSubset<T, SolutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SolutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Solution.
     * @param {SolutionCreateArgs} args - Arguments to create a Solution.
     * @example
     * // Create one Solution
     * const Solution = await prisma.solution.create({
     *   data: {
     *     // ... data to create a Solution
     *   }
     * })
     * 
     */
    create<T extends SolutionCreateArgs>(args: SelectSubset<T, SolutionCreateArgs<ExtArgs>>): Prisma__SolutionClient<$Result.GetResult<Prisma.$SolutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Solutions.
     * @param {SolutionCreateManyArgs} args - Arguments to create many Solutions.
     * @example
     * // Create many Solutions
     * const solution = await prisma.solution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SolutionCreateManyArgs>(args?: SelectSubset<T, SolutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Solutions and returns the data saved in the database.
     * @param {SolutionCreateManyAndReturnArgs} args - Arguments to create many Solutions.
     * @example
     * // Create many Solutions
     * const solution = await prisma.solution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Solutions and only return the `id`
     * const solutionWithIdOnly = await prisma.solution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SolutionCreateManyAndReturnArgs>(args?: SelectSubset<T, SolutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SolutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Solution.
     * @param {SolutionDeleteArgs} args - Arguments to delete one Solution.
     * @example
     * // Delete one Solution
     * const Solution = await prisma.solution.delete({
     *   where: {
     *     // ... filter to delete one Solution
     *   }
     * })
     * 
     */
    delete<T extends SolutionDeleteArgs>(args: SelectSubset<T, SolutionDeleteArgs<ExtArgs>>): Prisma__SolutionClient<$Result.GetResult<Prisma.$SolutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Solution.
     * @param {SolutionUpdateArgs} args - Arguments to update one Solution.
     * @example
     * // Update one Solution
     * const solution = await prisma.solution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SolutionUpdateArgs>(args: SelectSubset<T, SolutionUpdateArgs<ExtArgs>>): Prisma__SolutionClient<$Result.GetResult<Prisma.$SolutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Solutions.
     * @param {SolutionDeleteManyArgs} args - Arguments to filter Solutions to delete.
     * @example
     * // Delete a few Solutions
     * const { count } = await prisma.solution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SolutionDeleteManyArgs>(args?: SelectSubset<T, SolutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Solutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Solutions
     * const solution = await prisma.solution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SolutionUpdateManyArgs>(args: SelectSubset<T, SolutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Solutions and returns the data updated in the database.
     * @param {SolutionUpdateManyAndReturnArgs} args - Arguments to update many Solutions.
     * @example
     * // Update many Solutions
     * const solution = await prisma.solution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Solutions and only return the `id`
     * const solutionWithIdOnly = await prisma.solution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SolutionUpdateManyAndReturnArgs>(args: SelectSubset<T, SolutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SolutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Solution.
     * @param {SolutionUpsertArgs} args - Arguments to update or create a Solution.
     * @example
     * // Update or create a Solution
     * const solution = await prisma.solution.upsert({
     *   create: {
     *     // ... data to create a Solution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Solution we want to update
     *   }
     * })
     */
    upsert<T extends SolutionUpsertArgs>(args: SelectSubset<T, SolutionUpsertArgs<ExtArgs>>): Prisma__SolutionClient<$Result.GetResult<Prisma.$SolutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Solutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolutionCountArgs} args - Arguments to filter Solutions to count.
     * @example
     * // Count the number of Solutions
     * const count = await prisma.solution.count({
     *   where: {
     *     // ... the filter for the Solutions we want to count
     *   }
     * })
    **/
    count<T extends SolutionCountArgs>(
      args?: Subset<T, SolutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SolutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Solution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SolutionAggregateArgs>(args: Subset<T, SolutionAggregateArgs>): Prisma.PrismaPromise<GetSolutionAggregateType<T>>

    /**
     * Group by Solution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SolutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SolutionGroupByArgs['orderBy'] }
        : { orderBy?: SolutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SolutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSolutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Solution model
   */
  readonly fields: SolutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Solution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SolutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotspot<T extends Solution$hotspotArgs<ExtArgs> = {}>(args?: Subset<T, Solution$hotspotArgs<ExtArgs>>): Prisma__HotspotClient<$Result.GetResult<Prisma.$HotspotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    initiative<T extends Solution$initiativeArgs<ExtArgs> = {}>(args?: Subset<T, Solution$initiativeArgs<ExtArgs>>): Prisma__InitiativeClient<$Result.GetResult<Prisma.$InitiativePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    idea<T extends Solution$ideaArgs<ExtArgs> = {}>(args?: Subset<T, Solution$ideaArgs<ExtArgs>>): Prisma__IdeaClient<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    input<T extends Solution$inputArgs<ExtArgs> = {}>(args?: Subset<T, Solution$inputArgs<ExtArgs>>): Prisma__InputClient<$Result.GetResult<Prisma.$InputPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    requirements<T extends Solution$requirementsArgs<ExtArgs> = {}>(args?: Subset<T, Solution$requirementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    frdDocuments<T extends Solution$frdDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Solution$frdDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FRDDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Solution model
   */
  interface SolutionFieldRefs {
    readonly id: FieldRef<"Solution", 'String'>
    readonly title: FieldRef<"Solution", 'String'>
    readonly description: FieldRef<"Solution", 'String'>
    readonly status: FieldRef<"Solution", 'SolutionStatus'>
    readonly hotspotId: FieldRef<"Solution", 'String'>
    readonly initiativeId: FieldRef<"Solution", 'String'>
    readonly ideaId: FieldRef<"Solution", 'String'>
    readonly tasks: FieldRef<"Solution", 'Json'>
    readonly progress: FieldRef<"Solution", 'Float'>
    readonly targetDate: FieldRef<"Solution", 'DateTime'>
    readonly actualCompletionDate: FieldRef<"Solution", 'DateTime'>
    readonly estimatedEffort: FieldRef<"Solution", 'String'>
    readonly businessValue: FieldRef<"Solution", 'String'>
    readonly successMetrics: FieldRef<"Solution", 'Json'>
    readonly expectedImpactJson: FieldRef<"Solution", 'Json'>
    readonly actualImpactJson: FieldRef<"Solution", 'Json'>
    readonly inputId: FieldRef<"Solution", 'String'>
    readonly createdBy: FieldRef<"Solution", 'String'>
    readonly createdAt: FieldRef<"Solution", 'DateTime'>
    readonly updatedAt: FieldRef<"Solution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Solution findUnique
   */
  export type SolutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null
    /**
     * Filter, which Solution to fetch.
     */
    where: SolutionWhereUniqueInput
  }

  /**
   * Solution findUniqueOrThrow
   */
  export type SolutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null
    /**
     * Filter, which Solution to fetch.
     */
    where: SolutionWhereUniqueInput
  }

  /**
   * Solution findFirst
   */
  export type SolutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null
    /**
     * Filter, which Solution to fetch.
     */
    where?: SolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Solutions to fetch.
     */
    orderBy?: SolutionOrderByWithRelationInput | SolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Solutions.
     */
    cursor?: SolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Solutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Solutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Solutions.
     */
    distinct?: SolutionScalarFieldEnum | SolutionScalarFieldEnum[]
  }

  /**
   * Solution findFirstOrThrow
   */
  export type SolutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null
    /**
     * Filter, which Solution to fetch.
     */
    where?: SolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Solutions to fetch.
     */
    orderBy?: SolutionOrderByWithRelationInput | SolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Solutions.
     */
    cursor?: SolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Solutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Solutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Solutions.
     */
    distinct?: SolutionScalarFieldEnum | SolutionScalarFieldEnum[]
  }

  /**
   * Solution findMany
   */
  export type SolutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null
    /**
     * Filter, which Solutions to fetch.
     */
    where?: SolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Solutions to fetch.
     */
    orderBy?: SolutionOrderByWithRelationInput | SolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Solutions.
     */
    cursor?: SolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Solutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Solutions.
     */
    skip?: number
    distinct?: SolutionScalarFieldEnum | SolutionScalarFieldEnum[]
  }

  /**
   * Solution create
   */
  export type SolutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null
    /**
     * The data needed to create a Solution.
     */
    data: XOR<SolutionCreateInput, SolutionUncheckedCreateInput>
  }

  /**
   * Solution createMany
   */
  export type SolutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Solutions.
     */
    data: SolutionCreateManyInput | SolutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Solution createManyAndReturn
   */
  export type SolutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null
    /**
     * The data used to create many Solutions.
     */
    data: SolutionCreateManyInput | SolutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Solution update
   */
  export type SolutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null
    /**
     * The data needed to update a Solution.
     */
    data: XOR<SolutionUpdateInput, SolutionUncheckedUpdateInput>
    /**
     * Choose, which Solution to update.
     */
    where: SolutionWhereUniqueInput
  }

  /**
   * Solution updateMany
   */
  export type SolutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Solutions.
     */
    data: XOR<SolutionUpdateManyMutationInput, SolutionUncheckedUpdateManyInput>
    /**
     * Filter which Solutions to update
     */
    where?: SolutionWhereInput
    /**
     * Limit how many Solutions to update.
     */
    limit?: number
  }

  /**
   * Solution updateManyAndReturn
   */
  export type SolutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null
    /**
     * The data used to update Solutions.
     */
    data: XOR<SolutionUpdateManyMutationInput, SolutionUncheckedUpdateManyInput>
    /**
     * Filter which Solutions to update
     */
    where?: SolutionWhereInput
    /**
     * Limit how many Solutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Solution upsert
   */
  export type SolutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null
    /**
     * The filter to search for the Solution to update in case it exists.
     */
    where: SolutionWhereUniqueInput
    /**
     * In case the Solution found by the `where` argument doesn't exist, create a new Solution with this data.
     */
    create: XOR<SolutionCreateInput, SolutionUncheckedCreateInput>
    /**
     * In case the Solution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SolutionUpdateInput, SolutionUncheckedUpdateInput>
  }

  /**
   * Solution delete
   */
  export type SolutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null
    /**
     * Filter which Solution to delete.
     */
    where: SolutionWhereUniqueInput
  }

  /**
   * Solution deleteMany
   */
  export type SolutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Solutions to delete
     */
    where?: SolutionWhereInput
    /**
     * Limit how many Solutions to delete.
     */
    limit?: number
  }

  /**
   * Solution.hotspot
   */
  export type Solution$hotspotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotspot
     */
    select?: HotspotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotspot
     */
    omit?: HotspotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotspotInclude<ExtArgs> | null
    where?: HotspotWhereInput
  }

  /**
   * Solution.initiative
   */
  export type Solution$initiativeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Initiative
     */
    select?: InitiativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Initiative
     */
    omit?: InitiativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InitiativeInclude<ExtArgs> | null
    where?: InitiativeWhereInput
  }

  /**
   * Solution.idea
   */
  export type Solution$ideaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
    where?: IdeaWhereInput
  }

  /**
   * Solution.input
   */
  export type Solution$inputArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null
    where?: InputWhereInput
  }

  /**
   * Solution.requirements
   */
  export type Solution$requirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    where?: RequirementWhereInput
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    cursor?: RequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[]
  }

  /**
   * Solution.frdDocuments
   */
  export type Solution$frdDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null
    where?: FRDDocumentWhereInput
    orderBy?: FRDDocumentOrderByWithRelationInput | FRDDocumentOrderByWithRelationInput[]
    cursor?: FRDDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FRDDocumentScalarFieldEnum | FRDDocumentScalarFieldEnum[]
  }

  /**
   * Solution without action
   */
  export type SolutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Solution
     */
    select?: SolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Solution
     */
    omit?: SolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SolutionInclude<ExtArgs> | null
  }


  /**
   * Model Requirement
   */

  export type AggregateRequirement = {
    _count: RequirementCountAggregateOutputType | null
    _min: RequirementMinAggregateOutputType | null
    _max: RequirementMaxAggregateOutputType | null
  }

  export type RequirementMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    priority: $Enums.Priority | null
    status: $Enums.RequirementStatus | null
    estimatedEffort: string | null
    businessValue: string | null
    riskAssessment: string | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectionReason: string | null
    solutionId: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RequirementMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    priority: $Enums.Priority | null
    status: $Enums.RequirementStatus | null
    estimatedEffort: string | null
    businessValue: string | null
    riskAssessment: string | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectionReason: string | null
    solutionId: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RequirementCountAggregateOutputType = {
    id: number
    title: number
    description: number
    acceptanceCriteria: number
    priority: number
    status: number
    estimatedEffort: number
    dependencies: number
    businessValue: number
    riskAssessment: number
    stakeholders: number
    approvedBy: number
    approvedAt: number
    rejectionReason: number
    solutionId: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RequirementMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    priority?: true
    status?: true
    estimatedEffort?: true
    businessValue?: true
    riskAssessment?: true
    approvedBy?: true
    approvedAt?: true
    rejectionReason?: true
    solutionId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RequirementMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    priority?: true
    status?: true
    estimatedEffort?: true
    businessValue?: true
    riskAssessment?: true
    approvedBy?: true
    approvedAt?: true
    rejectionReason?: true
    solutionId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RequirementCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    acceptanceCriteria?: true
    priority?: true
    status?: true
    estimatedEffort?: true
    dependencies?: true
    businessValue?: true
    riskAssessment?: true
    stakeholders?: true
    approvedBy?: true
    approvedAt?: true
    rejectionReason?: true
    solutionId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RequirementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Requirement to aggregate.
     */
    where?: RequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requirements to fetch.
     */
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Requirements
    **/
    _count?: true | RequirementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequirementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequirementMaxAggregateInputType
  }

  export type GetRequirementAggregateType<T extends RequirementAggregateArgs> = {
        [P in keyof T & keyof AggregateRequirement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequirement[P]>
      : GetScalarType<T[P], AggregateRequirement[P]>
  }




  export type RequirementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementWhereInput
    orderBy?: RequirementOrderByWithAggregationInput | RequirementOrderByWithAggregationInput[]
    by: RequirementScalarFieldEnum[] | RequirementScalarFieldEnum
    having?: RequirementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequirementCountAggregateInputType | true
    _min?: RequirementMinAggregateInputType
    _max?: RequirementMaxAggregateInputType
  }

  export type RequirementGroupByOutputType = {
    id: string
    title: string
    description: string
    acceptanceCriteria: JsonValue
    priority: $Enums.Priority
    status: $Enums.RequirementStatus
    estimatedEffort: string | null
    dependencies: JsonValue | null
    businessValue: string | null
    riskAssessment: string | null
    stakeholders: JsonValue | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectionReason: string | null
    solutionId: string
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: RequirementCountAggregateOutputType | null
    _min: RequirementMinAggregateOutputType | null
    _max: RequirementMaxAggregateOutputType | null
  }

  type GetRequirementGroupByPayload<T extends RequirementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequirementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequirementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequirementGroupByOutputType[P]>
            : GetScalarType<T[P], RequirementGroupByOutputType[P]>
        }
      >
    >


  export type RequirementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    acceptanceCriteria?: boolean
    priority?: boolean
    status?: boolean
    estimatedEffort?: boolean
    dependencies?: boolean
    businessValue?: boolean
    riskAssessment?: boolean
    stakeholders?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectionReason?: boolean
    solutionId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    solution?: boolean | SolutionDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requirement"]>

  export type RequirementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    acceptanceCriteria?: boolean
    priority?: boolean
    status?: boolean
    estimatedEffort?: boolean
    dependencies?: boolean
    businessValue?: boolean
    riskAssessment?: boolean
    stakeholders?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectionReason?: boolean
    solutionId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    solution?: boolean | SolutionDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requirement"]>

  export type RequirementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    acceptanceCriteria?: boolean
    priority?: boolean
    status?: boolean
    estimatedEffort?: boolean
    dependencies?: boolean
    businessValue?: boolean
    riskAssessment?: boolean
    stakeholders?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectionReason?: boolean
    solutionId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    solution?: boolean | SolutionDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requirement"]>

  export type RequirementSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    acceptanceCriteria?: boolean
    priority?: boolean
    status?: boolean
    estimatedEffort?: boolean
    dependencies?: boolean
    businessValue?: boolean
    riskAssessment?: boolean
    stakeholders?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectionReason?: boolean
    solutionId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RequirementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "acceptanceCriteria" | "priority" | "status" | "estimatedEffort" | "dependencies" | "businessValue" | "riskAssessment" | "stakeholders" | "approvedBy" | "approvedAt" | "rejectionReason" | "solutionId" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["requirement"]>
  export type RequirementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    solution?: boolean | SolutionDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RequirementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    solution?: boolean | SolutionDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RequirementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    solution?: boolean | SolutionDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RequirementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Requirement"
    objects: {
      solution: Prisma.$SolutionPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      acceptanceCriteria: Prisma.JsonValue
      priority: $Enums.Priority
      status: $Enums.RequirementStatus
      estimatedEffort: string | null
      dependencies: Prisma.JsonValue | null
      businessValue: string | null
      riskAssessment: string | null
      stakeholders: Prisma.JsonValue | null
      approvedBy: string | null
      approvedAt: Date | null
      rejectionReason: string | null
      solutionId: string
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["requirement"]>
    composites: {}
  }

  type RequirementGetPayload<S extends boolean | null | undefined | RequirementDefaultArgs> = $Result.GetResult<Prisma.$RequirementPayload, S>

  type RequirementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequirementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequirementCountAggregateInputType | true
    }

  export interface RequirementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Requirement'], meta: { name: 'Requirement' } }
    /**
     * Find zero or one Requirement that matches the filter.
     * @param {RequirementFindUniqueArgs} args - Arguments to find a Requirement
     * @example
     * // Get one Requirement
     * const requirement = await prisma.requirement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequirementFindUniqueArgs>(args: SelectSubset<T, RequirementFindUniqueArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Requirement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequirementFindUniqueOrThrowArgs} args - Arguments to find a Requirement
     * @example
     * // Get one Requirement
     * const requirement = await prisma.requirement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequirementFindUniqueOrThrowArgs>(args: SelectSubset<T, RequirementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Requirement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementFindFirstArgs} args - Arguments to find a Requirement
     * @example
     * // Get one Requirement
     * const requirement = await prisma.requirement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequirementFindFirstArgs>(args?: SelectSubset<T, RequirementFindFirstArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Requirement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementFindFirstOrThrowArgs} args - Arguments to find a Requirement
     * @example
     * // Get one Requirement
     * const requirement = await prisma.requirement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequirementFindFirstOrThrowArgs>(args?: SelectSubset<T, RequirementFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Requirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Requirements
     * const requirements = await prisma.requirement.findMany()
     * 
     * // Get first 10 Requirements
     * const requirements = await prisma.requirement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requirementWithIdOnly = await prisma.requirement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequirementFindManyArgs>(args?: SelectSubset<T, RequirementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Requirement.
     * @param {RequirementCreateArgs} args - Arguments to create a Requirement.
     * @example
     * // Create one Requirement
     * const Requirement = await prisma.requirement.create({
     *   data: {
     *     // ... data to create a Requirement
     *   }
     * })
     * 
     */
    create<T extends RequirementCreateArgs>(args: SelectSubset<T, RequirementCreateArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Requirements.
     * @param {RequirementCreateManyArgs} args - Arguments to create many Requirements.
     * @example
     * // Create many Requirements
     * const requirement = await prisma.requirement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequirementCreateManyArgs>(args?: SelectSubset<T, RequirementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Requirements and returns the data saved in the database.
     * @param {RequirementCreateManyAndReturnArgs} args - Arguments to create many Requirements.
     * @example
     * // Create many Requirements
     * const requirement = await prisma.requirement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Requirements and only return the `id`
     * const requirementWithIdOnly = await prisma.requirement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequirementCreateManyAndReturnArgs>(args?: SelectSubset<T, RequirementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Requirement.
     * @param {RequirementDeleteArgs} args - Arguments to delete one Requirement.
     * @example
     * // Delete one Requirement
     * const Requirement = await prisma.requirement.delete({
     *   where: {
     *     // ... filter to delete one Requirement
     *   }
     * })
     * 
     */
    delete<T extends RequirementDeleteArgs>(args: SelectSubset<T, RequirementDeleteArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Requirement.
     * @param {RequirementUpdateArgs} args - Arguments to update one Requirement.
     * @example
     * // Update one Requirement
     * const requirement = await prisma.requirement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequirementUpdateArgs>(args: SelectSubset<T, RequirementUpdateArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Requirements.
     * @param {RequirementDeleteManyArgs} args - Arguments to filter Requirements to delete.
     * @example
     * // Delete a few Requirements
     * const { count } = await prisma.requirement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequirementDeleteManyArgs>(args?: SelectSubset<T, RequirementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Requirements
     * const requirement = await prisma.requirement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequirementUpdateManyArgs>(args: SelectSubset<T, RequirementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requirements and returns the data updated in the database.
     * @param {RequirementUpdateManyAndReturnArgs} args - Arguments to update many Requirements.
     * @example
     * // Update many Requirements
     * const requirement = await prisma.requirement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Requirements and only return the `id`
     * const requirementWithIdOnly = await prisma.requirement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequirementUpdateManyAndReturnArgs>(args: SelectSubset<T, RequirementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Requirement.
     * @param {RequirementUpsertArgs} args - Arguments to update or create a Requirement.
     * @example
     * // Update or create a Requirement
     * const requirement = await prisma.requirement.upsert({
     *   create: {
     *     // ... data to create a Requirement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Requirement we want to update
     *   }
     * })
     */
    upsert<T extends RequirementUpsertArgs>(args: SelectSubset<T, RequirementUpsertArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Requirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementCountArgs} args - Arguments to filter Requirements to count.
     * @example
     * // Count the number of Requirements
     * const count = await prisma.requirement.count({
     *   where: {
     *     // ... the filter for the Requirements we want to count
     *   }
     * })
    **/
    count<T extends RequirementCountArgs>(
      args?: Subset<T, RequirementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequirementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Requirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequirementAggregateArgs>(args: Subset<T, RequirementAggregateArgs>): Prisma.PrismaPromise<GetRequirementAggregateType<T>>

    /**
     * Group by Requirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequirementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequirementGroupByArgs['orderBy'] }
        : { orderBy?: RequirementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequirementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequirementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Requirement model
   */
  readonly fields: RequirementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Requirement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequirementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    solution<T extends SolutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SolutionDefaultArgs<ExtArgs>>): Prisma__SolutionClient<$Result.GetResult<Prisma.$SolutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Requirement model
   */
  interface RequirementFieldRefs {
    readonly id: FieldRef<"Requirement", 'String'>
    readonly title: FieldRef<"Requirement", 'String'>
    readonly description: FieldRef<"Requirement", 'String'>
    readonly acceptanceCriteria: FieldRef<"Requirement", 'Json'>
    readonly priority: FieldRef<"Requirement", 'Priority'>
    readonly status: FieldRef<"Requirement", 'RequirementStatus'>
    readonly estimatedEffort: FieldRef<"Requirement", 'String'>
    readonly dependencies: FieldRef<"Requirement", 'Json'>
    readonly businessValue: FieldRef<"Requirement", 'String'>
    readonly riskAssessment: FieldRef<"Requirement", 'String'>
    readonly stakeholders: FieldRef<"Requirement", 'Json'>
    readonly approvedBy: FieldRef<"Requirement", 'String'>
    readonly approvedAt: FieldRef<"Requirement", 'DateTime'>
    readonly rejectionReason: FieldRef<"Requirement", 'String'>
    readonly solutionId: FieldRef<"Requirement", 'String'>
    readonly createdBy: FieldRef<"Requirement", 'String'>
    readonly createdAt: FieldRef<"Requirement", 'DateTime'>
    readonly updatedAt: FieldRef<"Requirement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Requirement findUnique
   */
  export type RequirementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter, which Requirement to fetch.
     */
    where: RequirementWhereUniqueInput
  }

  /**
   * Requirement findUniqueOrThrow
   */
  export type RequirementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter, which Requirement to fetch.
     */
    where: RequirementWhereUniqueInput
  }

  /**
   * Requirement findFirst
   */
  export type RequirementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter, which Requirement to fetch.
     */
    where?: RequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requirements to fetch.
     */
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requirements.
     */
    cursor?: RequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requirements.
     */
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[]
  }

  /**
   * Requirement findFirstOrThrow
   */
  export type RequirementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter, which Requirement to fetch.
     */
    where?: RequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requirements to fetch.
     */
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requirements.
     */
    cursor?: RequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requirements.
     */
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[]
  }

  /**
   * Requirement findMany
   */
  export type RequirementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter, which Requirements to fetch.
     */
    where?: RequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requirements to fetch.
     */
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Requirements.
     */
    cursor?: RequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requirements.
     */
    skip?: number
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[]
  }

  /**
   * Requirement create
   */
  export type RequirementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * The data needed to create a Requirement.
     */
    data: XOR<RequirementCreateInput, RequirementUncheckedCreateInput>
  }

  /**
   * Requirement createMany
   */
  export type RequirementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Requirements.
     */
    data: RequirementCreateManyInput | RequirementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Requirement createManyAndReturn
   */
  export type RequirementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * The data used to create many Requirements.
     */
    data: RequirementCreateManyInput | RequirementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Requirement update
   */
  export type RequirementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * The data needed to update a Requirement.
     */
    data: XOR<RequirementUpdateInput, RequirementUncheckedUpdateInput>
    /**
     * Choose, which Requirement to update.
     */
    where: RequirementWhereUniqueInput
  }

  /**
   * Requirement updateMany
   */
  export type RequirementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Requirements.
     */
    data: XOR<RequirementUpdateManyMutationInput, RequirementUncheckedUpdateManyInput>
    /**
     * Filter which Requirements to update
     */
    where?: RequirementWhereInput
    /**
     * Limit how many Requirements to update.
     */
    limit?: number
  }

  /**
   * Requirement updateManyAndReturn
   */
  export type RequirementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * The data used to update Requirements.
     */
    data: XOR<RequirementUpdateManyMutationInput, RequirementUncheckedUpdateManyInput>
    /**
     * Filter which Requirements to update
     */
    where?: RequirementWhereInput
    /**
     * Limit how many Requirements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Requirement upsert
   */
  export type RequirementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * The filter to search for the Requirement to update in case it exists.
     */
    where: RequirementWhereUniqueInput
    /**
     * In case the Requirement found by the `where` argument doesn't exist, create a new Requirement with this data.
     */
    create: XOR<RequirementCreateInput, RequirementUncheckedCreateInput>
    /**
     * In case the Requirement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequirementUpdateInput, RequirementUncheckedUpdateInput>
  }

  /**
   * Requirement delete
   */
  export type RequirementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter which Requirement to delete.
     */
    where: RequirementWhereUniqueInput
  }

  /**
   * Requirement deleteMany
   */
  export type RequirementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Requirements to delete
     */
    where?: RequirementWhereInput
    /**
     * Limit how many Requirements to delete.
     */
    limit?: number
  }

  /**
   * Requirement without action
   */
  export type RequirementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
  }


  /**
   * Model FRDDocument
   */

  export type AggregateFRDDocument = {
    _count: FRDDocumentCountAggregateOutputType | null
    _avg: FRDDocumentAvgAggregateOutputType | null
    _sum: FRDDocumentSumAggregateOutputType | null
    _min: FRDDocumentMinAggregateOutputType | null
    _max: FRDDocumentMaxAggregateOutputType | null
  }

  export type FRDDocumentAvgAggregateOutputType = {
    aiConfidence: number | null
    generationTime: number | null
    wordCount: number | null
  }

  export type FRDDocumentSumAggregateOutputType = {
    aiConfidence: number | null
    generationTime: number | null
    wordCount: number | null
  }

  export type FRDDocumentMinAggregateOutputType = {
    id: string | null
    title: string | null
    aiGenerated: boolean | null
    aiConfidence: number | null
    aiPromptUsed: string | null
    version: string | null
    status: $Enums.FRDStatus | null
    executiveApproved: boolean | null
    templateUsed: string | null
    generationTime: number | null
    wordCount: number | null
    lastExportedAt: Date | null
    solutionId: string | null
    createdBy: string | null
    approvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FRDDocumentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    aiGenerated: boolean | null
    aiConfidence: number | null
    aiPromptUsed: string | null
    version: string | null
    status: $Enums.FRDStatus | null
    executiveApproved: boolean | null
    templateUsed: string | null
    generationTime: number | null
    wordCount: number | null
    lastExportedAt: Date | null
    solutionId: string | null
    createdBy: string | null
    approvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FRDDocumentCountAggregateOutputType = {
    id: number
    title: number
    content: number
    aiGenerated: number
    aiConfidence: number
    aiPromptUsed: number
    version: number
    status: number
    executiveApproved: number
    exportFormats: number
    templateUsed: number
    generationTime: number
    wordCount: number
    lastExportedAt: number
    solutionId: number
    createdBy: number
    approvedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FRDDocumentAvgAggregateInputType = {
    aiConfidence?: true
    generationTime?: true
    wordCount?: true
  }

  export type FRDDocumentSumAggregateInputType = {
    aiConfidence?: true
    generationTime?: true
    wordCount?: true
  }

  export type FRDDocumentMinAggregateInputType = {
    id?: true
    title?: true
    aiGenerated?: true
    aiConfidence?: true
    aiPromptUsed?: true
    version?: true
    status?: true
    executiveApproved?: true
    templateUsed?: true
    generationTime?: true
    wordCount?: true
    lastExportedAt?: true
    solutionId?: true
    createdBy?: true
    approvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FRDDocumentMaxAggregateInputType = {
    id?: true
    title?: true
    aiGenerated?: true
    aiConfidence?: true
    aiPromptUsed?: true
    version?: true
    status?: true
    executiveApproved?: true
    templateUsed?: true
    generationTime?: true
    wordCount?: true
    lastExportedAt?: true
    solutionId?: true
    createdBy?: true
    approvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FRDDocumentCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    aiGenerated?: true
    aiConfidence?: true
    aiPromptUsed?: true
    version?: true
    status?: true
    executiveApproved?: true
    exportFormats?: true
    templateUsed?: true
    generationTime?: true
    wordCount?: true
    lastExportedAt?: true
    solutionId?: true
    createdBy?: true
    approvedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FRDDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FRDDocument to aggregate.
     */
    where?: FRDDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FRDDocuments to fetch.
     */
    orderBy?: FRDDocumentOrderByWithRelationInput | FRDDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FRDDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FRDDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FRDDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FRDDocuments
    **/
    _count?: true | FRDDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FRDDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FRDDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FRDDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FRDDocumentMaxAggregateInputType
  }

  export type GetFRDDocumentAggregateType<T extends FRDDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateFRDDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFRDDocument[P]>
      : GetScalarType<T[P], AggregateFRDDocument[P]>
  }




  export type FRDDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FRDDocumentWhereInput
    orderBy?: FRDDocumentOrderByWithAggregationInput | FRDDocumentOrderByWithAggregationInput[]
    by: FRDDocumentScalarFieldEnum[] | FRDDocumentScalarFieldEnum
    having?: FRDDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FRDDocumentCountAggregateInputType | true
    _avg?: FRDDocumentAvgAggregateInputType
    _sum?: FRDDocumentSumAggregateInputType
    _min?: FRDDocumentMinAggregateInputType
    _max?: FRDDocumentMaxAggregateInputType
  }

  export type FRDDocumentGroupByOutputType = {
    id: string
    title: string
    content: JsonValue
    aiGenerated: boolean
    aiConfidence: number | null
    aiPromptUsed: string | null
    version: string
    status: $Enums.FRDStatus
    executiveApproved: boolean
    exportFormats: JsonValue | null
    templateUsed: string | null
    generationTime: number | null
    wordCount: number | null
    lastExportedAt: Date | null
    solutionId: string
    createdBy: string
    approvedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: FRDDocumentCountAggregateOutputType | null
    _avg: FRDDocumentAvgAggregateOutputType | null
    _sum: FRDDocumentSumAggregateOutputType | null
    _min: FRDDocumentMinAggregateOutputType | null
    _max: FRDDocumentMaxAggregateOutputType | null
  }

  type GetFRDDocumentGroupByPayload<T extends FRDDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FRDDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FRDDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FRDDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], FRDDocumentGroupByOutputType[P]>
        }
      >
    >


  export type FRDDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    aiGenerated?: boolean
    aiConfidence?: boolean
    aiPromptUsed?: boolean
    version?: boolean
    status?: boolean
    executiveApproved?: boolean
    exportFormats?: boolean
    templateUsed?: boolean
    generationTime?: boolean
    wordCount?: boolean
    lastExportedAt?: boolean
    solutionId?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    solution?: boolean | SolutionDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | FRDDocument$approverArgs<ExtArgs>
  }, ExtArgs["result"]["fRDDocument"]>

  export type FRDDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    aiGenerated?: boolean
    aiConfidence?: boolean
    aiPromptUsed?: boolean
    version?: boolean
    status?: boolean
    executiveApproved?: boolean
    exportFormats?: boolean
    templateUsed?: boolean
    generationTime?: boolean
    wordCount?: boolean
    lastExportedAt?: boolean
    solutionId?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    solution?: boolean | SolutionDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | FRDDocument$approverArgs<ExtArgs>
  }, ExtArgs["result"]["fRDDocument"]>

  export type FRDDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    aiGenerated?: boolean
    aiConfidence?: boolean
    aiPromptUsed?: boolean
    version?: boolean
    status?: boolean
    executiveApproved?: boolean
    exportFormats?: boolean
    templateUsed?: boolean
    generationTime?: boolean
    wordCount?: boolean
    lastExportedAt?: boolean
    solutionId?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    solution?: boolean | SolutionDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | FRDDocument$approverArgs<ExtArgs>
  }, ExtArgs["result"]["fRDDocument"]>

  export type FRDDocumentSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    aiGenerated?: boolean
    aiConfidence?: boolean
    aiPromptUsed?: boolean
    version?: boolean
    status?: boolean
    executiveApproved?: boolean
    exportFormats?: boolean
    templateUsed?: boolean
    generationTime?: boolean
    wordCount?: boolean
    lastExportedAt?: boolean
    solutionId?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FRDDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "aiGenerated" | "aiConfidence" | "aiPromptUsed" | "version" | "status" | "executiveApproved" | "exportFormats" | "templateUsed" | "generationTime" | "wordCount" | "lastExportedAt" | "solutionId" | "createdBy" | "approvedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["fRDDocument"]>
  export type FRDDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    solution?: boolean | SolutionDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | FRDDocument$approverArgs<ExtArgs>
  }
  export type FRDDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    solution?: boolean | SolutionDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | FRDDocument$approverArgs<ExtArgs>
  }
  export type FRDDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    solution?: boolean | SolutionDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | FRDDocument$approverArgs<ExtArgs>
  }

  export type $FRDDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FRDDocument"
    objects: {
      solution: Prisma.$SolutionPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: Prisma.JsonValue
      aiGenerated: boolean
      aiConfidence: number | null
      aiPromptUsed: string | null
      version: string
      status: $Enums.FRDStatus
      executiveApproved: boolean
      exportFormats: Prisma.JsonValue | null
      templateUsed: string | null
      generationTime: number | null
      wordCount: number | null
      lastExportedAt: Date | null
      solutionId: string
      createdBy: string
      approvedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fRDDocument"]>
    composites: {}
  }

  type FRDDocumentGetPayload<S extends boolean | null | undefined | FRDDocumentDefaultArgs> = $Result.GetResult<Prisma.$FRDDocumentPayload, S>

  type FRDDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FRDDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FRDDocumentCountAggregateInputType | true
    }

  export interface FRDDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FRDDocument'], meta: { name: 'FRDDocument' } }
    /**
     * Find zero or one FRDDocument that matches the filter.
     * @param {FRDDocumentFindUniqueArgs} args - Arguments to find a FRDDocument
     * @example
     * // Get one FRDDocument
     * const fRDDocument = await prisma.fRDDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FRDDocumentFindUniqueArgs>(args: SelectSubset<T, FRDDocumentFindUniqueArgs<ExtArgs>>): Prisma__FRDDocumentClient<$Result.GetResult<Prisma.$FRDDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FRDDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FRDDocumentFindUniqueOrThrowArgs} args - Arguments to find a FRDDocument
     * @example
     * // Get one FRDDocument
     * const fRDDocument = await prisma.fRDDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FRDDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, FRDDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FRDDocumentClient<$Result.GetResult<Prisma.$FRDDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FRDDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FRDDocumentFindFirstArgs} args - Arguments to find a FRDDocument
     * @example
     * // Get one FRDDocument
     * const fRDDocument = await prisma.fRDDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FRDDocumentFindFirstArgs>(args?: SelectSubset<T, FRDDocumentFindFirstArgs<ExtArgs>>): Prisma__FRDDocumentClient<$Result.GetResult<Prisma.$FRDDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FRDDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FRDDocumentFindFirstOrThrowArgs} args - Arguments to find a FRDDocument
     * @example
     * // Get one FRDDocument
     * const fRDDocument = await prisma.fRDDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FRDDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, FRDDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__FRDDocumentClient<$Result.GetResult<Prisma.$FRDDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FRDDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FRDDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FRDDocuments
     * const fRDDocuments = await prisma.fRDDocument.findMany()
     * 
     * // Get first 10 FRDDocuments
     * const fRDDocuments = await prisma.fRDDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fRDDocumentWithIdOnly = await prisma.fRDDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FRDDocumentFindManyArgs>(args?: SelectSubset<T, FRDDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FRDDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FRDDocument.
     * @param {FRDDocumentCreateArgs} args - Arguments to create a FRDDocument.
     * @example
     * // Create one FRDDocument
     * const FRDDocument = await prisma.fRDDocument.create({
     *   data: {
     *     // ... data to create a FRDDocument
     *   }
     * })
     * 
     */
    create<T extends FRDDocumentCreateArgs>(args: SelectSubset<T, FRDDocumentCreateArgs<ExtArgs>>): Prisma__FRDDocumentClient<$Result.GetResult<Prisma.$FRDDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FRDDocuments.
     * @param {FRDDocumentCreateManyArgs} args - Arguments to create many FRDDocuments.
     * @example
     * // Create many FRDDocuments
     * const fRDDocument = await prisma.fRDDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FRDDocumentCreateManyArgs>(args?: SelectSubset<T, FRDDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FRDDocuments and returns the data saved in the database.
     * @param {FRDDocumentCreateManyAndReturnArgs} args - Arguments to create many FRDDocuments.
     * @example
     * // Create many FRDDocuments
     * const fRDDocument = await prisma.fRDDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FRDDocuments and only return the `id`
     * const fRDDocumentWithIdOnly = await prisma.fRDDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FRDDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, FRDDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FRDDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FRDDocument.
     * @param {FRDDocumentDeleteArgs} args - Arguments to delete one FRDDocument.
     * @example
     * // Delete one FRDDocument
     * const FRDDocument = await prisma.fRDDocument.delete({
     *   where: {
     *     // ... filter to delete one FRDDocument
     *   }
     * })
     * 
     */
    delete<T extends FRDDocumentDeleteArgs>(args: SelectSubset<T, FRDDocumentDeleteArgs<ExtArgs>>): Prisma__FRDDocumentClient<$Result.GetResult<Prisma.$FRDDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FRDDocument.
     * @param {FRDDocumentUpdateArgs} args - Arguments to update one FRDDocument.
     * @example
     * // Update one FRDDocument
     * const fRDDocument = await prisma.fRDDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FRDDocumentUpdateArgs>(args: SelectSubset<T, FRDDocumentUpdateArgs<ExtArgs>>): Prisma__FRDDocumentClient<$Result.GetResult<Prisma.$FRDDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FRDDocuments.
     * @param {FRDDocumentDeleteManyArgs} args - Arguments to filter FRDDocuments to delete.
     * @example
     * // Delete a few FRDDocuments
     * const { count } = await prisma.fRDDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FRDDocumentDeleteManyArgs>(args?: SelectSubset<T, FRDDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FRDDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FRDDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FRDDocuments
     * const fRDDocument = await prisma.fRDDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FRDDocumentUpdateManyArgs>(args: SelectSubset<T, FRDDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FRDDocuments and returns the data updated in the database.
     * @param {FRDDocumentUpdateManyAndReturnArgs} args - Arguments to update many FRDDocuments.
     * @example
     * // Update many FRDDocuments
     * const fRDDocument = await prisma.fRDDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FRDDocuments and only return the `id`
     * const fRDDocumentWithIdOnly = await prisma.fRDDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FRDDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, FRDDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FRDDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FRDDocument.
     * @param {FRDDocumentUpsertArgs} args - Arguments to update or create a FRDDocument.
     * @example
     * // Update or create a FRDDocument
     * const fRDDocument = await prisma.fRDDocument.upsert({
     *   create: {
     *     // ... data to create a FRDDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FRDDocument we want to update
     *   }
     * })
     */
    upsert<T extends FRDDocumentUpsertArgs>(args: SelectSubset<T, FRDDocumentUpsertArgs<ExtArgs>>): Prisma__FRDDocumentClient<$Result.GetResult<Prisma.$FRDDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FRDDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FRDDocumentCountArgs} args - Arguments to filter FRDDocuments to count.
     * @example
     * // Count the number of FRDDocuments
     * const count = await prisma.fRDDocument.count({
     *   where: {
     *     // ... the filter for the FRDDocuments we want to count
     *   }
     * })
    **/
    count<T extends FRDDocumentCountArgs>(
      args?: Subset<T, FRDDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FRDDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FRDDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FRDDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FRDDocumentAggregateArgs>(args: Subset<T, FRDDocumentAggregateArgs>): Prisma.PrismaPromise<GetFRDDocumentAggregateType<T>>

    /**
     * Group by FRDDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FRDDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FRDDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FRDDocumentGroupByArgs['orderBy'] }
        : { orderBy?: FRDDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FRDDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFRDDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FRDDocument model
   */
  readonly fields: FRDDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FRDDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FRDDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    solution<T extends SolutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SolutionDefaultArgs<ExtArgs>>): Prisma__SolutionClient<$Result.GetResult<Prisma.$SolutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approver<T extends FRDDocument$approverArgs<ExtArgs> = {}>(args?: Subset<T, FRDDocument$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FRDDocument model
   */
  interface FRDDocumentFieldRefs {
    readonly id: FieldRef<"FRDDocument", 'String'>
    readonly title: FieldRef<"FRDDocument", 'String'>
    readonly content: FieldRef<"FRDDocument", 'Json'>
    readonly aiGenerated: FieldRef<"FRDDocument", 'Boolean'>
    readonly aiConfidence: FieldRef<"FRDDocument", 'Float'>
    readonly aiPromptUsed: FieldRef<"FRDDocument", 'String'>
    readonly version: FieldRef<"FRDDocument", 'String'>
    readonly status: FieldRef<"FRDDocument", 'FRDStatus'>
    readonly executiveApproved: FieldRef<"FRDDocument", 'Boolean'>
    readonly exportFormats: FieldRef<"FRDDocument", 'Json'>
    readonly templateUsed: FieldRef<"FRDDocument", 'String'>
    readonly generationTime: FieldRef<"FRDDocument", 'Float'>
    readonly wordCount: FieldRef<"FRDDocument", 'Int'>
    readonly lastExportedAt: FieldRef<"FRDDocument", 'DateTime'>
    readonly solutionId: FieldRef<"FRDDocument", 'String'>
    readonly createdBy: FieldRef<"FRDDocument", 'String'>
    readonly approvedBy: FieldRef<"FRDDocument", 'String'>
    readonly createdAt: FieldRef<"FRDDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"FRDDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FRDDocument findUnique
   */
  export type FRDDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null
    /**
     * Filter, which FRDDocument to fetch.
     */
    where: FRDDocumentWhereUniqueInput
  }

  /**
   * FRDDocument findUniqueOrThrow
   */
  export type FRDDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null
    /**
     * Filter, which FRDDocument to fetch.
     */
    where: FRDDocumentWhereUniqueInput
  }

  /**
   * FRDDocument findFirst
   */
  export type FRDDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null
    /**
     * Filter, which FRDDocument to fetch.
     */
    where?: FRDDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FRDDocuments to fetch.
     */
    orderBy?: FRDDocumentOrderByWithRelationInput | FRDDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FRDDocuments.
     */
    cursor?: FRDDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FRDDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FRDDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FRDDocuments.
     */
    distinct?: FRDDocumentScalarFieldEnum | FRDDocumentScalarFieldEnum[]
  }

  /**
   * FRDDocument findFirstOrThrow
   */
  export type FRDDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null
    /**
     * Filter, which FRDDocument to fetch.
     */
    where?: FRDDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FRDDocuments to fetch.
     */
    orderBy?: FRDDocumentOrderByWithRelationInput | FRDDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FRDDocuments.
     */
    cursor?: FRDDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FRDDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FRDDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FRDDocuments.
     */
    distinct?: FRDDocumentScalarFieldEnum | FRDDocumentScalarFieldEnum[]
  }

  /**
   * FRDDocument findMany
   */
  export type FRDDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null
    /**
     * Filter, which FRDDocuments to fetch.
     */
    where?: FRDDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FRDDocuments to fetch.
     */
    orderBy?: FRDDocumentOrderByWithRelationInput | FRDDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FRDDocuments.
     */
    cursor?: FRDDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FRDDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FRDDocuments.
     */
    skip?: number
    distinct?: FRDDocumentScalarFieldEnum | FRDDocumentScalarFieldEnum[]
  }

  /**
   * FRDDocument create
   */
  export type FRDDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a FRDDocument.
     */
    data: XOR<FRDDocumentCreateInput, FRDDocumentUncheckedCreateInput>
  }

  /**
   * FRDDocument createMany
   */
  export type FRDDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FRDDocuments.
     */
    data: FRDDocumentCreateManyInput | FRDDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FRDDocument createManyAndReturn
   */
  export type FRDDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many FRDDocuments.
     */
    data: FRDDocumentCreateManyInput | FRDDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FRDDocument update
   */
  export type FRDDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a FRDDocument.
     */
    data: XOR<FRDDocumentUpdateInput, FRDDocumentUncheckedUpdateInput>
    /**
     * Choose, which FRDDocument to update.
     */
    where: FRDDocumentWhereUniqueInput
  }

  /**
   * FRDDocument updateMany
   */
  export type FRDDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FRDDocuments.
     */
    data: XOR<FRDDocumentUpdateManyMutationInput, FRDDocumentUncheckedUpdateManyInput>
    /**
     * Filter which FRDDocuments to update
     */
    where?: FRDDocumentWhereInput
    /**
     * Limit how many FRDDocuments to update.
     */
    limit?: number
  }

  /**
   * FRDDocument updateManyAndReturn
   */
  export type FRDDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null
    /**
     * The data used to update FRDDocuments.
     */
    data: XOR<FRDDocumentUpdateManyMutationInput, FRDDocumentUncheckedUpdateManyInput>
    /**
     * Filter which FRDDocuments to update
     */
    where?: FRDDocumentWhereInput
    /**
     * Limit how many FRDDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FRDDocument upsert
   */
  export type FRDDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the FRDDocument to update in case it exists.
     */
    where: FRDDocumentWhereUniqueInput
    /**
     * In case the FRDDocument found by the `where` argument doesn't exist, create a new FRDDocument with this data.
     */
    create: XOR<FRDDocumentCreateInput, FRDDocumentUncheckedCreateInput>
    /**
     * In case the FRDDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FRDDocumentUpdateInput, FRDDocumentUncheckedUpdateInput>
  }

  /**
   * FRDDocument delete
   */
  export type FRDDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null
    /**
     * Filter which FRDDocument to delete.
     */
    where: FRDDocumentWhereUniqueInput
  }

  /**
   * FRDDocument deleteMany
   */
  export type FRDDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FRDDocuments to delete
     */
    where?: FRDDocumentWhereInput
    /**
     * Limit how many FRDDocuments to delete.
     */
    limit?: number
  }

  /**
   * FRDDocument.approver
   */
  export type FRDDocument$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * FRDDocument without action
   */
  export type FRDDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FRDDocument
     */
    select?: FRDDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FRDDocument
     */
    omit?: FRDDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FRDDocumentInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    entityType: $Enums.EntityType | null
    entityId: string | null
    parentId: string | null
    edited: boolean | null
    editedAt: Date | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    entityType: $Enums.EntityType | null
    entityId: string | null
    parentId: string | null
    edited: boolean | null
    editedAt: Date | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    content: number
    entityType: number
    entityId: number
    parentId: number
    mentions: number
    edited: number
    editedAt: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    content?: true
    entityType?: true
    entityId?: true
    parentId?: true
    edited?: true
    editedAt?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    content?: true
    entityType?: true
    entityId?: true
    parentId?: true
    edited?: true
    editedAt?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    content?: true
    entityType?: true
    entityId?: true
    parentId?: true
    mentions?: true
    edited?: true
    editedAt?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    content: string
    entityType: $Enums.EntityType
    entityId: string
    parentId: string | null
    mentions: JsonValue | null
    edited: boolean
    editedAt: Date | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    entityType?: boolean
    entityId?: boolean
    parentId?: boolean
    mentions?: boolean
    edited?: boolean
    editedAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    thread?: boolean | Comment$threadArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    entityType?: boolean
    entityId?: boolean
    parentId?: boolean
    mentions?: boolean
    edited?: boolean
    editedAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    thread?: boolean | Comment$threadArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    entityType?: boolean
    entityId?: boolean
    parentId?: boolean
    mentions?: boolean
    edited?: boolean
    editedAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    thread?: boolean | Comment$threadArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    content?: boolean
    entityType?: boolean
    entityId?: boolean
    parentId?: boolean
    mentions?: boolean
    edited?: boolean
    editedAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "entityType" | "entityId" | "parentId" | "mentions" | "edited" | "editedAt" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | Comment$threadArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | Comment$threadArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | Comment$threadArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      thread: Prisma.$CommentPayload<ExtArgs> | null
      replies: Prisma.$CommentPayload<ExtArgs>[]
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      entityType: $Enums.EntityType
      entityId: string
      parentId: string | null
      mentions: Prisma.JsonValue | null
      edited: boolean
      editedAt: Date | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    thread<T extends Comment$threadArgs<ExtArgs> = {}>(args?: Subset<T, Comment$threadArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly entityType: FieldRef<"Comment", 'EntityType'>
    readonly entityId: FieldRef<"Comment", 'String'>
    readonly parentId: FieldRef<"Comment", 'String'>
    readonly mentions: FieldRef<"Comment", 'Json'>
    readonly edited: FieldRef<"Comment", 'Boolean'>
    readonly editedAt: FieldRef<"Comment", 'DateTime'>
    readonly createdBy: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.thread
   */
  export type Comment$threadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Vote
   */

  export type AggregateVote = {
    _count: VoteCountAggregateOutputType | null
    _min: VoteMinAggregateOutputType | null
    _max: VoteMaxAggregateOutputType | null
  }

  export type VoteMinAggregateOutputType = {
    id: string | null
    value: $Enums.VoteValue | null
    entityType: $Enums.EntityType | null
    entityId: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type VoteMaxAggregateOutputType = {
    id: string | null
    value: $Enums.VoteValue | null
    entityType: $Enums.EntityType | null
    entityId: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type VoteCountAggregateOutputType = {
    id: number
    value: number
    entityType: number
    entityId: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type VoteMinAggregateInputType = {
    id?: true
    value?: true
    entityType?: true
    entityId?: true
    createdBy?: true
    createdAt?: true
  }

  export type VoteMaxAggregateInputType = {
    id?: true
    value?: true
    entityType?: true
    entityId?: true
    createdBy?: true
    createdAt?: true
  }

  export type VoteCountAggregateInputType = {
    id?: true
    value?: true
    entityType?: true
    entityId?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type VoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vote to aggregate.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Votes
    **/
    _count?: true | VoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoteMaxAggregateInputType
  }

  export type GetVoteAggregateType<T extends VoteAggregateArgs> = {
        [P in keyof T & keyof AggregateVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVote[P]>
      : GetScalarType<T[P], AggregateVote[P]>
  }




  export type VoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithAggregationInput | VoteOrderByWithAggregationInput[]
    by: VoteScalarFieldEnum[] | VoteScalarFieldEnum
    having?: VoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoteCountAggregateInputType | true
    _min?: VoteMinAggregateInputType
    _max?: VoteMaxAggregateInputType
  }

  export type VoteGroupByOutputType = {
    id: string
    value: $Enums.VoteValue
    entityType: $Enums.EntityType
    entityId: string
    createdBy: string
    createdAt: Date
    _count: VoteCountAggregateOutputType | null
    _min: VoteMinAggregateOutputType | null
    _max: VoteMaxAggregateOutputType | null
  }

  type GetVoteGroupByPayload<T extends VoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoteGroupByOutputType[P]>
            : GetScalarType<T[P], VoteGroupByOutputType[P]>
        }
      >
    >


  export type VoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    entityType?: boolean
    entityId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vote"]>

  export type VoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    entityType?: boolean
    entityId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vote"]>

  export type VoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    entityType?: boolean
    entityId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vote"]>

  export type VoteSelectScalar = {
    id?: boolean
    value?: boolean
    entityType?: boolean
    entityId?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type VoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "entityType" | "entityId" | "createdBy" | "createdAt", ExtArgs["result"]["vote"]>
  export type VoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vote"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: $Enums.VoteValue
      entityType: $Enums.EntityType
      entityId: string
      createdBy: string
      createdAt: Date
    }, ExtArgs["result"]["vote"]>
    composites: {}
  }

  type VoteGetPayload<S extends boolean | null | undefined | VoteDefaultArgs> = $Result.GetResult<Prisma.$VotePayload, S>

  type VoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoteCountAggregateInputType | true
    }

  export interface VoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vote'], meta: { name: 'Vote' } }
    /**
     * Find zero or one Vote that matches the filter.
     * @param {VoteFindUniqueArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoteFindUniqueArgs>(args: SelectSubset<T, VoteFindUniqueArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoteFindUniqueOrThrowArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoteFindUniqueOrThrowArgs>(args: SelectSubset<T, VoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindFirstArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoteFindFirstArgs>(args?: SelectSubset<T, VoteFindFirstArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindFirstOrThrowArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoteFindFirstOrThrowArgs>(args?: SelectSubset<T, VoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Votes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Votes
     * const votes = await prisma.vote.findMany()
     * 
     * // Get first 10 Votes
     * const votes = await prisma.vote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voteWithIdOnly = await prisma.vote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoteFindManyArgs>(args?: SelectSubset<T, VoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vote.
     * @param {VoteCreateArgs} args - Arguments to create a Vote.
     * @example
     * // Create one Vote
     * const Vote = await prisma.vote.create({
     *   data: {
     *     // ... data to create a Vote
     *   }
     * })
     * 
     */
    create<T extends VoteCreateArgs>(args: SelectSubset<T, VoteCreateArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Votes.
     * @param {VoteCreateManyArgs} args - Arguments to create many Votes.
     * @example
     * // Create many Votes
     * const vote = await prisma.vote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoteCreateManyArgs>(args?: SelectSubset<T, VoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Votes and returns the data saved in the database.
     * @param {VoteCreateManyAndReturnArgs} args - Arguments to create many Votes.
     * @example
     * // Create many Votes
     * const vote = await prisma.vote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Votes and only return the `id`
     * const voteWithIdOnly = await prisma.vote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoteCreateManyAndReturnArgs>(args?: SelectSubset<T, VoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vote.
     * @param {VoteDeleteArgs} args - Arguments to delete one Vote.
     * @example
     * // Delete one Vote
     * const Vote = await prisma.vote.delete({
     *   where: {
     *     // ... filter to delete one Vote
     *   }
     * })
     * 
     */
    delete<T extends VoteDeleteArgs>(args: SelectSubset<T, VoteDeleteArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vote.
     * @param {VoteUpdateArgs} args - Arguments to update one Vote.
     * @example
     * // Update one Vote
     * const vote = await prisma.vote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoteUpdateArgs>(args: SelectSubset<T, VoteUpdateArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Votes.
     * @param {VoteDeleteManyArgs} args - Arguments to filter Votes to delete.
     * @example
     * // Delete a few Votes
     * const { count } = await prisma.vote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoteDeleteManyArgs>(args?: SelectSubset<T, VoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Votes
     * const vote = await prisma.vote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoteUpdateManyArgs>(args: SelectSubset<T, VoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Votes and returns the data updated in the database.
     * @param {VoteUpdateManyAndReturnArgs} args - Arguments to update many Votes.
     * @example
     * // Update many Votes
     * const vote = await prisma.vote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Votes and only return the `id`
     * const voteWithIdOnly = await prisma.vote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoteUpdateManyAndReturnArgs>(args: SelectSubset<T, VoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vote.
     * @param {VoteUpsertArgs} args - Arguments to update or create a Vote.
     * @example
     * // Update or create a Vote
     * const vote = await prisma.vote.upsert({
     *   create: {
     *     // ... data to create a Vote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vote we want to update
     *   }
     * })
     */
    upsert<T extends VoteUpsertArgs>(args: SelectSubset<T, VoteUpsertArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteCountArgs} args - Arguments to filter Votes to count.
     * @example
     * // Count the number of Votes
     * const count = await prisma.vote.count({
     *   where: {
     *     // ... the filter for the Votes we want to count
     *   }
     * })
    **/
    count<T extends VoteCountArgs>(
      args?: Subset<T, VoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoteAggregateArgs>(args: Subset<T, VoteAggregateArgs>): Prisma.PrismaPromise<GetVoteAggregateType<T>>

    /**
     * Group by Vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoteGroupByArgs['orderBy'] }
        : { orderBy?: VoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vote model
   */
  readonly fields: VoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vote model
   */
  interface VoteFieldRefs {
    readonly id: FieldRef<"Vote", 'String'>
    readonly value: FieldRef<"Vote", 'VoteValue'>
    readonly entityType: FieldRef<"Vote", 'EntityType'>
    readonly entityId: FieldRef<"Vote", 'String'>
    readonly createdBy: FieldRef<"Vote", 'String'>
    readonly createdAt: FieldRef<"Vote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vote findUnique
   */
  export type VoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote findUniqueOrThrow
   */
  export type VoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote findFirst
   */
  export type VoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Votes.
     */
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote findFirstOrThrow
   */
  export type VoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Votes.
     */
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote findMany
   */
  export type VoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Votes to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote create
   */
  export type VoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Vote.
     */
    data: XOR<VoteCreateInput, VoteUncheckedCreateInput>
  }

  /**
   * Vote createMany
   */
  export type VoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Votes.
     */
    data: VoteCreateManyInput | VoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vote createManyAndReturn
   */
  export type VoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * The data used to create many Votes.
     */
    data: VoteCreateManyInput | VoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vote update
   */
  export type VoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Vote.
     */
    data: XOR<VoteUpdateInput, VoteUncheckedUpdateInput>
    /**
     * Choose, which Vote to update.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote updateMany
   */
  export type VoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Votes.
     */
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyInput>
    /**
     * Filter which Votes to update
     */
    where?: VoteWhereInput
    /**
     * Limit how many Votes to update.
     */
    limit?: number
  }

  /**
   * Vote updateManyAndReturn
   */
  export type VoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * The data used to update Votes.
     */
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyInput>
    /**
     * Filter which Votes to update
     */
    where?: VoteWhereInput
    /**
     * Limit how many Votes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vote upsert
   */
  export type VoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Vote to update in case it exists.
     */
    where: VoteWhereUniqueInput
    /**
     * In case the Vote found by the `where` argument doesn't exist, create a new Vote with this data.
     */
    create: XOR<VoteCreateInput, VoteUncheckedCreateInput>
    /**
     * In case the Vote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoteUpdateInput, VoteUncheckedUpdateInput>
  }

  /**
   * Vote delete
   */
  export type VoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter which Vote to delete.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote deleteMany
   */
  export type VoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Votes to delete
     */
    where?: VoteWhereInput
    /**
     * Limit how many Votes to delete.
     */
    limit?: number
  }

  /**
   * Vote without action
   */
  export type VoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
  }


  /**
   * Model InputGroup
   */

  export type AggregateInputGroup = {
    _count: InputGroupCountAggregateOutputType | null
    _avg: InputGroupAvgAggregateOutputType | null
    _sum: InputGroupSumAggregateOutputType | null
    _min: InputGroupMinAggregateOutputType | null
    _max: InputGroupMaxAggregateOutputType | null
  }

  export type InputGroupAvgAggregateOutputType = {
    aiConfidence: number | null
    inputCount: number | null
    avgPriority: number | null
  }

  export type InputGroupSumAggregateOutputType = {
    aiConfidence: number | null
    inputCount: number | null
    avgPriority: number | null
  }

  export type InputGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    color: string | null
    aiSuggested: boolean | null
    aiConfidence: number | null
    aiReasoning: string | null
    inputCount: number | null
    avgPriority: number | null
    lastActivity: Date | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InputGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    color: string | null
    aiSuggested: boolean | null
    aiConfidence: number | null
    aiReasoning: string | null
    inputCount: number | null
    avgPriority: number | null
    lastActivity: Date | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InputGroupCountAggregateOutputType = {
    id: number
    name: number
    description: number
    color: number
    aiSuggested: number
    aiConfidence: number
    aiReasoning: number
    inputCount: number
    avgPriority: number
    lastActivity: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InputGroupAvgAggregateInputType = {
    aiConfidence?: true
    inputCount?: true
    avgPriority?: true
  }

  export type InputGroupSumAggregateInputType = {
    aiConfidence?: true
    inputCount?: true
    avgPriority?: true
  }

  export type InputGroupMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    aiSuggested?: true
    aiConfidence?: true
    aiReasoning?: true
    inputCount?: true
    avgPriority?: true
    lastActivity?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InputGroupMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    aiSuggested?: true
    aiConfidence?: true
    aiReasoning?: true
    inputCount?: true
    avgPriority?: true
    lastActivity?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InputGroupCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    aiSuggested?: true
    aiConfidence?: true
    aiReasoning?: true
    inputCount?: true
    avgPriority?: true
    lastActivity?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InputGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InputGroup to aggregate.
     */
    where?: InputGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InputGroups to fetch.
     */
    orderBy?: InputGroupOrderByWithRelationInput | InputGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InputGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InputGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InputGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InputGroups
    **/
    _count?: true | InputGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InputGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InputGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InputGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InputGroupMaxAggregateInputType
  }

  export type GetInputGroupAggregateType<T extends InputGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateInputGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInputGroup[P]>
      : GetScalarType<T[P], AggregateInputGroup[P]>
  }




  export type InputGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InputGroupWhereInput
    orderBy?: InputGroupOrderByWithAggregationInput | InputGroupOrderByWithAggregationInput[]
    by: InputGroupScalarFieldEnum[] | InputGroupScalarFieldEnum
    having?: InputGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InputGroupCountAggregateInputType | true
    _avg?: InputGroupAvgAggregateInputType
    _sum?: InputGroupSumAggregateInputType
    _min?: InputGroupMinAggregateInputType
    _max?: InputGroupMaxAggregateInputType
  }

  export type InputGroupGroupByOutputType = {
    id: string
    name: string
    description: string | null
    color: string | null
    aiSuggested: boolean
    aiConfidence: number | null
    aiReasoning: string | null
    inputCount: number
    avgPriority: number | null
    lastActivity: Date | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: InputGroupCountAggregateOutputType | null
    _avg: InputGroupAvgAggregateOutputType | null
    _sum: InputGroupSumAggregateOutputType | null
    _min: InputGroupMinAggregateOutputType | null
    _max: InputGroupMaxAggregateOutputType | null
  }

  type GetInputGroupGroupByPayload<T extends InputGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InputGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InputGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InputGroupGroupByOutputType[P]>
            : GetScalarType<T[P], InputGroupGroupByOutputType[P]>
        }
      >
    >


  export type InputGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    aiSuggested?: boolean
    aiConfidence?: boolean
    aiReasoning?: boolean
    inputCount?: boolean
    avgPriority?: boolean
    lastActivity?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    inputs?: boolean | InputGroup$inputsArgs<ExtArgs>
    _count?: boolean | InputGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inputGroup"]>

  export type InputGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    aiSuggested?: boolean
    aiConfidence?: boolean
    aiReasoning?: boolean
    inputCount?: boolean
    avgPriority?: boolean
    lastActivity?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inputGroup"]>

  export type InputGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    aiSuggested?: boolean
    aiConfidence?: boolean
    aiReasoning?: boolean
    inputCount?: boolean
    avgPriority?: boolean
    lastActivity?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inputGroup"]>

  export type InputGroupSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    aiSuggested?: boolean
    aiConfidence?: boolean
    aiReasoning?: boolean
    inputCount?: boolean
    avgPriority?: boolean
    lastActivity?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InputGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "color" | "aiSuggested" | "aiConfidence" | "aiReasoning" | "inputCount" | "avgPriority" | "lastActivity" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["inputGroup"]>
  export type InputGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    inputs?: boolean | InputGroup$inputsArgs<ExtArgs>
    _count?: boolean | InputGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InputGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InputGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InputGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InputGroup"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      inputs: Prisma.$InputPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      color: string | null
      aiSuggested: boolean
      aiConfidence: number | null
      aiReasoning: string | null
      inputCount: number
      avgPriority: number | null
      lastActivity: Date | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inputGroup"]>
    composites: {}
  }

  type InputGroupGetPayload<S extends boolean | null | undefined | InputGroupDefaultArgs> = $Result.GetResult<Prisma.$InputGroupPayload, S>

  type InputGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InputGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InputGroupCountAggregateInputType | true
    }

  export interface InputGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InputGroup'], meta: { name: 'InputGroup' } }
    /**
     * Find zero or one InputGroup that matches the filter.
     * @param {InputGroupFindUniqueArgs} args - Arguments to find a InputGroup
     * @example
     * // Get one InputGroup
     * const inputGroup = await prisma.inputGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InputGroupFindUniqueArgs>(args: SelectSubset<T, InputGroupFindUniqueArgs<ExtArgs>>): Prisma__InputGroupClient<$Result.GetResult<Prisma.$InputGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InputGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InputGroupFindUniqueOrThrowArgs} args - Arguments to find a InputGroup
     * @example
     * // Get one InputGroup
     * const inputGroup = await prisma.inputGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InputGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, InputGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InputGroupClient<$Result.GetResult<Prisma.$InputGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InputGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputGroupFindFirstArgs} args - Arguments to find a InputGroup
     * @example
     * // Get one InputGroup
     * const inputGroup = await prisma.inputGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InputGroupFindFirstArgs>(args?: SelectSubset<T, InputGroupFindFirstArgs<ExtArgs>>): Prisma__InputGroupClient<$Result.GetResult<Prisma.$InputGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InputGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputGroupFindFirstOrThrowArgs} args - Arguments to find a InputGroup
     * @example
     * // Get one InputGroup
     * const inputGroup = await prisma.inputGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InputGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, InputGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__InputGroupClient<$Result.GetResult<Prisma.$InputGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InputGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InputGroups
     * const inputGroups = await prisma.inputGroup.findMany()
     * 
     * // Get first 10 InputGroups
     * const inputGroups = await prisma.inputGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inputGroupWithIdOnly = await prisma.inputGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InputGroupFindManyArgs>(args?: SelectSubset<T, InputGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InputGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InputGroup.
     * @param {InputGroupCreateArgs} args - Arguments to create a InputGroup.
     * @example
     * // Create one InputGroup
     * const InputGroup = await prisma.inputGroup.create({
     *   data: {
     *     // ... data to create a InputGroup
     *   }
     * })
     * 
     */
    create<T extends InputGroupCreateArgs>(args: SelectSubset<T, InputGroupCreateArgs<ExtArgs>>): Prisma__InputGroupClient<$Result.GetResult<Prisma.$InputGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InputGroups.
     * @param {InputGroupCreateManyArgs} args - Arguments to create many InputGroups.
     * @example
     * // Create many InputGroups
     * const inputGroup = await prisma.inputGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InputGroupCreateManyArgs>(args?: SelectSubset<T, InputGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InputGroups and returns the data saved in the database.
     * @param {InputGroupCreateManyAndReturnArgs} args - Arguments to create many InputGroups.
     * @example
     * // Create many InputGroups
     * const inputGroup = await prisma.inputGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InputGroups and only return the `id`
     * const inputGroupWithIdOnly = await prisma.inputGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InputGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, InputGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InputGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InputGroup.
     * @param {InputGroupDeleteArgs} args - Arguments to delete one InputGroup.
     * @example
     * // Delete one InputGroup
     * const InputGroup = await prisma.inputGroup.delete({
     *   where: {
     *     // ... filter to delete one InputGroup
     *   }
     * })
     * 
     */
    delete<T extends InputGroupDeleteArgs>(args: SelectSubset<T, InputGroupDeleteArgs<ExtArgs>>): Prisma__InputGroupClient<$Result.GetResult<Prisma.$InputGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InputGroup.
     * @param {InputGroupUpdateArgs} args - Arguments to update one InputGroup.
     * @example
     * // Update one InputGroup
     * const inputGroup = await prisma.inputGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InputGroupUpdateArgs>(args: SelectSubset<T, InputGroupUpdateArgs<ExtArgs>>): Prisma__InputGroupClient<$Result.GetResult<Prisma.$InputGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InputGroups.
     * @param {InputGroupDeleteManyArgs} args - Arguments to filter InputGroups to delete.
     * @example
     * // Delete a few InputGroups
     * const { count } = await prisma.inputGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InputGroupDeleteManyArgs>(args?: SelectSubset<T, InputGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InputGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InputGroups
     * const inputGroup = await prisma.inputGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InputGroupUpdateManyArgs>(args: SelectSubset<T, InputGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InputGroups and returns the data updated in the database.
     * @param {InputGroupUpdateManyAndReturnArgs} args - Arguments to update many InputGroups.
     * @example
     * // Update many InputGroups
     * const inputGroup = await prisma.inputGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InputGroups and only return the `id`
     * const inputGroupWithIdOnly = await prisma.inputGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InputGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, InputGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InputGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InputGroup.
     * @param {InputGroupUpsertArgs} args - Arguments to update or create a InputGroup.
     * @example
     * // Update or create a InputGroup
     * const inputGroup = await prisma.inputGroup.upsert({
     *   create: {
     *     // ... data to create a InputGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InputGroup we want to update
     *   }
     * })
     */
    upsert<T extends InputGroupUpsertArgs>(args: SelectSubset<T, InputGroupUpsertArgs<ExtArgs>>): Prisma__InputGroupClient<$Result.GetResult<Prisma.$InputGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InputGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputGroupCountArgs} args - Arguments to filter InputGroups to count.
     * @example
     * // Count the number of InputGroups
     * const count = await prisma.inputGroup.count({
     *   where: {
     *     // ... the filter for the InputGroups we want to count
     *   }
     * })
    **/
    count<T extends InputGroupCountArgs>(
      args?: Subset<T, InputGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InputGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InputGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InputGroupAggregateArgs>(args: Subset<T, InputGroupAggregateArgs>): Prisma.PrismaPromise<GetInputGroupAggregateType<T>>

    /**
     * Group by InputGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InputGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InputGroupGroupByArgs['orderBy'] }
        : { orderBy?: InputGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InputGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInputGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InputGroup model
   */
  readonly fields: InputGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InputGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InputGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inputs<T extends InputGroup$inputsArgs<ExtArgs> = {}>(args?: Subset<T, InputGroup$inputsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InputPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InputGroup model
   */
  interface InputGroupFieldRefs {
    readonly id: FieldRef<"InputGroup", 'String'>
    readonly name: FieldRef<"InputGroup", 'String'>
    readonly description: FieldRef<"InputGroup", 'String'>
    readonly color: FieldRef<"InputGroup", 'String'>
    readonly aiSuggested: FieldRef<"InputGroup", 'Boolean'>
    readonly aiConfidence: FieldRef<"InputGroup", 'Float'>
    readonly aiReasoning: FieldRef<"InputGroup", 'String'>
    readonly inputCount: FieldRef<"InputGroup", 'Int'>
    readonly avgPriority: FieldRef<"InputGroup", 'Float'>
    readonly lastActivity: FieldRef<"InputGroup", 'DateTime'>
    readonly createdBy: FieldRef<"InputGroup", 'String'>
    readonly createdAt: FieldRef<"InputGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"InputGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InputGroup findUnique
   */
  export type InputGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null
    /**
     * Filter, which InputGroup to fetch.
     */
    where: InputGroupWhereUniqueInput
  }

  /**
   * InputGroup findUniqueOrThrow
   */
  export type InputGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null
    /**
     * Filter, which InputGroup to fetch.
     */
    where: InputGroupWhereUniqueInput
  }

  /**
   * InputGroup findFirst
   */
  export type InputGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null
    /**
     * Filter, which InputGroup to fetch.
     */
    where?: InputGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InputGroups to fetch.
     */
    orderBy?: InputGroupOrderByWithRelationInput | InputGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InputGroups.
     */
    cursor?: InputGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InputGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InputGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InputGroups.
     */
    distinct?: InputGroupScalarFieldEnum | InputGroupScalarFieldEnum[]
  }

  /**
   * InputGroup findFirstOrThrow
   */
  export type InputGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null
    /**
     * Filter, which InputGroup to fetch.
     */
    where?: InputGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InputGroups to fetch.
     */
    orderBy?: InputGroupOrderByWithRelationInput | InputGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InputGroups.
     */
    cursor?: InputGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InputGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InputGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InputGroups.
     */
    distinct?: InputGroupScalarFieldEnum | InputGroupScalarFieldEnum[]
  }

  /**
   * InputGroup findMany
   */
  export type InputGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null
    /**
     * Filter, which InputGroups to fetch.
     */
    where?: InputGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InputGroups to fetch.
     */
    orderBy?: InputGroupOrderByWithRelationInput | InputGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InputGroups.
     */
    cursor?: InputGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InputGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InputGroups.
     */
    skip?: number
    distinct?: InputGroupScalarFieldEnum | InputGroupScalarFieldEnum[]
  }

  /**
   * InputGroup create
   */
  export type InputGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a InputGroup.
     */
    data: XOR<InputGroupCreateInput, InputGroupUncheckedCreateInput>
  }

  /**
   * InputGroup createMany
   */
  export type InputGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InputGroups.
     */
    data: InputGroupCreateManyInput | InputGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InputGroup createManyAndReturn
   */
  export type InputGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null
    /**
     * The data used to create many InputGroups.
     */
    data: InputGroupCreateManyInput | InputGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InputGroup update
   */
  export type InputGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a InputGroup.
     */
    data: XOR<InputGroupUpdateInput, InputGroupUncheckedUpdateInput>
    /**
     * Choose, which InputGroup to update.
     */
    where: InputGroupWhereUniqueInput
  }

  /**
   * InputGroup updateMany
   */
  export type InputGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InputGroups.
     */
    data: XOR<InputGroupUpdateManyMutationInput, InputGroupUncheckedUpdateManyInput>
    /**
     * Filter which InputGroups to update
     */
    where?: InputGroupWhereInput
    /**
     * Limit how many InputGroups to update.
     */
    limit?: number
  }

  /**
   * InputGroup updateManyAndReturn
   */
  export type InputGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null
    /**
     * The data used to update InputGroups.
     */
    data: XOR<InputGroupUpdateManyMutationInput, InputGroupUncheckedUpdateManyInput>
    /**
     * Filter which InputGroups to update
     */
    where?: InputGroupWhereInput
    /**
     * Limit how many InputGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InputGroup upsert
   */
  export type InputGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the InputGroup to update in case it exists.
     */
    where: InputGroupWhereUniqueInput
    /**
     * In case the InputGroup found by the `where` argument doesn't exist, create a new InputGroup with this data.
     */
    create: XOR<InputGroupCreateInput, InputGroupUncheckedCreateInput>
    /**
     * In case the InputGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InputGroupUpdateInput, InputGroupUncheckedUpdateInput>
  }

  /**
   * InputGroup delete
   */
  export type InputGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null
    /**
     * Filter which InputGroup to delete.
     */
    where: InputGroupWhereUniqueInput
  }

  /**
   * InputGroup deleteMany
   */
  export type InputGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InputGroups to delete
     */
    where?: InputGroupWhereInput
    /**
     * Limit how many InputGroups to delete.
     */
    limit?: number
  }

  /**
   * InputGroup.inputs
   */
  export type InputGroup$inputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Input
     */
    select?: InputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Input
     */
    omit?: InputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputInclude<ExtArgs> | null
    where?: InputWhereInput
    orderBy?: InputOrderByWithRelationInput | InputOrderByWithRelationInput[]
    cursor?: InputWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InputScalarFieldEnum | InputScalarFieldEnum[]
  }

  /**
   * InputGroup without action
   */
  export type InputGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InputGroup
     */
    select?: InputGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InputGroup
     */
    omit?: InputGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InputGroupInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    sessionId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    sessionId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    action: number
    entityType: number
    entityId: number
    changes: number
    ipAddress: number
    userAgent: number
    sessionId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    sessionId?: true
    userId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    sessionId?: true
    userId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    changes?: true
    ipAddress?: true
    userAgent?: true
    sessionId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    action: string
    entityType: string
    entityId: string
    changes: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    sessionId: string | null
    userId: string
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    sessionId?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    sessionId?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    sessionId?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    sessionId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "entityType" | "entityId" | "changes" | "ipAddress" | "userAgent" | "sessionId" | "userId" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      entityType: string
      entityId: string
      changes: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      sessionId: string | null
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly changes: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly sessionId: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    entityType: $Enums.EntityType | null
    entityId: string | null
    read: boolean | null
    readAt: Date | null
    delivered: boolean | null
    userId: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    entityType: $Enums.EntityType | null
    entityId: string | null
    read: boolean | null
    readAt: Date | null
    delivered: boolean | null
    userId: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    title: number
    message: number
    entityType: number
    entityId: number
    read: number
    readAt: number
    delivered: number
    userId: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    entityType?: true
    entityId?: true
    read?: true
    readAt?: true
    delivered?: true
    userId?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    entityType?: true
    entityId?: true
    read?: true
    readAt?: true
    delivered?: true
    userId?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    entityType?: true
    entityId?: true
    read?: true
    readAt?: true
    delivered?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    type: $Enums.NotificationType
    title: string
    message: string
    entityType: $Enums.EntityType | null
    entityId: string | null
    read: boolean
    readAt: Date | null
    delivered: boolean
    userId: string
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    entityType?: boolean
    entityId?: boolean
    read?: boolean
    readAt?: boolean
    delivered?: boolean
    userId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    entityType?: boolean
    entityId?: boolean
    read?: boolean
    readAt?: boolean
    delivered?: boolean
    userId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    entityType?: boolean
    entityId?: boolean
    read?: boolean
    readAt?: boolean
    delivered?: boolean
    userId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    entityType?: boolean
    entityId?: boolean
    read?: boolean
    readAt?: boolean
    delivered?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "title" | "message" | "entityType" | "entityId" | "read" | "readAt" | "delivered" | "userId" | "createdAt", ExtArgs["result"]["notification"]>

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.NotificationType
      title: string
      message: string
      entityType: $Enums.EntityType | null
      entityId: string | null
      read: boolean
      readAt: Date | null
      delivered: boolean
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly entityType: FieldRef<"Notification", 'EntityType'>
    readonly entityId: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly delivered: FieldRef<"Notification", 'Boolean'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    role: 'role',
    department: 'department',
    avatar: 'avatar',
    passwordHash: 'passwordHash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    departmentId: 'departmentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const InitiativeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    ownerId: 'ownerId',
    goalJson: 'goalJson',
    roiJson: 'roiJson',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InitiativeScalarFieldEnum = (typeof InitiativeScalarFieldEnum)[keyof typeof InitiativeScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const SignalScalarFieldEnum: {
    id: 'id',
    inputId: 'inputId',
    timestamp: 'timestamp',
    receivedAt: 'receivedAt',
    schemaVersion: 'schemaVersion',
    sourceJson: 'sourceJson',
    confidence: 'confidence',
    attachmentsJson: 'attachmentsJson',
    sourceType: 'sourceType',
    sourceId: 'sourceId',
    systemName: 'systemName',
    title: 'title',
    description: 'description',
    severity: 'severity',
    severityScore: 'severityScore',
    departmentId: 'departmentId',
    teamId: 'teamId',
    metricsJson: 'metricsJson',
    baselineJson: 'baselineJson',
    impactJson: 'impactJson',
    tagsJson: 'tagsJson',
    entitiesJson: 'entitiesJson',
    privacyLevel: 'privacyLevel',
    dedupeKey: 'dedupeKey',
    embedding: 'embedding',
    aiProcessed: 'aiProcessed',
    aiTagsJson: 'aiTagsJson',
    lineageJson: 'lineageJson',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SignalScalarFieldEnum = (typeof SignalScalarFieldEnum)[keyof typeof SignalScalarFieldEnum]


  export const HotspotScalarFieldEnum: {
    id: 'id',
    title: 'title',
    summary: 'summary',
    status: 'status',
    rankScore: 'rankScore',
    confidence: 'confidence',
    primaryCategoryId: 'primaryCategoryId',
    linkedEntitiesJson: 'linkedEntitiesJson',
    clusteringMethod: 'clusteringMethod',
    similarityThreshold: 'similarityThreshold',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HotspotScalarFieldEnum = (typeof HotspotScalarFieldEnum)[keyof typeof HotspotScalarFieldEnum]


  export const HotspotSignalScalarFieldEnum: {
    hotspotId: 'hotspotId',
    signalId: 'signalId',
    membershipStrength: 'membershipStrength',
    isOutlier: 'isOutlier',
    addedAt: 'addedAt'
  };

  export type HotspotSignalScalarFieldEnum = (typeof HotspotSignalScalarFieldEnum)[keyof typeof HotspotSignalScalarFieldEnum]


  export const IdeaScalarFieldEnum: {
    id: 'id',
    hotspotId: 'hotspotId',
    title: 'title',
    description: 'description',
    origin: 'origin',
    votes: 'votes',
    status: 'status',
    evidenceJson: 'evidenceJson',
    tagsJson: 'tagsJson',
    confidence: 'confidence',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IdeaScalarFieldEnum = (typeof IdeaScalarFieldEnum)[keyof typeof IdeaScalarFieldEnum]


  export const InputScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    type: 'type',
    department: 'department',
    issueType: 'issueType',
    rootCause: 'rootCause',
    priority: 'priority',
    aiTags: 'aiTags',
    aiConfidence: 'aiConfidence',
    aiSuggestions: 'aiSuggestions',
    status: 'status',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InputScalarFieldEnum = (typeof InputScalarFieldEnum)[keyof typeof InputScalarFieldEnum]


  export const SolutionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    hotspotId: 'hotspotId',
    initiativeId: 'initiativeId',
    ideaId: 'ideaId',
    tasks: 'tasks',
    progress: 'progress',
    targetDate: 'targetDate',
    actualCompletionDate: 'actualCompletionDate',
    estimatedEffort: 'estimatedEffort',
    businessValue: 'businessValue',
    successMetrics: 'successMetrics',
    expectedImpactJson: 'expectedImpactJson',
    actualImpactJson: 'actualImpactJson',
    inputId: 'inputId',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SolutionScalarFieldEnum = (typeof SolutionScalarFieldEnum)[keyof typeof SolutionScalarFieldEnum]


  export const RequirementScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    acceptanceCriteria: 'acceptanceCriteria',
    priority: 'priority',
    status: 'status',
    estimatedEffort: 'estimatedEffort',
    dependencies: 'dependencies',
    businessValue: 'businessValue',
    riskAssessment: 'riskAssessment',
    stakeholders: 'stakeholders',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    rejectionReason: 'rejectionReason',
    solutionId: 'solutionId',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RequirementScalarFieldEnum = (typeof RequirementScalarFieldEnum)[keyof typeof RequirementScalarFieldEnum]


  export const FRDDocumentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    aiGenerated: 'aiGenerated',
    aiConfidence: 'aiConfidence',
    aiPromptUsed: 'aiPromptUsed',
    version: 'version',
    status: 'status',
    executiveApproved: 'executiveApproved',
    exportFormats: 'exportFormats',
    templateUsed: 'templateUsed',
    generationTime: 'generationTime',
    wordCount: 'wordCount',
    lastExportedAt: 'lastExportedAt',
    solutionId: 'solutionId',
    createdBy: 'createdBy',
    approvedBy: 'approvedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FRDDocumentScalarFieldEnum = (typeof FRDDocumentScalarFieldEnum)[keyof typeof FRDDocumentScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    entityType: 'entityType',
    entityId: 'entityId',
    parentId: 'parentId',
    mentions: 'mentions',
    edited: 'edited',
    editedAt: 'editedAt',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const VoteScalarFieldEnum: {
    id: 'id',
    value: 'value',
    entityType: 'entityType',
    entityId: 'entityId',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type VoteScalarFieldEnum = (typeof VoteScalarFieldEnum)[keyof typeof VoteScalarFieldEnum]


  export const InputGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    color: 'color',
    aiSuggested: 'aiSuggested',
    aiConfidence: 'aiConfidence',
    aiReasoning: 'aiReasoning',
    inputCount: 'inputCount',
    avgPriority: 'avgPriority',
    lastActivity: 'lastActivity',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InputGroupScalarFieldEnum = (typeof InputGroupScalarFieldEnum)[keyof typeof InputGroupScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    changes: 'changes',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    sessionId: 'sessionId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    message: 'message',
    entityType: 'entityType',
    entityId: 'entityId',
    read: 'read',
    readAt: 'readAt',
    delivered: 'delivered',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Severity'
   */
  export type EnumSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Severity'>
    


  /**
   * Reference to a field of type 'Severity[]'
   */
  export type ListEnumSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Severity[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'HotspotStatus'
   */
  export type EnumHotspotStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HotspotStatus'>
    


  /**
   * Reference to a field of type 'HotspotStatus[]'
   */
  export type ListEnumHotspotStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HotspotStatus[]'>
    


  /**
   * Reference to a field of type 'InputType'
   */
  export type EnumInputTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InputType'>
    


  /**
   * Reference to a field of type 'InputType[]'
   */
  export type ListEnumInputTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InputType[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'InputStatus'
   */
  export type EnumInputStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InputStatus'>
    


  /**
   * Reference to a field of type 'InputStatus[]'
   */
  export type ListEnumInputStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InputStatus[]'>
    


  /**
   * Reference to a field of type 'SolutionStatus'
   */
  export type EnumSolutionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SolutionStatus'>
    


  /**
   * Reference to a field of type 'SolutionStatus[]'
   */
  export type ListEnumSolutionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SolutionStatus[]'>
    


  /**
   * Reference to a field of type 'RequirementStatus'
   */
  export type EnumRequirementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequirementStatus'>
    


  /**
   * Reference to a field of type 'RequirementStatus[]'
   */
  export type ListEnumRequirementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequirementStatus[]'>
    


  /**
   * Reference to a field of type 'FRDStatus'
   */
  export type EnumFRDStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FRDStatus'>
    


  /**
   * Reference to a field of type 'FRDStatus[]'
   */
  export type ListEnumFRDStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FRDStatus[]'>
    


  /**
   * Reference to a field of type 'EntityType'
   */
  export type EnumEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntityType'>
    


  /**
   * Reference to a field of type 'EntityType[]'
   */
  export type ListEnumEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntityType[]'>
    


  /**
   * Reference to a field of type 'VoteValue'
   */
  export type EnumVoteValueFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoteValue'>
    


  /**
   * Reference to a field of type 'VoteValue[]'
   */
  export type ListEnumVoteValueFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoteValue[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    department?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    inputs?: InputListRelationFilter
    signals?: SignalListRelationFilter
    initiatives?: InitiativeListRelationFilter
    ideas?: IdeaListRelationFilter
    solutions?: SolutionListRelationFilter
    comments?: CommentListRelationFilter
    votes?: VoteListRelationFilter
    requirements?: RequirementListRelationFilter
    frdDocuments?: FRDDocumentListRelationFilter
    approvedFRDs?: FRDDocumentListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    inputGroups?: InputGroupListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inputs?: InputOrderByRelationAggregateInput
    signals?: SignalOrderByRelationAggregateInput
    initiatives?: InitiativeOrderByRelationAggregateInput
    ideas?: IdeaOrderByRelationAggregateInput
    solutions?: SolutionOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    votes?: VoteOrderByRelationAggregateInput
    requirements?: RequirementOrderByRelationAggregateInput
    frdDocuments?: FRDDocumentOrderByRelationAggregateInput
    approvedFRDs?: FRDDocumentOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    inputGroups?: InputGroupOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    department?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    inputs?: InputListRelationFilter
    signals?: SignalListRelationFilter
    initiatives?: InitiativeListRelationFilter
    ideas?: IdeaListRelationFilter
    solutions?: SolutionListRelationFilter
    comments?: CommentListRelationFilter
    votes?: VoteListRelationFilter
    requirements?: RequirementListRelationFilter
    frdDocuments?: FRDDocumentListRelationFilter
    approvedFRDs?: FRDDocumentListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    inputGroups?: InputGroupListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    department?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    teams?: TeamListRelationFilter
    signals?: SignalListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teams?: TeamOrderByRelationAggregateInput
    signals?: SignalOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    teams?: TeamListRelationFilter
    signals?: SignalListRelationFilter
  }, "id" | "name">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    departmentId?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    signals?: SignalListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    signals?: SignalOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    name?: StringFilter<"Team"> | string
    departmentId?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    signals?: SignalListRelationFilter
  }, "id">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    departmentId?: StringNullableWithAggregatesFilter<"Team"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type InitiativeWhereInput = {
    AND?: InitiativeWhereInput | InitiativeWhereInput[]
    OR?: InitiativeWhereInput[]
    NOT?: InitiativeWhereInput | InitiativeWhereInput[]
    id?: StringFilter<"Initiative"> | string
    name?: StringFilter<"Initiative"> | string
    description?: StringNullableFilter<"Initiative"> | string | null
    ownerId?: StringNullableFilter<"Initiative"> | string | null
    goalJson?: JsonNullableFilter<"Initiative">
    roiJson?: JsonNullableFilter<"Initiative">
    createdAt?: DateTimeFilter<"Initiative"> | Date | string
    updatedAt?: DateTimeFilter<"Initiative"> | Date | string
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    solutions?: SolutionListRelationFilter
  }

  export type InitiativeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    goalJson?: SortOrderInput | SortOrder
    roiJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    solutions?: SolutionOrderByRelationAggregateInput
  }

  export type InitiativeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: InitiativeWhereInput | InitiativeWhereInput[]
    OR?: InitiativeWhereInput[]
    NOT?: InitiativeWhereInput | InitiativeWhereInput[]
    description?: StringNullableFilter<"Initiative"> | string | null
    ownerId?: StringNullableFilter<"Initiative"> | string | null
    goalJson?: JsonNullableFilter<"Initiative">
    roiJson?: JsonNullableFilter<"Initiative">
    createdAt?: DateTimeFilter<"Initiative"> | Date | string
    updatedAt?: DateTimeFilter<"Initiative"> | Date | string
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    solutions?: SolutionListRelationFilter
  }, "id" | "name">

  export type InitiativeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    goalJson?: SortOrderInput | SortOrder
    roiJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InitiativeCountOrderByAggregateInput
    _max?: InitiativeMaxOrderByAggregateInput
    _min?: InitiativeMinOrderByAggregateInput
  }

  export type InitiativeScalarWhereWithAggregatesInput = {
    AND?: InitiativeScalarWhereWithAggregatesInput | InitiativeScalarWhereWithAggregatesInput[]
    OR?: InitiativeScalarWhereWithAggregatesInput[]
    NOT?: InitiativeScalarWhereWithAggregatesInput | InitiativeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Initiative"> | string
    name?: StringWithAggregatesFilter<"Initiative"> | string
    description?: StringNullableWithAggregatesFilter<"Initiative"> | string | null
    ownerId?: StringNullableWithAggregatesFilter<"Initiative"> | string | null
    goalJson?: JsonNullableWithAggregatesFilter<"Initiative">
    roiJson?: JsonNullableWithAggregatesFilter<"Initiative">
    createdAt?: DateTimeWithAggregatesFilter<"Initiative"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Initiative"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    createdAt?: DateTimeFilter<"Category"> | Date | string
  }, "id" | "name">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type SignalWhereInput = {
    AND?: SignalWhereInput | SignalWhereInput[]
    OR?: SignalWhereInput[]
    NOT?: SignalWhereInput | SignalWhereInput[]
    id?: StringFilter<"Signal"> | string
    inputId?: StringFilter<"Signal"> | string
    timestamp?: DateTimeFilter<"Signal"> | Date | string
    receivedAt?: DateTimeFilter<"Signal"> | Date | string
    schemaVersion?: StringFilter<"Signal"> | string
    sourceJson?: JsonNullableFilter<"Signal">
    confidence?: FloatNullableFilter<"Signal"> | number | null
    attachmentsJson?: JsonNullableFilter<"Signal">
    sourceType?: StringFilter<"Signal"> | string
    sourceId?: StringNullableFilter<"Signal"> | string | null
    systemName?: StringNullableFilter<"Signal"> | string | null
    title?: StringNullableFilter<"Signal"> | string | null
    description?: StringFilter<"Signal"> | string
    severity?: EnumSeverityFilter<"Signal"> | $Enums.Severity
    severityScore?: IntFilter<"Signal"> | number
    departmentId?: StringNullableFilter<"Signal"> | string | null
    teamId?: StringNullableFilter<"Signal"> | string | null
    metricsJson?: JsonNullableFilter<"Signal">
    baselineJson?: JsonNullableFilter<"Signal">
    impactJson?: JsonNullableFilter<"Signal">
    tagsJson?: JsonNullableFilter<"Signal">
    entitiesJson?: JsonNullableFilter<"Signal">
    privacyLevel?: StringNullableFilter<"Signal"> | string | null
    dedupeKey?: StringNullableFilter<"Signal"> | string | null
    embedding?: BytesNullableFilter<"Signal"> | Uint8Array | null
    aiProcessed?: BoolFilter<"Signal"> | boolean
    aiTagsJson?: JsonNullableFilter<"Signal">
    lineageJson?: JsonNullableFilter<"Signal">
    createdById?: StringNullableFilter<"Signal"> | string | null
    createdAt?: DateTimeFilter<"Signal"> | Date | string
    updatedAt?: DateTimeFilter<"Signal"> | Date | string
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    hotspots?: HotspotSignalListRelationFilter
  }

  export type SignalOrderByWithRelationInput = {
    id?: SortOrder
    inputId?: SortOrder
    timestamp?: SortOrder
    receivedAt?: SortOrder
    schemaVersion?: SortOrder
    sourceJson?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    attachmentsJson?: SortOrderInput | SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    systemName?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrder
    severity?: SortOrder
    severityScore?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    metricsJson?: SortOrderInput | SortOrder
    baselineJson?: SortOrderInput | SortOrder
    impactJson?: SortOrderInput | SortOrder
    tagsJson?: SortOrderInput | SortOrder
    entitiesJson?: SortOrderInput | SortOrder
    privacyLevel?: SortOrderInput | SortOrder
    dedupeKey?: SortOrderInput | SortOrder
    embedding?: SortOrderInput | SortOrder
    aiProcessed?: SortOrder
    aiTagsJson?: SortOrderInput | SortOrder
    lineageJson?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    hotspots?: HotspotSignalOrderByRelationAggregateInput
  }

  export type SignalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    inputId?: string
    dedupeKey?: string
    AND?: SignalWhereInput | SignalWhereInput[]
    OR?: SignalWhereInput[]
    NOT?: SignalWhereInput | SignalWhereInput[]
    timestamp?: DateTimeFilter<"Signal"> | Date | string
    receivedAt?: DateTimeFilter<"Signal"> | Date | string
    schemaVersion?: StringFilter<"Signal"> | string
    sourceJson?: JsonNullableFilter<"Signal">
    confidence?: FloatNullableFilter<"Signal"> | number | null
    attachmentsJson?: JsonNullableFilter<"Signal">
    sourceType?: StringFilter<"Signal"> | string
    sourceId?: StringNullableFilter<"Signal"> | string | null
    systemName?: StringNullableFilter<"Signal"> | string | null
    title?: StringNullableFilter<"Signal"> | string | null
    description?: StringFilter<"Signal"> | string
    severity?: EnumSeverityFilter<"Signal"> | $Enums.Severity
    severityScore?: IntFilter<"Signal"> | number
    departmentId?: StringNullableFilter<"Signal"> | string | null
    teamId?: StringNullableFilter<"Signal"> | string | null
    metricsJson?: JsonNullableFilter<"Signal">
    baselineJson?: JsonNullableFilter<"Signal">
    impactJson?: JsonNullableFilter<"Signal">
    tagsJson?: JsonNullableFilter<"Signal">
    entitiesJson?: JsonNullableFilter<"Signal">
    privacyLevel?: StringNullableFilter<"Signal"> | string | null
    embedding?: BytesNullableFilter<"Signal"> | Uint8Array | null
    aiProcessed?: BoolFilter<"Signal"> | boolean
    aiTagsJson?: JsonNullableFilter<"Signal">
    lineageJson?: JsonNullableFilter<"Signal">
    createdById?: StringNullableFilter<"Signal"> | string | null
    createdAt?: DateTimeFilter<"Signal"> | Date | string
    updatedAt?: DateTimeFilter<"Signal"> | Date | string
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    hotspots?: HotspotSignalListRelationFilter
  }, "id" | "inputId" | "dedupeKey">

  export type SignalOrderByWithAggregationInput = {
    id?: SortOrder
    inputId?: SortOrder
    timestamp?: SortOrder
    receivedAt?: SortOrder
    schemaVersion?: SortOrder
    sourceJson?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    attachmentsJson?: SortOrderInput | SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    systemName?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrder
    severity?: SortOrder
    severityScore?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    metricsJson?: SortOrderInput | SortOrder
    baselineJson?: SortOrderInput | SortOrder
    impactJson?: SortOrderInput | SortOrder
    tagsJson?: SortOrderInput | SortOrder
    entitiesJson?: SortOrderInput | SortOrder
    privacyLevel?: SortOrderInput | SortOrder
    dedupeKey?: SortOrderInput | SortOrder
    embedding?: SortOrderInput | SortOrder
    aiProcessed?: SortOrder
    aiTagsJson?: SortOrderInput | SortOrder
    lineageJson?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SignalCountOrderByAggregateInput
    _avg?: SignalAvgOrderByAggregateInput
    _max?: SignalMaxOrderByAggregateInput
    _min?: SignalMinOrderByAggregateInput
    _sum?: SignalSumOrderByAggregateInput
  }

  export type SignalScalarWhereWithAggregatesInput = {
    AND?: SignalScalarWhereWithAggregatesInput | SignalScalarWhereWithAggregatesInput[]
    OR?: SignalScalarWhereWithAggregatesInput[]
    NOT?: SignalScalarWhereWithAggregatesInput | SignalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Signal"> | string
    inputId?: StringWithAggregatesFilter<"Signal"> | string
    timestamp?: DateTimeWithAggregatesFilter<"Signal"> | Date | string
    receivedAt?: DateTimeWithAggregatesFilter<"Signal"> | Date | string
    schemaVersion?: StringWithAggregatesFilter<"Signal"> | string
    sourceJson?: JsonNullableWithAggregatesFilter<"Signal">
    confidence?: FloatNullableWithAggregatesFilter<"Signal"> | number | null
    attachmentsJson?: JsonNullableWithAggregatesFilter<"Signal">
    sourceType?: StringWithAggregatesFilter<"Signal"> | string
    sourceId?: StringNullableWithAggregatesFilter<"Signal"> | string | null
    systemName?: StringNullableWithAggregatesFilter<"Signal"> | string | null
    title?: StringNullableWithAggregatesFilter<"Signal"> | string | null
    description?: StringWithAggregatesFilter<"Signal"> | string
    severity?: EnumSeverityWithAggregatesFilter<"Signal"> | $Enums.Severity
    severityScore?: IntWithAggregatesFilter<"Signal"> | number
    departmentId?: StringNullableWithAggregatesFilter<"Signal"> | string | null
    teamId?: StringNullableWithAggregatesFilter<"Signal"> | string | null
    metricsJson?: JsonNullableWithAggregatesFilter<"Signal">
    baselineJson?: JsonNullableWithAggregatesFilter<"Signal">
    impactJson?: JsonNullableWithAggregatesFilter<"Signal">
    tagsJson?: JsonNullableWithAggregatesFilter<"Signal">
    entitiesJson?: JsonNullableWithAggregatesFilter<"Signal">
    privacyLevel?: StringNullableWithAggregatesFilter<"Signal"> | string | null
    dedupeKey?: StringNullableWithAggregatesFilter<"Signal"> | string | null
    embedding?: BytesNullableWithAggregatesFilter<"Signal"> | Uint8Array | null
    aiProcessed?: BoolWithAggregatesFilter<"Signal"> | boolean
    aiTagsJson?: JsonNullableWithAggregatesFilter<"Signal">
    lineageJson?: JsonNullableWithAggregatesFilter<"Signal">
    createdById?: StringNullableWithAggregatesFilter<"Signal"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Signal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Signal"> | Date | string
  }

  export type HotspotWhereInput = {
    AND?: HotspotWhereInput | HotspotWhereInput[]
    OR?: HotspotWhereInput[]
    NOT?: HotspotWhereInput | HotspotWhereInput[]
    id?: StringFilter<"Hotspot"> | string
    title?: StringFilter<"Hotspot"> | string
    summary?: StringFilter<"Hotspot"> | string
    status?: EnumHotspotStatusFilter<"Hotspot"> | $Enums.HotspotStatus
    rankScore?: FloatFilter<"Hotspot"> | number
    confidence?: FloatFilter<"Hotspot"> | number
    primaryCategoryId?: StringNullableFilter<"Hotspot"> | string | null
    linkedEntitiesJson?: JsonNullableFilter<"Hotspot">
    clusteringMethod?: StringNullableFilter<"Hotspot"> | string | null
    similarityThreshold?: FloatNullableFilter<"Hotspot"> | number | null
    createdAt?: DateTimeFilter<"Hotspot"> | Date | string
    updatedAt?: DateTimeFilter<"Hotspot"> | Date | string
    signals?: HotspotSignalListRelationFilter
    ideas?: IdeaListRelationFilter
    solutions?: SolutionListRelationFilter
  }

  export type HotspotOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    rankScore?: SortOrder
    confidence?: SortOrder
    primaryCategoryId?: SortOrderInput | SortOrder
    linkedEntitiesJson?: SortOrderInput | SortOrder
    clusteringMethod?: SortOrderInput | SortOrder
    similarityThreshold?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    signals?: HotspotSignalOrderByRelationAggregateInput
    ideas?: IdeaOrderByRelationAggregateInput
    solutions?: SolutionOrderByRelationAggregateInput
  }

  export type HotspotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HotspotWhereInput | HotspotWhereInput[]
    OR?: HotspotWhereInput[]
    NOT?: HotspotWhereInput | HotspotWhereInput[]
    title?: StringFilter<"Hotspot"> | string
    summary?: StringFilter<"Hotspot"> | string
    status?: EnumHotspotStatusFilter<"Hotspot"> | $Enums.HotspotStatus
    rankScore?: FloatFilter<"Hotspot"> | number
    confidence?: FloatFilter<"Hotspot"> | number
    primaryCategoryId?: StringNullableFilter<"Hotspot"> | string | null
    linkedEntitiesJson?: JsonNullableFilter<"Hotspot">
    clusteringMethod?: StringNullableFilter<"Hotspot"> | string | null
    similarityThreshold?: FloatNullableFilter<"Hotspot"> | number | null
    createdAt?: DateTimeFilter<"Hotspot"> | Date | string
    updatedAt?: DateTimeFilter<"Hotspot"> | Date | string
    signals?: HotspotSignalListRelationFilter
    ideas?: IdeaListRelationFilter
    solutions?: SolutionListRelationFilter
  }, "id">

  export type HotspotOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    rankScore?: SortOrder
    confidence?: SortOrder
    primaryCategoryId?: SortOrderInput | SortOrder
    linkedEntitiesJson?: SortOrderInput | SortOrder
    clusteringMethod?: SortOrderInput | SortOrder
    similarityThreshold?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HotspotCountOrderByAggregateInput
    _avg?: HotspotAvgOrderByAggregateInput
    _max?: HotspotMaxOrderByAggregateInput
    _min?: HotspotMinOrderByAggregateInput
    _sum?: HotspotSumOrderByAggregateInput
  }

  export type HotspotScalarWhereWithAggregatesInput = {
    AND?: HotspotScalarWhereWithAggregatesInput | HotspotScalarWhereWithAggregatesInput[]
    OR?: HotspotScalarWhereWithAggregatesInput[]
    NOT?: HotspotScalarWhereWithAggregatesInput | HotspotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Hotspot"> | string
    title?: StringWithAggregatesFilter<"Hotspot"> | string
    summary?: StringWithAggregatesFilter<"Hotspot"> | string
    status?: EnumHotspotStatusWithAggregatesFilter<"Hotspot"> | $Enums.HotspotStatus
    rankScore?: FloatWithAggregatesFilter<"Hotspot"> | number
    confidence?: FloatWithAggregatesFilter<"Hotspot"> | number
    primaryCategoryId?: StringNullableWithAggregatesFilter<"Hotspot"> | string | null
    linkedEntitiesJson?: JsonNullableWithAggregatesFilter<"Hotspot">
    clusteringMethod?: StringNullableWithAggregatesFilter<"Hotspot"> | string | null
    similarityThreshold?: FloatNullableWithAggregatesFilter<"Hotspot"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Hotspot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Hotspot"> | Date | string
  }

  export type HotspotSignalWhereInput = {
    AND?: HotspotSignalWhereInput | HotspotSignalWhereInput[]
    OR?: HotspotSignalWhereInput[]
    NOT?: HotspotSignalWhereInput | HotspotSignalWhereInput[]
    hotspotId?: StringFilter<"HotspotSignal"> | string
    signalId?: StringFilter<"HotspotSignal"> | string
    membershipStrength?: FloatFilter<"HotspotSignal"> | number
    isOutlier?: BoolFilter<"HotspotSignal"> | boolean
    addedAt?: DateTimeFilter<"HotspotSignal"> | Date | string
    hotspot?: XOR<HotspotScalarRelationFilter, HotspotWhereInput>
    signal?: XOR<SignalScalarRelationFilter, SignalWhereInput>
  }

  export type HotspotSignalOrderByWithRelationInput = {
    hotspotId?: SortOrder
    signalId?: SortOrder
    membershipStrength?: SortOrder
    isOutlier?: SortOrder
    addedAt?: SortOrder
    hotspot?: HotspotOrderByWithRelationInput
    signal?: SignalOrderByWithRelationInput
  }

  export type HotspotSignalWhereUniqueInput = Prisma.AtLeast<{
    hotspotId_signalId?: HotspotSignalHotspotIdSignalIdCompoundUniqueInput
    AND?: HotspotSignalWhereInput | HotspotSignalWhereInput[]
    OR?: HotspotSignalWhereInput[]
    NOT?: HotspotSignalWhereInput | HotspotSignalWhereInput[]
    hotspotId?: StringFilter<"HotspotSignal"> | string
    signalId?: StringFilter<"HotspotSignal"> | string
    membershipStrength?: FloatFilter<"HotspotSignal"> | number
    isOutlier?: BoolFilter<"HotspotSignal"> | boolean
    addedAt?: DateTimeFilter<"HotspotSignal"> | Date | string
    hotspot?: XOR<HotspotScalarRelationFilter, HotspotWhereInput>
    signal?: XOR<SignalScalarRelationFilter, SignalWhereInput>
  }, "hotspotId_signalId">

  export type HotspotSignalOrderByWithAggregationInput = {
    hotspotId?: SortOrder
    signalId?: SortOrder
    membershipStrength?: SortOrder
    isOutlier?: SortOrder
    addedAt?: SortOrder
    _count?: HotspotSignalCountOrderByAggregateInput
    _avg?: HotspotSignalAvgOrderByAggregateInput
    _max?: HotspotSignalMaxOrderByAggregateInput
    _min?: HotspotSignalMinOrderByAggregateInput
    _sum?: HotspotSignalSumOrderByAggregateInput
  }

  export type HotspotSignalScalarWhereWithAggregatesInput = {
    AND?: HotspotSignalScalarWhereWithAggregatesInput | HotspotSignalScalarWhereWithAggregatesInput[]
    OR?: HotspotSignalScalarWhereWithAggregatesInput[]
    NOT?: HotspotSignalScalarWhereWithAggregatesInput | HotspotSignalScalarWhereWithAggregatesInput[]
    hotspotId?: StringWithAggregatesFilter<"HotspotSignal"> | string
    signalId?: StringWithAggregatesFilter<"HotspotSignal"> | string
    membershipStrength?: FloatWithAggregatesFilter<"HotspotSignal"> | number
    isOutlier?: BoolWithAggregatesFilter<"HotspotSignal"> | boolean
    addedAt?: DateTimeWithAggregatesFilter<"HotspotSignal"> | Date | string
  }

  export type IdeaWhereInput = {
    AND?: IdeaWhereInput | IdeaWhereInput[]
    OR?: IdeaWhereInput[]
    NOT?: IdeaWhereInput | IdeaWhereInput[]
    id?: StringFilter<"Idea"> | string
    hotspotId?: StringFilter<"Idea"> | string
    title?: StringNullableFilter<"Idea"> | string | null
    description?: StringFilter<"Idea"> | string
    origin?: StringFilter<"Idea"> | string
    votes?: IntFilter<"Idea"> | number
    status?: StringFilter<"Idea"> | string
    evidenceJson?: JsonNullableFilter<"Idea">
    tagsJson?: JsonNullableFilter<"Idea">
    confidence?: FloatNullableFilter<"Idea"> | number | null
    createdById?: StringNullableFilter<"Idea"> | string | null
    createdAt?: DateTimeFilter<"Idea"> | Date | string
    updatedAt?: DateTimeFilter<"Idea"> | Date | string
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    hotspot?: XOR<HotspotScalarRelationFilter, HotspotWhereInput>
    solution?: XOR<SolutionNullableScalarRelationFilter, SolutionWhereInput> | null
  }

  export type IdeaOrderByWithRelationInput = {
    id?: SortOrder
    hotspotId?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrder
    origin?: SortOrder
    votes?: SortOrder
    status?: SortOrder
    evidenceJson?: SortOrderInput | SortOrder
    tagsJson?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    hotspot?: HotspotOrderByWithRelationInput
    solution?: SolutionOrderByWithRelationInput
  }

  export type IdeaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IdeaWhereInput | IdeaWhereInput[]
    OR?: IdeaWhereInput[]
    NOT?: IdeaWhereInput | IdeaWhereInput[]
    hotspotId?: StringFilter<"Idea"> | string
    title?: StringNullableFilter<"Idea"> | string | null
    description?: StringFilter<"Idea"> | string
    origin?: StringFilter<"Idea"> | string
    votes?: IntFilter<"Idea"> | number
    status?: StringFilter<"Idea"> | string
    evidenceJson?: JsonNullableFilter<"Idea">
    tagsJson?: JsonNullableFilter<"Idea">
    confidence?: FloatNullableFilter<"Idea"> | number | null
    createdById?: StringNullableFilter<"Idea"> | string | null
    createdAt?: DateTimeFilter<"Idea"> | Date | string
    updatedAt?: DateTimeFilter<"Idea"> | Date | string
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    hotspot?: XOR<HotspotScalarRelationFilter, HotspotWhereInput>
    solution?: XOR<SolutionNullableScalarRelationFilter, SolutionWhereInput> | null
  }, "id">

  export type IdeaOrderByWithAggregationInput = {
    id?: SortOrder
    hotspotId?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrder
    origin?: SortOrder
    votes?: SortOrder
    status?: SortOrder
    evidenceJson?: SortOrderInput | SortOrder
    tagsJson?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IdeaCountOrderByAggregateInput
    _avg?: IdeaAvgOrderByAggregateInput
    _max?: IdeaMaxOrderByAggregateInput
    _min?: IdeaMinOrderByAggregateInput
    _sum?: IdeaSumOrderByAggregateInput
  }

  export type IdeaScalarWhereWithAggregatesInput = {
    AND?: IdeaScalarWhereWithAggregatesInput | IdeaScalarWhereWithAggregatesInput[]
    OR?: IdeaScalarWhereWithAggregatesInput[]
    NOT?: IdeaScalarWhereWithAggregatesInput | IdeaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Idea"> | string
    hotspotId?: StringWithAggregatesFilter<"Idea"> | string
    title?: StringNullableWithAggregatesFilter<"Idea"> | string | null
    description?: StringWithAggregatesFilter<"Idea"> | string
    origin?: StringWithAggregatesFilter<"Idea"> | string
    votes?: IntWithAggregatesFilter<"Idea"> | number
    status?: StringWithAggregatesFilter<"Idea"> | string
    evidenceJson?: JsonNullableWithAggregatesFilter<"Idea">
    tagsJson?: JsonNullableWithAggregatesFilter<"Idea">
    confidence?: FloatNullableWithAggregatesFilter<"Idea"> | number | null
    createdById?: StringNullableWithAggregatesFilter<"Idea"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Idea"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Idea"> | Date | string
  }

  export type InputWhereInput = {
    AND?: InputWhereInput | InputWhereInput[]
    OR?: InputWhereInput[]
    NOT?: InputWhereInput | InputWhereInput[]
    id?: StringFilter<"Input"> | string
    title?: StringFilter<"Input"> | string
    description?: StringFilter<"Input"> | string
    type?: EnumInputTypeFilter<"Input"> | $Enums.InputType
    department?: StringNullableFilter<"Input"> | string | null
    issueType?: StringNullableFilter<"Input"> | string | null
    rootCause?: StringNullableFilter<"Input"> | string | null
    priority?: EnumPriorityFilter<"Input"> | $Enums.Priority
    aiTags?: JsonNullableFilter<"Input">
    aiConfidence?: FloatNullableFilter<"Input"> | number | null
    aiSuggestions?: JsonNullableFilter<"Input">
    status?: EnumInputStatusFilter<"Input"> | $Enums.InputStatus
    createdBy?: StringFilter<"Input"> | string
    createdAt?: DateTimeFilter<"Input"> | Date | string
    updatedAt?: DateTimeFilter<"Input"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    solutions?: SolutionListRelationFilter
    groups?: InputGroupListRelationFilter
  }

  export type InputOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    department?: SortOrderInput | SortOrder
    issueType?: SortOrderInput | SortOrder
    rootCause?: SortOrderInput | SortOrder
    priority?: SortOrder
    aiTags?: SortOrderInput | SortOrder
    aiConfidence?: SortOrderInput | SortOrder
    aiSuggestions?: SortOrderInput | SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    solutions?: SolutionOrderByRelationAggregateInput
    groups?: InputGroupOrderByRelationAggregateInput
  }

  export type InputWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InputWhereInput | InputWhereInput[]
    OR?: InputWhereInput[]
    NOT?: InputWhereInput | InputWhereInput[]
    title?: StringFilter<"Input"> | string
    description?: StringFilter<"Input"> | string
    type?: EnumInputTypeFilter<"Input"> | $Enums.InputType
    department?: StringNullableFilter<"Input"> | string | null
    issueType?: StringNullableFilter<"Input"> | string | null
    rootCause?: StringNullableFilter<"Input"> | string | null
    priority?: EnumPriorityFilter<"Input"> | $Enums.Priority
    aiTags?: JsonNullableFilter<"Input">
    aiConfidence?: FloatNullableFilter<"Input"> | number | null
    aiSuggestions?: JsonNullableFilter<"Input">
    status?: EnumInputStatusFilter<"Input"> | $Enums.InputStatus
    createdBy?: StringFilter<"Input"> | string
    createdAt?: DateTimeFilter<"Input"> | Date | string
    updatedAt?: DateTimeFilter<"Input"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    solutions?: SolutionListRelationFilter
    groups?: InputGroupListRelationFilter
  }, "id">

  export type InputOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    department?: SortOrderInput | SortOrder
    issueType?: SortOrderInput | SortOrder
    rootCause?: SortOrderInput | SortOrder
    priority?: SortOrder
    aiTags?: SortOrderInput | SortOrder
    aiConfidence?: SortOrderInput | SortOrder
    aiSuggestions?: SortOrderInput | SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InputCountOrderByAggregateInput
    _avg?: InputAvgOrderByAggregateInput
    _max?: InputMaxOrderByAggregateInput
    _min?: InputMinOrderByAggregateInput
    _sum?: InputSumOrderByAggregateInput
  }

  export type InputScalarWhereWithAggregatesInput = {
    AND?: InputScalarWhereWithAggregatesInput | InputScalarWhereWithAggregatesInput[]
    OR?: InputScalarWhereWithAggregatesInput[]
    NOT?: InputScalarWhereWithAggregatesInput | InputScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Input"> | string
    title?: StringWithAggregatesFilter<"Input"> | string
    description?: StringWithAggregatesFilter<"Input"> | string
    type?: EnumInputTypeWithAggregatesFilter<"Input"> | $Enums.InputType
    department?: StringNullableWithAggregatesFilter<"Input"> | string | null
    issueType?: StringNullableWithAggregatesFilter<"Input"> | string | null
    rootCause?: StringNullableWithAggregatesFilter<"Input"> | string | null
    priority?: EnumPriorityWithAggregatesFilter<"Input"> | $Enums.Priority
    aiTags?: JsonNullableWithAggregatesFilter<"Input">
    aiConfidence?: FloatNullableWithAggregatesFilter<"Input"> | number | null
    aiSuggestions?: JsonNullableWithAggregatesFilter<"Input">
    status?: EnumInputStatusWithAggregatesFilter<"Input"> | $Enums.InputStatus
    createdBy?: StringWithAggregatesFilter<"Input"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Input"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Input"> | Date | string
  }

  export type SolutionWhereInput = {
    AND?: SolutionWhereInput | SolutionWhereInput[]
    OR?: SolutionWhereInput[]
    NOT?: SolutionWhereInput | SolutionWhereInput[]
    id?: StringFilter<"Solution"> | string
    title?: StringFilter<"Solution"> | string
    description?: StringFilter<"Solution"> | string
    status?: EnumSolutionStatusFilter<"Solution"> | $Enums.SolutionStatus
    hotspotId?: StringNullableFilter<"Solution"> | string | null
    initiativeId?: StringNullableFilter<"Solution"> | string | null
    ideaId?: StringNullableFilter<"Solution"> | string | null
    tasks?: JsonNullableFilter<"Solution">
    progress?: FloatFilter<"Solution"> | number
    targetDate?: DateTimeNullableFilter<"Solution"> | Date | string | null
    actualCompletionDate?: DateTimeNullableFilter<"Solution"> | Date | string | null
    estimatedEffort?: StringNullableFilter<"Solution"> | string | null
    businessValue?: StringNullableFilter<"Solution"> | string | null
    successMetrics?: JsonNullableFilter<"Solution">
    expectedImpactJson?: JsonNullableFilter<"Solution">
    actualImpactJson?: JsonNullableFilter<"Solution">
    inputId?: StringNullableFilter<"Solution"> | string | null
    createdBy?: StringFilter<"Solution"> | string
    createdAt?: DateTimeFilter<"Solution"> | Date | string
    updatedAt?: DateTimeFilter<"Solution"> | Date | string
    hotspot?: XOR<HotspotNullableScalarRelationFilter, HotspotWhereInput> | null
    initiative?: XOR<InitiativeNullableScalarRelationFilter, InitiativeWhereInput> | null
    idea?: XOR<IdeaNullableScalarRelationFilter, IdeaWhereInput> | null
    input?: XOR<InputNullableScalarRelationFilter, InputWhereInput> | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    requirements?: RequirementListRelationFilter
    frdDocuments?: FRDDocumentListRelationFilter
  }

  export type SolutionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    hotspotId?: SortOrderInput | SortOrder
    initiativeId?: SortOrderInput | SortOrder
    ideaId?: SortOrderInput | SortOrder
    tasks?: SortOrderInput | SortOrder
    progress?: SortOrder
    targetDate?: SortOrderInput | SortOrder
    actualCompletionDate?: SortOrderInput | SortOrder
    estimatedEffort?: SortOrderInput | SortOrder
    businessValue?: SortOrderInput | SortOrder
    successMetrics?: SortOrderInput | SortOrder
    expectedImpactJson?: SortOrderInput | SortOrder
    actualImpactJson?: SortOrderInput | SortOrder
    inputId?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotspot?: HotspotOrderByWithRelationInput
    initiative?: InitiativeOrderByWithRelationInput
    idea?: IdeaOrderByWithRelationInput
    input?: InputOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    requirements?: RequirementOrderByRelationAggregateInput
    frdDocuments?: FRDDocumentOrderByRelationAggregateInput
  }

  export type SolutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ideaId?: string
    AND?: SolutionWhereInput | SolutionWhereInput[]
    OR?: SolutionWhereInput[]
    NOT?: SolutionWhereInput | SolutionWhereInput[]
    title?: StringFilter<"Solution"> | string
    description?: StringFilter<"Solution"> | string
    status?: EnumSolutionStatusFilter<"Solution"> | $Enums.SolutionStatus
    hotspotId?: StringNullableFilter<"Solution"> | string | null
    initiativeId?: StringNullableFilter<"Solution"> | string | null
    tasks?: JsonNullableFilter<"Solution">
    progress?: FloatFilter<"Solution"> | number
    targetDate?: DateTimeNullableFilter<"Solution"> | Date | string | null
    actualCompletionDate?: DateTimeNullableFilter<"Solution"> | Date | string | null
    estimatedEffort?: StringNullableFilter<"Solution"> | string | null
    businessValue?: StringNullableFilter<"Solution"> | string | null
    successMetrics?: JsonNullableFilter<"Solution">
    expectedImpactJson?: JsonNullableFilter<"Solution">
    actualImpactJson?: JsonNullableFilter<"Solution">
    inputId?: StringNullableFilter<"Solution"> | string | null
    createdBy?: StringFilter<"Solution"> | string
    createdAt?: DateTimeFilter<"Solution"> | Date | string
    updatedAt?: DateTimeFilter<"Solution"> | Date | string
    hotspot?: XOR<HotspotNullableScalarRelationFilter, HotspotWhereInput> | null
    initiative?: XOR<InitiativeNullableScalarRelationFilter, InitiativeWhereInput> | null
    idea?: XOR<IdeaNullableScalarRelationFilter, IdeaWhereInput> | null
    input?: XOR<InputNullableScalarRelationFilter, InputWhereInput> | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    requirements?: RequirementListRelationFilter
    frdDocuments?: FRDDocumentListRelationFilter
  }, "id" | "ideaId">

  export type SolutionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    hotspotId?: SortOrderInput | SortOrder
    initiativeId?: SortOrderInput | SortOrder
    ideaId?: SortOrderInput | SortOrder
    tasks?: SortOrderInput | SortOrder
    progress?: SortOrder
    targetDate?: SortOrderInput | SortOrder
    actualCompletionDate?: SortOrderInput | SortOrder
    estimatedEffort?: SortOrderInput | SortOrder
    businessValue?: SortOrderInput | SortOrder
    successMetrics?: SortOrderInput | SortOrder
    expectedImpactJson?: SortOrderInput | SortOrder
    actualImpactJson?: SortOrderInput | SortOrder
    inputId?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SolutionCountOrderByAggregateInput
    _avg?: SolutionAvgOrderByAggregateInput
    _max?: SolutionMaxOrderByAggregateInput
    _min?: SolutionMinOrderByAggregateInput
    _sum?: SolutionSumOrderByAggregateInput
  }

  export type SolutionScalarWhereWithAggregatesInput = {
    AND?: SolutionScalarWhereWithAggregatesInput | SolutionScalarWhereWithAggregatesInput[]
    OR?: SolutionScalarWhereWithAggregatesInput[]
    NOT?: SolutionScalarWhereWithAggregatesInput | SolutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Solution"> | string
    title?: StringWithAggregatesFilter<"Solution"> | string
    description?: StringWithAggregatesFilter<"Solution"> | string
    status?: EnumSolutionStatusWithAggregatesFilter<"Solution"> | $Enums.SolutionStatus
    hotspotId?: StringNullableWithAggregatesFilter<"Solution"> | string | null
    initiativeId?: StringNullableWithAggregatesFilter<"Solution"> | string | null
    ideaId?: StringNullableWithAggregatesFilter<"Solution"> | string | null
    tasks?: JsonNullableWithAggregatesFilter<"Solution">
    progress?: FloatWithAggregatesFilter<"Solution"> | number
    targetDate?: DateTimeNullableWithAggregatesFilter<"Solution"> | Date | string | null
    actualCompletionDate?: DateTimeNullableWithAggregatesFilter<"Solution"> | Date | string | null
    estimatedEffort?: StringNullableWithAggregatesFilter<"Solution"> | string | null
    businessValue?: StringNullableWithAggregatesFilter<"Solution"> | string | null
    successMetrics?: JsonNullableWithAggregatesFilter<"Solution">
    expectedImpactJson?: JsonNullableWithAggregatesFilter<"Solution">
    actualImpactJson?: JsonNullableWithAggregatesFilter<"Solution">
    inputId?: StringNullableWithAggregatesFilter<"Solution"> | string | null
    createdBy?: StringWithAggregatesFilter<"Solution"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Solution"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Solution"> | Date | string
  }

  export type RequirementWhereInput = {
    AND?: RequirementWhereInput | RequirementWhereInput[]
    OR?: RequirementWhereInput[]
    NOT?: RequirementWhereInput | RequirementWhereInput[]
    id?: StringFilter<"Requirement"> | string
    title?: StringFilter<"Requirement"> | string
    description?: StringFilter<"Requirement"> | string
    acceptanceCriteria?: JsonFilter<"Requirement">
    priority?: EnumPriorityFilter<"Requirement"> | $Enums.Priority
    status?: EnumRequirementStatusFilter<"Requirement"> | $Enums.RequirementStatus
    estimatedEffort?: StringNullableFilter<"Requirement"> | string | null
    dependencies?: JsonNullableFilter<"Requirement">
    businessValue?: StringNullableFilter<"Requirement"> | string | null
    riskAssessment?: StringNullableFilter<"Requirement"> | string | null
    stakeholders?: JsonNullableFilter<"Requirement">
    approvedBy?: StringNullableFilter<"Requirement"> | string | null
    approvedAt?: DateTimeNullableFilter<"Requirement"> | Date | string | null
    rejectionReason?: StringNullableFilter<"Requirement"> | string | null
    solutionId?: StringFilter<"Requirement"> | string
    createdBy?: StringFilter<"Requirement"> | string
    createdAt?: DateTimeFilter<"Requirement"> | Date | string
    updatedAt?: DateTimeFilter<"Requirement"> | Date | string
    solution?: XOR<SolutionScalarRelationFilter, SolutionWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RequirementOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    acceptanceCriteria?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    estimatedEffort?: SortOrderInput | SortOrder
    dependencies?: SortOrderInput | SortOrder
    businessValue?: SortOrderInput | SortOrder
    riskAssessment?: SortOrderInput | SortOrder
    stakeholders?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    solutionId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    solution?: SolutionOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type RequirementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RequirementWhereInput | RequirementWhereInput[]
    OR?: RequirementWhereInput[]
    NOT?: RequirementWhereInput | RequirementWhereInput[]
    title?: StringFilter<"Requirement"> | string
    description?: StringFilter<"Requirement"> | string
    acceptanceCriteria?: JsonFilter<"Requirement">
    priority?: EnumPriorityFilter<"Requirement"> | $Enums.Priority
    status?: EnumRequirementStatusFilter<"Requirement"> | $Enums.RequirementStatus
    estimatedEffort?: StringNullableFilter<"Requirement"> | string | null
    dependencies?: JsonNullableFilter<"Requirement">
    businessValue?: StringNullableFilter<"Requirement"> | string | null
    riskAssessment?: StringNullableFilter<"Requirement"> | string | null
    stakeholders?: JsonNullableFilter<"Requirement">
    approvedBy?: StringNullableFilter<"Requirement"> | string | null
    approvedAt?: DateTimeNullableFilter<"Requirement"> | Date | string | null
    rejectionReason?: StringNullableFilter<"Requirement"> | string | null
    solutionId?: StringFilter<"Requirement"> | string
    createdBy?: StringFilter<"Requirement"> | string
    createdAt?: DateTimeFilter<"Requirement"> | Date | string
    updatedAt?: DateTimeFilter<"Requirement"> | Date | string
    solution?: XOR<SolutionScalarRelationFilter, SolutionWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RequirementOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    acceptanceCriteria?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    estimatedEffort?: SortOrderInput | SortOrder
    dependencies?: SortOrderInput | SortOrder
    businessValue?: SortOrderInput | SortOrder
    riskAssessment?: SortOrderInput | SortOrder
    stakeholders?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    solutionId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RequirementCountOrderByAggregateInput
    _max?: RequirementMaxOrderByAggregateInput
    _min?: RequirementMinOrderByAggregateInput
  }

  export type RequirementScalarWhereWithAggregatesInput = {
    AND?: RequirementScalarWhereWithAggregatesInput | RequirementScalarWhereWithAggregatesInput[]
    OR?: RequirementScalarWhereWithAggregatesInput[]
    NOT?: RequirementScalarWhereWithAggregatesInput | RequirementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Requirement"> | string
    title?: StringWithAggregatesFilter<"Requirement"> | string
    description?: StringWithAggregatesFilter<"Requirement"> | string
    acceptanceCriteria?: JsonWithAggregatesFilter<"Requirement">
    priority?: EnumPriorityWithAggregatesFilter<"Requirement"> | $Enums.Priority
    status?: EnumRequirementStatusWithAggregatesFilter<"Requirement"> | $Enums.RequirementStatus
    estimatedEffort?: StringNullableWithAggregatesFilter<"Requirement"> | string | null
    dependencies?: JsonNullableWithAggregatesFilter<"Requirement">
    businessValue?: StringNullableWithAggregatesFilter<"Requirement"> | string | null
    riskAssessment?: StringNullableWithAggregatesFilter<"Requirement"> | string | null
    stakeholders?: JsonNullableWithAggregatesFilter<"Requirement">
    approvedBy?: StringNullableWithAggregatesFilter<"Requirement"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Requirement"> | Date | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"Requirement"> | string | null
    solutionId?: StringWithAggregatesFilter<"Requirement"> | string
    createdBy?: StringWithAggregatesFilter<"Requirement"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Requirement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Requirement"> | Date | string
  }

  export type FRDDocumentWhereInput = {
    AND?: FRDDocumentWhereInput | FRDDocumentWhereInput[]
    OR?: FRDDocumentWhereInput[]
    NOT?: FRDDocumentWhereInput | FRDDocumentWhereInput[]
    id?: StringFilter<"FRDDocument"> | string
    title?: StringFilter<"FRDDocument"> | string
    content?: JsonFilter<"FRDDocument">
    aiGenerated?: BoolFilter<"FRDDocument"> | boolean
    aiConfidence?: FloatNullableFilter<"FRDDocument"> | number | null
    aiPromptUsed?: StringNullableFilter<"FRDDocument"> | string | null
    version?: StringFilter<"FRDDocument"> | string
    status?: EnumFRDStatusFilter<"FRDDocument"> | $Enums.FRDStatus
    executiveApproved?: BoolFilter<"FRDDocument"> | boolean
    exportFormats?: JsonNullableFilter<"FRDDocument">
    templateUsed?: StringNullableFilter<"FRDDocument"> | string | null
    generationTime?: FloatNullableFilter<"FRDDocument"> | number | null
    wordCount?: IntNullableFilter<"FRDDocument"> | number | null
    lastExportedAt?: DateTimeNullableFilter<"FRDDocument"> | Date | string | null
    solutionId?: StringFilter<"FRDDocument"> | string
    createdBy?: StringFilter<"FRDDocument"> | string
    approvedBy?: StringNullableFilter<"FRDDocument"> | string | null
    createdAt?: DateTimeFilter<"FRDDocument"> | Date | string
    updatedAt?: DateTimeFilter<"FRDDocument"> | Date | string
    solution?: XOR<SolutionScalarRelationFilter, SolutionWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type FRDDocumentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    aiGenerated?: SortOrder
    aiConfidence?: SortOrderInput | SortOrder
    aiPromptUsed?: SortOrderInput | SortOrder
    version?: SortOrder
    status?: SortOrder
    executiveApproved?: SortOrder
    exportFormats?: SortOrderInput | SortOrder
    templateUsed?: SortOrderInput | SortOrder
    generationTime?: SortOrderInput | SortOrder
    wordCount?: SortOrderInput | SortOrder
    lastExportedAt?: SortOrderInput | SortOrder
    solutionId?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    solution?: SolutionOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
  }

  export type FRDDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FRDDocumentWhereInput | FRDDocumentWhereInput[]
    OR?: FRDDocumentWhereInput[]
    NOT?: FRDDocumentWhereInput | FRDDocumentWhereInput[]
    title?: StringFilter<"FRDDocument"> | string
    content?: JsonFilter<"FRDDocument">
    aiGenerated?: BoolFilter<"FRDDocument"> | boolean
    aiConfidence?: FloatNullableFilter<"FRDDocument"> | number | null
    aiPromptUsed?: StringNullableFilter<"FRDDocument"> | string | null
    version?: StringFilter<"FRDDocument"> | string
    status?: EnumFRDStatusFilter<"FRDDocument"> | $Enums.FRDStatus
    executiveApproved?: BoolFilter<"FRDDocument"> | boolean
    exportFormats?: JsonNullableFilter<"FRDDocument">
    templateUsed?: StringNullableFilter<"FRDDocument"> | string | null
    generationTime?: FloatNullableFilter<"FRDDocument"> | number | null
    wordCount?: IntNullableFilter<"FRDDocument"> | number | null
    lastExportedAt?: DateTimeNullableFilter<"FRDDocument"> | Date | string | null
    solutionId?: StringFilter<"FRDDocument"> | string
    createdBy?: StringFilter<"FRDDocument"> | string
    approvedBy?: StringNullableFilter<"FRDDocument"> | string | null
    createdAt?: DateTimeFilter<"FRDDocument"> | Date | string
    updatedAt?: DateTimeFilter<"FRDDocument"> | Date | string
    solution?: XOR<SolutionScalarRelationFilter, SolutionWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type FRDDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    aiGenerated?: SortOrder
    aiConfidence?: SortOrderInput | SortOrder
    aiPromptUsed?: SortOrderInput | SortOrder
    version?: SortOrder
    status?: SortOrder
    executiveApproved?: SortOrder
    exportFormats?: SortOrderInput | SortOrder
    templateUsed?: SortOrderInput | SortOrder
    generationTime?: SortOrderInput | SortOrder
    wordCount?: SortOrderInput | SortOrder
    lastExportedAt?: SortOrderInput | SortOrder
    solutionId?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FRDDocumentCountOrderByAggregateInput
    _avg?: FRDDocumentAvgOrderByAggregateInput
    _max?: FRDDocumentMaxOrderByAggregateInput
    _min?: FRDDocumentMinOrderByAggregateInput
    _sum?: FRDDocumentSumOrderByAggregateInput
  }

  export type FRDDocumentScalarWhereWithAggregatesInput = {
    AND?: FRDDocumentScalarWhereWithAggregatesInput | FRDDocumentScalarWhereWithAggregatesInput[]
    OR?: FRDDocumentScalarWhereWithAggregatesInput[]
    NOT?: FRDDocumentScalarWhereWithAggregatesInput | FRDDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FRDDocument"> | string
    title?: StringWithAggregatesFilter<"FRDDocument"> | string
    content?: JsonWithAggregatesFilter<"FRDDocument">
    aiGenerated?: BoolWithAggregatesFilter<"FRDDocument"> | boolean
    aiConfidence?: FloatNullableWithAggregatesFilter<"FRDDocument"> | number | null
    aiPromptUsed?: StringNullableWithAggregatesFilter<"FRDDocument"> | string | null
    version?: StringWithAggregatesFilter<"FRDDocument"> | string
    status?: EnumFRDStatusWithAggregatesFilter<"FRDDocument"> | $Enums.FRDStatus
    executiveApproved?: BoolWithAggregatesFilter<"FRDDocument"> | boolean
    exportFormats?: JsonNullableWithAggregatesFilter<"FRDDocument">
    templateUsed?: StringNullableWithAggregatesFilter<"FRDDocument"> | string | null
    generationTime?: FloatNullableWithAggregatesFilter<"FRDDocument"> | number | null
    wordCount?: IntNullableWithAggregatesFilter<"FRDDocument"> | number | null
    lastExportedAt?: DateTimeNullableWithAggregatesFilter<"FRDDocument"> | Date | string | null
    solutionId?: StringWithAggregatesFilter<"FRDDocument"> | string
    createdBy?: StringWithAggregatesFilter<"FRDDocument"> | string
    approvedBy?: StringNullableWithAggregatesFilter<"FRDDocument"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FRDDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FRDDocument"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    entityType?: EnumEntityTypeFilter<"Comment"> | $Enums.EntityType
    entityId?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    mentions?: JsonNullableFilter<"Comment">
    edited?: BoolFilter<"Comment"> | boolean
    editedAt?: DateTimeNullableFilter<"Comment"> | Date | string | null
    createdBy?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    thread?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    mentions?: SortOrderInput | SortOrder
    edited?: SortOrder
    editedAt?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    thread?: CommentOrderByWithRelationInput
    replies?: CommentOrderByRelationAggregateInput
    creator?: UserOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    content?: StringFilter<"Comment"> | string
    entityType?: EnumEntityTypeFilter<"Comment"> | $Enums.EntityType
    entityId?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    mentions?: JsonNullableFilter<"Comment">
    edited?: BoolFilter<"Comment"> | boolean
    editedAt?: DateTimeNullableFilter<"Comment"> | Date | string | null
    createdBy?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    thread?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    mentions?: SortOrderInput | SortOrder
    edited?: SortOrder
    editedAt?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    entityType?: EnumEntityTypeWithAggregatesFilter<"Comment"> | $Enums.EntityType
    entityId?: StringWithAggregatesFilter<"Comment"> | string
    parentId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    mentions?: JsonNullableWithAggregatesFilter<"Comment">
    edited?: BoolWithAggregatesFilter<"Comment"> | boolean
    editedAt?: DateTimeNullableWithAggregatesFilter<"Comment"> | Date | string | null
    createdBy?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type VoteWhereInput = {
    AND?: VoteWhereInput | VoteWhereInput[]
    OR?: VoteWhereInput[]
    NOT?: VoteWhereInput | VoteWhereInput[]
    id?: StringFilter<"Vote"> | string
    value?: EnumVoteValueFilter<"Vote"> | $Enums.VoteValue
    entityType?: EnumEntityTypeFilter<"Vote"> | $Enums.EntityType
    entityId?: StringFilter<"Vote"> | string
    createdBy?: StringFilter<"Vote"> | string
    createdAt?: DateTimeFilter<"Vote"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type VoteOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type VoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    entityType_entityId_createdBy?: VoteEntityTypeEntityIdCreatedByCompoundUniqueInput
    AND?: VoteWhereInput | VoteWhereInput[]
    OR?: VoteWhereInput[]
    NOT?: VoteWhereInput | VoteWhereInput[]
    value?: EnumVoteValueFilter<"Vote"> | $Enums.VoteValue
    entityType?: EnumEntityTypeFilter<"Vote"> | $Enums.EntityType
    entityId?: StringFilter<"Vote"> | string
    createdBy?: StringFilter<"Vote"> | string
    createdAt?: DateTimeFilter<"Vote"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "entityType_entityId_createdBy">

  export type VoteOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: VoteCountOrderByAggregateInput
    _max?: VoteMaxOrderByAggregateInput
    _min?: VoteMinOrderByAggregateInput
  }

  export type VoteScalarWhereWithAggregatesInput = {
    AND?: VoteScalarWhereWithAggregatesInput | VoteScalarWhereWithAggregatesInput[]
    OR?: VoteScalarWhereWithAggregatesInput[]
    NOT?: VoteScalarWhereWithAggregatesInput | VoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vote"> | string
    value?: EnumVoteValueWithAggregatesFilter<"Vote"> | $Enums.VoteValue
    entityType?: EnumEntityTypeWithAggregatesFilter<"Vote"> | $Enums.EntityType
    entityId?: StringWithAggregatesFilter<"Vote"> | string
    createdBy?: StringWithAggregatesFilter<"Vote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Vote"> | Date | string
  }

  export type InputGroupWhereInput = {
    AND?: InputGroupWhereInput | InputGroupWhereInput[]
    OR?: InputGroupWhereInput[]
    NOT?: InputGroupWhereInput | InputGroupWhereInput[]
    id?: StringFilter<"InputGroup"> | string
    name?: StringFilter<"InputGroup"> | string
    description?: StringNullableFilter<"InputGroup"> | string | null
    color?: StringNullableFilter<"InputGroup"> | string | null
    aiSuggested?: BoolFilter<"InputGroup"> | boolean
    aiConfidence?: FloatNullableFilter<"InputGroup"> | number | null
    aiReasoning?: StringNullableFilter<"InputGroup"> | string | null
    inputCount?: IntFilter<"InputGroup"> | number
    avgPriority?: FloatNullableFilter<"InputGroup"> | number | null
    lastActivity?: DateTimeNullableFilter<"InputGroup"> | Date | string | null
    createdBy?: StringFilter<"InputGroup"> | string
    createdAt?: DateTimeFilter<"InputGroup"> | Date | string
    updatedAt?: DateTimeFilter<"InputGroup"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    inputs?: InputListRelationFilter
  }

  export type InputGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    aiSuggested?: SortOrder
    aiConfidence?: SortOrderInput | SortOrder
    aiReasoning?: SortOrderInput | SortOrder
    inputCount?: SortOrder
    avgPriority?: SortOrderInput | SortOrder
    lastActivity?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    inputs?: InputOrderByRelationAggregateInput
  }

  export type InputGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InputGroupWhereInput | InputGroupWhereInput[]
    OR?: InputGroupWhereInput[]
    NOT?: InputGroupWhereInput | InputGroupWhereInput[]
    name?: StringFilter<"InputGroup"> | string
    description?: StringNullableFilter<"InputGroup"> | string | null
    color?: StringNullableFilter<"InputGroup"> | string | null
    aiSuggested?: BoolFilter<"InputGroup"> | boolean
    aiConfidence?: FloatNullableFilter<"InputGroup"> | number | null
    aiReasoning?: StringNullableFilter<"InputGroup"> | string | null
    inputCount?: IntFilter<"InputGroup"> | number
    avgPriority?: FloatNullableFilter<"InputGroup"> | number | null
    lastActivity?: DateTimeNullableFilter<"InputGroup"> | Date | string | null
    createdBy?: StringFilter<"InputGroup"> | string
    createdAt?: DateTimeFilter<"InputGroup"> | Date | string
    updatedAt?: DateTimeFilter<"InputGroup"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    inputs?: InputListRelationFilter
  }, "id">

  export type InputGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    aiSuggested?: SortOrder
    aiConfidence?: SortOrderInput | SortOrder
    aiReasoning?: SortOrderInput | SortOrder
    inputCount?: SortOrder
    avgPriority?: SortOrderInput | SortOrder
    lastActivity?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InputGroupCountOrderByAggregateInput
    _avg?: InputGroupAvgOrderByAggregateInput
    _max?: InputGroupMaxOrderByAggregateInput
    _min?: InputGroupMinOrderByAggregateInput
    _sum?: InputGroupSumOrderByAggregateInput
  }

  export type InputGroupScalarWhereWithAggregatesInput = {
    AND?: InputGroupScalarWhereWithAggregatesInput | InputGroupScalarWhereWithAggregatesInput[]
    OR?: InputGroupScalarWhereWithAggregatesInput[]
    NOT?: InputGroupScalarWhereWithAggregatesInput | InputGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InputGroup"> | string
    name?: StringWithAggregatesFilter<"InputGroup"> | string
    description?: StringNullableWithAggregatesFilter<"InputGroup"> | string | null
    color?: StringNullableWithAggregatesFilter<"InputGroup"> | string | null
    aiSuggested?: BoolWithAggregatesFilter<"InputGroup"> | boolean
    aiConfidence?: FloatNullableWithAggregatesFilter<"InputGroup"> | number | null
    aiReasoning?: StringNullableWithAggregatesFilter<"InputGroup"> | string | null
    inputCount?: IntWithAggregatesFilter<"InputGroup"> | number
    avgPriority?: FloatNullableWithAggregatesFilter<"InputGroup"> | number | null
    lastActivity?: DateTimeNullableWithAggregatesFilter<"InputGroup"> | Date | string | null
    createdBy?: StringWithAggregatesFilter<"InputGroup"> | string
    createdAt?: DateTimeWithAggregatesFilter<"InputGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InputGroup"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    sessionId?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    sessionId?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    changes?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    entityType?: EnumEntityTypeNullableFilter<"Notification"> | $Enums.EntityType | null
    entityId?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    delivered?: BoolFilter<"Notification"> | boolean
    userId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    read?: SortOrder
    readAt?: SortOrderInput | SortOrder
    delivered?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    entityType?: EnumEntityTypeNullableFilter<"Notification"> | $Enums.EntityType | null
    entityId?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    delivered?: BoolFilter<"Notification"> | boolean
    userId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    read?: SortOrder
    readAt?: SortOrderInput | SortOrder
    delivered?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    entityType?: EnumEntityTypeNullableWithAggregatesFilter<"Notification"> | $Enums.EntityType | null
    entityId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    delivered?: BoolWithAggregatesFilter<"Notification"> | boolean
    userId?: StringWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputCreateNestedManyWithoutCreatorInput
    signals?: SignalCreateNestedManyWithoutCreatedByInput
    initiatives?: InitiativeCreateNestedManyWithoutOwnerInput
    ideas?: IdeaCreateNestedManyWithoutCreatedByInput
    solutions?: SolutionCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    votes?: VoteCreateNestedManyWithoutCreatorInput
    requirements?: RequirementCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    inputGroups?: InputGroupCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput
    signals?: SignalUncheckedCreateNestedManyWithoutCreatedByInput
    initiatives?: InitiativeUncheckedCreateNestedManyWithoutOwnerInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutCreatedByInput
    solutions?: SolutionUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    votes?: VoteUncheckedCreateNestedManyWithoutCreatorInput
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUpdateManyWithoutCreatorNestedInput
    signals?: SignalUpdateManyWithoutCreatedByNestedInput
    initiatives?: InitiativeUpdateManyWithoutOwnerNestedInput
    ideas?: IdeaUpdateManyWithoutCreatedByNestedInput
    solutions?: SolutionUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    votes?: VoteUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    inputGroups?: InputGroupUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput
    signals?: SignalUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatives?: InitiativeUncheckedUpdateManyWithoutOwnerNestedInput
    ideas?: IdeaUncheckedUpdateManyWithoutCreatedByNestedInput
    solutions?: SolutionUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    inputGroups?: InputGroupUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamCreateNestedManyWithoutDepartmentInput
    signals?: SignalCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutDepartmentInput
    signals?: SignalUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUpdateManyWithoutDepartmentNestedInput
    signals?: SignalUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutDepartmentNestedInput
    signals?: SignalUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutTeamsInput
    signals?: SignalCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    name: string
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    signals?: SignalUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutTeamsNestedInput
    signals?: SignalUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: SignalUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    name: string
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InitiativeCreateInput = {
    id?: string
    name: string
    description?: string | null
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutInitiativesInput
    solutions?: SolutionCreateNestedManyWithoutInitiativeInput
  }

  export type InitiativeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    ownerId?: string | null
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    solutions?: SolutionUncheckedCreateNestedManyWithoutInitiativeInput
  }

  export type InitiativeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutInitiativesNestedInput
    solutions?: SolutionUpdateManyWithoutInitiativeNestedInput
  }

  export type InitiativeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solutions?: SolutionUncheckedUpdateManyWithoutInitiativeNestedInput
  }

  export type InitiativeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    ownerId?: string | null
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InitiativeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InitiativeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalCreateInput = {
    id?: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutSignalsInput
    team?: TeamCreateNestedOneWithoutSignalsInput
    createdBy?: UserCreateNestedOneWithoutSignalsInput
    hotspots?: HotspotSignalCreateNestedManyWithoutSignalInput
  }

  export type SignalUncheckedCreateInput = {
    id?: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    departmentId?: string | null
    teamId?: string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotspots?: HotspotSignalUncheckedCreateNestedManyWithoutSignalInput
  }

  export type SignalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutSignalsNestedInput
    team?: TeamUpdateOneWithoutSignalsNestedInput
    createdBy?: UserUpdateOneWithoutSignalsNestedInput
    hotspots?: HotspotSignalUpdateManyWithoutSignalNestedInput
  }

  export type SignalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotspots?: HotspotSignalUncheckedUpdateManyWithoutSignalNestedInput
  }

  export type SignalCreateManyInput = {
    id?: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    departmentId?: string | null
    teamId?: string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SignalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotspotCreateInput = {
    id?: string
    title: string
    summary: string
    status?: $Enums.HotspotStatus
    rankScore?: number
    confidence?: number
    primaryCategoryId?: string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: string | null
    similarityThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    signals?: HotspotSignalCreateNestedManyWithoutHotspotInput
    ideas?: IdeaCreateNestedManyWithoutHotspotInput
    solutions?: SolutionCreateNestedManyWithoutHotspotInput
  }

  export type HotspotUncheckedCreateInput = {
    id?: string
    title: string
    summary: string
    status?: $Enums.HotspotStatus
    rankScore?: number
    confidence?: number
    primaryCategoryId?: string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: string | null
    similarityThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    signals?: HotspotSignalUncheckedCreateNestedManyWithoutHotspotInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutHotspotInput
    solutions?: SolutionUncheckedCreateNestedManyWithoutHotspotInput
  }

  export type HotspotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumHotspotStatusFieldUpdateOperationsInput | $Enums.HotspotStatus
    rankScore?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    primaryCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: NullableStringFieldUpdateOperationsInput | string | null
    similarityThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: HotspotSignalUpdateManyWithoutHotspotNestedInput
    ideas?: IdeaUpdateManyWithoutHotspotNestedInput
    solutions?: SolutionUpdateManyWithoutHotspotNestedInput
  }

  export type HotspotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumHotspotStatusFieldUpdateOperationsInput | $Enums.HotspotStatus
    rankScore?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    primaryCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: NullableStringFieldUpdateOperationsInput | string | null
    similarityThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: HotspotSignalUncheckedUpdateManyWithoutHotspotNestedInput
    ideas?: IdeaUncheckedUpdateManyWithoutHotspotNestedInput
    solutions?: SolutionUncheckedUpdateManyWithoutHotspotNestedInput
  }

  export type HotspotCreateManyInput = {
    id?: string
    title: string
    summary: string
    status?: $Enums.HotspotStatus
    rankScore?: number
    confidence?: number
    primaryCategoryId?: string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: string | null
    similarityThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotspotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumHotspotStatusFieldUpdateOperationsInput | $Enums.HotspotStatus
    rankScore?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    primaryCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: NullableStringFieldUpdateOperationsInput | string | null
    similarityThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotspotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumHotspotStatusFieldUpdateOperationsInput | $Enums.HotspotStatus
    rankScore?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    primaryCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: NullableStringFieldUpdateOperationsInput | string | null
    similarityThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotspotSignalCreateInput = {
    membershipStrength?: number
    isOutlier?: boolean
    addedAt?: Date | string
    hotspot: HotspotCreateNestedOneWithoutSignalsInput
    signal: SignalCreateNestedOneWithoutHotspotsInput
  }

  export type HotspotSignalUncheckedCreateInput = {
    hotspotId: string
    signalId: string
    membershipStrength?: number
    isOutlier?: boolean
    addedAt?: Date | string
  }

  export type HotspotSignalUpdateInput = {
    membershipStrength?: FloatFieldUpdateOperationsInput | number
    isOutlier?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotspot?: HotspotUpdateOneRequiredWithoutSignalsNestedInput
    signal?: SignalUpdateOneRequiredWithoutHotspotsNestedInput
  }

  export type HotspotSignalUncheckedUpdateInput = {
    hotspotId?: StringFieldUpdateOperationsInput | string
    signalId?: StringFieldUpdateOperationsInput | string
    membershipStrength?: FloatFieldUpdateOperationsInput | number
    isOutlier?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotspotSignalCreateManyInput = {
    hotspotId: string
    signalId: string
    membershipStrength?: number
    isOutlier?: boolean
    addedAt?: Date | string
  }

  export type HotspotSignalUpdateManyMutationInput = {
    membershipStrength?: FloatFieldUpdateOperationsInput | number
    isOutlier?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotspotSignalUncheckedUpdateManyInput = {
    hotspotId?: StringFieldUpdateOperationsInput | string
    signalId?: StringFieldUpdateOperationsInput | string
    membershipStrength?: FloatFieldUpdateOperationsInput | number
    isOutlier?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdeaCreateInput = {
    id?: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutIdeasInput
    hotspot: HotspotCreateNestedOneWithoutIdeasInput
    solution?: SolutionCreateNestedOneWithoutIdeaInput
  }

  export type IdeaUncheckedCreateInput = {
    id?: string
    hotspotId: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    solution?: SolutionUncheckedCreateNestedOneWithoutIdeaInput
  }

  export type IdeaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutIdeasNestedInput
    hotspot?: HotspotUpdateOneRequiredWithoutIdeasNestedInput
    solution?: SolutionUpdateOneWithoutIdeaNestedInput
  }

  export type IdeaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotspotId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solution?: SolutionUncheckedUpdateOneWithoutIdeaNestedInput
  }

  export type IdeaCreateManyInput = {
    id?: string
    hotspotId: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdeaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdeaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotspotId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputCreateInput = {
    id?: string
    title: string
    description: string
    type?: $Enums.InputType
    department?: string | null
    issueType?: string | null
    rootCause?: string | null
    priority?: $Enums.Priority
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: number | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.InputStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutInputsInput
    solutions?: SolutionCreateNestedManyWithoutInputInput
    groups?: InputGroupCreateNestedManyWithoutInputsInput
  }

  export type InputUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    type?: $Enums.InputType
    department?: string | null
    issueType?: string | null
    rootCause?: string | null
    priority?: $Enums.Priority
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: number | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.InputStatus
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    solutions?: SolutionUncheckedCreateNestedManyWithoutInputInput
    groups?: InputGroupUncheckedCreateNestedManyWithoutInputsInput
  }

  export type InputUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    department?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutInputsNestedInput
    solutions?: SolutionUpdateManyWithoutInputNestedInput
    groups?: InputGroupUpdateManyWithoutInputsNestedInput
  }

  export type InputUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    department?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solutions?: SolutionUncheckedUpdateManyWithoutInputNestedInput
    groups?: InputGroupUncheckedUpdateManyWithoutInputsNestedInput
  }

  export type InputCreateManyInput = {
    id?: string
    title: string
    description: string
    type?: $Enums.InputType
    department?: string | null
    issueType?: string | null
    rootCause?: string | null
    priority?: $Enums.Priority
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: number | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.InputStatus
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InputUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    department?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    department?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SolutionCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    targetDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    estimatedEffort?: string | null
    businessValue?: string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotspot?: HotspotCreateNestedOneWithoutSolutionsInput
    initiative?: InitiativeCreateNestedOneWithoutSolutionsInput
    idea?: IdeaCreateNestedOneWithoutSolutionInput
    input?: InputCreateNestedOneWithoutSolutionsInput
    creator: UserCreateNestedOneWithoutSolutionsInput
    requirements?: RequirementCreateNestedManyWithoutSolutionInput
    frdDocuments?: FRDDocumentCreateNestedManyWithoutSolutionInput
  }

  export type SolutionUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    hotspotId?: string | null
    initiativeId?: string | null
    ideaId?: string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    targetDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    estimatedEffort?: string | null
    businessValue?: string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    inputId?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requirements?: RequirementUncheckedCreateNestedManyWithoutSolutionInput
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutSolutionInput
  }

  export type SolutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotspot?: HotspotUpdateOneWithoutSolutionsNestedInput
    initiative?: InitiativeUpdateOneWithoutSolutionsNestedInput
    idea?: IdeaUpdateOneWithoutSolutionNestedInput
    input?: InputUpdateOneWithoutSolutionsNestedInput
    creator?: UserUpdateOneRequiredWithoutSolutionsNestedInput
    requirements?: RequirementUpdateManyWithoutSolutionNestedInput
    frdDocuments?: FRDDocumentUpdateManyWithoutSolutionNestedInput
  }

  export type SolutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    hotspotId?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    inputId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirements?: RequirementUncheckedUpdateManyWithoutSolutionNestedInput
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutSolutionNestedInput
  }

  export type SolutionCreateManyInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    hotspotId?: string | null
    initiativeId?: string | null
    ideaId?: string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    targetDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    estimatedEffort?: string | null
    businessValue?: string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    inputId?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SolutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SolutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    hotspotId?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    inputId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementCreateInput = {
    id?: string
    title: string
    description: string
    acceptanceCriteria: JsonNullValueInput | InputJsonValue
    priority?: $Enums.Priority
    status?: $Enums.RequirementStatus
    estimatedEffort?: string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    riskAssessment?: string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    solution: SolutionCreateNestedOneWithoutRequirementsInput
    creator: UserCreateNestedOneWithoutRequirementsInput
  }

  export type RequirementUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    acceptanceCriteria: JsonNullValueInput | InputJsonValue
    priority?: $Enums.Priority
    status?: $Enums.RequirementStatus
    estimatedEffort?: string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    riskAssessment?: string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    solutionId: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequirementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solution?: SolutionUpdateOneRequiredWithoutRequirementsNestedInput
    creator?: UserUpdateOneRequiredWithoutRequirementsNestedInput
  }

  export type RequirementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementCreateManyInput = {
    id?: string
    title: string
    description: string
    acceptanceCriteria: JsonNullValueInput | InputJsonValue
    priority?: $Enums.Priority
    status?: $Enums.RequirementStatus
    estimatedEffort?: string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    riskAssessment?: string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    solutionId: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequirementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FRDDocumentCreateInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    solution: SolutionCreateNestedOneWithoutFrdDocumentsInput
    creator: UserCreateNestedOneWithoutFrdDocumentsInput
    approver?: UserCreateNestedOneWithoutApprovedFRDsInput
  }

  export type FRDDocumentUncheckedCreateInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    solutionId: string
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FRDDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solution?: SolutionUpdateOneRequiredWithoutFrdDocumentsNestedInput
    creator?: UserUpdateOneRequiredWithoutFrdDocumentsNestedInput
    approver?: UserUpdateOneWithoutApprovedFRDsNestedInput
  }

  export type FRDDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    solutionId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FRDDocumentCreateManyInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    solutionId: string
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FRDDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FRDDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    solutionId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    entityType: $Enums.EntityType
    entityId: string
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: boolean
    editedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    thread?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutThreadInput
    creator: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    content: string
    entityType: $Enums.EntityType
    entityId: string
    parentId?: string | null
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: boolean
    editedAt?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutThreadInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutThreadNestedInput
    creator?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    content: string
    entityType: $Enums.EntityType
    entityId: string
    parentId?: string | null
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: boolean
    editedAt?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteCreateInput = {
    id?: string
    value: $Enums.VoteValue
    entityType: $Enums.EntityType
    entityId: string
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutVotesInput
  }

  export type VoteUncheckedCreateInput = {
    id?: string
    value: $Enums.VoteValue
    entityType: $Enums.EntityType
    entityId: string
    createdBy: string
    createdAt?: Date | string
  }

  export type VoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: EnumVoteValueFieldUpdateOperationsInput | $Enums.VoteValue
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutVotesNestedInput
  }

  export type VoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: EnumVoteValueFieldUpdateOperationsInput | $Enums.VoteValue
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteCreateManyInput = {
    id?: string
    value: $Enums.VoteValue
    entityType: $Enums.EntityType
    entityId: string
    createdBy: string
    createdAt?: Date | string
  }

  export type VoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: EnumVoteValueFieldUpdateOperationsInput | $Enums.VoteValue
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: EnumVoteValueFieldUpdateOperationsInput | $Enums.VoteValue
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputGroupCreateInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    aiSuggested?: boolean
    aiConfidence?: number | null
    aiReasoning?: string | null
    inputCount?: number
    avgPriority?: number | null
    lastActivity?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutInputGroupsInput
    inputs?: InputCreateNestedManyWithoutGroupsInput
  }

  export type InputGroupUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    aiSuggested?: boolean
    aiConfidence?: number | null
    aiReasoning?: string | null
    inputCount?: number
    avgPriority?: number | null
    lastActivity?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type InputGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    inputCount?: IntFieldUpdateOperationsInput | number
    avgPriority?: NullableFloatFieldUpdateOperationsInput | number | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutInputGroupsNestedInput
    inputs?: InputUpdateManyWithoutGroupsNestedInput
  }

  export type InputGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    inputCount?: IntFieldUpdateOperationsInput | number
    avgPriority?: NullableFloatFieldUpdateOperationsInput | number | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type InputGroupCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    aiSuggested?: boolean
    aiConfidence?: number | null
    aiReasoning?: string | null
    inputCount?: number
    avgPriority?: number | null
    lastActivity?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InputGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    inputCount?: IntFieldUpdateOperationsInput | number
    avgPriority?: NullableFloatFieldUpdateOperationsInput | number | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    inputCount?: IntFieldUpdateOperationsInput | number
    avgPriority?: NullableFloatFieldUpdateOperationsInput | number | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    sessionId?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    sessionId?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    sessionId?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    entityType?: $Enums.EntityType | null
    entityId?: string | null
    read?: boolean
    readAt?: Date | string | null
    delivered?: boolean
    userId: string
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    entityType?: $Enums.EntityType | null
    entityId?: string | null
    read?: boolean
    readAt?: Date | string | null
    delivered?: boolean
    userId: string
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    entityType?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    entityType?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    entityType?: $Enums.EntityType | null
    entityId?: string | null
    read?: boolean
    readAt?: Date | string | null
    delivered?: boolean
    userId: string
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    entityType?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    entityType?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type InputListRelationFilter = {
    every?: InputWhereInput
    some?: InputWhereInput
    none?: InputWhereInput
  }

  export type SignalListRelationFilter = {
    every?: SignalWhereInput
    some?: SignalWhereInput
    none?: SignalWhereInput
  }

  export type InitiativeListRelationFilter = {
    every?: InitiativeWhereInput
    some?: InitiativeWhereInput
    none?: InitiativeWhereInput
  }

  export type IdeaListRelationFilter = {
    every?: IdeaWhereInput
    some?: IdeaWhereInput
    none?: IdeaWhereInput
  }

  export type SolutionListRelationFilter = {
    every?: SolutionWhereInput
    some?: SolutionWhereInput
    none?: SolutionWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type VoteListRelationFilter = {
    every?: VoteWhereInput
    some?: VoteWhereInput
    none?: VoteWhereInput
  }

  export type RequirementListRelationFilter = {
    every?: RequirementWhereInput
    some?: RequirementWhereInput
    none?: RequirementWhereInput
  }

  export type FRDDocumentListRelationFilter = {
    every?: FRDDocumentWhereInput
    some?: FRDDocumentWhereInput
    none?: FRDDocumentWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type InputGroupListRelationFilter = {
    every?: InputGroupWhereInput
    some?: InputGroupWhereInput
    none?: InputGroupWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type InputOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SignalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InitiativeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IdeaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SolutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequirementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FRDDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InputGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrder
    avatar?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrder
    avatar?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrder
    avatar?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type InitiativeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    goalJson?: SortOrder
    roiJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InitiativeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InitiativeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSeverityFilter<$PrismaModel> | $Enums.Severity
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type TeamNullableScalarRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type HotspotSignalListRelationFilter = {
    every?: HotspotSignalWhereInput
    some?: HotspotSignalWhereInput
    none?: HotspotSignalWhereInput
  }

  export type HotspotSignalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SignalCountOrderByAggregateInput = {
    id?: SortOrder
    inputId?: SortOrder
    timestamp?: SortOrder
    receivedAt?: SortOrder
    schemaVersion?: SortOrder
    sourceJson?: SortOrder
    confidence?: SortOrder
    attachmentsJson?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    systemName?: SortOrder
    title?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    severityScore?: SortOrder
    departmentId?: SortOrder
    teamId?: SortOrder
    metricsJson?: SortOrder
    baselineJson?: SortOrder
    impactJson?: SortOrder
    tagsJson?: SortOrder
    entitiesJson?: SortOrder
    privacyLevel?: SortOrder
    dedupeKey?: SortOrder
    embedding?: SortOrder
    aiProcessed?: SortOrder
    aiTagsJson?: SortOrder
    lineageJson?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SignalAvgOrderByAggregateInput = {
    confidence?: SortOrder
    severityScore?: SortOrder
  }

  export type SignalMaxOrderByAggregateInput = {
    id?: SortOrder
    inputId?: SortOrder
    timestamp?: SortOrder
    receivedAt?: SortOrder
    schemaVersion?: SortOrder
    confidence?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    systemName?: SortOrder
    title?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    severityScore?: SortOrder
    departmentId?: SortOrder
    teamId?: SortOrder
    privacyLevel?: SortOrder
    dedupeKey?: SortOrder
    embedding?: SortOrder
    aiProcessed?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SignalMinOrderByAggregateInput = {
    id?: SortOrder
    inputId?: SortOrder
    timestamp?: SortOrder
    receivedAt?: SortOrder
    schemaVersion?: SortOrder
    confidence?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    systemName?: SortOrder
    title?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    severityScore?: SortOrder
    departmentId?: SortOrder
    teamId?: SortOrder
    privacyLevel?: SortOrder
    dedupeKey?: SortOrder
    embedding?: SortOrder
    aiProcessed?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SignalSumOrderByAggregateInput = {
    confidence?: SortOrder
    severityScore?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSeverityWithAggregatesFilter<$PrismaModel> | $Enums.Severity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeverityFilter<$PrismaModel>
    _max?: NestedEnumSeverityFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumHotspotStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HotspotStatus | EnumHotspotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HotspotStatus[] | ListEnumHotspotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HotspotStatus[] | ListEnumHotspotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHotspotStatusFilter<$PrismaModel> | $Enums.HotspotStatus
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type HotspotCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    rankScore?: SortOrder
    confidence?: SortOrder
    primaryCategoryId?: SortOrder
    linkedEntitiesJson?: SortOrder
    clusteringMethod?: SortOrder
    similarityThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotspotAvgOrderByAggregateInput = {
    rankScore?: SortOrder
    confidence?: SortOrder
    similarityThreshold?: SortOrder
  }

  export type HotspotMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    rankScore?: SortOrder
    confidence?: SortOrder
    primaryCategoryId?: SortOrder
    clusteringMethod?: SortOrder
    similarityThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotspotMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    rankScore?: SortOrder
    confidence?: SortOrder
    primaryCategoryId?: SortOrder
    clusteringMethod?: SortOrder
    similarityThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotspotSumOrderByAggregateInput = {
    rankScore?: SortOrder
    confidence?: SortOrder
    similarityThreshold?: SortOrder
  }

  export type EnumHotspotStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HotspotStatus | EnumHotspotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HotspotStatus[] | ListEnumHotspotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HotspotStatus[] | ListEnumHotspotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHotspotStatusWithAggregatesFilter<$PrismaModel> | $Enums.HotspotStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHotspotStatusFilter<$PrismaModel>
    _max?: NestedEnumHotspotStatusFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type HotspotScalarRelationFilter = {
    is?: HotspotWhereInput
    isNot?: HotspotWhereInput
  }

  export type SignalScalarRelationFilter = {
    is?: SignalWhereInput
    isNot?: SignalWhereInput
  }

  export type HotspotSignalHotspotIdSignalIdCompoundUniqueInput = {
    hotspotId: string
    signalId: string
  }

  export type HotspotSignalCountOrderByAggregateInput = {
    hotspotId?: SortOrder
    signalId?: SortOrder
    membershipStrength?: SortOrder
    isOutlier?: SortOrder
    addedAt?: SortOrder
  }

  export type HotspotSignalAvgOrderByAggregateInput = {
    membershipStrength?: SortOrder
  }

  export type HotspotSignalMaxOrderByAggregateInput = {
    hotspotId?: SortOrder
    signalId?: SortOrder
    membershipStrength?: SortOrder
    isOutlier?: SortOrder
    addedAt?: SortOrder
  }

  export type HotspotSignalMinOrderByAggregateInput = {
    hotspotId?: SortOrder
    signalId?: SortOrder
    membershipStrength?: SortOrder
    isOutlier?: SortOrder
    addedAt?: SortOrder
  }

  export type HotspotSignalSumOrderByAggregateInput = {
    membershipStrength?: SortOrder
  }

  export type SolutionNullableScalarRelationFilter = {
    is?: SolutionWhereInput | null
    isNot?: SolutionWhereInput | null
  }

  export type IdeaCountOrderByAggregateInput = {
    id?: SortOrder
    hotspotId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    origin?: SortOrder
    votes?: SortOrder
    status?: SortOrder
    evidenceJson?: SortOrder
    tagsJson?: SortOrder
    confidence?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IdeaAvgOrderByAggregateInput = {
    votes?: SortOrder
    confidence?: SortOrder
  }

  export type IdeaMaxOrderByAggregateInput = {
    id?: SortOrder
    hotspotId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    origin?: SortOrder
    votes?: SortOrder
    status?: SortOrder
    confidence?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IdeaMinOrderByAggregateInput = {
    id?: SortOrder
    hotspotId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    origin?: SortOrder
    votes?: SortOrder
    status?: SortOrder
    confidence?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IdeaSumOrderByAggregateInput = {
    votes?: SortOrder
    confidence?: SortOrder
  }

  export type EnumInputTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InputType | EnumInputTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInputTypeFilter<$PrismaModel> | $Enums.InputType
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type EnumInputStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InputStatus | EnumInputStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InputStatus[] | ListEnumInputStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InputStatus[] | ListEnumInputStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInputStatusFilter<$PrismaModel> | $Enums.InputStatus
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type InputCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    department?: SortOrder
    issueType?: SortOrder
    rootCause?: SortOrder
    priority?: SortOrder
    aiTags?: SortOrder
    aiConfidence?: SortOrder
    aiSuggestions?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InputAvgOrderByAggregateInput = {
    aiConfidence?: SortOrder
  }

  export type InputMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    department?: SortOrder
    issueType?: SortOrder
    rootCause?: SortOrder
    priority?: SortOrder
    aiConfidence?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InputMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    department?: SortOrder
    issueType?: SortOrder
    rootCause?: SortOrder
    priority?: SortOrder
    aiConfidence?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InputSumOrderByAggregateInput = {
    aiConfidence?: SortOrder
  }

  export type EnumInputTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InputType | EnumInputTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInputTypeWithAggregatesFilter<$PrismaModel> | $Enums.InputType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInputTypeFilter<$PrismaModel>
    _max?: NestedEnumInputTypeFilter<$PrismaModel>
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type EnumInputStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InputStatus | EnumInputStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InputStatus[] | ListEnumInputStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InputStatus[] | ListEnumInputStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInputStatusWithAggregatesFilter<$PrismaModel> | $Enums.InputStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInputStatusFilter<$PrismaModel>
    _max?: NestedEnumInputStatusFilter<$PrismaModel>
  }

  export type EnumSolutionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SolutionStatus | EnumSolutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SolutionStatus[] | ListEnumSolutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SolutionStatus[] | ListEnumSolutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSolutionStatusFilter<$PrismaModel> | $Enums.SolutionStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type HotspotNullableScalarRelationFilter = {
    is?: HotspotWhereInput | null
    isNot?: HotspotWhereInput | null
  }

  export type InitiativeNullableScalarRelationFilter = {
    is?: InitiativeWhereInput | null
    isNot?: InitiativeWhereInput | null
  }

  export type IdeaNullableScalarRelationFilter = {
    is?: IdeaWhereInput | null
    isNot?: IdeaWhereInput | null
  }

  export type InputNullableScalarRelationFilter = {
    is?: InputWhereInput | null
    isNot?: InputWhereInput | null
  }

  export type SolutionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    hotspotId?: SortOrder
    initiativeId?: SortOrder
    ideaId?: SortOrder
    tasks?: SortOrder
    progress?: SortOrder
    targetDate?: SortOrder
    actualCompletionDate?: SortOrder
    estimatedEffort?: SortOrder
    businessValue?: SortOrder
    successMetrics?: SortOrder
    expectedImpactJson?: SortOrder
    actualImpactJson?: SortOrder
    inputId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SolutionAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type SolutionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    hotspotId?: SortOrder
    initiativeId?: SortOrder
    ideaId?: SortOrder
    progress?: SortOrder
    targetDate?: SortOrder
    actualCompletionDate?: SortOrder
    estimatedEffort?: SortOrder
    businessValue?: SortOrder
    inputId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SolutionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    hotspotId?: SortOrder
    initiativeId?: SortOrder
    ideaId?: SortOrder
    progress?: SortOrder
    targetDate?: SortOrder
    actualCompletionDate?: SortOrder
    estimatedEffort?: SortOrder
    businessValue?: SortOrder
    inputId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SolutionSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type EnumSolutionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SolutionStatus | EnumSolutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SolutionStatus[] | ListEnumSolutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SolutionStatus[] | ListEnumSolutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSolutionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SolutionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSolutionStatusFilter<$PrismaModel>
    _max?: NestedEnumSolutionStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumRequirementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementStatus | EnumRequirementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementStatusFilter<$PrismaModel> | $Enums.RequirementStatus
  }

  export type SolutionScalarRelationFilter = {
    is?: SolutionWhereInput
    isNot?: SolutionWhereInput
  }

  export type RequirementCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    acceptanceCriteria?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    estimatedEffort?: SortOrder
    dependencies?: SortOrder
    businessValue?: SortOrder
    riskAssessment?: SortOrder
    stakeholders?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectionReason?: SortOrder
    solutionId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequirementMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    estimatedEffort?: SortOrder
    businessValue?: SortOrder
    riskAssessment?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectionReason?: SortOrder
    solutionId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequirementMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    estimatedEffort?: SortOrder
    businessValue?: SortOrder
    riskAssessment?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectionReason?: SortOrder
    solutionId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumRequirementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementStatus | EnumRequirementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequirementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequirementStatusFilter<$PrismaModel>
    _max?: NestedEnumRequirementStatusFilter<$PrismaModel>
  }

  export type EnumFRDStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FRDStatus | EnumFRDStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFRDStatusFilter<$PrismaModel> | $Enums.FRDStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FRDDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    aiGenerated?: SortOrder
    aiConfidence?: SortOrder
    aiPromptUsed?: SortOrder
    version?: SortOrder
    status?: SortOrder
    executiveApproved?: SortOrder
    exportFormats?: SortOrder
    templateUsed?: SortOrder
    generationTime?: SortOrder
    wordCount?: SortOrder
    lastExportedAt?: SortOrder
    solutionId?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FRDDocumentAvgOrderByAggregateInput = {
    aiConfidence?: SortOrder
    generationTime?: SortOrder
    wordCount?: SortOrder
  }

  export type FRDDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    aiGenerated?: SortOrder
    aiConfidence?: SortOrder
    aiPromptUsed?: SortOrder
    version?: SortOrder
    status?: SortOrder
    executiveApproved?: SortOrder
    templateUsed?: SortOrder
    generationTime?: SortOrder
    wordCount?: SortOrder
    lastExportedAt?: SortOrder
    solutionId?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FRDDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    aiGenerated?: SortOrder
    aiConfidence?: SortOrder
    aiPromptUsed?: SortOrder
    version?: SortOrder
    status?: SortOrder
    executiveApproved?: SortOrder
    templateUsed?: SortOrder
    generationTime?: SortOrder
    wordCount?: SortOrder
    lastExportedAt?: SortOrder
    solutionId?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FRDDocumentSumOrderByAggregateInput = {
    aiConfidence?: SortOrder
    generationTime?: SortOrder
    wordCount?: SortOrder
  }

  export type EnumFRDStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FRDStatus | EnumFRDStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFRDStatusWithAggregatesFilter<$PrismaModel> | $Enums.FRDStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFRDStatusFilter<$PrismaModel>
    _max?: NestedEnumFRDStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityTypeFilter<$PrismaModel> | $Enums.EntityType
  }

  export type CommentNullableScalarRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    parentId?: SortOrder
    mentions?: SortOrder
    edited?: SortOrder
    editedAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    parentId?: SortOrder
    edited?: SortOrder
    editedAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    parentId?: SortOrder
    edited?: SortOrder
    editedAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.EntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumEntityTypeFilter<$PrismaModel>
  }

  export type EnumVoteValueFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteValue | EnumVoteValueFieldRefInput<$PrismaModel>
    in?: $Enums.VoteValue[] | ListEnumVoteValueFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteValue[] | ListEnumVoteValueFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteValueFilter<$PrismaModel> | $Enums.VoteValue
  }

  export type VoteEntityTypeEntityIdCreatedByCompoundUniqueInput = {
    entityType: $Enums.EntityType
    entityId: string
    createdBy: string
  }

  export type VoteCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type VoteMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type VoteMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumVoteValueWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteValue | EnumVoteValueFieldRefInput<$PrismaModel>
    in?: $Enums.VoteValue[] | ListEnumVoteValueFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteValue[] | ListEnumVoteValueFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteValueWithAggregatesFilter<$PrismaModel> | $Enums.VoteValue
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoteValueFilter<$PrismaModel>
    _max?: NestedEnumVoteValueFilter<$PrismaModel>
  }

  export type InputGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    aiSuggested?: SortOrder
    aiConfidence?: SortOrder
    aiReasoning?: SortOrder
    inputCount?: SortOrder
    avgPriority?: SortOrder
    lastActivity?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InputGroupAvgOrderByAggregateInput = {
    aiConfidence?: SortOrder
    inputCount?: SortOrder
    avgPriority?: SortOrder
  }

  export type InputGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    aiSuggested?: SortOrder
    aiConfidence?: SortOrder
    aiReasoning?: SortOrder
    inputCount?: SortOrder
    avgPriority?: SortOrder
    lastActivity?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InputGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    aiSuggested?: SortOrder
    aiConfidence?: SortOrder
    aiReasoning?: SortOrder
    inputCount?: SortOrder
    avgPriority?: SortOrder
    lastActivity?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InputGroupSumOrderByAggregateInput = {
    aiConfidence?: SortOrder
    inputCount?: SortOrder
    avgPriority?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumEntityTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEntityTypeNullableFilter<$PrismaModel> | $Enums.EntityType | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    delivered?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    delivered?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    delivered?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumEntityTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEntityTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EntityType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEntityTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumEntityTypeNullableFilter<$PrismaModel>
  }

  export type InputCreateNestedManyWithoutCreatorInput = {
    create?: XOR<InputCreateWithoutCreatorInput, InputUncheckedCreateWithoutCreatorInput> | InputCreateWithoutCreatorInput[] | InputUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InputCreateOrConnectWithoutCreatorInput | InputCreateOrConnectWithoutCreatorInput[]
    createMany?: InputCreateManyCreatorInputEnvelope
    connect?: InputWhereUniqueInput | InputWhereUniqueInput[]
  }

  export type SignalCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SignalCreateWithoutCreatedByInput, SignalUncheckedCreateWithoutCreatedByInput> | SignalCreateWithoutCreatedByInput[] | SignalUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SignalCreateOrConnectWithoutCreatedByInput | SignalCreateOrConnectWithoutCreatedByInput[]
    createMany?: SignalCreateManyCreatedByInputEnvelope
    connect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
  }

  export type InitiativeCreateNestedManyWithoutOwnerInput = {
    create?: XOR<InitiativeCreateWithoutOwnerInput, InitiativeUncheckedCreateWithoutOwnerInput> | InitiativeCreateWithoutOwnerInput[] | InitiativeUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: InitiativeCreateOrConnectWithoutOwnerInput | InitiativeCreateOrConnectWithoutOwnerInput[]
    createMany?: InitiativeCreateManyOwnerInputEnvelope
    connect?: InitiativeWhereUniqueInput | InitiativeWhereUniqueInput[]
  }

  export type IdeaCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<IdeaCreateWithoutCreatedByInput, IdeaUncheckedCreateWithoutCreatedByInput> | IdeaCreateWithoutCreatedByInput[] | IdeaUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: IdeaCreateOrConnectWithoutCreatedByInput | IdeaCreateOrConnectWithoutCreatedByInput[]
    createMany?: IdeaCreateManyCreatedByInputEnvelope
    connect?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
  }

  export type SolutionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SolutionCreateWithoutCreatorInput, SolutionUncheckedCreateWithoutCreatorInput> | SolutionCreateWithoutCreatorInput[] | SolutionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SolutionCreateOrConnectWithoutCreatorInput | SolutionCreateOrConnectWithoutCreatorInput[]
    createMany?: SolutionCreateManyCreatorInputEnvelope
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CommentCreateWithoutCreatorInput, CommentUncheckedCreateWithoutCreatorInput> | CommentCreateWithoutCreatorInput[] | CommentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCreatorInput | CommentCreateOrConnectWithoutCreatorInput[]
    createMany?: CommentCreateManyCreatorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type VoteCreateNestedManyWithoutCreatorInput = {
    create?: XOR<VoteCreateWithoutCreatorInput, VoteUncheckedCreateWithoutCreatorInput> | VoteCreateWithoutCreatorInput[] | VoteUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutCreatorInput | VoteCreateOrConnectWithoutCreatorInput[]
    createMany?: VoteCreateManyCreatorInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type RequirementCreateNestedManyWithoutCreatorInput = {
    create?: XOR<RequirementCreateWithoutCreatorInput, RequirementUncheckedCreateWithoutCreatorInput> | RequirementCreateWithoutCreatorInput[] | RequirementUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutCreatorInput | RequirementCreateOrConnectWithoutCreatorInput[]
    createMany?: RequirementCreateManyCreatorInputEnvelope
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
  }

  export type FRDDocumentCreateNestedManyWithoutCreatorInput = {
    create?: XOR<FRDDocumentCreateWithoutCreatorInput, FRDDocumentUncheckedCreateWithoutCreatorInput> | FRDDocumentCreateWithoutCreatorInput[] | FRDDocumentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FRDDocumentCreateOrConnectWithoutCreatorInput | FRDDocumentCreateOrConnectWithoutCreatorInput[]
    createMany?: FRDDocumentCreateManyCreatorInputEnvelope
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
  }

  export type FRDDocumentCreateNestedManyWithoutApproverInput = {
    create?: XOR<FRDDocumentCreateWithoutApproverInput, FRDDocumentUncheckedCreateWithoutApproverInput> | FRDDocumentCreateWithoutApproverInput[] | FRDDocumentUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: FRDDocumentCreateOrConnectWithoutApproverInput | FRDDocumentCreateOrConnectWithoutApproverInput[]
    createMany?: FRDDocumentCreateManyApproverInputEnvelope
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type InputGroupCreateNestedManyWithoutCreatorInput = {
    create?: XOR<InputGroupCreateWithoutCreatorInput, InputGroupUncheckedCreateWithoutCreatorInput> | InputGroupCreateWithoutCreatorInput[] | InputGroupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InputGroupCreateOrConnectWithoutCreatorInput | InputGroupCreateOrConnectWithoutCreatorInput[]
    createMany?: InputGroupCreateManyCreatorInputEnvelope
    connect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[]
  }

  export type InputUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<InputCreateWithoutCreatorInput, InputUncheckedCreateWithoutCreatorInput> | InputCreateWithoutCreatorInput[] | InputUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InputCreateOrConnectWithoutCreatorInput | InputCreateOrConnectWithoutCreatorInput[]
    createMany?: InputCreateManyCreatorInputEnvelope
    connect?: InputWhereUniqueInput | InputWhereUniqueInput[]
  }

  export type SignalUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SignalCreateWithoutCreatedByInput, SignalUncheckedCreateWithoutCreatedByInput> | SignalCreateWithoutCreatedByInput[] | SignalUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SignalCreateOrConnectWithoutCreatedByInput | SignalCreateOrConnectWithoutCreatedByInput[]
    createMany?: SignalCreateManyCreatedByInputEnvelope
    connect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
  }

  export type InitiativeUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<InitiativeCreateWithoutOwnerInput, InitiativeUncheckedCreateWithoutOwnerInput> | InitiativeCreateWithoutOwnerInput[] | InitiativeUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: InitiativeCreateOrConnectWithoutOwnerInput | InitiativeCreateOrConnectWithoutOwnerInput[]
    createMany?: InitiativeCreateManyOwnerInputEnvelope
    connect?: InitiativeWhereUniqueInput | InitiativeWhereUniqueInput[]
  }

  export type IdeaUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<IdeaCreateWithoutCreatedByInput, IdeaUncheckedCreateWithoutCreatedByInput> | IdeaCreateWithoutCreatedByInput[] | IdeaUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: IdeaCreateOrConnectWithoutCreatedByInput | IdeaCreateOrConnectWithoutCreatedByInput[]
    createMany?: IdeaCreateManyCreatedByInputEnvelope
    connect?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
  }

  export type SolutionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SolutionCreateWithoutCreatorInput, SolutionUncheckedCreateWithoutCreatorInput> | SolutionCreateWithoutCreatorInput[] | SolutionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SolutionCreateOrConnectWithoutCreatorInput | SolutionCreateOrConnectWithoutCreatorInput[]
    createMany?: SolutionCreateManyCreatorInputEnvelope
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CommentCreateWithoutCreatorInput, CommentUncheckedCreateWithoutCreatorInput> | CommentCreateWithoutCreatorInput[] | CommentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCreatorInput | CommentCreateOrConnectWithoutCreatorInput[]
    createMany?: CommentCreateManyCreatorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type VoteUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<VoteCreateWithoutCreatorInput, VoteUncheckedCreateWithoutCreatorInput> | VoteCreateWithoutCreatorInput[] | VoteUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutCreatorInput | VoteCreateOrConnectWithoutCreatorInput[]
    createMany?: VoteCreateManyCreatorInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type RequirementUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<RequirementCreateWithoutCreatorInput, RequirementUncheckedCreateWithoutCreatorInput> | RequirementCreateWithoutCreatorInput[] | RequirementUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutCreatorInput | RequirementCreateOrConnectWithoutCreatorInput[]
    createMany?: RequirementCreateManyCreatorInputEnvelope
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
  }

  export type FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<FRDDocumentCreateWithoutCreatorInput, FRDDocumentUncheckedCreateWithoutCreatorInput> | FRDDocumentCreateWithoutCreatorInput[] | FRDDocumentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FRDDocumentCreateOrConnectWithoutCreatorInput | FRDDocumentCreateOrConnectWithoutCreatorInput[]
    createMany?: FRDDocumentCreateManyCreatorInputEnvelope
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
  }

  export type FRDDocumentUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<FRDDocumentCreateWithoutApproverInput, FRDDocumentUncheckedCreateWithoutApproverInput> | FRDDocumentCreateWithoutApproverInput[] | FRDDocumentUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: FRDDocumentCreateOrConnectWithoutApproverInput | FRDDocumentCreateOrConnectWithoutApproverInput[]
    createMany?: FRDDocumentCreateManyApproverInputEnvelope
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type InputGroupUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<InputGroupCreateWithoutCreatorInput, InputGroupUncheckedCreateWithoutCreatorInput> | InputGroupCreateWithoutCreatorInput[] | InputGroupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InputGroupCreateOrConnectWithoutCreatorInput | InputGroupCreateOrConnectWithoutCreatorInput[]
    createMany?: InputGroupCreateManyCreatorInputEnvelope
    connect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type InputUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<InputCreateWithoutCreatorInput, InputUncheckedCreateWithoutCreatorInput> | InputCreateWithoutCreatorInput[] | InputUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InputCreateOrConnectWithoutCreatorInput | InputCreateOrConnectWithoutCreatorInput[]
    upsert?: InputUpsertWithWhereUniqueWithoutCreatorInput | InputUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: InputCreateManyCreatorInputEnvelope
    set?: InputWhereUniqueInput | InputWhereUniqueInput[]
    disconnect?: InputWhereUniqueInput | InputWhereUniqueInput[]
    delete?: InputWhereUniqueInput | InputWhereUniqueInput[]
    connect?: InputWhereUniqueInput | InputWhereUniqueInput[]
    update?: InputUpdateWithWhereUniqueWithoutCreatorInput | InputUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: InputUpdateManyWithWhereWithoutCreatorInput | InputUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: InputScalarWhereInput | InputScalarWhereInput[]
  }

  export type SignalUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SignalCreateWithoutCreatedByInput, SignalUncheckedCreateWithoutCreatedByInput> | SignalCreateWithoutCreatedByInput[] | SignalUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SignalCreateOrConnectWithoutCreatedByInput | SignalCreateOrConnectWithoutCreatedByInput[]
    upsert?: SignalUpsertWithWhereUniqueWithoutCreatedByInput | SignalUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SignalCreateManyCreatedByInputEnvelope
    set?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    disconnect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    delete?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    connect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    update?: SignalUpdateWithWhereUniqueWithoutCreatedByInput | SignalUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SignalUpdateManyWithWhereWithoutCreatedByInput | SignalUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SignalScalarWhereInput | SignalScalarWhereInput[]
  }

  export type InitiativeUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<InitiativeCreateWithoutOwnerInput, InitiativeUncheckedCreateWithoutOwnerInput> | InitiativeCreateWithoutOwnerInput[] | InitiativeUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: InitiativeCreateOrConnectWithoutOwnerInput | InitiativeCreateOrConnectWithoutOwnerInput[]
    upsert?: InitiativeUpsertWithWhereUniqueWithoutOwnerInput | InitiativeUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: InitiativeCreateManyOwnerInputEnvelope
    set?: InitiativeWhereUniqueInput | InitiativeWhereUniqueInput[]
    disconnect?: InitiativeWhereUniqueInput | InitiativeWhereUniqueInput[]
    delete?: InitiativeWhereUniqueInput | InitiativeWhereUniqueInput[]
    connect?: InitiativeWhereUniqueInput | InitiativeWhereUniqueInput[]
    update?: InitiativeUpdateWithWhereUniqueWithoutOwnerInput | InitiativeUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: InitiativeUpdateManyWithWhereWithoutOwnerInput | InitiativeUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: InitiativeScalarWhereInput | InitiativeScalarWhereInput[]
  }

  export type IdeaUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<IdeaCreateWithoutCreatedByInput, IdeaUncheckedCreateWithoutCreatedByInput> | IdeaCreateWithoutCreatedByInput[] | IdeaUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: IdeaCreateOrConnectWithoutCreatedByInput | IdeaCreateOrConnectWithoutCreatedByInput[]
    upsert?: IdeaUpsertWithWhereUniqueWithoutCreatedByInput | IdeaUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: IdeaCreateManyCreatedByInputEnvelope
    set?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    disconnect?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    delete?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    connect?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    update?: IdeaUpdateWithWhereUniqueWithoutCreatedByInput | IdeaUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: IdeaUpdateManyWithWhereWithoutCreatedByInput | IdeaUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: IdeaScalarWhereInput | IdeaScalarWhereInput[]
  }

  export type SolutionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SolutionCreateWithoutCreatorInput, SolutionUncheckedCreateWithoutCreatorInput> | SolutionCreateWithoutCreatorInput[] | SolutionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SolutionCreateOrConnectWithoutCreatorInput | SolutionCreateOrConnectWithoutCreatorInput[]
    upsert?: SolutionUpsertWithWhereUniqueWithoutCreatorInput | SolutionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SolutionCreateManyCreatorInputEnvelope
    set?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    disconnect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    delete?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    update?: SolutionUpdateWithWhereUniqueWithoutCreatorInput | SolutionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SolutionUpdateManyWithWhereWithoutCreatorInput | SolutionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SolutionScalarWhereInput | SolutionScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CommentCreateWithoutCreatorInput, CommentUncheckedCreateWithoutCreatorInput> | CommentCreateWithoutCreatorInput[] | CommentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCreatorInput | CommentCreateOrConnectWithoutCreatorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutCreatorInput | CommentUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CommentCreateManyCreatorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutCreatorInput | CommentUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutCreatorInput | CommentUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type VoteUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<VoteCreateWithoutCreatorInput, VoteUncheckedCreateWithoutCreatorInput> | VoteCreateWithoutCreatorInput[] | VoteUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutCreatorInput | VoteCreateOrConnectWithoutCreatorInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutCreatorInput | VoteUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: VoteCreateManyCreatorInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutCreatorInput | VoteUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutCreatorInput | VoteUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type RequirementUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<RequirementCreateWithoutCreatorInput, RequirementUncheckedCreateWithoutCreatorInput> | RequirementCreateWithoutCreatorInput[] | RequirementUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutCreatorInput | RequirementCreateOrConnectWithoutCreatorInput[]
    upsert?: RequirementUpsertWithWhereUniqueWithoutCreatorInput | RequirementUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: RequirementCreateManyCreatorInputEnvelope
    set?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    disconnect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    delete?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    update?: RequirementUpdateWithWhereUniqueWithoutCreatorInput | RequirementUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: RequirementUpdateManyWithWhereWithoutCreatorInput | RequirementUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
  }

  export type FRDDocumentUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<FRDDocumentCreateWithoutCreatorInput, FRDDocumentUncheckedCreateWithoutCreatorInput> | FRDDocumentCreateWithoutCreatorInput[] | FRDDocumentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FRDDocumentCreateOrConnectWithoutCreatorInput | FRDDocumentCreateOrConnectWithoutCreatorInput[]
    upsert?: FRDDocumentUpsertWithWhereUniqueWithoutCreatorInput | FRDDocumentUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: FRDDocumentCreateManyCreatorInputEnvelope
    set?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    disconnect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    delete?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    update?: FRDDocumentUpdateWithWhereUniqueWithoutCreatorInput | FRDDocumentUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: FRDDocumentUpdateManyWithWhereWithoutCreatorInput | FRDDocumentUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: FRDDocumentScalarWhereInput | FRDDocumentScalarWhereInput[]
  }

  export type FRDDocumentUpdateManyWithoutApproverNestedInput = {
    create?: XOR<FRDDocumentCreateWithoutApproverInput, FRDDocumentUncheckedCreateWithoutApproverInput> | FRDDocumentCreateWithoutApproverInput[] | FRDDocumentUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: FRDDocumentCreateOrConnectWithoutApproverInput | FRDDocumentCreateOrConnectWithoutApproverInput[]
    upsert?: FRDDocumentUpsertWithWhereUniqueWithoutApproverInput | FRDDocumentUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: FRDDocumentCreateManyApproverInputEnvelope
    set?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    disconnect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    delete?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    update?: FRDDocumentUpdateWithWhereUniqueWithoutApproverInput | FRDDocumentUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: FRDDocumentUpdateManyWithWhereWithoutApproverInput | FRDDocumentUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: FRDDocumentScalarWhereInput | FRDDocumentScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type InputGroupUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<InputGroupCreateWithoutCreatorInput, InputGroupUncheckedCreateWithoutCreatorInput> | InputGroupCreateWithoutCreatorInput[] | InputGroupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InputGroupCreateOrConnectWithoutCreatorInput | InputGroupCreateOrConnectWithoutCreatorInput[]
    upsert?: InputGroupUpsertWithWhereUniqueWithoutCreatorInput | InputGroupUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: InputGroupCreateManyCreatorInputEnvelope
    set?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[]
    disconnect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[]
    delete?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[]
    connect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[]
    update?: InputGroupUpdateWithWhereUniqueWithoutCreatorInput | InputGroupUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: InputGroupUpdateManyWithWhereWithoutCreatorInput | InputGroupUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: InputGroupScalarWhereInput | InputGroupScalarWhereInput[]
  }

  export type InputUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<InputCreateWithoutCreatorInput, InputUncheckedCreateWithoutCreatorInput> | InputCreateWithoutCreatorInput[] | InputUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InputCreateOrConnectWithoutCreatorInput | InputCreateOrConnectWithoutCreatorInput[]
    upsert?: InputUpsertWithWhereUniqueWithoutCreatorInput | InputUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: InputCreateManyCreatorInputEnvelope
    set?: InputWhereUniqueInput | InputWhereUniqueInput[]
    disconnect?: InputWhereUniqueInput | InputWhereUniqueInput[]
    delete?: InputWhereUniqueInput | InputWhereUniqueInput[]
    connect?: InputWhereUniqueInput | InputWhereUniqueInput[]
    update?: InputUpdateWithWhereUniqueWithoutCreatorInput | InputUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: InputUpdateManyWithWhereWithoutCreatorInput | InputUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: InputScalarWhereInput | InputScalarWhereInput[]
  }

  export type SignalUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SignalCreateWithoutCreatedByInput, SignalUncheckedCreateWithoutCreatedByInput> | SignalCreateWithoutCreatedByInput[] | SignalUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SignalCreateOrConnectWithoutCreatedByInput | SignalCreateOrConnectWithoutCreatedByInput[]
    upsert?: SignalUpsertWithWhereUniqueWithoutCreatedByInput | SignalUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SignalCreateManyCreatedByInputEnvelope
    set?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    disconnect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    delete?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    connect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    update?: SignalUpdateWithWhereUniqueWithoutCreatedByInput | SignalUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SignalUpdateManyWithWhereWithoutCreatedByInput | SignalUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SignalScalarWhereInput | SignalScalarWhereInput[]
  }

  export type InitiativeUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<InitiativeCreateWithoutOwnerInput, InitiativeUncheckedCreateWithoutOwnerInput> | InitiativeCreateWithoutOwnerInput[] | InitiativeUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: InitiativeCreateOrConnectWithoutOwnerInput | InitiativeCreateOrConnectWithoutOwnerInput[]
    upsert?: InitiativeUpsertWithWhereUniqueWithoutOwnerInput | InitiativeUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: InitiativeCreateManyOwnerInputEnvelope
    set?: InitiativeWhereUniqueInput | InitiativeWhereUniqueInput[]
    disconnect?: InitiativeWhereUniqueInput | InitiativeWhereUniqueInput[]
    delete?: InitiativeWhereUniqueInput | InitiativeWhereUniqueInput[]
    connect?: InitiativeWhereUniqueInput | InitiativeWhereUniqueInput[]
    update?: InitiativeUpdateWithWhereUniqueWithoutOwnerInput | InitiativeUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: InitiativeUpdateManyWithWhereWithoutOwnerInput | InitiativeUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: InitiativeScalarWhereInput | InitiativeScalarWhereInput[]
  }

  export type IdeaUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<IdeaCreateWithoutCreatedByInput, IdeaUncheckedCreateWithoutCreatedByInput> | IdeaCreateWithoutCreatedByInput[] | IdeaUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: IdeaCreateOrConnectWithoutCreatedByInput | IdeaCreateOrConnectWithoutCreatedByInput[]
    upsert?: IdeaUpsertWithWhereUniqueWithoutCreatedByInput | IdeaUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: IdeaCreateManyCreatedByInputEnvelope
    set?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    disconnect?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    delete?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    connect?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    update?: IdeaUpdateWithWhereUniqueWithoutCreatedByInput | IdeaUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: IdeaUpdateManyWithWhereWithoutCreatedByInput | IdeaUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: IdeaScalarWhereInput | IdeaScalarWhereInput[]
  }

  export type SolutionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SolutionCreateWithoutCreatorInput, SolutionUncheckedCreateWithoutCreatorInput> | SolutionCreateWithoutCreatorInput[] | SolutionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SolutionCreateOrConnectWithoutCreatorInput | SolutionCreateOrConnectWithoutCreatorInput[]
    upsert?: SolutionUpsertWithWhereUniqueWithoutCreatorInput | SolutionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SolutionCreateManyCreatorInputEnvelope
    set?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    disconnect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    delete?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    update?: SolutionUpdateWithWhereUniqueWithoutCreatorInput | SolutionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SolutionUpdateManyWithWhereWithoutCreatorInput | SolutionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SolutionScalarWhereInput | SolutionScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CommentCreateWithoutCreatorInput, CommentUncheckedCreateWithoutCreatorInput> | CommentCreateWithoutCreatorInput[] | CommentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCreatorInput | CommentCreateOrConnectWithoutCreatorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutCreatorInput | CommentUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CommentCreateManyCreatorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutCreatorInput | CommentUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutCreatorInput | CommentUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type VoteUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<VoteCreateWithoutCreatorInput, VoteUncheckedCreateWithoutCreatorInput> | VoteCreateWithoutCreatorInput[] | VoteUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutCreatorInput | VoteCreateOrConnectWithoutCreatorInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutCreatorInput | VoteUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: VoteCreateManyCreatorInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutCreatorInput | VoteUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutCreatorInput | VoteUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type RequirementUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<RequirementCreateWithoutCreatorInput, RequirementUncheckedCreateWithoutCreatorInput> | RequirementCreateWithoutCreatorInput[] | RequirementUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutCreatorInput | RequirementCreateOrConnectWithoutCreatorInput[]
    upsert?: RequirementUpsertWithWhereUniqueWithoutCreatorInput | RequirementUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: RequirementCreateManyCreatorInputEnvelope
    set?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    disconnect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    delete?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    update?: RequirementUpdateWithWhereUniqueWithoutCreatorInput | RequirementUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: RequirementUpdateManyWithWhereWithoutCreatorInput | RequirementUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
  }

  export type FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<FRDDocumentCreateWithoutCreatorInput, FRDDocumentUncheckedCreateWithoutCreatorInput> | FRDDocumentCreateWithoutCreatorInput[] | FRDDocumentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FRDDocumentCreateOrConnectWithoutCreatorInput | FRDDocumentCreateOrConnectWithoutCreatorInput[]
    upsert?: FRDDocumentUpsertWithWhereUniqueWithoutCreatorInput | FRDDocumentUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: FRDDocumentCreateManyCreatorInputEnvelope
    set?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    disconnect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    delete?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    update?: FRDDocumentUpdateWithWhereUniqueWithoutCreatorInput | FRDDocumentUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: FRDDocumentUpdateManyWithWhereWithoutCreatorInput | FRDDocumentUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: FRDDocumentScalarWhereInput | FRDDocumentScalarWhereInput[]
  }

  export type FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<FRDDocumentCreateWithoutApproverInput, FRDDocumentUncheckedCreateWithoutApproverInput> | FRDDocumentCreateWithoutApproverInput[] | FRDDocumentUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: FRDDocumentCreateOrConnectWithoutApproverInput | FRDDocumentCreateOrConnectWithoutApproverInput[]
    upsert?: FRDDocumentUpsertWithWhereUniqueWithoutApproverInput | FRDDocumentUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: FRDDocumentCreateManyApproverInputEnvelope
    set?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    disconnect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    delete?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    update?: FRDDocumentUpdateWithWhereUniqueWithoutApproverInput | FRDDocumentUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: FRDDocumentUpdateManyWithWhereWithoutApproverInput | FRDDocumentUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: FRDDocumentScalarWhereInput | FRDDocumentScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type InputGroupUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<InputGroupCreateWithoutCreatorInput, InputGroupUncheckedCreateWithoutCreatorInput> | InputGroupCreateWithoutCreatorInput[] | InputGroupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InputGroupCreateOrConnectWithoutCreatorInput | InputGroupCreateOrConnectWithoutCreatorInput[]
    upsert?: InputGroupUpsertWithWhereUniqueWithoutCreatorInput | InputGroupUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: InputGroupCreateManyCreatorInputEnvelope
    set?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[]
    disconnect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[]
    delete?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[]
    connect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[]
    update?: InputGroupUpdateWithWhereUniqueWithoutCreatorInput | InputGroupUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: InputGroupUpdateManyWithWhereWithoutCreatorInput | InputGroupUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: InputGroupScalarWhereInput | InputGroupScalarWhereInput[]
  }

  export type TeamCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<TeamCreateWithoutDepartmentInput, TeamUncheckedCreateWithoutDepartmentInput> | TeamCreateWithoutDepartmentInput[] | TeamUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutDepartmentInput | TeamCreateOrConnectWithoutDepartmentInput[]
    createMany?: TeamCreateManyDepartmentInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type SignalCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<SignalCreateWithoutDepartmentInput, SignalUncheckedCreateWithoutDepartmentInput> | SignalCreateWithoutDepartmentInput[] | SignalUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: SignalCreateOrConnectWithoutDepartmentInput | SignalCreateOrConnectWithoutDepartmentInput[]
    createMany?: SignalCreateManyDepartmentInputEnvelope
    connect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<TeamCreateWithoutDepartmentInput, TeamUncheckedCreateWithoutDepartmentInput> | TeamCreateWithoutDepartmentInput[] | TeamUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutDepartmentInput | TeamCreateOrConnectWithoutDepartmentInput[]
    createMany?: TeamCreateManyDepartmentInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type SignalUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<SignalCreateWithoutDepartmentInput, SignalUncheckedCreateWithoutDepartmentInput> | SignalCreateWithoutDepartmentInput[] | SignalUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: SignalCreateOrConnectWithoutDepartmentInput | SignalCreateOrConnectWithoutDepartmentInput[]
    createMany?: SignalCreateManyDepartmentInputEnvelope
    connect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
  }

  export type TeamUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<TeamCreateWithoutDepartmentInput, TeamUncheckedCreateWithoutDepartmentInput> | TeamCreateWithoutDepartmentInput[] | TeamUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutDepartmentInput | TeamCreateOrConnectWithoutDepartmentInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutDepartmentInput | TeamUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: TeamCreateManyDepartmentInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutDepartmentInput | TeamUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutDepartmentInput | TeamUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type SignalUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<SignalCreateWithoutDepartmentInput, SignalUncheckedCreateWithoutDepartmentInput> | SignalCreateWithoutDepartmentInput[] | SignalUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: SignalCreateOrConnectWithoutDepartmentInput | SignalCreateOrConnectWithoutDepartmentInput[]
    upsert?: SignalUpsertWithWhereUniqueWithoutDepartmentInput | SignalUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: SignalCreateManyDepartmentInputEnvelope
    set?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    disconnect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    delete?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    connect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    update?: SignalUpdateWithWhereUniqueWithoutDepartmentInput | SignalUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: SignalUpdateManyWithWhereWithoutDepartmentInput | SignalUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: SignalScalarWhereInput | SignalScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<TeamCreateWithoutDepartmentInput, TeamUncheckedCreateWithoutDepartmentInput> | TeamCreateWithoutDepartmentInput[] | TeamUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutDepartmentInput | TeamCreateOrConnectWithoutDepartmentInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutDepartmentInput | TeamUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: TeamCreateManyDepartmentInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutDepartmentInput | TeamUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutDepartmentInput | TeamUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type SignalUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<SignalCreateWithoutDepartmentInput, SignalUncheckedCreateWithoutDepartmentInput> | SignalCreateWithoutDepartmentInput[] | SignalUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: SignalCreateOrConnectWithoutDepartmentInput | SignalCreateOrConnectWithoutDepartmentInput[]
    upsert?: SignalUpsertWithWhereUniqueWithoutDepartmentInput | SignalUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: SignalCreateManyDepartmentInputEnvelope
    set?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    disconnect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    delete?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    connect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    update?: SignalUpdateWithWhereUniqueWithoutDepartmentInput | SignalUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: SignalUpdateManyWithWhereWithoutDepartmentInput | SignalUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: SignalScalarWhereInput | SignalScalarWhereInput[]
  }

  export type DepartmentCreateNestedOneWithoutTeamsInput = {
    create?: XOR<DepartmentCreateWithoutTeamsInput, DepartmentUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutTeamsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type SignalCreateNestedManyWithoutTeamInput = {
    create?: XOR<SignalCreateWithoutTeamInput, SignalUncheckedCreateWithoutTeamInput> | SignalCreateWithoutTeamInput[] | SignalUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SignalCreateOrConnectWithoutTeamInput | SignalCreateOrConnectWithoutTeamInput[]
    createMany?: SignalCreateManyTeamInputEnvelope
    connect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
  }

  export type SignalUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<SignalCreateWithoutTeamInput, SignalUncheckedCreateWithoutTeamInput> | SignalCreateWithoutTeamInput[] | SignalUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SignalCreateOrConnectWithoutTeamInput | SignalCreateOrConnectWithoutTeamInput[]
    createMany?: SignalCreateManyTeamInputEnvelope
    connect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
  }

  export type DepartmentUpdateOneWithoutTeamsNestedInput = {
    create?: XOR<DepartmentCreateWithoutTeamsInput, DepartmentUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutTeamsInput
    upsert?: DepartmentUpsertWithoutTeamsInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutTeamsInput, DepartmentUpdateWithoutTeamsInput>, DepartmentUncheckedUpdateWithoutTeamsInput>
  }

  export type SignalUpdateManyWithoutTeamNestedInput = {
    create?: XOR<SignalCreateWithoutTeamInput, SignalUncheckedCreateWithoutTeamInput> | SignalCreateWithoutTeamInput[] | SignalUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SignalCreateOrConnectWithoutTeamInput | SignalCreateOrConnectWithoutTeamInput[]
    upsert?: SignalUpsertWithWhereUniqueWithoutTeamInput | SignalUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: SignalCreateManyTeamInputEnvelope
    set?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    disconnect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    delete?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    connect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    update?: SignalUpdateWithWhereUniqueWithoutTeamInput | SignalUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: SignalUpdateManyWithWhereWithoutTeamInput | SignalUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: SignalScalarWhereInput | SignalScalarWhereInput[]
  }

  export type SignalUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<SignalCreateWithoutTeamInput, SignalUncheckedCreateWithoutTeamInput> | SignalCreateWithoutTeamInput[] | SignalUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SignalCreateOrConnectWithoutTeamInput | SignalCreateOrConnectWithoutTeamInput[]
    upsert?: SignalUpsertWithWhereUniqueWithoutTeamInput | SignalUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: SignalCreateManyTeamInputEnvelope
    set?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    disconnect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    delete?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    connect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    update?: SignalUpdateWithWhereUniqueWithoutTeamInput | SignalUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: SignalUpdateManyWithWhereWithoutTeamInput | SignalUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: SignalScalarWhereInput | SignalScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutInitiativesInput = {
    create?: XOR<UserCreateWithoutInitiativesInput, UserUncheckedCreateWithoutInitiativesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInitiativesInput
    connect?: UserWhereUniqueInput
  }

  export type SolutionCreateNestedManyWithoutInitiativeInput = {
    create?: XOR<SolutionCreateWithoutInitiativeInput, SolutionUncheckedCreateWithoutInitiativeInput> | SolutionCreateWithoutInitiativeInput[] | SolutionUncheckedCreateWithoutInitiativeInput[]
    connectOrCreate?: SolutionCreateOrConnectWithoutInitiativeInput | SolutionCreateOrConnectWithoutInitiativeInput[]
    createMany?: SolutionCreateManyInitiativeInputEnvelope
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
  }

  export type SolutionUncheckedCreateNestedManyWithoutInitiativeInput = {
    create?: XOR<SolutionCreateWithoutInitiativeInput, SolutionUncheckedCreateWithoutInitiativeInput> | SolutionCreateWithoutInitiativeInput[] | SolutionUncheckedCreateWithoutInitiativeInput[]
    connectOrCreate?: SolutionCreateOrConnectWithoutInitiativeInput | SolutionCreateOrConnectWithoutInitiativeInput[]
    createMany?: SolutionCreateManyInitiativeInputEnvelope
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutInitiativesNestedInput = {
    create?: XOR<UserCreateWithoutInitiativesInput, UserUncheckedCreateWithoutInitiativesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInitiativesInput
    upsert?: UserUpsertWithoutInitiativesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInitiativesInput, UserUpdateWithoutInitiativesInput>, UserUncheckedUpdateWithoutInitiativesInput>
  }

  export type SolutionUpdateManyWithoutInitiativeNestedInput = {
    create?: XOR<SolutionCreateWithoutInitiativeInput, SolutionUncheckedCreateWithoutInitiativeInput> | SolutionCreateWithoutInitiativeInput[] | SolutionUncheckedCreateWithoutInitiativeInput[]
    connectOrCreate?: SolutionCreateOrConnectWithoutInitiativeInput | SolutionCreateOrConnectWithoutInitiativeInput[]
    upsert?: SolutionUpsertWithWhereUniqueWithoutInitiativeInput | SolutionUpsertWithWhereUniqueWithoutInitiativeInput[]
    createMany?: SolutionCreateManyInitiativeInputEnvelope
    set?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    disconnect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    delete?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    update?: SolutionUpdateWithWhereUniqueWithoutInitiativeInput | SolutionUpdateWithWhereUniqueWithoutInitiativeInput[]
    updateMany?: SolutionUpdateManyWithWhereWithoutInitiativeInput | SolutionUpdateManyWithWhereWithoutInitiativeInput[]
    deleteMany?: SolutionScalarWhereInput | SolutionScalarWhereInput[]
  }

  export type SolutionUncheckedUpdateManyWithoutInitiativeNestedInput = {
    create?: XOR<SolutionCreateWithoutInitiativeInput, SolutionUncheckedCreateWithoutInitiativeInput> | SolutionCreateWithoutInitiativeInput[] | SolutionUncheckedCreateWithoutInitiativeInput[]
    connectOrCreate?: SolutionCreateOrConnectWithoutInitiativeInput | SolutionCreateOrConnectWithoutInitiativeInput[]
    upsert?: SolutionUpsertWithWhereUniqueWithoutInitiativeInput | SolutionUpsertWithWhereUniqueWithoutInitiativeInput[]
    createMany?: SolutionCreateManyInitiativeInputEnvelope
    set?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    disconnect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    delete?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    update?: SolutionUpdateWithWhereUniqueWithoutInitiativeInput | SolutionUpdateWithWhereUniqueWithoutInitiativeInput[]
    updateMany?: SolutionUpdateManyWithWhereWithoutInitiativeInput | SolutionUpdateManyWithWhereWithoutInitiativeInput[]
    deleteMany?: SolutionScalarWhereInput | SolutionScalarWhereInput[]
  }

  export type DepartmentCreateNestedOneWithoutSignalsInput = {
    create?: XOR<DepartmentCreateWithoutSignalsInput, DepartmentUncheckedCreateWithoutSignalsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutSignalsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutSignalsInput = {
    create?: XOR<TeamCreateWithoutSignalsInput, TeamUncheckedCreateWithoutSignalsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutSignalsInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSignalsInput = {
    create?: XOR<UserCreateWithoutSignalsInput, UserUncheckedCreateWithoutSignalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSignalsInput
    connect?: UserWhereUniqueInput
  }

  export type HotspotSignalCreateNestedManyWithoutSignalInput = {
    create?: XOR<HotspotSignalCreateWithoutSignalInput, HotspotSignalUncheckedCreateWithoutSignalInput> | HotspotSignalCreateWithoutSignalInput[] | HotspotSignalUncheckedCreateWithoutSignalInput[]
    connectOrCreate?: HotspotSignalCreateOrConnectWithoutSignalInput | HotspotSignalCreateOrConnectWithoutSignalInput[]
    createMany?: HotspotSignalCreateManySignalInputEnvelope
    connect?: HotspotSignalWhereUniqueInput | HotspotSignalWhereUniqueInput[]
  }

  export type HotspotSignalUncheckedCreateNestedManyWithoutSignalInput = {
    create?: XOR<HotspotSignalCreateWithoutSignalInput, HotspotSignalUncheckedCreateWithoutSignalInput> | HotspotSignalCreateWithoutSignalInput[] | HotspotSignalUncheckedCreateWithoutSignalInput[]
    connectOrCreate?: HotspotSignalCreateOrConnectWithoutSignalInput | HotspotSignalCreateOrConnectWithoutSignalInput[]
    createMany?: HotspotSignalCreateManySignalInputEnvelope
    connect?: HotspotSignalWhereUniqueInput | HotspotSignalWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumSeverityFieldUpdateOperationsInput = {
    set?: $Enums.Severity
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Uint8Array | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DepartmentUpdateOneWithoutSignalsNestedInput = {
    create?: XOR<DepartmentCreateWithoutSignalsInput, DepartmentUncheckedCreateWithoutSignalsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutSignalsInput
    upsert?: DepartmentUpsertWithoutSignalsInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutSignalsInput, DepartmentUpdateWithoutSignalsInput>, DepartmentUncheckedUpdateWithoutSignalsInput>
  }

  export type TeamUpdateOneWithoutSignalsNestedInput = {
    create?: XOR<TeamCreateWithoutSignalsInput, TeamUncheckedCreateWithoutSignalsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutSignalsInput
    upsert?: TeamUpsertWithoutSignalsInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutSignalsInput, TeamUpdateWithoutSignalsInput>, TeamUncheckedUpdateWithoutSignalsInput>
  }

  export type UserUpdateOneWithoutSignalsNestedInput = {
    create?: XOR<UserCreateWithoutSignalsInput, UserUncheckedCreateWithoutSignalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSignalsInput
    upsert?: UserUpsertWithoutSignalsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSignalsInput, UserUpdateWithoutSignalsInput>, UserUncheckedUpdateWithoutSignalsInput>
  }

  export type HotspotSignalUpdateManyWithoutSignalNestedInput = {
    create?: XOR<HotspotSignalCreateWithoutSignalInput, HotspotSignalUncheckedCreateWithoutSignalInput> | HotspotSignalCreateWithoutSignalInput[] | HotspotSignalUncheckedCreateWithoutSignalInput[]
    connectOrCreate?: HotspotSignalCreateOrConnectWithoutSignalInput | HotspotSignalCreateOrConnectWithoutSignalInput[]
    upsert?: HotspotSignalUpsertWithWhereUniqueWithoutSignalInput | HotspotSignalUpsertWithWhereUniqueWithoutSignalInput[]
    createMany?: HotspotSignalCreateManySignalInputEnvelope
    set?: HotspotSignalWhereUniqueInput | HotspotSignalWhereUniqueInput[]
    disconnect?: HotspotSignalWhereUniqueInput | HotspotSignalWhereUniqueInput[]
    delete?: HotspotSignalWhereUniqueInput | HotspotSignalWhereUniqueInput[]
    connect?: HotspotSignalWhereUniqueInput | HotspotSignalWhereUniqueInput[]
    update?: HotspotSignalUpdateWithWhereUniqueWithoutSignalInput | HotspotSignalUpdateWithWhereUniqueWithoutSignalInput[]
    updateMany?: HotspotSignalUpdateManyWithWhereWithoutSignalInput | HotspotSignalUpdateManyWithWhereWithoutSignalInput[]
    deleteMany?: HotspotSignalScalarWhereInput | HotspotSignalScalarWhereInput[]
  }

  export type HotspotSignalUncheckedUpdateManyWithoutSignalNestedInput = {
    create?: XOR<HotspotSignalCreateWithoutSignalInput, HotspotSignalUncheckedCreateWithoutSignalInput> | HotspotSignalCreateWithoutSignalInput[] | HotspotSignalUncheckedCreateWithoutSignalInput[]
    connectOrCreate?: HotspotSignalCreateOrConnectWithoutSignalInput | HotspotSignalCreateOrConnectWithoutSignalInput[]
    upsert?: HotspotSignalUpsertWithWhereUniqueWithoutSignalInput | HotspotSignalUpsertWithWhereUniqueWithoutSignalInput[]
    createMany?: HotspotSignalCreateManySignalInputEnvelope
    set?: HotspotSignalWhereUniqueInput | HotspotSignalWhereUniqueInput[]
    disconnect?: HotspotSignalWhereUniqueInput | HotspotSignalWhereUniqueInput[]
    delete?: HotspotSignalWhereUniqueInput | HotspotSignalWhereUniqueInput[]
    connect?: HotspotSignalWhereUniqueInput | HotspotSignalWhereUniqueInput[]
    update?: HotspotSignalUpdateWithWhereUniqueWithoutSignalInput | HotspotSignalUpdateWithWhereUniqueWithoutSignalInput[]
    updateMany?: HotspotSignalUpdateManyWithWhereWithoutSignalInput | HotspotSignalUpdateManyWithWhereWithoutSignalInput[]
    deleteMany?: HotspotSignalScalarWhereInput | HotspotSignalScalarWhereInput[]
  }

  export type HotspotSignalCreateNestedManyWithoutHotspotInput = {
    create?: XOR<HotspotSignalCreateWithoutHotspotInput, HotspotSignalUncheckedCreateWithoutHotspotInput> | HotspotSignalCreateWithoutHotspotInput[] | HotspotSignalUncheckedCreateWithoutHotspotInput[]
    connectOrCreate?: HotspotSignalCreateOrConnectWithoutHotspotInput | HotspotSignalCreateOrConnectWithoutHotspotInput[]
    createMany?: HotspotSignalCreateManyHotspotInputEnvelope
    connect?: HotspotSignalWhereUniqueInput | HotspotSignalWhereUniqueInput[]
  }

  export type IdeaCreateNestedManyWithoutHotspotInput = {
    create?: XOR<IdeaCreateWithoutHotspotInput, IdeaUncheckedCreateWithoutHotspotInput> | IdeaCreateWithoutHotspotInput[] | IdeaUncheckedCreateWithoutHotspotInput[]
    connectOrCreate?: IdeaCreateOrConnectWithoutHotspotInput | IdeaCreateOrConnectWithoutHotspotInput[]
    createMany?: IdeaCreateManyHotspotInputEnvelope
    connect?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
  }

  export type SolutionCreateNestedManyWithoutHotspotInput = {
    create?: XOR<SolutionCreateWithoutHotspotInput, SolutionUncheckedCreateWithoutHotspotInput> | SolutionCreateWithoutHotspotInput[] | SolutionUncheckedCreateWithoutHotspotInput[]
    connectOrCreate?: SolutionCreateOrConnectWithoutHotspotInput | SolutionCreateOrConnectWithoutHotspotInput[]
    createMany?: SolutionCreateManyHotspotInputEnvelope
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
  }

  export type HotspotSignalUncheckedCreateNestedManyWithoutHotspotInput = {
    create?: XOR<HotspotSignalCreateWithoutHotspotInput, HotspotSignalUncheckedCreateWithoutHotspotInput> | HotspotSignalCreateWithoutHotspotInput[] | HotspotSignalUncheckedCreateWithoutHotspotInput[]
    connectOrCreate?: HotspotSignalCreateOrConnectWithoutHotspotInput | HotspotSignalCreateOrConnectWithoutHotspotInput[]
    createMany?: HotspotSignalCreateManyHotspotInputEnvelope
    connect?: HotspotSignalWhereUniqueInput | HotspotSignalWhereUniqueInput[]
  }

  export type IdeaUncheckedCreateNestedManyWithoutHotspotInput = {
    create?: XOR<IdeaCreateWithoutHotspotInput, IdeaUncheckedCreateWithoutHotspotInput> | IdeaCreateWithoutHotspotInput[] | IdeaUncheckedCreateWithoutHotspotInput[]
    connectOrCreate?: IdeaCreateOrConnectWithoutHotspotInput | IdeaCreateOrConnectWithoutHotspotInput[]
    createMany?: IdeaCreateManyHotspotInputEnvelope
    connect?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
  }

  export type SolutionUncheckedCreateNestedManyWithoutHotspotInput = {
    create?: XOR<SolutionCreateWithoutHotspotInput, SolutionUncheckedCreateWithoutHotspotInput> | SolutionCreateWithoutHotspotInput[] | SolutionUncheckedCreateWithoutHotspotInput[]
    connectOrCreate?: SolutionCreateOrConnectWithoutHotspotInput | SolutionCreateOrConnectWithoutHotspotInput[]
    createMany?: SolutionCreateManyHotspotInputEnvelope
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
  }

  export type EnumHotspotStatusFieldUpdateOperationsInput = {
    set?: $Enums.HotspotStatus
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type HotspotSignalUpdateManyWithoutHotspotNestedInput = {
    create?: XOR<HotspotSignalCreateWithoutHotspotInput, HotspotSignalUncheckedCreateWithoutHotspotInput> | HotspotSignalCreateWithoutHotspotInput[] | HotspotSignalUncheckedCreateWithoutHotspotInput[]
    connectOrCreate?: HotspotSignalCreateOrConnectWithoutHotspotInput | HotspotSignalCreateOrConnectWithoutHotspotInput[]
    upsert?: HotspotSignalUpsertWithWhereUniqueWithoutHotspotInput | HotspotSignalUpsertWithWhereUniqueWithoutHotspotInput[]
    createMany?: HotspotSignalCreateManyHotspotInputEnvelope
    set?: HotspotSignalWhereUniqueInput | HotspotSignalWhereUniqueInput[]
    disconnect?: HotspotSignalWhereUniqueInput | HotspotSignalWhereUniqueInput[]
    delete?: HotspotSignalWhereUniqueInput | HotspotSignalWhereUniqueInput[]
    connect?: HotspotSignalWhereUniqueInput | HotspotSignalWhereUniqueInput[]
    update?: HotspotSignalUpdateWithWhereUniqueWithoutHotspotInput | HotspotSignalUpdateWithWhereUniqueWithoutHotspotInput[]
    updateMany?: HotspotSignalUpdateManyWithWhereWithoutHotspotInput | HotspotSignalUpdateManyWithWhereWithoutHotspotInput[]
    deleteMany?: HotspotSignalScalarWhereInput | HotspotSignalScalarWhereInput[]
  }

  export type IdeaUpdateManyWithoutHotspotNestedInput = {
    create?: XOR<IdeaCreateWithoutHotspotInput, IdeaUncheckedCreateWithoutHotspotInput> | IdeaCreateWithoutHotspotInput[] | IdeaUncheckedCreateWithoutHotspotInput[]
    connectOrCreate?: IdeaCreateOrConnectWithoutHotspotInput | IdeaCreateOrConnectWithoutHotspotInput[]
    upsert?: IdeaUpsertWithWhereUniqueWithoutHotspotInput | IdeaUpsertWithWhereUniqueWithoutHotspotInput[]
    createMany?: IdeaCreateManyHotspotInputEnvelope
    set?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    disconnect?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    delete?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    connect?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    update?: IdeaUpdateWithWhereUniqueWithoutHotspotInput | IdeaUpdateWithWhereUniqueWithoutHotspotInput[]
    updateMany?: IdeaUpdateManyWithWhereWithoutHotspotInput | IdeaUpdateManyWithWhereWithoutHotspotInput[]
    deleteMany?: IdeaScalarWhereInput | IdeaScalarWhereInput[]
  }

  export type SolutionUpdateManyWithoutHotspotNestedInput = {
    create?: XOR<SolutionCreateWithoutHotspotInput, SolutionUncheckedCreateWithoutHotspotInput> | SolutionCreateWithoutHotspotInput[] | SolutionUncheckedCreateWithoutHotspotInput[]
    connectOrCreate?: SolutionCreateOrConnectWithoutHotspotInput | SolutionCreateOrConnectWithoutHotspotInput[]
    upsert?: SolutionUpsertWithWhereUniqueWithoutHotspotInput | SolutionUpsertWithWhereUniqueWithoutHotspotInput[]
    createMany?: SolutionCreateManyHotspotInputEnvelope
    set?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    disconnect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    delete?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    update?: SolutionUpdateWithWhereUniqueWithoutHotspotInput | SolutionUpdateWithWhereUniqueWithoutHotspotInput[]
    updateMany?: SolutionUpdateManyWithWhereWithoutHotspotInput | SolutionUpdateManyWithWhereWithoutHotspotInput[]
    deleteMany?: SolutionScalarWhereInput | SolutionScalarWhereInput[]
  }

  export type HotspotSignalUncheckedUpdateManyWithoutHotspotNestedInput = {
    create?: XOR<HotspotSignalCreateWithoutHotspotInput, HotspotSignalUncheckedCreateWithoutHotspotInput> | HotspotSignalCreateWithoutHotspotInput[] | HotspotSignalUncheckedCreateWithoutHotspotInput[]
    connectOrCreate?: HotspotSignalCreateOrConnectWithoutHotspotInput | HotspotSignalCreateOrConnectWithoutHotspotInput[]
    upsert?: HotspotSignalUpsertWithWhereUniqueWithoutHotspotInput | HotspotSignalUpsertWithWhereUniqueWithoutHotspotInput[]
    createMany?: HotspotSignalCreateManyHotspotInputEnvelope
    set?: HotspotSignalWhereUniqueInput | HotspotSignalWhereUniqueInput[]
    disconnect?: HotspotSignalWhereUniqueInput | HotspotSignalWhereUniqueInput[]
    delete?: HotspotSignalWhereUniqueInput | HotspotSignalWhereUniqueInput[]
    connect?: HotspotSignalWhereUniqueInput | HotspotSignalWhereUniqueInput[]
    update?: HotspotSignalUpdateWithWhereUniqueWithoutHotspotInput | HotspotSignalUpdateWithWhereUniqueWithoutHotspotInput[]
    updateMany?: HotspotSignalUpdateManyWithWhereWithoutHotspotInput | HotspotSignalUpdateManyWithWhereWithoutHotspotInput[]
    deleteMany?: HotspotSignalScalarWhereInput | HotspotSignalScalarWhereInput[]
  }

  export type IdeaUncheckedUpdateManyWithoutHotspotNestedInput = {
    create?: XOR<IdeaCreateWithoutHotspotInput, IdeaUncheckedCreateWithoutHotspotInput> | IdeaCreateWithoutHotspotInput[] | IdeaUncheckedCreateWithoutHotspotInput[]
    connectOrCreate?: IdeaCreateOrConnectWithoutHotspotInput | IdeaCreateOrConnectWithoutHotspotInput[]
    upsert?: IdeaUpsertWithWhereUniqueWithoutHotspotInput | IdeaUpsertWithWhereUniqueWithoutHotspotInput[]
    createMany?: IdeaCreateManyHotspotInputEnvelope
    set?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    disconnect?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    delete?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    connect?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    update?: IdeaUpdateWithWhereUniqueWithoutHotspotInput | IdeaUpdateWithWhereUniqueWithoutHotspotInput[]
    updateMany?: IdeaUpdateManyWithWhereWithoutHotspotInput | IdeaUpdateManyWithWhereWithoutHotspotInput[]
    deleteMany?: IdeaScalarWhereInput | IdeaScalarWhereInput[]
  }

  export type SolutionUncheckedUpdateManyWithoutHotspotNestedInput = {
    create?: XOR<SolutionCreateWithoutHotspotInput, SolutionUncheckedCreateWithoutHotspotInput> | SolutionCreateWithoutHotspotInput[] | SolutionUncheckedCreateWithoutHotspotInput[]
    connectOrCreate?: SolutionCreateOrConnectWithoutHotspotInput | SolutionCreateOrConnectWithoutHotspotInput[]
    upsert?: SolutionUpsertWithWhereUniqueWithoutHotspotInput | SolutionUpsertWithWhereUniqueWithoutHotspotInput[]
    createMany?: SolutionCreateManyHotspotInputEnvelope
    set?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    disconnect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    delete?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    update?: SolutionUpdateWithWhereUniqueWithoutHotspotInput | SolutionUpdateWithWhereUniqueWithoutHotspotInput[]
    updateMany?: SolutionUpdateManyWithWhereWithoutHotspotInput | SolutionUpdateManyWithWhereWithoutHotspotInput[]
    deleteMany?: SolutionScalarWhereInput | SolutionScalarWhereInput[]
  }

  export type HotspotCreateNestedOneWithoutSignalsInput = {
    create?: XOR<HotspotCreateWithoutSignalsInput, HotspotUncheckedCreateWithoutSignalsInput>
    connectOrCreate?: HotspotCreateOrConnectWithoutSignalsInput
    connect?: HotspotWhereUniqueInput
  }

  export type SignalCreateNestedOneWithoutHotspotsInput = {
    create?: XOR<SignalCreateWithoutHotspotsInput, SignalUncheckedCreateWithoutHotspotsInput>
    connectOrCreate?: SignalCreateOrConnectWithoutHotspotsInput
    connect?: SignalWhereUniqueInput
  }

  export type HotspotUpdateOneRequiredWithoutSignalsNestedInput = {
    create?: XOR<HotspotCreateWithoutSignalsInput, HotspotUncheckedCreateWithoutSignalsInput>
    connectOrCreate?: HotspotCreateOrConnectWithoutSignalsInput
    upsert?: HotspotUpsertWithoutSignalsInput
    connect?: HotspotWhereUniqueInput
    update?: XOR<XOR<HotspotUpdateToOneWithWhereWithoutSignalsInput, HotspotUpdateWithoutSignalsInput>, HotspotUncheckedUpdateWithoutSignalsInput>
  }

  export type SignalUpdateOneRequiredWithoutHotspotsNestedInput = {
    create?: XOR<SignalCreateWithoutHotspotsInput, SignalUncheckedCreateWithoutHotspotsInput>
    connectOrCreate?: SignalCreateOrConnectWithoutHotspotsInput
    upsert?: SignalUpsertWithoutHotspotsInput
    connect?: SignalWhereUniqueInput
    update?: XOR<XOR<SignalUpdateToOneWithWhereWithoutHotspotsInput, SignalUpdateWithoutHotspotsInput>, SignalUncheckedUpdateWithoutHotspotsInput>
  }

  export type UserCreateNestedOneWithoutIdeasInput = {
    create?: XOR<UserCreateWithoutIdeasInput, UserUncheckedCreateWithoutIdeasInput>
    connectOrCreate?: UserCreateOrConnectWithoutIdeasInput
    connect?: UserWhereUniqueInput
  }

  export type HotspotCreateNestedOneWithoutIdeasInput = {
    create?: XOR<HotspotCreateWithoutIdeasInput, HotspotUncheckedCreateWithoutIdeasInput>
    connectOrCreate?: HotspotCreateOrConnectWithoutIdeasInput
    connect?: HotspotWhereUniqueInput
  }

  export type SolutionCreateNestedOneWithoutIdeaInput = {
    create?: XOR<SolutionCreateWithoutIdeaInput, SolutionUncheckedCreateWithoutIdeaInput>
    connectOrCreate?: SolutionCreateOrConnectWithoutIdeaInput
    connect?: SolutionWhereUniqueInput
  }

  export type SolutionUncheckedCreateNestedOneWithoutIdeaInput = {
    create?: XOR<SolutionCreateWithoutIdeaInput, SolutionUncheckedCreateWithoutIdeaInput>
    connectOrCreate?: SolutionCreateOrConnectWithoutIdeaInput
    connect?: SolutionWhereUniqueInput
  }

  export type UserUpdateOneWithoutIdeasNestedInput = {
    create?: XOR<UserCreateWithoutIdeasInput, UserUncheckedCreateWithoutIdeasInput>
    connectOrCreate?: UserCreateOrConnectWithoutIdeasInput
    upsert?: UserUpsertWithoutIdeasInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIdeasInput, UserUpdateWithoutIdeasInput>, UserUncheckedUpdateWithoutIdeasInput>
  }

  export type HotspotUpdateOneRequiredWithoutIdeasNestedInput = {
    create?: XOR<HotspotCreateWithoutIdeasInput, HotspotUncheckedCreateWithoutIdeasInput>
    connectOrCreate?: HotspotCreateOrConnectWithoutIdeasInput
    upsert?: HotspotUpsertWithoutIdeasInput
    connect?: HotspotWhereUniqueInput
    update?: XOR<XOR<HotspotUpdateToOneWithWhereWithoutIdeasInput, HotspotUpdateWithoutIdeasInput>, HotspotUncheckedUpdateWithoutIdeasInput>
  }

  export type SolutionUpdateOneWithoutIdeaNestedInput = {
    create?: XOR<SolutionCreateWithoutIdeaInput, SolutionUncheckedCreateWithoutIdeaInput>
    connectOrCreate?: SolutionCreateOrConnectWithoutIdeaInput
    upsert?: SolutionUpsertWithoutIdeaInput
    disconnect?: SolutionWhereInput | boolean
    delete?: SolutionWhereInput | boolean
    connect?: SolutionWhereUniqueInput
    update?: XOR<XOR<SolutionUpdateToOneWithWhereWithoutIdeaInput, SolutionUpdateWithoutIdeaInput>, SolutionUncheckedUpdateWithoutIdeaInput>
  }

  export type SolutionUncheckedUpdateOneWithoutIdeaNestedInput = {
    create?: XOR<SolutionCreateWithoutIdeaInput, SolutionUncheckedCreateWithoutIdeaInput>
    connectOrCreate?: SolutionCreateOrConnectWithoutIdeaInput
    upsert?: SolutionUpsertWithoutIdeaInput
    disconnect?: SolutionWhereInput | boolean
    delete?: SolutionWhereInput | boolean
    connect?: SolutionWhereUniqueInput
    update?: XOR<XOR<SolutionUpdateToOneWithWhereWithoutIdeaInput, SolutionUpdateWithoutIdeaInput>, SolutionUncheckedUpdateWithoutIdeaInput>
  }

  export type UserCreateNestedOneWithoutInputsInput = {
    create?: XOR<UserCreateWithoutInputsInput, UserUncheckedCreateWithoutInputsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInputsInput
    connect?: UserWhereUniqueInput
  }

  export type SolutionCreateNestedManyWithoutInputInput = {
    create?: XOR<SolutionCreateWithoutInputInput, SolutionUncheckedCreateWithoutInputInput> | SolutionCreateWithoutInputInput[] | SolutionUncheckedCreateWithoutInputInput[]
    connectOrCreate?: SolutionCreateOrConnectWithoutInputInput | SolutionCreateOrConnectWithoutInputInput[]
    createMany?: SolutionCreateManyInputInputEnvelope
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
  }

  export type InputGroupCreateNestedManyWithoutInputsInput = {
    create?: XOR<InputGroupCreateWithoutInputsInput, InputGroupUncheckedCreateWithoutInputsInput> | InputGroupCreateWithoutInputsInput[] | InputGroupUncheckedCreateWithoutInputsInput[]
    connectOrCreate?: InputGroupCreateOrConnectWithoutInputsInput | InputGroupCreateOrConnectWithoutInputsInput[]
    connect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[]
  }

  export type SolutionUncheckedCreateNestedManyWithoutInputInput = {
    create?: XOR<SolutionCreateWithoutInputInput, SolutionUncheckedCreateWithoutInputInput> | SolutionCreateWithoutInputInput[] | SolutionUncheckedCreateWithoutInputInput[]
    connectOrCreate?: SolutionCreateOrConnectWithoutInputInput | SolutionCreateOrConnectWithoutInputInput[]
    createMany?: SolutionCreateManyInputInputEnvelope
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
  }

  export type InputGroupUncheckedCreateNestedManyWithoutInputsInput = {
    create?: XOR<InputGroupCreateWithoutInputsInput, InputGroupUncheckedCreateWithoutInputsInput> | InputGroupCreateWithoutInputsInput[] | InputGroupUncheckedCreateWithoutInputsInput[]
    connectOrCreate?: InputGroupCreateOrConnectWithoutInputsInput | InputGroupCreateOrConnectWithoutInputsInput[]
    connect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[]
  }

  export type EnumInputTypeFieldUpdateOperationsInput = {
    set?: $Enums.InputType
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type EnumInputStatusFieldUpdateOperationsInput = {
    set?: $Enums.InputStatus
  }

  export type UserUpdateOneRequiredWithoutInputsNestedInput = {
    create?: XOR<UserCreateWithoutInputsInput, UserUncheckedCreateWithoutInputsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInputsInput
    upsert?: UserUpsertWithoutInputsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInputsInput, UserUpdateWithoutInputsInput>, UserUncheckedUpdateWithoutInputsInput>
  }

  export type SolutionUpdateManyWithoutInputNestedInput = {
    create?: XOR<SolutionCreateWithoutInputInput, SolutionUncheckedCreateWithoutInputInput> | SolutionCreateWithoutInputInput[] | SolutionUncheckedCreateWithoutInputInput[]
    connectOrCreate?: SolutionCreateOrConnectWithoutInputInput | SolutionCreateOrConnectWithoutInputInput[]
    upsert?: SolutionUpsertWithWhereUniqueWithoutInputInput | SolutionUpsertWithWhereUniqueWithoutInputInput[]
    createMany?: SolutionCreateManyInputInputEnvelope
    set?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    disconnect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    delete?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    update?: SolutionUpdateWithWhereUniqueWithoutInputInput | SolutionUpdateWithWhereUniqueWithoutInputInput[]
    updateMany?: SolutionUpdateManyWithWhereWithoutInputInput | SolutionUpdateManyWithWhereWithoutInputInput[]
    deleteMany?: SolutionScalarWhereInput | SolutionScalarWhereInput[]
  }

  export type InputGroupUpdateManyWithoutInputsNestedInput = {
    create?: XOR<InputGroupCreateWithoutInputsInput, InputGroupUncheckedCreateWithoutInputsInput> | InputGroupCreateWithoutInputsInput[] | InputGroupUncheckedCreateWithoutInputsInput[]
    connectOrCreate?: InputGroupCreateOrConnectWithoutInputsInput | InputGroupCreateOrConnectWithoutInputsInput[]
    upsert?: InputGroupUpsertWithWhereUniqueWithoutInputsInput | InputGroupUpsertWithWhereUniqueWithoutInputsInput[]
    set?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[]
    disconnect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[]
    delete?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[]
    connect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[]
    update?: InputGroupUpdateWithWhereUniqueWithoutInputsInput | InputGroupUpdateWithWhereUniqueWithoutInputsInput[]
    updateMany?: InputGroupUpdateManyWithWhereWithoutInputsInput | InputGroupUpdateManyWithWhereWithoutInputsInput[]
    deleteMany?: InputGroupScalarWhereInput | InputGroupScalarWhereInput[]
  }

  export type SolutionUncheckedUpdateManyWithoutInputNestedInput = {
    create?: XOR<SolutionCreateWithoutInputInput, SolutionUncheckedCreateWithoutInputInput> | SolutionCreateWithoutInputInput[] | SolutionUncheckedCreateWithoutInputInput[]
    connectOrCreate?: SolutionCreateOrConnectWithoutInputInput | SolutionCreateOrConnectWithoutInputInput[]
    upsert?: SolutionUpsertWithWhereUniqueWithoutInputInput | SolutionUpsertWithWhereUniqueWithoutInputInput[]
    createMany?: SolutionCreateManyInputInputEnvelope
    set?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    disconnect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    delete?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    connect?: SolutionWhereUniqueInput | SolutionWhereUniqueInput[]
    update?: SolutionUpdateWithWhereUniqueWithoutInputInput | SolutionUpdateWithWhereUniqueWithoutInputInput[]
    updateMany?: SolutionUpdateManyWithWhereWithoutInputInput | SolutionUpdateManyWithWhereWithoutInputInput[]
    deleteMany?: SolutionScalarWhereInput | SolutionScalarWhereInput[]
  }

  export type InputGroupUncheckedUpdateManyWithoutInputsNestedInput = {
    create?: XOR<InputGroupCreateWithoutInputsInput, InputGroupUncheckedCreateWithoutInputsInput> | InputGroupCreateWithoutInputsInput[] | InputGroupUncheckedCreateWithoutInputsInput[]
    connectOrCreate?: InputGroupCreateOrConnectWithoutInputsInput | InputGroupCreateOrConnectWithoutInputsInput[]
    upsert?: InputGroupUpsertWithWhereUniqueWithoutInputsInput | InputGroupUpsertWithWhereUniqueWithoutInputsInput[]
    set?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[]
    disconnect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[]
    delete?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[]
    connect?: InputGroupWhereUniqueInput | InputGroupWhereUniqueInput[]
    update?: InputGroupUpdateWithWhereUniqueWithoutInputsInput | InputGroupUpdateWithWhereUniqueWithoutInputsInput[]
    updateMany?: InputGroupUpdateManyWithWhereWithoutInputsInput | InputGroupUpdateManyWithWhereWithoutInputsInput[]
    deleteMany?: InputGroupScalarWhereInput | InputGroupScalarWhereInput[]
  }

  export type HotspotCreateNestedOneWithoutSolutionsInput = {
    create?: XOR<HotspotCreateWithoutSolutionsInput, HotspotUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: HotspotCreateOrConnectWithoutSolutionsInput
    connect?: HotspotWhereUniqueInput
  }

  export type InitiativeCreateNestedOneWithoutSolutionsInput = {
    create?: XOR<InitiativeCreateWithoutSolutionsInput, InitiativeUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: InitiativeCreateOrConnectWithoutSolutionsInput
    connect?: InitiativeWhereUniqueInput
  }

  export type IdeaCreateNestedOneWithoutSolutionInput = {
    create?: XOR<IdeaCreateWithoutSolutionInput, IdeaUncheckedCreateWithoutSolutionInput>
    connectOrCreate?: IdeaCreateOrConnectWithoutSolutionInput
    connect?: IdeaWhereUniqueInput
  }

  export type InputCreateNestedOneWithoutSolutionsInput = {
    create?: XOR<InputCreateWithoutSolutionsInput, InputUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: InputCreateOrConnectWithoutSolutionsInput
    connect?: InputWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSolutionsInput = {
    create?: XOR<UserCreateWithoutSolutionsInput, UserUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSolutionsInput
    connect?: UserWhereUniqueInput
  }

  export type RequirementCreateNestedManyWithoutSolutionInput = {
    create?: XOR<RequirementCreateWithoutSolutionInput, RequirementUncheckedCreateWithoutSolutionInput> | RequirementCreateWithoutSolutionInput[] | RequirementUncheckedCreateWithoutSolutionInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutSolutionInput | RequirementCreateOrConnectWithoutSolutionInput[]
    createMany?: RequirementCreateManySolutionInputEnvelope
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
  }

  export type FRDDocumentCreateNestedManyWithoutSolutionInput = {
    create?: XOR<FRDDocumentCreateWithoutSolutionInput, FRDDocumentUncheckedCreateWithoutSolutionInput> | FRDDocumentCreateWithoutSolutionInput[] | FRDDocumentUncheckedCreateWithoutSolutionInput[]
    connectOrCreate?: FRDDocumentCreateOrConnectWithoutSolutionInput | FRDDocumentCreateOrConnectWithoutSolutionInput[]
    createMany?: FRDDocumentCreateManySolutionInputEnvelope
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
  }

  export type RequirementUncheckedCreateNestedManyWithoutSolutionInput = {
    create?: XOR<RequirementCreateWithoutSolutionInput, RequirementUncheckedCreateWithoutSolutionInput> | RequirementCreateWithoutSolutionInput[] | RequirementUncheckedCreateWithoutSolutionInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutSolutionInput | RequirementCreateOrConnectWithoutSolutionInput[]
    createMany?: RequirementCreateManySolutionInputEnvelope
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
  }

  export type FRDDocumentUncheckedCreateNestedManyWithoutSolutionInput = {
    create?: XOR<FRDDocumentCreateWithoutSolutionInput, FRDDocumentUncheckedCreateWithoutSolutionInput> | FRDDocumentCreateWithoutSolutionInput[] | FRDDocumentUncheckedCreateWithoutSolutionInput[]
    connectOrCreate?: FRDDocumentCreateOrConnectWithoutSolutionInput | FRDDocumentCreateOrConnectWithoutSolutionInput[]
    createMany?: FRDDocumentCreateManySolutionInputEnvelope
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
  }

  export type EnumSolutionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SolutionStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type HotspotUpdateOneWithoutSolutionsNestedInput = {
    create?: XOR<HotspotCreateWithoutSolutionsInput, HotspotUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: HotspotCreateOrConnectWithoutSolutionsInput
    upsert?: HotspotUpsertWithoutSolutionsInput
    disconnect?: HotspotWhereInput | boolean
    delete?: HotspotWhereInput | boolean
    connect?: HotspotWhereUniqueInput
    update?: XOR<XOR<HotspotUpdateToOneWithWhereWithoutSolutionsInput, HotspotUpdateWithoutSolutionsInput>, HotspotUncheckedUpdateWithoutSolutionsInput>
  }

  export type InitiativeUpdateOneWithoutSolutionsNestedInput = {
    create?: XOR<InitiativeCreateWithoutSolutionsInput, InitiativeUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: InitiativeCreateOrConnectWithoutSolutionsInput
    upsert?: InitiativeUpsertWithoutSolutionsInput
    disconnect?: InitiativeWhereInput | boolean
    delete?: InitiativeWhereInput | boolean
    connect?: InitiativeWhereUniqueInput
    update?: XOR<XOR<InitiativeUpdateToOneWithWhereWithoutSolutionsInput, InitiativeUpdateWithoutSolutionsInput>, InitiativeUncheckedUpdateWithoutSolutionsInput>
  }

  export type IdeaUpdateOneWithoutSolutionNestedInput = {
    create?: XOR<IdeaCreateWithoutSolutionInput, IdeaUncheckedCreateWithoutSolutionInput>
    connectOrCreate?: IdeaCreateOrConnectWithoutSolutionInput
    upsert?: IdeaUpsertWithoutSolutionInput
    disconnect?: IdeaWhereInput | boolean
    delete?: IdeaWhereInput | boolean
    connect?: IdeaWhereUniqueInput
    update?: XOR<XOR<IdeaUpdateToOneWithWhereWithoutSolutionInput, IdeaUpdateWithoutSolutionInput>, IdeaUncheckedUpdateWithoutSolutionInput>
  }

  export type InputUpdateOneWithoutSolutionsNestedInput = {
    create?: XOR<InputCreateWithoutSolutionsInput, InputUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: InputCreateOrConnectWithoutSolutionsInput
    upsert?: InputUpsertWithoutSolutionsInput
    disconnect?: InputWhereInput | boolean
    delete?: InputWhereInput | boolean
    connect?: InputWhereUniqueInput
    update?: XOR<XOR<InputUpdateToOneWithWhereWithoutSolutionsInput, InputUpdateWithoutSolutionsInput>, InputUncheckedUpdateWithoutSolutionsInput>
  }

  export type UserUpdateOneRequiredWithoutSolutionsNestedInput = {
    create?: XOR<UserCreateWithoutSolutionsInput, UserUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSolutionsInput
    upsert?: UserUpsertWithoutSolutionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSolutionsInput, UserUpdateWithoutSolutionsInput>, UserUncheckedUpdateWithoutSolutionsInput>
  }

  export type RequirementUpdateManyWithoutSolutionNestedInput = {
    create?: XOR<RequirementCreateWithoutSolutionInput, RequirementUncheckedCreateWithoutSolutionInput> | RequirementCreateWithoutSolutionInput[] | RequirementUncheckedCreateWithoutSolutionInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutSolutionInput | RequirementCreateOrConnectWithoutSolutionInput[]
    upsert?: RequirementUpsertWithWhereUniqueWithoutSolutionInput | RequirementUpsertWithWhereUniqueWithoutSolutionInput[]
    createMany?: RequirementCreateManySolutionInputEnvelope
    set?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    disconnect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    delete?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    update?: RequirementUpdateWithWhereUniqueWithoutSolutionInput | RequirementUpdateWithWhereUniqueWithoutSolutionInput[]
    updateMany?: RequirementUpdateManyWithWhereWithoutSolutionInput | RequirementUpdateManyWithWhereWithoutSolutionInput[]
    deleteMany?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
  }

  export type FRDDocumentUpdateManyWithoutSolutionNestedInput = {
    create?: XOR<FRDDocumentCreateWithoutSolutionInput, FRDDocumentUncheckedCreateWithoutSolutionInput> | FRDDocumentCreateWithoutSolutionInput[] | FRDDocumentUncheckedCreateWithoutSolutionInput[]
    connectOrCreate?: FRDDocumentCreateOrConnectWithoutSolutionInput | FRDDocumentCreateOrConnectWithoutSolutionInput[]
    upsert?: FRDDocumentUpsertWithWhereUniqueWithoutSolutionInput | FRDDocumentUpsertWithWhereUniqueWithoutSolutionInput[]
    createMany?: FRDDocumentCreateManySolutionInputEnvelope
    set?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    disconnect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    delete?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    update?: FRDDocumentUpdateWithWhereUniqueWithoutSolutionInput | FRDDocumentUpdateWithWhereUniqueWithoutSolutionInput[]
    updateMany?: FRDDocumentUpdateManyWithWhereWithoutSolutionInput | FRDDocumentUpdateManyWithWhereWithoutSolutionInput[]
    deleteMany?: FRDDocumentScalarWhereInput | FRDDocumentScalarWhereInput[]
  }

  export type RequirementUncheckedUpdateManyWithoutSolutionNestedInput = {
    create?: XOR<RequirementCreateWithoutSolutionInput, RequirementUncheckedCreateWithoutSolutionInput> | RequirementCreateWithoutSolutionInput[] | RequirementUncheckedCreateWithoutSolutionInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutSolutionInput | RequirementCreateOrConnectWithoutSolutionInput[]
    upsert?: RequirementUpsertWithWhereUniqueWithoutSolutionInput | RequirementUpsertWithWhereUniqueWithoutSolutionInput[]
    createMany?: RequirementCreateManySolutionInputEnvelope
    set?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    disconnect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    delete?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    update?: RequirementUpdateWithWhereUniqueWithoutSolutionInput | RequirementUpdateWithWhereUniqueWithoutSolutionInput[]
    updateMany?: RequirementUpdateManyWithWhereWithoutSolutionInput | RequirementUpdateManyWithWhereWithoutSolutionInput[]
    deleteMany?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
  }

  export type FRDDocumentUncheckedUpdateManyWithoutSolutionNestedInput = {
    create?: XOR<FRDDocumentCreateWithoutSolutionInput, FRDDocumentUncheckedCreateWithoutSolutionInput> | FRDDocumentCreateWithoutSolutionInput[] | FRDDocumentUncheckedCreateWithoutSolutionInput[]
    connectOrCreate?: FRDDocumentCreateOrConnectWithoutSolutionInput | FRDDocumentCreateOrConnectWithoutSolutionInput[]
    upsert?: FRDDocumentUpsertWithWhereUniqueWithoutSolutionInput | FRDDocumentUpsertWithWhereUniqueWithoutSolutionInput[]
    createMany?: FRDDocumentCreateManySolutionInputEnvelope
    set?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    disconnect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    delete?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    connect?: FRDDocumentWhereUniqueInput | FRDDocumentWhereUniqueInput[]
    update?: FRDDocumentUpdateWithWhereUniqueWithoutSolutionInput | FRDDocumentUpdateWithWhereUniqueWithoutSolutionInput[]
    updateMany?: FRDDocumentUpdateManyWithWhereWithoutSolutionInput | FRDDocumentUpdateManyWithWhereWithoutSolutionInput[]
    deleteMany?: FRDDocumentScalarWhereInput | FRDDocumentScalarWhereInput[]
  }

  export type SolutionCreateNestedOneWithoutRequirementsInput = {
    create?: XOR<SolutionCreateWithoutRequirementsInput, SolutionUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: SolutionCreateOrConnectWithoutRequirementsInput
    connect?: SolutionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRequirementsInput = {
    create?: XOR<UserCreateWithoutRequirementsInput, UserUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequirementsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumRequirementStatusFieldUpdateOperationsInput = {
    set?: $Enums.RequirementStatus
  }

  export type SolutionUpdateOneRequiredWithoutRequirementsNestedInput = {
    create?: XOR<SolutionCreateWithoutRequirementsInput, SolutionUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: SolutionCreateOrConnectWithoutRequirementsInput
    upsert?: SolutionUpsertWithoutRequirementsInput
    connect?: SolutionWhereUniqueInput
    update?: XOR<XOR<SolutionUpdateToOneWithWhereWithoutRequirementsInput, SolutionUpdateWithoutRequirementsInput>, SolutionUncheckedUpdateWithoutRequirementsInput>
  }

  export type UserUpdateOneRequiredWithoutRequirementsNestedInput = {
    create?: XOR<UserCreateWithoutRequirementsInput, UserUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequirementsInput
    upsert?: UserUpsertWithoutRequirementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRequirementsInput, UserUpdateWithoutRequirementsInput>, UserUncheckedUpdateWithoutRequirementsInput>
  }

  export type SolutionCreateNestedOneWithoutFrdDocumentsInput = {
    create?: XOR<SolutionCreateWithoutFrdDocumentsInput, SolutionUncheckedCreateWithoutFrdDocumentsInput>
    connectOrCreate?: SolutionCreateOrConnectWithoutFrdDocumentsInput
    connect?: SolutionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFrdDocumentsInput = {
    create?: XOR<UserCreateWithoutFrdDocumentsInput, UserUncheckedCreateWithoutFrdDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFrdDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedFRDsInput = {
    create?: XOR<UserCreateWithoutApprovedFRDsInput, UserUncheckedCreateWithoutApprovedFRDsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedFRDsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFRDStatusFieldUpdateOperationsInput = {
    set?: $Enums.FRDStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SolutionUpdateOneRequiredWithoutFrdDocumentsNestedInput = {
    create?: XOR<SolutionCreateWithoutFrdDocumentsInput, SolutionUncheckedCreateWithoutFrdDocumentsInput>
    connectOrCreate?: SolutionCreateOrConnectWithoutFrdDocumentsInput
    upsert?: SolutionUpsertWithoutFrdDocumentsInput
    connect?: SolutionWhereUniqueInput
    update?: XOR<XOR<SolutionUpdateToOneWithWhereWithoutFrdDocumentsInput, SolutionUpdateWithoutFrdDocumentsInput>, SolutionUncheckedUpdateWithoutFrdDocumentsInput>
  }

  export type UserUpdateOneRequiredWithoutFrdDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutFrdDocumentsInput, UserUncheckedCreateWithoutFrdDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFrdDocumentsInput
    upsert?: UserUpsertWithoutFrdDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFrdDocumentsInput, UserUpdateWithoutFrdDocumentsInput>, UserUncheckedUpdateWithoutFrdDocumentsInput>
  }

  export type UserUpdateOneWithoutApprovedFRDsNestedInput = {
    create?: XOR<UserCreateWithoutApprovedFRDsInput, UserUncheckedCreateWithoutApprovedFRDsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedFRDsInput
    upsert?: UserUpsertWithoutApprovedFRDsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedFRDsInput, UserUpdateWithoutApprovedFRDsInput>, UserUncheckedUpdateWithoutApprovedFRDsInput>
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutThreadInput = {
    create?: XOR<CommentCreateWithoutThreadInput, CommentUncheckedCreateWithoutThreadInput> | CommentCreateWithoutThreadInput[] | CommentUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutThreadInput | CommentCreateOrConnectWithoutThreadInput[]
    createMany?: CommentCreateManyThreadInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<CommentCreateWithoutThreadInput, CommentUncheckedCreateWithoutThreadInput> | CommentCreateWithoutThreadInput[] | CommentUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutThreadInput | CommentCreateOrConnectWithoutThreadInput[]
    createMany?: CommentCreateManyThreadInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type EnumEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.EntityType
  }

  export type CommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateManyWithoutThreadNestedInput = {
    create?: XOR<CommentCreateWithoutThreadInput, CommentUncheckedCreateWithoutThreadInput> | CommentCreateWithoutThreadInput[] | CommentUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutThreadInput | CommentCreateOrConnectWithoutThreadInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutThreadInput | CommentUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: CommentCreateManyThreadInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutThreadInput | CommentUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutThreadInput | CommentUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<CommentCreateWithoutThreadInput, CommentUncheckedCreateWithoutThreadInput> | CommentCreateWithoutThreadInput[] | CommentUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutThreadInput | CommentCreateOrConnectWithoutThreadInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutThreadInput | CommentUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: CommentCreateManyThreadInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutThreadInput | CommentUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutThreadInput | CommentUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutVotesInput = {
    create?: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVotesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumVoteValueFieldUpdateOperationsInput = {
    set?: $Enums.VoteValue
  }

  export type UserUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVotesInput
    upsert?: UserUpsertWithoutVotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVotesInput, UserUpdateWithoutVotesInput>, UserUncheckedUpdateWithoutVotesInput>
  }

  export type UserCreateNestedOneWithoutInputGroupsInput = {
    create?: XOR<UserCreateWithoutInputGroupsInput, UserUncheckedCreateWithoutInputGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInputGroupsInput
    connect?: UserWhereUniqueInput
  }

  export type InputCreateNestedManyWithoutGroupsInput = {
    create?: XOR<InputCreateWithoutGroupsInput, InputUncheckedCreateWithoutGroupsInput> | InputCreateWithoutGroupsInput[] | InputUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: InputCreateOrConnectWithoutGroupsInput | InputCreateOrConnectWithoutGroupsInput[]
    connect?: InputWhereUniqueInput | InputWhereUniqueInput[]
  }

  export type InputUncheckedCreateNestedManyWithoutGroupsInput = {
    create?: XOR<InputCreateWithoutGroupsInput, InputUncheckedCreateWithoutGroupsInput> | InputCreateWithoutGroupsInput[] | InputUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: InputCreateOrConnectWithoutGroupsInput | InputCreateOrConnectWithoutGroupsInput[]
    connect?: InputWhereUniqueInput | InputWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutInputGroupsNestedInput = {
    create?: XOR<UserCreateWithoutInputGroupsInput, UserUncheckedCreateWithoutInputGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInputGroupsInput
    upsert?: UserUpsertWithoutInputGroupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInputGroupsInput, UserUpdateWithoutInputGroupsInput>, UserUncheckedUpdateWithoutInputGroupsInput>
  }

  export type InputUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<InputCreateWithoutGroupsInput, InputUncheckedCreateWithoutGroupsInput> | InputCreateWithoutGroupsInput[] | InputUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: InputCreateOrConnectWithoutGroupsInput | InputCreateOrConnectWithoutGroupsInput[]
    upsert?: InputUpsertWithWhereUniqueWithoutGroupsInput | InputUpsertWithWhereUniqueWithoutGroupsInput[]
    set?: InputWhereUniqueInput | InputWhereUniqueInput[]
    disconnect?: InputWhereUniqueInput | InputWhereUniqueInput[]
    delete?: InputWhereUniqueInput | InputWhereUniqueInput[]
    connect?: InputWhereUniqueInput | InputWhereUniqueInput[]
    update?: InputUpdateWithWhereUniqueWithoutGroupsInput | InputUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: InputUpdateManyWithWhereWithoutGroupsInput | InputUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: InputScalarWhereInput | InputScalarWhereInput[]
  }

  export type InputUncheckedUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<InputCreateWithoutGroupsInput, InputUncheckedCreateWithoutGroupsInput> | InputCreateWithoutGroupsInput[] | InputUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: InputCreateOrConnectWithoutGroupsInput | InputCreateOrConnectWithoutGroupsInput[]
    upsert?: InputUpsertWithWhereUniqueWithoutGroupsInput | InputUpsertWithWhereUniqueWithoutGroupsInput[]
    set?: InputWhereUniqueInput | InputWhereUniqueInput[]
    disconnect?: InputWhereUniqueInput | InputWhereUniqueInput[]
    delete?: InputWhereUniqueInput | InputWhereUniqueInput[]
    connect?: InputWhereUniqueInput | InputWhereUniqueInput[]
    update?: InputUpdateWithWhereUniqueWithoutGroupsInput | InputUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: InputUpdateManyWithWhereWithoutGroupsInput | InputUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: InputScalarWhereInput | InputScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type NullableEnumEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.EntityType | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSeverityFilter<$PrismaModel> | $Enums.Severity
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSeverityWithAggregatesFilter<$PrismaModel> | $Enums.Severity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeverityFilter<$PrismaModel>
    _max?: NestedEnumSeverityFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumHotspotStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HotspotStatus | EnumHotspotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HotspotStatus[] | ListEnumHotspotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HotspotStatus[] | ListEnumHotspotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHotspotStatusFilter<$PrismaModel> | $Enums.HotspotStatus
  }

  export type NestedEnumHotspotStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HotspotStatus | EnumHotspotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HotspotStatus[] | ListEnumHotspotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HotspotStatus[] | ListEnumHotspotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHotspotStatusWithAggregatesFilter<$PrismaModel> | $Enums.HotspotStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHotspotStatusFilter<$PrismaModel>
    _max?: NestedEnumHotspotStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumInputTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InputType | EnumInputTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInputTypeFilter<$PrismaModel> | $Enums.InputType
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumInputStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InputStatus | EnumInputStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InputStatus[] | ListEnumInputStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InputStatus[] | ListEnumInputStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInputStatusFilter<$PrismaModel> | $Enums.InputStatus
  }

  export type NestedEnumInputTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InputType | EnumInputTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InputType[] | ListEnumInputTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInputTypeWithAggregatesFilter<$PrismaModel> | $Enums.InputType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInputTypeFilter<$PrismaModel>
    _max?: NestedEnumInputTypeFilter<$PrismaModel>
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumInputStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InputStatus | EnumInputStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InputStatus[] | ListEnumInputStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InputStatus[] | ListEnumInputStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInputStatusWithAggregatesFilter<$PrismaModel> | $Enums.InputStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInputStatusFilter<$PrismaModel>
    _max?: NestedEnumInputStatusFilter<$PrismaModel>
  }

  export type NestedEnumSolutionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SolutionStatus | EnumSolutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SolutionStatus[] | ListEnumSolutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SolutionStatus[] | ListEnumSolutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSolutionStatusFilter<$PrismaModel> | $Enums.SolutionStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSolutionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SolutionStatus | EnumSolutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SolutionStatus[] | ListEnumSolutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SolutionStatus[] | ListEnumSolutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSolutionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SolutionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSolutionStatusFilter<$PrismaModel>
    _max?: NestedEnumSolutionStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumRequirementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementStatus | EnumRequirementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementStatusFilter<$PrismaModel> | $Enums.RequirementStatus
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumRequirementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementStatus | EnumRequirementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequirementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequirementStatusFilter<$PrismaModel>
    _max?: NestedEnumRequirementStatusFilter<$PrismaModel>
  }

  export type NestedEnumFRDStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FRDStatus | EnumFRDStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFRDStatusFilter<$PrismaModel> | $Enums.FRDStatus
  }

  export type NestedEnumFRDStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FRDStatus | EnumFRDStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FRDStatus[] | ListEnumFRDStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFRDStatusWithAggregatesFilter<$PrismaModel> | $Enums.FRDStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFRDStatusFilter<$PrismaModel>
    _max?: NestedEnumFRDStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityTypeFilter<$PrismaModel> | $Enums.EntityType
  }

  export type NestedEnumEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.EntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumEntityTypeFilter<$PrismaModel>
  }

  export type NestedEnumVoteValueFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteValue | EnumVoteValueFieldRefInput<$PrismaModel>
    in?: $Enums.VoteValue[] | ListEnumVoteValueFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteValue[] | ListEnumVoteValueFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteValueFilter<$PrismaModel> | $Enums.VoteValue
  }

  export type NestedEnumVoteValueWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteValue | EnumVoteValueFieldRefInput<$PrismaModel>
    in?: $Enums.VoteValue[] | ListEnumVoteValueFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteValue[] | ListEnumVoteValueFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteValueWithAggregatesFilter<$PrismaModel> | $Enums.VoteValue
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoteValueFilter<$PrismaModel>
    _max?: NestedEnumVoteValueFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumEntityTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEntityTypeNullableFilter<$PrismaModel> | $Enums.EntityType | null
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumEntityTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEntityTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EntityType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEntityTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumEntityTypeNullableFilter<$PrismaModel>
  }

  export type InputCreateWithoutCreatorInput = {
    id?: string
    title: string
    description: string
    type?: $Enums.InputType
    department?: string | null
    issueType?: string | null
    rootCause?: string | null
    priority?: $Enums.Priority
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: number | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.InputStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    solutions?: SolutionCreateNestedManyWithoutInputInput
    groups?: InputGroupCreateNestedManyWithoutInputsInput
  }

  export type InputUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description: string
    type?: $Enums.InputType
    department?: string | null
    issueType?: string | null
    rootCause?: string | null
    priority?: $Enums.Priority
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: number | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.InputStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    solutions?: SolutionUncheckedCreateNestedManyWithoutInputInput
    groups?: InputGroupUncheckedCreateNestedManyWithoutInputsInput
  }

  export type InputCreateOrConnectWithoutCreatorInput = {
    where: InputWhereUniqueInput
    create: XOR<InputCreateWithoutCreatorInput, InputUncheckedCreateWithoutCreatorInput>
  }

  export type InputCreateManyCreatorInputEnvelope = {
    data: InputCreateManyCreatorInput | InputCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type SignalCreateWithoutCreatedByInput = {
    id?: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutSignalsInput
    team?: TeamCreateNestedOneWithoutSignalsInput
    hotspots?: HotspotSignalCreateNestedManyWithoutSignalInput
  }

  export type SignalUncheckedCreateWithoutCreatedByInput = {
    id?: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    departmentId?: string | null
    teamId?: string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotspots?: HotspotSignalUncheckedCreateNestedManyWithoutSignalInput
  }

  export type SignalCreateOrConnectWithoutCreatedByInput = {
    where: SignalWhereUniqueInput
    create: XOR<SignalCreateWithoutCreatedByInput, SignalUncheckedCreateWithoutCreatedByInput>
  }

  export type SignalCreateManyCreatedByInputEnvelope = {
    data: SignalCreateManyCreatedByInput | SignalCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type InitiativeCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    solutions?: SolutionCreateNestedManyWithoutInitiativeInput
  }

  export type InitiativeUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    solutions?: SolutionUncheckedCreateNestedManyWithoutInitiativeInput
  }

  export type InitiativeCreateOrConnectWithoutOwnerInput = {
    where: InitiativeWhereUniqueInput
    create: XOR<InitiativeCreateWithoutOwnerInput, InitiativeUncheckedCreateWithoutOwnerInput>
  }

  export type InitiativeCreateManyOwnerInputEnvelope = {
    data: InitiativeCreateManyOwnerInput | InitiativeCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type IdeaCreateWithoutCreatedByInput = {
    id?: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotspot: HotspotCreateNestedOneWithoutIdeasInput
    solution?: SolutionCreateNestedOneWithoutIdeaInput
  }

  export type IdeaUncheckedCreateWithoutCreatedByInput = {
    id?: string
    hotspotId: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    solution?: SolutionUncheckedCreateNestedOneWithoutIdeaInput
  }

  export type IdeaCreateOrConnectWithoutCreatedByInput = {
    where: IdeaWhereUniqueInput
    create: XOR<IdeaCreateWithoutCreatedByInput, IdeaUncheckedCreateWithoutCreatedByInput>
  }

  export type IdeaCreateManyCreatedByInputEnvelope = {
    data: IdeaCreateManyCreatedByInput | IdeaCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type SolutionCreateWithoutCreatorInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    targetDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    estimatedEffort?: string | null
    businessValue?: string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotspot?: HotspotCreateNestedOneWithoutSolutionsInput
    initiative?: InitiativeCreateNestedOneWithoutSolutionsInput
    idea?: IdeaCreateNestedOneWithoutSolutionInput
    input?: InputCreateNestedOneWithoutSolutionsInput
    requirements?: RequirementCreateNestedManyWithoutSolutionInput
    frdDocuments?: FRDDocumentCreateNestedManyWithoutSolutionInput
  }

  export type SolutionUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    hotspotId?: string | null
    initiativeId?: string | null
    ideaId?: string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    targetDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    estimatedEffort?: string | null
    businessValue?: string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    inputId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requirements?: RequirementUncheckedCreateNestedManyWithoutSolutionInput
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutSolutionInput
  }

  export type SolutionCreateOrConnectWithoutCreatorInput = {
    where: SolutionWhereUniqueInput
    create: XOR<SolutionCreateWithoutCreatorInput, SolutionUncheckedCreateWithoutCreatorInput>
  }

  export type SolutionCreateManyCreatorInputEnvelope = {
    data: SolutionCreateManyCreatorInput | SolutionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutCreatorInput = {
    id?: string
    content: string
    entityType: $Enums.EntityType
    entityId: string
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: boolean
    editedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    thread?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutThreadInput
  }

  export type CommentUncheckedCreateWithoutCreatorInput = {
    id?: string
    content: string
    entityType: $Enums.EntityType
    entityId: string
    parentId?: string | null
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: boolean
    editedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutThreadInput
  }

  export type CommentCreateOrConnectWithoutCreatorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutCreatorInput, CommentUncheckedCreateWithoutCreatorInput>
  }

  export type CommentCreateManyCreatorInputEnvelope = {
    data: CommentCreateManyCreatorInput | CommentCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type VoteCreateWithoutCreatorInput = {
    id?: string
    value: $Enums.VoteValue
    entityType: $Enums.EntityType
    entityId: string
    createdAt?: Date | string
  }

  export type VoteUncheckedCreateWithoutCreatorInput = {
    id?: string
    value: $Enums.VoteValue
    entityType: $Enums.EntityType
    entityId: string
    createdAt?: Date | string
  }

  export type VoteCreateOrConnectWithoutCreatorInput = {
    where: VoteWhereUniqueInput
    create: XOR<VoteCreateWithoutCreatorInput, VoteUncheckedCreateWithoutCreatorInput>
  }

  export type VoteCreateManyCreatorInputEnvelope = {
    data: VoteCreateManyCreatorInput | VoteCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type RequirementCreateWithoutCreatorInput = {
    id?: string
    title: string
    description: string
    acceptanceCriteria: JsonNullValueInput | InputJsonValue
    priority?: $Enums.Priority
    status?: $Enums.RequirementStatus
    estimatedEffort?: string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    riskAssessment?: string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    solution: SolutionCreateNestedOneWithoutRequirementsInput
  }

  export type RequirementUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description: string
    acceptanceCriteria: JsonNullValueInput | InputJsonValue
    priority?: $Enums.Priority
    status?: $Enums.RequirementStatus
    estimatedEffort?: string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    riskAssessment?: string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    solutionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequirementCreateOrConnectWithoutCreatorInput = {
    where: RequirementWhereUniqueInput
    create: XOR<RequirementCreateWithoutCreatorInput, RequirementUncheckedCreateWithoutCreatorInput>
  }

  export type RequirementCreateManyCreatorInputEnvelope = {
    data: RequirementCreateManyCreatorInput | RequirementCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type FRDDocumentCreateWithoutCreatorInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    solution: SolutionCreateNestedOneWithoutFrdDocumentsInput
    approver?: UserCreateNestedOneWithoutApprovedFRDsInput
  }

  export type FRDDocumentUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    solutionId: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FRDDocumentCreateOrConnectWithoutCreatorInput = {
    where: FRDDocumentWhereUniqueInput
    create: XOR<FRDDocumentCreateWithoutCreatorInput, FRDDocumentUncheckedCreateWithoutCreatorInput>
  }

  export type FRDDocumentCreateManyCreatorInputEnvelope = {
    data: FRDDocumentCreateManyCreatorInput | FRDDocumentCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type FRDDocumentCreateWithoutApproverInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    solution: SolutionCreateNestedOneWithoutFrdDocumentsInput
    creator: UserCreateNestedOneWithoutFrdDocumentsInput
  }

  export type FRDDocumentUncheckedCreateWithoutApproverInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    solutionId: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FRDDocumentCreateOrConnectWithoutApproverInput = {
    where: FRDDocumentWhereUniqueInput
    create: XOR<FRDDocumentCreateWithoutApproverInput, FRDDocumentUncheckedCreateWithoutApproverInput>
  }

  export type FRDDocumentCreateManyApproverInputEnvelope = {
    data: FRDDocumentCreateManyApproverInput | FRDDocumentCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    sessionId?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    sessionId?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InputGroupCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    aiSuggested?: boolean
    aiConfidence?: number | null
    aiReasoning?: string | null
    inputCount?: number
    avgPriority?: number | null
    lastActivity?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputCreateNestedManyWithoutGroupsInput
  }

  export type InputGroupUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    aiSuggested?: boolean
    aiConfidence?: number | null
    aiReasoning?: string | null
    inputCount?: number
    avgPriority?: number | null
    lastActivity?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type InputGroupCreateOrConnectWithoutCreatorInput = {
    where: InputGroupWhereUniqueInput
    create: XOR<InputGroupCreateWithoutCreatorInput, InputGroupUncheckedCreateWithoutCreatorInput>
  }

  export type InputGroupCreateManyCreatorInputEnvelope = {
    data: InputGroupCreateManyCreatorInput | InputGroupCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type InputUpsertWithWhereUniqueWithoutCreatorInput = {
    where: InputWhereUniqueInput
    update: XOR<InputUpdateWithoutCreatorInput, InputUncheckedUpdateWithoutCreatorInput>
    create: XOR<InputCreateWithoutCreatorInput, InputUncheckedCreateWithoutCreatorInput>
  }

  export type InputUpdateWithWhereUniqueWithoutCreatorInput = {
    where: InputWhereUniqueInput
    data: XOR<InputUpdateWithoutCreatorInput, InputUncheckedUpdateWithoutCreatorInput>
  }

  export type InputUpdateManyWithWhereWithoutCreatorInput = {
    where: InputScalarWhereInput
    data: XOR<InputUpdateManyMutationInput, InputUncheckedUpdateManyWithoutCreatorInput>
  }

  export type InputScalarWhereInput = {
    AND?: InputScalarWhereInput | InputScalarWhereInput[]
    OR?: InputScalarWhereInput[]
    NOT?: InputScalarWhereInput | InputScalarWhereInput[]
    id?: StringFilter<"Input"> | string
    title?: StringFilter<"Input"> | string
    description?: StringFilter<"Input"> | string
    type?: EnumInputTypeFilter<"Input"> | $Enums.InputType
    department?: StringNullableFilter<"Input"> | string | null
    issueType?: StringNullableFilter<"Input"> | string | null
    rootCause?: StringNullableFilter<"Input"> | string | null
    priority?: EnumPriorityFilter<"Input"> | $Enums.Priority
    aiTags?: JsonNullableFilter<"Input">
    aiConfidence?: FloatNullableFilter<"Input"> | number | null
    aiSuggestions?: JsonNullableFilter<"Input">
    status?: EnumInputStatusFilter<"Input"> | $Enums.InputStatus
    createdBy?: StringFilter<"Input"> | string
    createdAt?: DateTimeFilter<"Input"> | Date | string
    updatedAt?: DateTimeFilter<"Input"> | Date | string
  }

  export type SignalUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: SignalWhereUniqueInput
    update: XOR<SignalUpdateWithoutCreatedByInput, SignalUncheckedUpdateWithoutCreatedByInput>
    create: XOR<SignalCreateWithoutCreatedByInput, SignalUncheckedCreateWithoutCreatedByInput>
  }

  export type SignalUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: SignalWhereUniqueInput
    data: XOR<SignalUpdateWithoutCreatedByInput, SignalUncheckedUpdateWithoutCreatedByInput>
  }

  export type SignalUpdateManyWithWhereWithoutCreatedByInput = {
    where: SignalScalarWhereInput
    data: XOR<SignalUpdateManyMutationInput, SignalUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type SignalScalarWhereInput = {
    AND?: SignalScalarWhereInput | SignalScalarWhereInput[]
    OR?: SignalScalarWhereInput[]
    NOT?: SignalScalarWhereInput | SignalScalarWhereInput[]
    id?: StringFilter<"Signal"> | string
    inputId?: StringFilter<"Signal"> | string
    timestamp?: DateTimeFilter<"Signal"> | Date | string
    receivedAt?: DateTimeFilter<"Signal"> | Date | string
    schemaVersion?: StringFilter<"Signal"> | string
    sourceJson?: JsonNullableFilter<"Signal">
    confidence?: FloatNullableFilter<"Signal"> | number | null
    attachmentsJson?: JsonNullableFilter<"Signal">
    sourceType?: StringFilter<"Signal"> | string
    sourceId?: StringNullableFilter<"Signal"> | string | null
    systemName?: StringNullableFilter<"Signal"> | string | null
    title?: StringNullableFilter<"Signal"> | string | null
    description?: StringFilter<"Signal"> | string
    severity?: EnumSeverityFilter<"Signal"> | $Enums.Severity
    severityScore?: IntFilter<"Signal"> | number
    departmentId?: StringNullableFilter<"Signal"> | string | null
    teamId?: StringNullableFilter<"Signal"> | string | null
    metricsJson?: JsonNullableFilter<"Signal">
    baselineJson?: JsonNullableFilter<"Signal">
    impactJson?: JsonNullableFilter<"Signal">
    tagsJson?: JsonNullableFilter<"Signal">
    entitiesJson?: JsonNullableFilter<"Signal">
    privacyLevel?: StringNullableFilter<"Signal"> | string | null
    dedupeKey?: StringNullableFilter<"Signal"> | string | null
    embedding?: BytesNullableFilter<"Signal"> | Uint8Array | null
    aiProcessed?: BoolFilter<"Signal"> | boolean
    aiTagsJson?: JsonNullableFilter<"Signal">
    lineageJson?: JsonNullableFilter<"Signal">
    createdById?: StringNullableFilter<"Signal"> | string | null
    createdAt?: DateTimeFilter<"Signal"> | Date | string
    updatedAt?: DateTimeFilter<"Signal"> | Date | string
  }

  export type InitiativeUpsertWithWhereUniqueWithoutOwnerInput = {
    where: InitiativeWhereUniqueInput
    update: XOR<InitiativeUpdateWithoutOwnerInput, InitiativeUncheckedUpdateWithoutOwnerInput>
    create: XOR<InitiativeCreateWithoutOwnerInput, InitiativeUncheckedCreateWithoutOwnerInput>
  }

  export type InitiativeUpdateWithWhereUniqueWithoutOwnerInput = {
    where: InitiativeWhereUniqueInput
    data: XOR<InitiativeUpdateWithoutOwnerInput, InitiativeUncheckedUpdateWithoutOwnerInput>
  }

  export type InitiativeUpdateManyWithWhereWithoutOwnerInput = {
    where: InitiativeScalarWhereInput
    data: XOR<InitiativeUpdateManyMutationInput, InitiativeUncheckedUpdateManyWithoutOwnerInput>
  }

  export type InitiativeScalarWhereInput = {
    AND?: InitiativeScalarWhereInput | InitiativeScalarWhereInput[]
    OR?: InitiativeScalarWhereInput[]
    NOT?: InitiativeScalarWhereInput | InitiativeScalarWhereInput[]
    id?: StringFilter<"Initiative"> | string
    name?: StringFilter<"Initiative"> | string
    description?: StringNullableFilter<"Initiative"> | string | null
    ownerId?: StringNullableFilter<"Initiative"> | string | null
    goalJson?: JsonNullableFilter<"Initiative">
    roiJson?: JsonNullableFilter<"Initiative">
    createdAt?: DateTimeFilter<"Initiative"> | Date | string
    updatedAt?: DateTimeFilter<"Initiative"> | Date | string
  }

  export type IdeaUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: IdeaWhereUniqueInput
    update: XOR<IdeaUpdateWithoutCreatedByInput, IdeaUncheckedUpdateWithoutCreatedByInput>
    create: XOR<IdeaCreateWithoutCreatedByInput, IdeaUncheckedCreateWithoutCreatedByInput>
  }

  export type IdeaUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: IdeaWhereUniqueInput
    data: XOR<IdeaUpdateWithoutCreatedByInput, IdeaUncheckedUpdateWithoutCreatedByInput>
  }

  export type IdeaUpdateManyWithWhereWithoutCreatedByInput = {
    where: IdeaScalarWhereInput
    data: XOR<IdeaUpdateManyMutationInput, IdeaUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type IdeaScalarWhereInput = {
    AND?: IdeaScalarWhereInput | IdeaScalarWhereInput[]
    OR?: IdeaScalarWhereInput[]
    NOT?: IdeaScalarWhereInput | IdeaScalarWhereInput[]
    id?: StringFilter<"Idea"> | string
    hotspotId?: StringFilter<"Idea"> | string
    title?: StringNullableFilter<"Idea"> | string | null
    description?: StringFilter<"Idea"> | string
    origin?: StringFilter<"Idea"> | string
    votes?: IntFilter<"Idea"> | number
    status?: StringFilter<"Idea"> | string
    evidenceJson?: JsonNullableFilter<"Idea">
    tagsJson?: JsonNullableFilter<"Idea">
    confidence?: FloatNullableFilter<"Idea"> | number | null
    createdById?: StringNullableFilter<"Idea"> | string | null
    createdAt?: DateTimeFilter<"Idea"> | Date | string
    updatedAt?: DateTimeFilter<"Idea"> | Date | string
  }

  export type SolutionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: SolutionWhereUniqueInput
    update: XOR<SolutionUpdateWithoutCreatorInput, SolutionUncheckedUpdateWithoutCreatorInput>
    create: XOR<SolutionCreateWithoutCreatorInput, SolutionUncheckedCreateWithoutCreatorInput>
  }

  export type SolutionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: SolutionWhereUniqueInput
    data: XOR<SolutionUpdateWithoutCreatorInput, SolutionUncheckedUpdateWithoutCreatorInput>
  }

  export type SolutionUpdateManyWithWhereWithoutCreatorInput = {
    where: SolutionScalarWhereInput
    data: XOR<SolutionUpdateManyMutationInput, SolutionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type SolutionScalarWhereInput = {
    AND?: SolutionScalarWhereInput | SolutionScalarWhereInput[]
    OR?: SolutionScalarWhereInput[]
    NOT?: SolutionScalarWhereInput | SolutionScalarWhereInput[]
    id?: StringFilter<"Solution"> | string
    title?: StringFilter<"Solution"> | string
    description?: StringFilter<"Solution"> | string
    status?: EnumSolutionStatusFilter<"Solution"> | $Enums.SolutionStatus
    hotspotId?: StringNullableFilter<"Solution"> | string | null
    initiativeId?: StringNullableFilter<"Solution"> | string | null
    ideaId?: StringNullableFilter<"Solution"> | string | null
    tasks?: JsonNullableFilter<"Solution">
    progress?: FloatFilter<"Solution"> | number
    targetDate?: DateTimeNullableFilter<"Solution"> | Date | string | null
    actualCompletionDate?: DateTimeNullableFilter<"Solution"> | Date | string | null
    estimatedEffort?: StringNullableFilter<"Solution"> | string | null
    businessValue?: StringNullableFilter<"Solution"> | string | null
    successMetrics?: JsonNullableFilter<"Solution">
    expectedImpactJson?: JsonNullableFilter<"Solution">
    actualImpactJson?: JsonNullableFilter<"Solution">
    inputId?: StringNullableFilter<"Solution"> | string | null
    createdBy?: StringFilter<"Solution"> | string
    createdAt?: DateTimeFilter<"Solution"> | Date | string
    updatedAt?: DateTimeFilter<"Solution"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutCreatorInput, CommentUncheckedUpdateWithoutCreatorInput>
    create: XOR<CommentCreateWithoutCreatorInput, CommentUncheckedCreateWithoutCreatorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutCreatorInput, CommentUncheckedUpdateWithoutCreatorInput>
  }

  export type CommentUpdateManyWithWhereWithoutCreatorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    entityType?: EnumEntityTypeFilter<"Comment"> | $Enums.EntityType
    entityId?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    mentions?: JsonNullableFilter<"Comment">
    edited?: BoolFilter<"Comment"> | boolean
    editedAt?: DateTimeNullableFilter<"Comment"> | Date | string | null
    createdBy?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type VoteUpsertWithWhereUniqueWithoutCreatorInput = {
    where: VoteWhereUniqueInput
    update: XOR<VoteUpdateWithoutCreatorInput, VoteUncheckedUpdateWithoutCreatorInput>
    create: XOR<VoteCreateWithoutCreatorInput, VoteUncheckedCreateWithoutCreatorInput>
  }

  export type VoteUpdateWithWhereUniqueWithoutCreatorInput = {
    where: VoteWhereUniqueInput
    data: XOR<VoteUpdateWithoutCreatorInput, VoteUncheckedUpdateWithoutCreatorInput>
  }

  export type VoteUpdateManyWithWhereWithoutCreatorInput = {
    where: VoteScalarWhereInput
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyWithoutCreatorInput>
  }

  export type VoteScalarWhereInput = {
    AND?: VoteScalarWhereInput | VoteScalarWhereInput[]
    OR?: VoteScalarWhereInput[]
    NOT?: VoteScalarWhereInput | VoteScalarWhereInput[]
    id?: StringFilter<"Vote"> | string
    value?: EnumVoteValueFilter<"Vote"> | $Enums.VoteValue
    entityType?: EnumEntityTypeFilter<"Vote"> | $Enums.EntityType
    entityId?: StringFilter<"Vote"> | string
    createdBy?: StringFilter<"Vote"> | string
    createdAt?: DateTimeFilter<"Vote"> | Date | string
  }

  export type RequirementUpsertWithWhereUniqueWithoutCreatorInput = {
    where: RequirementWhereUniqueInput
    update: XOR<RequirementUpdateWithoutCreatorInput, RequirementUncheckedUpdateWithoutCreatorInput>
    create: XOR<RequirementCreateWithoutCreatorInput, RequirementUncheckedCreateWithoutCreatorInput>
  }

  export type RequirementUpdateWithWhereUniqueWithoutCreatorInput = {
    where: RequirementWhereUniqueInput
    data: XOR<RequirementUpdateWithoutCreatorInput, RequirementUncheckedUpdateWithoutCreatorInput>
  }

  export type RequirementUpdateManyWithWhereWithoutCreatorInput = {
    where: RequirementScalarWhereInput
    data: XOR<RequirementUpdateManyMutationInput, RequirementUncheckedUpdateManyWithoutCreatorInput>
  }

  export type RequirementScalarWhereInput = {
    AND?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
    OR?: RequirementScalarWhereInput[]
    NOT?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
    id?: StringFilter<"Requirement"> | string
    title?: StringFilter<"Requirement"> | string
    description?: StringFilter<"Requirement"> | string
    acceptanceCriteria?: JsonFilter<"Requirement">
    priority?: EnumPriorityFilter<"Requirement"> | $Enums.Priority
    status?: EnumRequirementStatusFilter<"Requirement"> | $Enums.RequirementStatus
    estimatedEffort?: StringNullableFilter<"Requirement"> | string | null
    dependencies?: JsonNullableFilter<"Requirement">
    businessValue?: StringNullableFilter<"Requirement"> | string | null
    riskAssessment?: StringNullableFilter<"Requirement"> | string | null
    stakeholders?: JsonNullableFilter<"Requirement">
    approvedBy?: StringNullableFilter<"Requirement"> | string | null
    approvedAt?: DateTimeNullableFilter<"Requirement"> | Date | string | null
    rejectionReason?: StringNullableFilter<"Requirement"> | string | null
    solutionId?: StringFilter<"Requirement"> | string
    createdBy?: StringFilter<"Requirement"> | string
    createdAt?: DateTimeFilter<"Requirement"> | Date | string
    updatedAt?: DateTimeFilter<"Requirement"> | Date | string
  }

  export type FRDDocumentUpsertWithWhereUniqueWithoutCreatorInput = {
    where: FRDDocumentWhereUniqueInput
    update: XOR<FRDDocumentUpdateWithoutCreatorInput, FRDDocumentUncheckedUpdateWithoutCreatorInput>
    create: XOR<FRDDocumentCreateWithoutCreatorInput, FRDDocumentUncheckedCreateWithoutCreatorInput>
  }

  export type FRDDocumentUpdateWithWhereUniqueWithoutCreatorInput = {
    where: FRDDocumentWhereUniqueInput
    data: XOR<FRDDocumentUpdateWithoutCreatorInput, FRDDocumentUncheckedUpdateWithoutCreatorInput>
  }

  export type FRDDocumentUpdateManyWithWhereWithoutCreatorInput = {
    where: FRDDocumentScalarWhereInput
    data: XOR<FRDDocumentUpdateManyMutationInput, FRDDocumentUncheckedUpdateManyWithoutCreatorInput>
  }

  export type FRDDocumentScalarWhereInput = {
    AND?: FRDDocumentScalarWhereInput | FRDDocumentScalarWhereInput[]
    OR?: FRDDocumentScalarWhereInput[]
    NOT?: FRDDocumentScalarWhereInput | FRDDocumentScalarWhereInput[]
    id?: StringFilter<"FRDDocument"> | string
    title?: StringFilter<"FRDDocument"> | string
    content?: JsonFilter<"FRDDocument">
    aiGenerated?: BoolFilter<"FRDDocument"> | boolean
    aiConfidence?: FloatNullableFilter<"FRDDocument"> | number | null
    aiPromptUsed?: StringNullableFilter<"FRDDocument"> | string | null
    version?: StringFilter<"FRDDocument"> | string
    status?: EnumFRDStatusFilter<"FRDDocument"> | $Enums.FRDStatus
    executiveApproved?: BoolFilter<"FRDDocument"> | boolean
    exportFormats?: JsonNullableFilter<"FRDDocument">
    templateUsed?: StringNullableFilter<"FRDDocument"> | string | null
    generationTime?: FloatNullableFilter<"FRDDocument"> | number | null
    wordCount?: IntNullableFilter<"FRDDocument"> | number | null
    lastExportedAt?: DateTimeNullableFilter<"FRDDocument"> | Date | string | null
    solutionId?: StringFilter<"FRDDocument"> | string
    createdBy?: StringFilter<"FRDDocument"> | string
    approvedBy?: StringNullableFilter<"FRDDocument"> | string | null
    createdAt?: DateTimeFilter<"FRDDocument"> | Date | string
    updatedAt?: DateTimeFilter<"FRDDocument"> | Date | string
  }

  export type FRDDocumentUpsertWithWhereUniqueWithoutApproverInput = {
    where: FRDDocumentWhereUniqueInput
    update: XOR<FRDDocumentUpdateWithoutApproverInput, FRDDocumentUncheckedUpdateWithoutApproverInput>
    create: XOR<FRDDocumentCreateWithoutApproverInput, FRDDocumentUncheckedCreateWithoutApproverInput>
  }

  export type FRDDocumentUpdateWithWhereUniqueWithoutApproverInput = {
    where: FRDDocumentWhereUniqueInput
    data: XOR<FRDDocumentUpdateWithoutApproverInput, FRDDocumentUncheckedUpdateWithoutApproverInput>
  }

  export type FRDDocumentUpdateManyWithWhereWithoutApproverInput = {
    where: FRDDocumentScalarWhereInput
    data: XOR<FRDDocumentUpdateManyMutationInput, FRDDocumentUncheckedUpdateManyWithoutApproverInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    sessionId?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type InputGroupUpsertWithWhereUniqueWithoutCreatorInput = {
    where: InputGroupWhereUniqueInput
    update: XOR<InputGroupUpdateWithoutCreatorInput, InputGroupUncheckedUpdateWithoutCreatorInput>
    create: XOR<InputGroupCreateWithoutCreatorInput, InputGroupUncheckedCreateWithoutCreatorInput>
  }

  export type InputGroupUpdateWithWhereUniqueWithoutCreatorInput = {
    where: InputGroupWhereUniqueInput
    data: XOR<InputGroupUpdateWithoutCreatorInput, InputGroupUncheckedUpdateWithoutCreatorInput>
  }

  export type InputGroupUpdateManyWithWhereWithoutCreatorInput = {
    where: InputGroupScalarWhereInput
    data: XOR<InputGroupUpdateManyMutationInput, InputGroupUncheckedUpdateManyWithoutCreatorInput>
  }

  export type InputGroupScalarWhereInput = {
    AND?: InputGroupScalarWhereInput | InputGroupScalarWhereInput[]
    OR?: InputGroupScalarWhereInput[]
    NOT?: InputGroupScalarWhereInput | InputGroupScalarWhereInput[]
    id?: StringFilter<"InputGroup"> | string
    name?: StringFilter<"InputGroup"> | string
    description?: StringNullableFilter<"InputGroup"> | string | null
    color?: StringNullableFilter<"InputGroup"> | string | null
    aiSuggested?: BoolFilter<"InputGroup"> | boolean
    aiConfidence?: FloatNullableFilter<"InputGroup"> | number | null
    aiReasoning?: StringNullableFilter<"InputGroup"> | string | null
    inputCount?: IntFilter<"InputGroup"> | number
    avgPriority?: FloatNullableFilter<"InputGroup"> | number | null
    lastActivity?: DateTimeNullableFilter<"InputGroup"> | Date | string | null
    createdBy?: StringFilter<"InputGroup"> | string
    createdAt?: DateTimeFilter<"InputGroup"> | Date | string
    updatedAt?: DateTimeFilter<"InputGroup"> | Date | string
  }

  export type TeamCreateWithoutDepartmentInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    signals?: SignalCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutDepartmentInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    signals?: SignalUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutDepartmentInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutDepartmentInput, TeamUncheckedCreateWithoutDepartmentInput>
  }

  export type TeamCreateManyDepartmentInputEnvelope = {
    data: TeamCreateManyDepartmentInput | TeamCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type SignalCreateWithoutDepartmentInput = {
    id?: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutSignalsInput
    createdBy?: UserCreateNestedOneWithoutSignalsInput
    hotspots?: HotspotSignalCreateNestedManyWithoutSignalInput
  }

  export type SignalUncheckedCreateWithoutDepartmentInput = {
    id?: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    teamId?: string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotspots?: HotspotSignalUncheckedCreateNestedManyWithoutSignalInput
  }

  export type SignalCreateOrConnectWithoutDepartmentInput = {
    where: SignalWhereUniqueInput
    create: XOR<SignalCreateWithoutDepartmentInput, SignalUncheckedCreateWithoutDepartmentInput>
  }

  export type SignalCreateManyDepartmentInputEnvelope = {
    data: SignalCreateManyDepartmentInput | SignalCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type TeamUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutDepartmentInput, TeamUncheckedUpdateWithoutDepartmentInput>
    create: XOR<TeamCreateWithoutDepartmentInput, TeamUncheckedCreateWithoutDepartmentInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutDepartmentInput, TeamUncheckedUpdateWithoutDepartmentInput>
  }

  export type TeamUpdateManyWithWhereWithoutDepartmentInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    departmentId?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
  }

  export type SignalUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: SignalWhereUniqueInput
    update: XOR<SignalUpdateWithoutDepartmentInput, SignalUncheckedUpdateWithoutDepartmentInput>
    create: XOR<SignalCreateWithoutDepartmentInput, SignalUncheckedCreateWithoutDepartmentInput>
  }

  export type SignalUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: SignalWhereUniqueInput
    data: XOR<SignalUpdateWithoutDepartmentInput, SignalUncheckedUpdateWithoutDepartmentInput>
  }

  export type SignalUpdateManyWithWhereWithoutDepartmentInput = {
    where: SignalScalarWhereInput
    data: XOR<SignalUpdateManyMutationInput, SignalUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type DepartmentCreateWithoutTeamsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    signals?: SignalCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutTeamsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    signals?: SignalUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutTeamsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutTeamsInput, DepartmentUncheckedCreateWithoutTeamsInput>
  }

  export type SignalCreateWithoutTeamInput = {
    id?: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutSignalsInput
    createdBy?: UserCreateNestedOneWithoutSignalsInput
    hotspots?: HotspotSignalCreateNestedManyWithoutSignalInput
  }

  export type SignalUncheckedCreateWithoutTeamInput = {
    id?: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    departmentId?: string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotspots?: HotspotSignalUncheckedCreateNestedManyWithoutSignalInput
  }

  export type SignalCreateOrConnectWithoutTeamInput = {
    where: SignalWhereUniqueInput
    create: XOR<SignalCreateWithoutTeamInput, SignalUncheckedCreateWithoutTeamInput>
  }

  export type SignalCreateManyTeamInputEnvelope = {
    data: SignalCreateManyTeamInput | SignalCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithoutTeamsInput = {
    update: XOR<DepartmentUpdateWithoutTeamsInput, DepartmentUncheckedUpdateWithoutTeamsInput>
    create: XOR<DepartmentCreateWithoutTeamsInput, DepartmentUncheckedCreateWithoutTeamsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutTeamsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutTeamsInput, DepartmentUncheckedUpdateWithoutTeamsInput>
  }

  export type DepartmentUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: SignalUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: SignalUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type SignalUpsertWithWhereUniqueWithoutTeamInput = {
    where: SignalWhereUniqueInput
    update: XOR<SignalUpdateWithoutTeamInput, SignalUncheckedUpdateWithoutTeamInput>
    create: XOR<SignalCreateWithoutTeamInput, SignalUncheckedCreateWithoutTeamInput>
  }

  export type SignalUpdateWithWhereUniqueWithoutTeamInput = {
    where: SignalWhereUniqueInput
    data: XOR<SignalUpdateWithoutTeamInput, SignalUncheckedUpdateWithoutTeamInput>
  }

  export type SignalUpdateManyWithWhereWithoutTeamInput = {
    where: SignalScalarWhereInput
    data: XOR<SignalUpdateManyMutationInput, SignalUncheckedUpdateManyWithoutTeamInput>
  }

  export type UserCreateWithoutInitiativesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputCreateNestedManyWithoutCreatorInput
    signals?: SignalCreateNestedManyWithoutCreatedByInput
    ideas?: IdeaCreateNestedManyWithoutCreatedByInput
    solutions?: SolutionCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    votes?: VoteCreateNestedManyWithoutCreatorInput
    requirements?: RequirementCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    inputGroups?: InputGroupCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutInitiativesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput
    signals?: SignalUncheckedCreateNestedManyWithoutCreatedByInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutCreatedByInput
    solutions?: SolutionUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    votes?: VoteUncheckedCreateNestedManyWithoutCreatorInput
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutInitiativesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInitiativesInput, UserUncheckedCreateWithoutInitiativesInput>
  }

  export type SolutionCreateWithoutInitiativeInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    targetDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    estimatedEffort?: string | null
    businessValue?: string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotspot?: HotspotCreateNestedOneWithoutSolutionsInput
    idea?: IdeaCreateNestedOneWithoutSolutionInput
    input?: InputCreateNestedOneWithoutSolutionsInput
    creator: UserCreateNestedOneWithoutSolutionsInput
    requirements?: RequirementCreateNestedManyWithoutSolutionInput
    frdDocuments?: FRDDocumentCreateNestedManyWithoutSolutionInput
  }

  export type SolutionUncheckedCreateWithoutInitiativeInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    hotspotId?: string | null
    ideaId?: string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    targetDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    estimatedEffort?: string | null
    businessValue?: string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    inputId?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requirements?: RequirementUncheckedCreateNestedManyWithoutSolutionInput
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutSolutionInput
  }

  export type SolutionCreateOrConnectWithoutInitiativeInput = {
    where: SolutionWhereUniqueInput
    create: XOR<SolutionCreateWithoutInitiativeInput, SolutionUncheckedCreateWithoutInitiativeInput>
  }

  export type SolutionCreateManyInitiativeInputEnvelope = {
    data: SolutionCreateManyInitiativeInput | SolutionCreateManyInitiativeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInitiativesInput = {
    update: XOR<UserUpdateWithoutInitiativesInput, UserUncheckedUpdateWithoutInitiativesInput>
    create: XOR<UserCreateWithoutInitiativesInput, UserUncheckedCreateWithoutInitiativesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInitiativesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInitiativesInput, UserUncheckedUpdateWithoutInitiativesInput>
  }

  export type UserUpdateWithoutInitiativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUpdateManyWithoutCreatorNestedInput
    signals?: SignalUpdateManyWithoutCreatedByNestedInput
    ideas?: IdeaUpdateManyWithoutCreatedByNestedInput
    solutions?: SolutionUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    votes?: VoteUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    inputGroups?: InputGroupUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutInitiativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput
    signals?: SignalUncheckedUpdateManyWithoutCreatedByNestedInput
    ideas?: IdeaUncheckedUpdateManyWithoutCreatedByNestedInput
    solutions?: SolutionUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    inputGroups?: InputGroupUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type SolutionUpsertWithWhereUniqueWithoutInitiativeInput = {
    where: SolutionWhereUniqueInput
    update: XOR<SolutionUpdateWithoutInitiativeInput, SolutionUncheckedUpdateWithoutInitiativeInput>
    create: XOR<SolutionCreateWithoutInitiativeInput, SolutionUncheckedCreateWithoutInitiativeInput>
  }

  export type SolutionUpdateWithWhereUniqueWithoutInitiativeInput = {
    where: SolutionWhereUniqueInput
    data: XOR<SolutionUpdateWithoutInitiativeInput, SolutionUncheckedUpdateWithoutInitiativeInput>
  }

  export type SolutionUpdateManyWithWhereWithoutInitiativeInput = {
    where: SolutionScalarWhereInput
    data: XOR<SolutionUpdateManyMutationInput, SolutionUncheckedUpdateManyWithoutInitiativeInput>
  }

  export type DepartmentCreateWithoutSignalsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutSignalsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutSignalsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutSignalsInput, DepartmentUncheckedCreateWithoutSignalsInput>
  }

  export type TeamCreateWithoutSignalsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutTeamsInput
  }

  export type TeamUncheckedCreateWithoutSignalsInput = {
    id?: string
    name: string
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamCreateOrConnectWithoutSignalsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutSignalsInput, TeamUncheckedCreateWithoutSignalsInput>
  }

  export type UserCreateWithoutSignalsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputCreateNestedManyWithoutCreatorInput
    initiatives?: InitiativeCreateNestedManyWithoutOwnerInput
    ideas?: IdeaCreateNestedManyWithoutCreatedByInput
    solutions?: SolutionCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    votes?: VoteCreateNestedManyWithoutCreatorInput
    requirements?: RequirementCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    inputGroups?: InputGroupCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutSignalsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput
    initiatives?: InitiativeUncheckedCreateNestedManyWithoutOwnerInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutCreatedByInput
    solutions?: SolutionUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    votes?: VoteUncheckedCreateNestedManyWithoutCreatorInput
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutSignalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSignalsInput, UserUncheckedCreateWithoutSignalsInput>
  }

  export type HotspotSignalCreateWithoutSignalInput = {
    membershipStrength?: number
    isOutlier?: boolean
    addedAt?: Date | string
    hotspot: HotspotCreateNestedOneWithoutSignalsInput
  }

  export type HotspotSignalUncheckedCreateWithoutSignalInput = {
    hotspotId: string
    membershipStrength?: number
    isOutlier?: boolean
    addedAt?: Date | string
  }

  export type HotspotSignalCreateOrConnectWithoutSignalInput = {
    where: HotspotSignalWhereUniqueInput
    create: XOR<HotspotSignalCreateWithoutSignalInput, HotspotSignalUncheckedCreateWithoutSignalInput>
  }

  export type HotspotSignalCreateManySignalInputEnvelope = {
    data: HotspotSignalCreateManySignalInput | HotspotSignalCreateManySignalInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithoutSignalsInput = {
    update: XOR<DepartmentUpdateWithoutSignalsInput, DepartmentUncheckedUpdateWithoutSignalsInput>
    create: XOR<DepartmentCreateWithoutSignalsInput, DepartmentUncheckedCreateWithoutSignalsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutSignalsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutSignalsInput, DepartmentUncheckedUpdateWithoutSignalsInput>
  }

  export type DepartmentUpdateWithoutSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type TeamUpsertWithoutSignalsInput = {
    update: XOR<TeamUpdateWithoutSignalsInput, TeamUncheckedUpdateWithoutSignalsInput>
    create: XOR<TeamCreateWithoutSignalsInput, TeamUncheckedCreateWithoutSignalsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutSignalsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutSignalsInput, TeamUncheckedUpdateWithoutSignalsInput>
  }

  export type TeamUpdateWithoutSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutTeamsNestedInput
  }

  export type TeamUncheckedUpdateWithoutSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutSignalsInput = {
    update: XOR<UserUpdateWithoutSignalsInput, UserUncheckedUpdateWithoutSignalsInput>
    create: XOR<UserCreateWithoutSignalsInput, UserUncheckedCreateWithoutSignalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSignalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSignalsInput, UserUncheckedUpdateWithoutSignalsInput>
  }

  export type UserUpdateWithoutSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUpdateManyWithoutCreatorNestedInput
    initiatives?: InitiativeUpdateManyWithoutOwnerNestedInput
    ideas?: IdeaUpdateManyWithoutCreatedByNestedInput
    solutions?: SolutionUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    votes?: VoteUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    inputGroups?: InputGroupUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput
    initiatives?: InitiativeUncheckedUpdateManyWithoutOwnerNestedInput
    ideas?: IdeaUncheckedUpdateManyWithoutCreatedByNestedInput
    solutions?: SolutionUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    inputGroups?: InputGroupUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type HotspotSignalUpsertWithWhereUniqueWithoutSignalInput = {
    where: HotspotSignalWhereUniqueInput
    update: XOR<HotspotSignalUpdateWithoutSignalInput, HotspotSignalUncheckedUpdateWithoutSignalInput>
    create: XOR<HotspotSignalCreateWithoutSignalInput, HotspotSignalUncheckedCreateWithoutSignalInput>
  }

  export type HotspotSignalUpdateWithWhereUniqueWithoutSignalInput = {
    where: HotspotSignalWhereUniqueInput
    data: XOR<HotspotSignalUpdateWithoutSignalInput, HotspotSignalUncheckedUpdateWithoutSignalInput>
  }

  export type HotspotSignalUpdateManyWithWhereWithoutSignalInput = {
    where: HotspotSignalScalarWhereInput
    data: XOR<HotspotSignalUpdateManyMutationInput, HotspotSignalUncheckedUpdateManyWithoutSignalInput>
  }

  export type HotspotSignalScalarWhereInput = {
    AND?: HotspotSignalScalarWhereInput | HotspotSignalScalarWhereInput[]
    OR?: HotspotSignalScalarWhereInput[]
    NOT?: HotspotSignalScalarWhereInput | HotspotSignalScalarWhereInput[]
    hotspotId?: StringFilter<"HotspotSignal"> | string
    signalId?: StringFilter<"HotspotSignal"> | string
    membershipStrength?: FloatFilter<"HotspotSignal"> | number
    isOutlier?: BoolFilter<"HotspotSignal"> | boolean
    addedAt?: DateTimeFilter<"HotspotSignal"> | Date | string
  }

  export type HotspotSignalCreateWithoutHotspotInput = {
    membershipStrength?: number
    isOutlier?: boolean
    addedAt?: Date | string
    signal: SignalCreateNestedOneWithoutHotspotsInput
  }

  export type HotspotSignalUncheckedCreateWithoutHotspotInput = {
    signalId: string
    membershipStrength?: number
    isOutlier?: boolean
    addedAt?: Date | string
  }

  export type HotspotSignalCreateOrConnectWithoutHotspotInput = {
    where: HotspotSignalWhereUniqueInput
    create: XOR<HotspotSignalCreateWithoutHotspotInput, HotspotSignalUncheckedCreateWithoutHotspotInput>
  }

  export type HotspotSignalCreateManyHotspotInputEnvelope = {
    data: HotspotSignalCreateManyHotspotInput | HotspotSignalCreateManyHotspotInput[]
    skipDuplicates?: boolean
  }

  export type IdeaCreateWithoutHotspotInput = {
    id?: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutIdeasInput
    solution?: SolutionCreateNestedOneWithoutIdeaInput
  }

  export type IdeaUncheckedCreateWithoutHotspotInput = {
    id?: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    solution?: SolutionUncheckedCreateNestedOneWithoutIdeaInput
  }

  export type IdeaCreateOrConnectWithoutHotspotInput = {
    where: IdeaWhereUniqueInput
    create: XOR<IdeaCreateWithoutHotspotInput, IdeaUncheckedCreateWithoutHotspotInput>
  }

  export type IdeaCreateManyHotspotInputEnvelope = {
    data: IdeaCreateManyHotspotInput | IdeaCreateManyHotspotInput[]
    skipDuplicates?: boolean
  }

  export type SolutionCreateWithoutHotspotInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    targetDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    estimatedEffort?: string | null
    businessValue?: string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    initiative?: InitiativeCreateNestedOneWithoutSolutionsInput
    idea?: IdeaCreateNestedOneWithoutSolutionInput
    input?: InputCreateNestedOneWithoutSolutionsInput
    creator: UserCreateNestedOneWithoutSolutionsInput
    requirements?: RequirementCreateNestedManyWithoutSolutionInput
    frdDocuments?: FRDDocumentCreateNestedManyWithoutSolutionInput
  }

  export type SolutionUncheckedCreateWithoutHotspotInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    initiativeId?: string | null
    ideaId?: string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    targetDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    estimatedEffort?: string | null
    businessValue?: string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    inputId?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requirements?: RequirementUncheckedCreateNestedManyWithoutSolutionInput
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutSolutionInput
  }

  export type SolutionCreateOrConnectWithoutHotspotInput = {
    where: SolutionWhereUniqueInput
    create: XOR<SolutionCreateWithoutHotspotInput, SolutionUncheckedCreateWithoutHotspotInput>
  }

  export type SolutionCreateManyHotspotInputEnvelope = {
    data: SolutionCreateManyHotspotInput | SolutionCreateManyHotspotInput[]
    skipDuplicates?: boolean
  }

  export type HotspotSignalUpsertWithWhereUniqueWithoutHotspotInput = {
    where: HotspotSignalWhereUniqueInput
    update: XOR<HotspotSignalUpdateWithoutHotspotInput, HotspotSignalUncheckedUpdateWithoutHotspotInput>
    create: XOR<HotspotSignalCreateWithoutHotspotInput, HotspotSignalUncheckedCreateWithoutHotspotInput>
  }

  export type HotspotSignalUpdateWithWhereUniqueWithoutHotspotInput = {
    where: HotspotSignalWhereUniqueInput
    data: XOR<HotspotSignalUpdateWithoutHotspotInput, HotspotSignalUncheckedUpdateWithoutHotspotInput>
  }

  export type HotspotSignalUpdateManyWithWhereWithoutHotspotInput = {
    where: HotspotSignalScalarWhereInput
    data: XOR<HotspotSignalUpdateManyMutationInput, HotspotSignalUncheckedUpdateManyWithoutHotspotInput>
  }

  export type IdeaUpsertWithWhereUniqueWithoutHotspotInput = {
    where: IdeaWhereUniqueInput
    update: XOR<IdeaUpdateWithoutHotspotInput, IdeaUncheckedUpdateWithoutHotspotInput>
    create: XOR<IdeaCreateWithoutHotspotInput, IdeaUncheckedCreateWithoutHotspotInput>
  }

  export type IdeaUpdateWithWhereUniqueWithoutHotspotInput = {
    where: IdeaWhereUniqueInput
    data: XOR<IdeaUpdateWithoutHotspotInput, IdeaUncheckedUpdateWithoutHotspotInput>
  }

  export type IdeaUpdateManyWithWhereWithoutHotspotInput = {
    where: IdeaScalarWhereInput
    data: XOR<IdeaUpdateManyMutationInput, IdeaUncheckedUpdateManyWithoutHotspotInput>
  }

  export type SolutionUpsertWithWhereUniqueWithoutHotspotInput = {
    where: SolutionWhereUniqueInput
    update: XOR<SolutionUpdateWithoutHotspotInput, SolutionUncheckedUpdateWithoutHotspotInput>
    create: XOR<SolutionCreateWithoutHotspotInput, SolutionUncheckedCreateWithoutHotspotInput>
  }

  export type SolutionUpdateWithWhereUniqueWithoutHotspotInput = {
    where: SolutionWhereUniqueInput
    data: XOR<SolutionUpdateWithoutHotspotInput, SolutionUncheckedUpdateWithoutHotspotInput>
  }

  export type SolutionUpdateManyWithWhereWithoutHotspotInput = {
    where: SolutionScalarWhereInput
    data: XOR<SolutionUpdateManyMutationInput, SolutionUncheckedUpdateManyWithoutHotspotInput>
  }

  export type HotspotCreateWithoutSignalsInput = {
    id?: string
    title: string
    summary: string
    status?: $Enums.HotspotStatus
    rankScore?: number
    confidence?: number
    primaryCategoryId?: string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: string | null
    similarityThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ideas?: IdeaCreateNestedManyWithoutHotspotInput
    solutions?: SolutionCreateNestedManyWithoutHotspotInput
  }

  export type HotspotUncheckedCreateWithoutSignalsInput = {
    id?: string
    title: string
    summary: string
    status?: $Enums.HotspotStatus
    rankScore?: number
    confidence?: number
    primaryCategoryId?: string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: string | null
    similarityThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ideas?: IdeaUncheckedCreateNestedManyWithoutHotspotInput
    solutions?: SolutionUncheckedCreateNestedManyWithoutHotspotInput
  }

  export type HotspotCreateOrConnectWithoutSignalsInput = {
    where: HotspotWhereUniqueInput
    create: XOR<HotspotCreateWithoutSignalsInput, HotspotUncheckedCreateWithoutSignalsInput>
  }

  export type SignalCreateWithoutHotspotsInput = {
    id?: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutSignalsInput
    team?: TeamCreateNestedOneWithoutSignalsInput
    createdBy?: UserCreateNestedOneWithoutSignalsInput
  }

  export type SignalUncheckedCreateWithoutHotspotsInput = {
    id?: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    departmentId?: string | null
    teamId?: string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SignalCreateOrConnectWithoutHotspotsInput = {
    where: SignalWhereUniqueInput
    create: XOR<SignalCreateWithoutHotspotsInput, SignalUncheckedCreateWithoutHotspotsInput>
  }

  export type HotspotUpsertWithoutSignalsInput = {
    update: XOR<HotspotUpdateWithoutSignalsInput, HotspotUncheckedUpdateWithoutSignalsInput>
    create: XOR<HotspotCreateWithoutSignalsInput, HotspotUncheckedCreateWithoutSignalsInput>
    where?: HotspotWhereInput
  }

  export type HotspotUpdateToOneWithWhereWithoutSignalsInput = {
    where?: HotspotWhereInput
    data: XOR<HotspotUpdateWithoutSignalsInput, HotspotUncheckedUpdateWithoutSignalsInput>
  }

  export type HotspotUpdateWithoutSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumHotspotStatusFieldUpdateOperationsInput | $Enums.HotspotStatus
    rankScore?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    primaryCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: NullableStringFieldUpdateOperationsInput | string | null
    similarityThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ideas?: IdeaUpdateManyWithoutHotspotNestedInput
    solutions?: SolutionUpdateManyWithoutHotspotNestedInput
  }

  export type HotspotUncheckedUpdateWithoutSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumHotspotStatusFieldUpdateOperationsInput | $Enums.HotspotStatus
    rankScore?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    primaryCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: NullableStringFieldUpdateOperationsInput | string | null
    similarityThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ideas?: IdeaUncheckedUpdateManyWithoutHotspotNestedInput
    solutions?: SolutionUncheckedUpdateManyWithoutHotspotNestedInput
  }

  export type SignalUpsertWithoutHotspotsInput = {
    update: XOR<SignalUpdateWithoutHotspotsInput, SignalUncheckedUpdateWithoutHotspotsInput>
    create: XOR<SignalCreateWithoutHotspotsInput, SignalUncheckedCreateWithoutHotspotsInput>
    where?: SignalWhereInput
  }

  export type SignalUpdateToOneWithWhereWithoutHotspotsInput = {
    where?: SignalWhereInput
    data: XOR<SignalUpdateWithoutHotspotsInput, SignalUncheckedUpdateWithoutHotspotsInput>
  }

  export type SignalUpdateWithoutHotspotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutSignalsNestedInput
    team?: TeamUpdateOneWithoutSignalsNestedInput
    createdBy?: UserUpdateOneWithoutSignalsNestedInput
  }

  export type SignalUncheckedUpdateWithoutHotspotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutIdeasInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputCreateNestedManyWithoutCreatorInput
    signals?: SignalCreateNestedManyWithoutCreatedByInput
    initiatives?: InitiativeCreateNestedManyWithoutOwnerInput
    solutions?: SolutionCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    votes?: VoteCreateNestedManyWithoutCreatorInput
    requirements?: RequirementCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    inputGroups?: InputGroupCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutIdeasInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput
    signals?: SignalUncheckedCreateNestedManyWithoutCreatedByInput
    initiatives?: InitiativeUncheckedCreateNestedManyWithoutOwnerInput
    solutions?: SolutionUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    votes?: VoteUncheckedCreateNestedManyWithoutCreatorInput
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutIdeasInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIdeasInput, UserUncheckedCreateWithoutIdeasInput>
  }

  export type HotspotCreateWithoutIdeasInput = {
    id?: string
    title: string
    summary: string
    status?: $Enums.HotspotStatus
    rankScore?: number
    confidence?: number
    primaryCategoryId?: string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: string | null
    similarityThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    signals?: HotspotSignalCreateNestedManyWithoutHotspotInput
    solutions?: SolutionCreateNestedManyWithoutHotspotInput
  }

  export type HotspotUncheckedCreateWithoutIdeasInput = {
    id?: string
    title: string
    summary: string
    status?: $Enums.HotspotStatus
    rankScore?: number
    confidence?: number
    primaryCategoryId?: string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: string | null
    similarityThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    signals?: HotspotSignalUncheckedCreateNestedManyWithoutHotspotInput
    solutions?: SolutionUncheckedCreateNestedManyWithoutHotspotInput
  }

  export type HotspotCreateOrConnectWithoutIdeasInput = {
    where: HotspotWhereUniqueInput
    create: XOR<HotspotCreateWithoutIdeasInput, HotspotUncheckedCreateWithoutIdeasInput>
  }

  export type SolutionCreateWithoutIdeaInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    targetDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    estimatedEffort?: string | null
    businessValue?: string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotspot?: HotspotCreateNestedOneWithoutSolutionsInput
    initiative?: InitiativeCreateNestedOneWithoutSolutionsInput
    input?: InputCreateNestedOneWithoutSolutionsInput
    creator: UserCreateNestedOneWithoutSolutionsInput
    requirements?: RequirementCreateNestedManyWithoutSolutionInput
    frdDocuments?: FRDDocumentCreateNestedManyWithoutSolutionInput
  }

  export type SolutionUncheckedCreateWithoutIdeaInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    hotspotId?: string | null
    initiativeId?: string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    targetDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    estimatedEffort?: string | null
    businessValue?: string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    inputId?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requirements?: RequirementUncheckedCreateNestedManyWithoutSolutionInput
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutSolutionInput
  }

  export type SolutionCreateOrConnectWithoutIdeaInput = {
    where: SolutionWhereUniqueInput
    create: XOR<SolutionCreateWithoutIdeaInput, SolutionUncheckedCreateWithoutIdeaInput>
  }

  export type UserUpsertWithoutIdeasInput = {
    update: XOR<UserUpdateWithoutIdeasInput, UserUncheckedUpdateWithoutIdeasInput>
    create: XOR<UserCreateWithoutIdeasInput, UserUncheckedCreateWithoutIdeasInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIdeasInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIdeasInput, UserUncheckedUpdateWithoutIdeasInput>
  }

  export type UserUpdateWithoutIdeasInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUpdateManyWithoutCreatorNestedInput
    signals?: SignalUpdateManyWithoutCreatedByNestedInput
    initiatives?: InitiativeUpdateManyWithoutOwnerNestedInput
    solutions?: SolutionUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    votes?: VoteUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    inputGroups?: InputGroupUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutIdeasInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput
    signals?: SignalUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatives?: InitiativeUncheckedUpdateManyWithoutOwnerNestedInput
    solutions?: SolutionUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    inputGroups?: InputGroupUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type HotspotUpsertWithoutIdeasInput = {
    update: XOR<HotspotUpdateWithoutIdeasInput, HotspotUncheckedUpdateWithoutIdeasInput>
    create: XOR<HotspotCreateWithoutIdeasInput, HotspotUncheckedCreateWithoutIdeasInput>
    where?: HotspotWhereInput
  }

  export type HotspotUpdateToOneWithWhereWithoutIdeasInput = {
    where?: HotspotWhereInput
    data: XOR<HotspotUpdateWithoutIdeasInput, HotspotUncheckedUpdateWithoutIdeasInput>
  }

  export type HotspotUpdateWithoutIdeasInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumHotspotStatusFieldUpdateOperationsInput | $Enums.HotspotStatus
    rankScore?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    primaryCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: NullableStringFieldUpdateOperationsInput | string | null
    similarityThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: HotspotSignalUpdateManyWithoutHotspotNestedInput
    solutions?: SolutionUpdateManyWithoutHotspotNestedInput
  }

  export type HotspotUncheckedUpdateWithoutIdeasInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumHotspotStatusFieldUpdateOperationsInput | $Enums.HotspotStatus
    rankScore?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    primaryCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: NullableStringFieldUpdateOperationsInput | string | null
    similarityThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: HotspotSignalUncheckedUpdateManyWithoutHotspotNestedInput
    solutions?: SolutionUncheckedUpdateManyWithoutHotspotNestedInput
  }

  export type SolutionUpsertWithoutIdeaInput = {
    update: XOR<SolutionUpdateWithoutIdeaInput, SolutionUncheckedUpdateWithoutIdeaInput>
    create: XOR<SolutionCreateWithoutIdeaInput, SolutionUncheckedCreateWithoutIdeaInput>
    where?: SolutionWhereInput
  }

  export type SolutionUpdateToOneWithWhereWithoutIdeaInput = {
    where?: SolutionWhereInput
    data: XOR<SolutionUpdateWithoutIdeaInput, SolutionUncheckedUpdateWithoutIdeaInput>
  }

  export type SolutionUpdateWithoutIdeaInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotspot?: HotspotUpdateOneWithoutSolutionsNestedInput
    initiative?: InitiativeUpdateOneWithoutSolutionsNestedInput
    input?: InputUpdateOneWithoutSolutionsNestedInput
    creator?: UserUpdateOneRequiredWithoutSolutionsNestedInput
    requirements?: RequirementUpdateManyWithoutSolutionNestedInput
    frdDocuments?: FRDDocumentUpdateManyWithoutSolutionNestedInput
  }

  export type SolutionUncheckedUpdateWithoutIdeaInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    hotspotId?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    inputId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirements?: RequirementUncheckedUpdateManyWithoutSolutionNestedInput
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutSolutionNestedInput
  }

  export type UserCreateWithoutInputsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    signals?: SignalCreateNestedManyWithoutCreatedByInput
    initiatives?: InitiativeCreateNestedManyWithoutOwnerInput
    ideas?: IdeaCreateNestedManyWithoutCreatedByInput
    solutions?: SolutionCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    votes?: VoteCreateNestedManyWithoutCreatorInput
    requirements?: RequirementCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    inputGroups?: InputGroupCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutInputsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    signals?: SignalUncheckedCreateNestedManyWithoutCreatedByInput
    initiatives?: InitiativeUncheckedCreateNestedManyWithoutOwnerInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutCreatedByInput
    solutions?: SolutionUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    votes?: VoteUncheckedCreateNestedManyWithoutCreatorInput
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutInputsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInputsInput, UserUncheckedCreateWithoutInputsInput>
  }

  export type SolutionCreateWithoutInputInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    targetDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    estimatedEffort?: string | null
    businessValue?: string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotspot?: HotspotCreateNestedOneWithoutSolutionsInput
    initiative?: InitiativeCreateNestedOneWithoutSolutionsInput
    idea?: IdeaCreateNestedOneWithoutSolutionInput
    creator: UserCreateNestedOneWithoutSolutionsInput
    requirements?: RequirementCreateNestedManyWithoutSolutionInput
    frdDocuments?: FRDDocumentCreateNestedManyWithoutSolutionInput
  }

  export type SolutionUncheckedCreateWithoutInputInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    hotspotId?: string | null
    initiativeId?: string | null
    ideaId?: string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    targetDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    estimatedEffort?: string | null
    businessValue?: string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requirements?: RequirementUncheckedCreateNestedManyWithoutSolutionInput
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutSolutionInput
  }

  export type SolutionCreateOrConnectWithoutInputInput = {
    where: SolutionWhereUniqueInput
    create: XOR<SolutionCreateWithoutInputInput, SolutionUncheckedCreateWithoutInputInput>
  }

  export type SolutionCreateManyInputInputEnvelope = {
    data: SolutionCreateManyInputInput | SolutionCreateManyInputInput[]
    skipDuplicates?: boolean
  }

  export type InputGroupCreateWithoutInputsInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    aiSuggested?: boolean
    aiConfidence?: number | null
    aiReasoning?: string | null
    inputCount?: number
    avgPriority?: number | null
    lastActivity?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutInputGroupsInput
  }

  export type InputGroupUncheckedCreateWithoutInputsInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    aiSuggested?: boolean
    aiConfidence?: number | null
    aiReasoning?: string | null
    inputCount?: number
    avgPriority?: number | null
    lastActivity?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InputGroupCreateOrConnectWithoutInputsInput = {
    where: InputGroupWhereUniqueInput
    create: XOR<InputGroupCreateWithoutInputsInput, InputGroupUncheckedCreateWithoutInputsInput>
  }

  export type UserUpsertWithoutInputsInput = {
    update: XOR<UserUpdateWithoutInputsInput, UserUncheckedUpdateWithoutInputsInput>
    create: XOR<UserCreateWithoutInputsInput, UserUncheckedCreateWithoutInputsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInputsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInputsInput, UserUncheckedUpdateWithoutInputsInput>
  }

  export type UserUpdateWithoutInputsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: SignalUpdateManyWithoutCreatedByNestedInput
    initiatives?: InitiativeUpdateManyWithoutOwnerNestedInput
    ideas?: IdeaUpdateManyWithoutCreatedByNestedInput
    solutions?: SolutionUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    votes?: VoteUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    inputGroups?: InputGroupUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutInputsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: SignalUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatives?: InitiativeUncheckedUpdateManyWithoutOwnerNestedInput
    ideas?: IdeaUncheckedUpdateManyWithoutCreatedByNestedInput
    solutions?: SolutionUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    inputGroups?: InputGroupUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type SolutionUpsertWithWhereUniqueWithoutInputInput = {
    where: SolutionWhereUniqueInput
    update: XOR<SolutionUpdateWithoutInputInput, SolutionUncheckedUpdateWithoutInputInput>
    create: XOR<SolutionCreateWithoutInputInput, SolutionUncheckedCreateWithoutInputInput>
  }

  export type SolutionUpdateWithWhereUniqueWithoutInputInput = {
    where: SolutionWhereUniqueInput
    data: XOR<SolutionUpdateWithoutInputInput, SolutionUncheckedUpdateWithoutInputInput>
  }

  export type SolutionUpdateManyWithWhereWithoutInputInput = {
    where: SolutionScalarWhereInput
    data: XOR<SolutionUpdateManyMutationInput, SolutionUncheckedUpdateManyWithoutInputInput>
  }

  export type InputGroupUpsertWithWhereUniqueWithoutInputsInput = {
    where: InputGroupWhereUniqueInput
    update: XOR<InputGroupUpdateWithoutInputsInput, InputGroupUncheckedUpdateWithoutInputsInput>
    create: XOR<InputGroupCreateWithoutInputsInput, InputGroupUncheckedCreateWithoutInputsInput>
  }

  export type InputGroupUpdateWithWhereUniqueWithoutInputsInput = {
    where: InputGroupWhereUniqueInput
    data: XOR<InputGroupUpdateWithoutInputsInput, InputGroupUncheckedUpdateWithoutInputsInput>
  }

  export type InputGroupUpdateManyWithWhereWithoutInputsInput = {
    where: InputGroupScalarWhereInput
    data: XOR<InputGroupUpdateManyMutationInput, InputGroupUncheckedUpdateManyWithoutInputsInput>
  }

  export type HotspotCreateWithoutSolutionsInput = {
    id?: string
    title: string
    summary: string
    status?: $Enums.HotspotStatus
    rankScore?: number
    confidence?: number
    primaryCategoryId?: string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: string | null
    similarityThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    signals?: HotspotSignalCreateNestedManyWithoutHotspotInput
    ideas?: IdeaCreateNestedManyWithoutHotspotInput
  }

  export type HotspotUncheckedCreateWithoutSolutionsInput = {
    id?: string
    title: string
    summary: string
    status?: $Enums.HotspotStatus
    rankScore?: number
    confidence?: number
    primaryCategoryId?: string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: string | null
    similarityThreshold?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    signals?: HotspotSignalUncheckedCreateNestedManyWithoutHotspotInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutHotspotInput
  }

  export type HotspotCreateOrConnectWithoutSolutionsInput = {
    where: HotspotWhereUniqueInput
    create: XOR<HotspotCreateWithoutSolutionsInput, HotspotUncheckedCreateWithoutSolutionsInput>
  }

  export type InitiativeCreateWithoutSolutionsInput = {
    id?: string
    name: string
    description?: string | null
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutInitiativesInput
  }

  export type InitiativeUncheckedCreateWithoutSolutionsInput = {
    id?: string
    name: string
    description?: string | null
    ownerId?: string | null
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InitiativeCreateOrConnectWithoutSolutionsInput = {
    where: InitiativeWhereUniqueInput
    create: XOR<InitiativeCreateWithoutSolutionsInput, InitiativeUncheckedCreateWithoutSolutionsInput>
  }

  export type IdeaCreateWithoutSolutionInput = {
    id?: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutIdeasInput
    hotspot: HotspotCreateNestedOneWithoutIdeasInput
  }

  export type IdeaUncheckedCreateWithoutSolutionInput = {
    id?: string
    hotspotId: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdeaCreateOrConnectWithoutSolutionInput = {
    where: IdeaWhereUniqueInput
    create: XOR<IdeaCreateWithoutSolutionInput, IdeaUncheckedCreateWithoutSolutionInput>
  }

  export type InputCreateWithoutSolutionsInput = {
    id?: string
    title: string
    description: string
    type?: $Enums.InputType
    department?: string | null
    issueType?: string | null
    rootCause?: string | null
    priority?: $Enums.Priority
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: number | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.InputStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutInputsInput
    groups?: InputGroupCreateNestedManyWithoutInputsInput
  }

  export type InputUncheckedCreateWithoutSolutionsInput = {
    id?: string
    title: string
    description: string
    type?: $Enums.InputType
    department?: string | null
    issueType?: string | null
    rootCause?: string | null
    priority?: $Enums.Priority
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: number | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.InputStatus
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: InputGroupUncheckedCreateNestedManyWithoutInputsInput
  }

  export type InputCreateOrConnectWithoutSolutionsInput = {
    where: InputWhereUniqueInput
    create: XOR<InputCreateWithoutSolutionsInput, InputUncheckedCreateWithoutSolutionsInput>
  }

  export type UserCreateWithoutSolutionsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputCreateNestedManyWithoutCreatorInput
    signals?: SignalCreateNestedManyWithoutCreatedByInput
    initiatives?: InitiativeCreateNestedManyWithoutOwnerInput
    ideas?: IdeaCreateNestedManyWithoutCreatedByInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    votes?: VoteCreateNestedManyWithoutCreatorInput
    requirements?: RequirementCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    inputGroups?: InputGroupCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutSolutionsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput
    signals?: SignalUncheckedCreateNestedManyWithoutCreatedByInput
    initiatives?: InitiativeUncheckedCreateNestedManyWithoutOwnerInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutCreatedByInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    votes?: VoteUncheckedCreateNestedManyWithoutCreatorInput
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutSolutionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSolutionsInput, UserUncheckedCreateWithoutSolutionsInput>
  }

  export type RequirementCreateWithoutSolutionInput = {
    id?: string
    title: string
    description: string
    acceptanceCriteria: JsonNullValueInput | InputJsonValue
    priority?: $Enums.Priority
    status?: $Enums.RequirementStatus
    estimatedEffort?: string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    riskAssessment?: string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutRequirementsInput
  }

  export type RequirementUncheckedCreateWithoutSolutionInput = {
    id?: string
    title: string
    description: string
    acceptanceCriteria: JsonNullValueInput | InputJsonValue
    priority?: $Enums.Priority
    status?: $Enums.RequirementStatus
    estimatedEffort?: string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    riskAssessment?: string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequirementCreateOrConnectWithoutSolutionInput = {
    where: RequirementWhereUniqueInput
    create: XOR<RequirementCreateWithoutSolutionInput, RequirementUncheckedCreateWithoutSolutionInput>
  }

  export type RequirementCreateManySolutionInputEnvelope = {
    data: RequirementCreateManySolutionInput | RequirementCreateManySolutionInput[]
    skipDuplicates?: boolean
  }

  export type FRDDocumentCreateWithoutSolutionInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutFrdDocumentsInput
    approver?: UserCreateNestedOneWithoutApprovedFRDsInput
  }

  export type FRDDocumentUncheckedCreateWithoutSolutionInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FRDDocumentCreateOrConnectWithoutSolutionInput = {
    where: FRDDocumentWhereUniqueInput
    create: XOR<FRDDocumentCreateWithoutSolutionInput, FRDDocumentUncheckedCreateWithoutSolutionInput>
  }

  export type FRDDocumentCreateManySolutionInputEnvelope = {
    data: FRDDocumentCreateManySolutionInput | FRDDocumentCreateManySolutionInput[]
    skipDuplicates?: boolean
  }

  export type HotspotUpsertWithoutSolutionsInput = {
    update: XOR<HotspotUpdateWithoutSolutionsInput, HotspotUncheckedUpdateWithoutSolutionsInput>
    create: XOR<HotspotCreateWithoutSolutionsInput, HotspotUncheckedCreateWithoutSolutionsInput>
    where?: HotspotWhereInput
  }

  export type HotspotUpdateToOneWithWhereWithoutSolutionsInput = {
    where?: HotspotWhereInput
    data: XOR<HotspotUpdateWithoutSolutionsInput, HotspotUncheckedUpdateWithoutSolutionsInput>
  }

  export type HotspotUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumHotspotStatusFieldUpdateOperationsInput | $Enums.HotspotStatus
    rankScore?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    primaryCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: NullableStringFieldUpdateOperationsInput | string | null
    similarityThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: HotspotSignalUpdateManyWithoutHotspotNestedInput
    ideas?: IdeaUpdateManyWithoutHotspotNestedInput
  }

  export type HotspotUncheckedUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumHotspotStatusFieldUpdateOperationsInput | $Enums.HotspotStatus
    rankScore?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    primaryCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    linkedEntitiesJson?: NullableJsonNullValueInput | InputJsonValue
    clusteringMethod?: NullableStringFieldUpdateOperationsInput | string | null
    similarityThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: HotspotSignalUncheckedUpdateManyWithoutHotspotNestedInput
    ideas?: IdeaUncheckedUpdateManyWithoutHotspotNestedInput
  }

  export type InitiativeUpsertWithoutSolutionsInput = {
    update: XOR<InitiativeUpdateWithoutSolutionsInput, InitiativeUncheckedUpdateWithoutSolutionsInput>
    create: XOR<InitiativeCreateWithoutSolutionsInput, InitiativeUncheckedCreateWithoutSolutionsInput>
    where?: InitiativeWhereInput
  }

  export type InitiativeUpdateToOneWithWhereWithoutSolutionsInput = {
    where?: InitiativeWhereInput
    data: XOR<InitiativeUpdateWithoutSolutionsInput, InitiativeUncheckedUpdateWithoutSolutionsInput>
  }

  export type InitiativeUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutInitiativesNestedInput
  }

  export type InitiativeUncheckedUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdeaUpsertWithoutSolutionInput = {
    update: XOR<IdeaUpdateWithoutSolutionInput, IdeaUncheckedUpdateWithoutSolutionInput>
    create: XOR<IdeaCreateWithoutSolutionInput, IdeaUncheckedCreateWithoutSolutionInput>
    where?: IdeaWhereInput
  }

  export type IdeaUpdateToOneWithWhereWithoutSolutionInput = {
    where?: IdeaWhereInput
    data: XOR<IdeaUpdateWithoutSolutionInput, IdeaUncheckedUpdateWithoutSolutionInput>
  }

  export type IdeaUpdateWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutIdeasNestedInput
    hotspot?: HotspotUpdateOneRequiredWithoutIdeasNestedInput
  }

  export type IdeaUncheckedUpdateWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotspotId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputUpsertWithoutSolutionsInput = {
    update: XOR<InputUpdateWithoutSolutionsInput, InputUncheckedUpdateWithoutSolutionsInput>
    create: XOR<InputCreateWithoutSolutionsInput, InputUncheckedCreateWithoutSolutionsInput>
    where?: InputWhereInput
  }

  export type InputUpdateToOneWithWhereWithoutSolutionsInput = {
    where?: InputWhereInput
    data: XOR<InputUpdateWithoutSolutionsInput, InputUncheckedUpdateWithoutSolutionsInput>
  }

  export type InputUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    department?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutInputsNestedInput
    groups?: InputGroupUpdateManyWithoutInputsNestedInput
  }

  export type InputUncheckedUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    department?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: InputGroupUncheckedUpdateManyWithoutInputsNestedInput
  }

  export type UserUpsertWithoutSolutionsInput = {
    update: XOR<UserUpdateWithoutSolutionsInput, UserUncheckedUpdateWithoutSolutionsInput>
    create: XOR<UserCreateWithoutSolutionsInput, UserUncheckedCreateWithoutSolutionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSolutionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSolutionsInput, UserUncheckedUpdateWithoutSolutionsInput>
  }

  export type UserUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUpdateManyWithoutCreatorNestedInput
    signals?: SignalUpdateManyWithoutCreatedByNestedInput
    initiatives?: InitiativeUpdateManyWithoutOwnerNestedInput
    ideas?: IdeaUpdateManyWithoutCreatedByNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    votes?: VoteUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    inputGroups?: InputGroupUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput
    signals?: SignalUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatives?: InitiativeUncheckedUpdateManyWithoutOwnerNestedInput
    ideas?: IdeaUncheckedUpdateManyWithoutCreatedByNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    inputGroups?: InputGroupUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type RequirementUpsertWithWhereUniqueWithoutSolutionInput = {
    where: RequirementWhereUniqueInput
    update: XOR<RequirementUpdateWithoutSolutionInput, RequirementUncheckedUpdateWithoutSolutionInput>
    create: XOR<RequirementCreateWithoutSolutionInput, RequirementUncheckedCreateWithoutSolutionInput>
  }

  export type RequirementUpdateWithWhereUniqueWithoutSolutionInput = {
    where: RequirementWhereUniqueInput
    data: XOR<RequirementUpdateWithoutSolutionInput, RequirementUncheckedUpdateWithoutSolutionInput>
  }

  export type RequirementUpdateManyWithWhereWithoutSolutionInput = {
    where: RequirementScalarWhereInput
    data: XOR<RequirementUpdateManyMutationInput, RequirementUncheckedUpdateManyWithoutSolutionInput>
  }

  export type FRDDocumentUpsertWithWhereUniqueWithoutSolutionInput = {
    where: FRDDocumentWhereUniqueInput
    update: XOR<FRDDocumentUpdateWithoutSolutionInput, FRDDocumentUncheckedUpdateWithoutSolutionInput>
    create: XOR<FRDDocumentCreateWithoutSolutionInput, FRDDocumentUncheckedCreateWithoutSolutionInput>
  }

  export type FRDDocumentUpdateWithWhereUniqueWithoutSolutionInput = {
    where: FRDDocumentWhereUniqueInput
    data: XOR<FRDDocumentUpdateWithoutSolutionInput, FRDDocumentUncheckedUpdateWithoutSolutionInput>
  }

  export type FRDDocumentUpdateManyWithWhereWithoutSolutionInput = {
    where: FRDDocumentScalarWhereInput
    data: XOR<FRDDocumentUpdateManyMutationInput, FRDDocumentUncheckedUpdateManyWithoutSolutionInput>
  }

  export type SolutionCreateWithoutRequirementsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    targetDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    estimatedEffort?: string | null
    businessValue?: string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotspot?: HotspotCreateNestedOneWithoutSolutionsInput
    initiative?: InitiativeCreateNestedOneWithoutSolutionsInput
    idea?: IdeaCreateNestedOneWithoutSolutionInput
    input?: InputCreateNestedOneWithoutSolutionsInput
    creator: UserCreateNestedOneWithoutSolutionsInput
    frdDocuments?: FRDDocumentCreateNestedManyWithoutSolutionInput
  }

  export type SolutionUncheckedCreateWithoutRequirementsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    hotspotId?: string | null
    initiativeId?: string | null
    ideaId?: string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    targetDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    estimatedEffort?: string | null
    businessValue?: string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    inputId?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutSolutionInput
  }

  export type SolutionCreateOrConnectWithoutRequirementsInput = {
    where: SolutionWhereUniqueInput
    create: XOR<SolutionCreateWithoutRequirementsInput, SolutionUncheckedCreateWithoutRequirementsInput>
  }

  export type UserCreateWithoutRequirementsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputCreateNestedManyWithoutCreatorInput
    signals?: SignalCreateNestedManyWithoutCreatedByInput
    initiatives?: InitiativeCreateNestedManyWithoutOwnerInput
    ideas?: IdeaCreateNestedManyWithoutCreatedByInput
    solutions?: SolutionCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    votes?: VoteCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    inputGroups?: InputGroupCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutRequirementsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput
    signals?: SignalUncheckedCreateNestedManyWithoutCreatedByInput
    initiatives?: InitiativeUncheckedCreateNestedManyWithoutOwnerInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutCreatedByInput
    solutions?: SolutionUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    votes?: VoteUncheckedCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutRequirementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequirementsInput, UserUncheckedCreateWithoutRequirementsInput>
  }

  export type SolutionUpsertWithoutRequirementsInput = {
    update: XOR<SolutionUpdateWithoutRequirementsInput, SolutionUncheckedUpdateWithoutRequirementsInput>
    create: XOR<SolutionCreateWithoutRequirementsInput, SolutionUncheckedCreateWithoutRequirementsInput>
    where?: SolutionWhereInput
  }

  export type SolutionUpdateToOneWithWhereWithoutRequirementsInput = {
    where?: SolutionWhereInput
    data: XOR<SolutionUpdateWithoutRequirementsInput, SolutionUncheckedUpdateWithoutRequirementsInput>
  }

  export type SolutionUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotspot?: HotspotUpdateOneWithoutSolutionsNestedInput
    initiative?: InitiativeUpdateOneWithoutSolutionsNestedInput
    idea?: IdeaUpdateOneWithoutSolutionNestedInput
    input?: InputUpdateOneWithoutSolutionsNestedInput
    creator?: UserUpdateOneRequiredWithoutSolutionsNestedInput
    frdDocuments?: FRDDocumentUpdateManyWithoutSolutionNestedInput
  }

  export type SolutionUncheckedUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    hotspotId?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    inputId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutSolutionNestedInput
  }

  export type UserUpsertWithoutRequirementsInput = {
    update: XOR<UserUpdateWithoutRequirementsInput, UserUncheckedUpdateWithoutRequirementsInput>
    create: XOR<UserCreateWithoutRequirementsInput, UserUncheckedCreateWithoutRequirementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRequirementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRequirementsInput, UserUncheckedUpdateWithoutRequirementsInput>
  }

  export type UserUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUpdateManyWithoutCreatorNestedInput
    signals?: SignalUpdateManyWithoutCreatedByNestedInput
    initiatives?: InitiativeUpdateManyWithoutOwnerNestedInput
    ideas?: IdeaUpdateManyWithoutCreatedByNestedInput
    solutions?: SolutionUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    votes?: VoteUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    inputGroups?: InputGroupUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput
    signals?: SignalUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatives?: InitiativeUncheckedUpdateManyWithoutOwnerNestedInput
    ideas?: IdeaUncheckedUpdateManyWithoutCreatedByNestedInput
    solutions?: SolutionUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    inputGroups?: InputGroupUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type SolutionCreateWithoutFrdDocumentsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    targetDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    estimatedEffort?: string | null
    businessValue?: string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotspot?: HotspotCreateNestedOneWithoutSolutionsInput
    initiative?: InitiativeCreateNestedOneWithoutSolutionsInput
    idea?: IdeaCreateNestedOneWithoutSolutionInput
    input?: InputCreateNestedOneWithoutSolutionsInput
    creator: UserCreateNestedOneWithoutSolutionsInput
    requirements?: RequirementCreateNestedManyWithoutSolutionInput
  }

  export type SolutionUncheckedCreateWithoutFrdDocumentsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    hotspotId?: string | null
    initiativeId?: string | null
    ideaId?: string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    targetDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    estimatedEffort?: string | null
    businessValue?: string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    inputId?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requirements?: RequirementUncheckedCreateNestedManyWithoutSolutionInput
  }

  export type SolutionCreateOrConnectWithoutFrdDocumentsInput = {
    where: SolutionWhereUniqueInput
    create: XOR<SolutionCreateWithoutFrdDocumentsInput, SolutionUncheckedCreateWithoutFrdDocumentsInput>
  }

  export type UserCreateWithoutFrdDocumentsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputCreateNestedManyWithoutCreatorInput
    signals?: SignalCreateNestedManyWithoutCreatedByInput
    initiatives?: InitiativeCreateNestedManyWithoutOwnerInput
    ideas?: IdeaCreateNestedManyWithoutCreatedByInput
    solutions?: SolutionCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    votes?: VoteCreateNestedManyWithoutCreatorInput
    requirements?: RequirementCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    inputGroups?: InputGroupCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutFrdDocumentsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput
    signals?: SignalUncheckedCreateNestedManyWithoutCreatedByInput
    initiatives?: InitiativeUncheckedCreateNestedManyWithoutOwnerInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutCreatedByInput
    solutions?: SolutionUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    votes?: VoteUncheckedCreateNestedManyWithoutCreatorInput
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutFrdDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFrdDocumentsInput, UserUncheckedCreateWithoutFrdDocumentsInput>
  }

  export type UserCreateWithoutApprovedFRDsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputCreateNestedManyWithoutCreatorInput
    signals?: SignalCreateNestedManyWithoutCreatedByInput
    initiatives?: InitiativeCreateNestedManyWithoutOwnerInput
    ideas?: IdeaCreateNestedManyWithoutCreatedByInput
    solutions?: SolutionCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    votes?: VoteCreateNestedManyWithoutCreatorInput
    requirements?: RequirementCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    inputGroups?: InputGroupCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutApprovedFRDsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput
    signals?: SignalUncheckedCreateNestedManyWithoutCreatedByInput
    initiatives?: InitiativeUncheckedCreateNestedManyWithoutOwnerInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutCreatedByInput
    solutions?: SolutionUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    votes?: VoteUncheckedCreateNestedManyWithoutCreatorInput
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutApprovedFRDsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedFRDsInput, UserUncheckedCreateWithoutApprovedFRDsInput>
  }

  export type SolutionUpsertWithoutFrdDocumentsInput = {
    update: XOR<SolutionUpdateWithoutFrdDocumentsInput, SolutionUncheckedUpdateWithoutFrdDocumentsInput>
    create: XOR<SolutionCreateWithoutFrdDocumentsInput, SolutionUncheckedCreateWithoutFrdDocumentsInput>
    where?: SolutionWhereInput
  }

  export type SolutionUpdateToOneWithWhereWithoutFrdDocumentsInput = {
    where?: SolutionWhereInput
    data: XOR<SolutionUpdateWithoutFrdDocumentsInput, SolutionUncheckedUpdateWithoutFrdDocumentsInput>
  }

  export type SolutionUpdateWithoutFrdDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotspot?: HotspotUpdateOneWithoutSolutionsNestedInput
    initiative?: InitiativeUpdateOneWithoutSolutionsNestedInput
    idea?: IdeaUpdateOneWithoutSolutionNestedInput
    input?: InputUpdateOneWithoutSolutionsNestedInput
    creator?: UserUpdateOneRequiredWithoutSolutionsNestedInput
    requirements?: RequirementUpdateManyWithoutSolutionNestedInput
  }

  export type SolutionUncheckedUpdateWithoutFrdDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    hotspotId?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    inputId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirements?: RequirementUncheckedUpdateManyWithoutSolutionNestedInput
  }

  export type UserUpsertWithoutFrdDocumentsInput = {
    update: XOR<UserUpdateWithoutFrdDocumentsInput, UserUncheckedUpdateWithoutFrdDocumentsInput>
    create: XOR<UserCreateWithoutFrdDocumentsInput, UserUncheckedCreateWithoutFrdDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFrdDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFrdDocumentsInput, UserUncheckedUpdateWithoutFrdDocumentsInput>
  }

  export type UserUpdateWithoutFrdDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUpdateManyWithoutCreatorNestedInput
    signals?: SignalUpdateManyWithoutCreatedByNestedInput
    initiatives?: InitiativeUpdateManyWithoutOwnerNestedInput
    ideas?: IdeaUpdateManyWithoutCreatedByNestedInput
    solutions?: SolutionUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    votes?: VoteUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    inputGroups?: InputGroupUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutFrdDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput
    signals?: SignalUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatives?: InitiativeUncheckedUpdateManyWithoutOwnerNestedInput
    ideas?: IdeaUncheckedUpdateManyWithoutCreatedByNestedInput
    solutions?: SolutionUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    inputGroups?: InputGroupUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithoutApprovedFRDsInput = {
    update: XOR<UserUpdateWithoutApprovedFRDsInput, UserUncheckedUpdateWithoutApprovedFRDsInput>
    create: XOR<UserCreateWithoutApprovedFRDsInput, UserUncheckedCreateWithoutApprovedFRDsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedFRDsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedFRDsInput, UserUncheckedUpdateWithoutApprovedFRDsInput>
  }

  export type UserUpdateWithoutApprovedFRDsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUpdateManyWithoutCreatorNestedInput
    signals?: SignalUpdateManyWithoutCreatedByNestedInput
    initiatives?: InitiativeUpdateManyWithoutOwnerNestedInput
    ideas?: IdeaUpdateManyWithoutCreatedByNestedInput
    solutions?: SolutionUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    votes?: VoteUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    inputGroups?: InputGroupUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedFRDsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput
    signals?: SignalUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatives?: InitiativeUncheckedUpdateManyWithoutOwnerNestedInput
    ideas?: IdeaUncheckedUpdateManyWithoutCreatedByNestedInput
    solutions?: SolutionUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    inputGroups?: InputGroupUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CommentCreateWithoutRepliesInput = {
    id?: string
    content: string
    entityType: $Enums.EntityType
    entityId: string
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: boolean
    editedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    thread?: CommentCreateNestedOneWithoutRepliesInput
    creator: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    content: string
    entityType: $Enums.EntityType
    entityId: string
    parentId?: string | null
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: boolean
    editedAt?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type CommentCreateWithoutThreadInput = {
    id?: string
    content: string
    entityType: $Enums.EntityType
    entityId: string
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: boolean
    editedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentCreateNestedManyWithoutThreadInput
    creator: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutThreadInput = {
    id?: string
    content: string
    entityType: $Enums.EntityType
    entityId: string
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: boolean
    editedAt?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutThreadInput
  }

  export type CommentCreateOrConnectWithoutThreadInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutThreadInput, CommentUncheckedCreateWithoutThreadInput>
  }

  export type CommentCreateManyThreadInputEnvelope = {
    data: CommentCreateManyThreadInput | CommentCreateManyThreadInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputCreateNestedManyWithoutCreatorInput
    signals?: SignalCreateNestedManyWithoutCreatedByInput
    initiatives?: InitiativeCreateNestedManyWithoutOwnerInput
    ideas?: IdeaCreateNestedManyWithoutCreatedByInput
    solutions?: SolutionCreateNestedManyWithoutCreatorInput
    votes?: VoteCreateNestedManyWithoutCreatorInput
    requirements?: RequirementCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    inputGroups?: InputGroupCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput
    signals?: SignalUncheckedCreateNestedManyWithoutCreatedByInput
    initiatives?: InitiativeUncheckedCreateNestedManyWithoutOwnerInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutCreatedByInput
    solutions?: SolutionUncheckedCreateNestedManyWithoutCreatorInput
    votes?: VoteUncheckedCreateNestedManyWithoutCreatorInput
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: CommentUpdateOneWithoutRepliesNestedInput
    creator?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutThreadInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutThreadInput, CommentUncheckedUpdateWithoutThreadInput>
    create: XOR<CommentCreateWithoutThreadInput, CommentUncheckedCreateWithoutThreadInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutThreadInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutThreadInput, CommentUncheckedUpdateWithoutThreadInput>
  }

  export type CommentUpdateManyWithWhereWithoutThreadInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutThreadInput>
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUpdateManyWithoutCreatorNestedInput
    signals?: SignalUpdateManyWithoutCreatedByNestedInput
    initiatives?: InitiativeUpdateManyWithoutOwnerNestedInput
    ideas?: IdeaUpdateManyWithoutCreatedByNestedInput
    solutions?: SolutionUpdateManyWithoutCreatorNestedInput
    votes?: VoteUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    inputGroups?: InputGroupUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput
    signals?: SignalUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatives?: InitiativeUncheckedUpdateManyWithoutOwnerNestedInput
    ideas?: IdeaUncheckedUpdateManyWithoutCreatedByNestedInput
    solutions?: SolutionUncheckedUpdateManyWithoutCreatorNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    inputGroups?: InputGroupUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutVotesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputCreateNestedManyWithoutCreatorInput
    signals?: SignalCreateNestedManyWithoutCreatedByInput
    initiatives?: InitiativeCreateNestedManyWithoutOwnerInput
    ideas?: IdeaCreateNestedManyWithoutCreatedByInput
    solutions?: SolutionCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    requirements?: RequirementCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    inputGroups?: InputGroupCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutVotesInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput
    signals?: SignalUncheckedCreateNestedManyWithoutCreatedByInput
    initiatives?: InitiativeUncheckedCreateNestedManyWithoutOwnerInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutCreatedByInput
    solutions?: SolutionUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
  }

  export type UserUpsertWithoutVotesInput = {
    update: XOR<UserUpdateWithoutVotesInput, UserUncheckedUpdateWithoutVotesInput>
    create: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVotesInput, UserUncheckedUpdateWithoutVotesInput>
  }

  export type UserUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUpdateManyWithoutCreatorNestedInput
    signals?: SignalUpdateManyWithoutCreatedByNestedInput
    initiatives?: InitiativeUpdateManyWithoutOwnerNestedInput
    ideas?: IdeaUpdateManyWithoutCreatedByNestedInput
    solutions?: SolutionUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    inputGroups?: InputGroupUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput
    signals?: SignalUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatives?: InitiativeUncheckedUpdateManyWithoutOwnerNestedInput
    ideas?: IdeaUncheckedUpdateManyWithoutCreatedByNestedInput
    solutions?: SolutionUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    inputGroups?: InputGroupUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutInputGroupsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputCreateNestedManyWithoutCreatorInput
    signals?: SignalCreateNestedManyWithoutCreatedByInput
    initiatives?: InitiativeCreateNestedManyWithoutOwnerInput
    ideas?: IdeaCreateNestedManyWithoutCreatedByInput
    solutions?: SolutionCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    votes?: VoteCreateNestedManyWithoutCreatorInput
    requirements?: RequirementCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInputGroupsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput
    signals?: SignalUncheckedCreateNestedManyWithoutCreatedByInput
    initiatives?: InitiativeUncheckedCreateNestedManyWithoutOwnerInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutCreatedByInput
    solutions?: SolutionUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    votes?: VoteUncheckedCreateNestedManyWithoutCreatorInput
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInputGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInputGroupsInput, UserUncheckedCreateWithoutInputGroupsInput>
  }

  export type InputCreateWithoutGroupsInput = {
    id?: string
    title: string
    description: string
    type?: $Enums.InputType
    department?: string | null
    issueType?: string | null
    rootCause?: string | null
    priority?: $Enums.Priority
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: number | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.InputStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutInputsInput
    solutions?: SolutionCreateNestedManyWithoutInputInput
  }

  export type InputUncheckedCreateWithoutGroupsInput = {
    id?: string
    title: string
    description: string
    type?: $Enums.InputType
    department?: string | null
    issueType?: string | null
    rootCause?: string | null
    priority?: $Enums.Priority
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: number | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.InputStatus
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    solutions?: SolutionUncheckedCreateNestedManyWithoutInputInput
  }

  export type InputCreateOrConnectWithoutGroupsInput = {
    where: InputWhereUniqueInput
    create: XOR<InputCreateWithoutGroupsInput, InputUncheckedCreateWithoutGroupsInput>
  }

  export type UserUpsertWithoutInputGroupsInput = {
    update: XOR<UserUpdateWithoutInputGroupsInput, UserUncheckedUpdateWithoutInputGroupsInput>
    create: XOR<UserCreateWithoutInputGroupsInput, UserUncheckedCreateWithoutInputGroupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInputGroupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInputGroupsInput, UserUncheckedUpdateWithoutInputGroupsInput>
  }

  export type UserUpdateWithoutInputGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUpdateManyWithoutCreatorNestedInput
    signals?: SignalUpdateManyWithoutCreatedByNestedInput
    initiatives?: InitiativeUpdateManyWithoutOwnerNestedInput
    ideas?: IdeaUpdateManyWithoutCreatedByNestedInput
    solutions?: SolutionUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    votes?: VoteUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInputGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput
    signals?: SignalUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatives?: InitiativeUncheckedUpdateManyWithoutOwnerNestedInput
    ideas?: IdeaUncheckedUpdateManyWithoutCreatedByNestedInput
    solutions?: SolutionUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InputUpsertWithWhereUniqueWithoutGroupsInput = {
    where: InputWhereUniqueInput
    update: XOR<InputUpdateWithoutGroupsInput, InputUncheckedUpdateWithoutGroupsInput>
    create: XOR<InputCreateWithoutGroupsInput, InputUncheckedCreateWithoutGroupsInput>
  }

  export type InputUpdateWithWhereUniqueWithoutGroupsInput = {
    where: InputWhereUniqueInput
    data: XOR<InputUpdateWithoutGroupsInput, InputUncheckedUpdateWithoutGroupsInput>
  }

  export type InputUpdateManyWithWhereWithoutGroupsInput = {
    where: InputScalarWhereInput
    data: XOR<InputUpdateManyMutationInput, InputUncheckedUpdateManyWithoutGroupsInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputCreateNestedManyWithoutCreatorInput
    signals?: SignalCreateNestedManyWithoutCreatedByInput
    initiatives?: InitiativeCreateNestedManyWithoutOwnerInput
    ideas?: IdeaCreateNestedManyWithoutCreatedByInput
    solutions?: SolutionCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    votes?: VoteCreateNestedManyWithoutCreatorInput
    requirements?: RequirementCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentCreateNestedManyWithoutApproverInput
    inputGroups?: InputGroupCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    department?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: InputUncheckedCreateNestedManyWithoutCreatorInput
    signals?: SignalUncheckedCreateNestedManyWithoutCreatedByInput
    initiatives?: InitiativeUncheckedCreateNestedManyWithoutOwnerInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutCreatedByInput
    solutions?: SolutionUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    votes?: VoteUncheckedCreateNestedManyWithoutCreatorInput
    requirements?: RequirementUncheckedCreateNestedManyWithoutCreatorInput
    frdDocuments?: FRDDocumentUncheckedCreateNestedManyWithoutCreatorInput
    approvedFRDs?: FRDDocumentUncheckedCreateNestedManyWithoutApproverInput
    inputGroups?: InputGroupUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUpdateManyWithoutCreatorNestedInput
    signals?: SignalUpdateManyWithoutCreatedByNestedInput
    initiatives?: InitiativeUpdateManyWithoutOwnerNestedInput
    ideas?: IdeaUpdateManyWithoutCreatedByNestedInput
    solutions?: SolutionUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    votes?: VoteUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUpdateManyWithoutApproverNestedInput
    inputGroups?: InputGroupUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUncheckedUpdateManyWithoutCreatorNestedInput
    signals?: SignalUncheckedUpdateManyWithoutCreatedByNestedInput
    initiatives?: InitiativeUncheckedUpdateManyWithoutOwnerNestedInput
    ideas?: IdeaUncheckedUpdateManyWithoutCreatedByNestedInput
    solutions?: SolutionUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCreatorNestedInput
    requirements?: RequirementUncheckedUpdateManyWithoutCreatorNestedInput
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    approvedFRDs?: FRDDocumentUncheckedUpdateManyWithoutApproverNestedInput
    inputGroups?: InputGroupUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type InputCreateManyCreatorInput = {
    id?: string
    title: string
    description: string
    type?: $Enums.InputType
    department?: string | null
    issueType?: string | null
    rootCause?: string | null
    priority?: $Enums.Priority
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: number | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.InputStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SignalCreateManyCreatedByInput = {
    id?: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    departmentId?: string | null
    teamId?: string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InitiativeCreateManyOwnerInput = {
    id?: string
    name: string
    description?: string | null
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdeaCreateManyCreatedByInput = {
    id?: string
    hotspotId: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SolutionCreateManyCreatorInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    hotspotId?: string | null
    initiativeId?: string | null
    ideaId?: string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    targetDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    estimatedEffort?: string | null
    businessValue?: string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    inputId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyCreatorInput = {
    id?: string
    content: string
    entityType: $Enums.EntityType
    entityId: string
    parentId?: string | null
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: boolean
    editedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoteCreateManyCreatorInput = {
    id?: string
    value: $Enums.VoteValue
    entityType: $Enums.EntityType
    entityId: string
    createdAt?: Date | string
  }

  export type RequirementCreateManyCreatorInput = {
    id?: string
    title: string
    description: string
    acceptanceCriteria: JsonNullValueInput | InputJsonValue
    priority?: $Enums.Priority
    status?: $Enums.RequirementStatus
    estimatedEffort?: string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    riskAssessment?: string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    solutionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FRDDocumentCreateManyCreatorInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    solutionId: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FRDDocumentCreateManyApproverInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    solutionId: string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    sessionId?: string | null
    createdAt?: Date | string
  }

  export type InputGroupCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    aiSuggested?: boolean
    aiConfidence?: number | null
    aiReasoning?: string | null
    inputCount?: number
    avgPriority?: number | null
    lastActivity?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InputUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    department?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solutions?: SolutionUpdateManyWithoutInputNestedInput
    groups?: InputGroupUpdateManyWithoutInputsNestedInput
  }

  export type InputUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    department?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solutions?: SolutionUncheckedUpdateManyWithoutInputNestedInput
    groups?: InputGroupUncheckedUpdateManyWithoutInputsNestedInput
  }

  export type InputUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    department?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutSignalsNestedInput
    team?: TeamUpdateOneWithoutSignalsNestedInput
    hotspots?: HotspotSignalUpdateManyWithoutSignalNestedInput
  }

  export type SignalUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotspots?: HotspotSignalUncheckedUpdateManyWithoutSignalNestedInput
  }

  export type SignalUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InitiativeUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solutions?: SolutionUpdateManyWithoutInitiativeNestedInput
  }

  export type InitiativeUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solutions?: SolutionUncheckedUpdateManyWithoutInitiativeNestedInput
  }

  export type InitiativeUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    goalJson?: NullableJsonNullValueInput | InputJsonValue
    roiJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdeaUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotspot?: HotspotUpdateOneRequiredWithoutIdeasNestedInput
    solution?: SolutionUpdateOneWithoutIdeaNestedInput
  }

  export type IdeaUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotspotId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solution?: SolutionUncheckedUpdateOneWithoutIdeaNestedInput
  }

  export type IdeaUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotspotId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SolutionUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotspot?: HotspotUpdateOneWithoutSolutionsNestedInput
    initiative?: InitiativeUpdateOneWithoutSolutionsNestedInput
    idea?: IdeaUpdateOneWithoutSolutionNestedInput
    input?: InputUpdateOneWithoutSolutionsNestedInput
    requirements?: RequirementUpdateManyWithoutSolutionNestedInput
    frdDocuments?: FRDDocumentUpdateManyWithoutSolutionNestedInput
  }

  export type SolutionUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    hotspotId?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    inputId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirements?: RequirementUncheckedUpdateManyWithoutSolutionNestedInput
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutSolutionNestedInput
  }

  export type SolutionUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    hotspotId?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    inputId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutThreadNestedInput
  }

  export type CommentUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: EnumVoteValueFieldUpdateOperationsInput | $Enums.VoteValue
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: EnumVoteValueFieldUpdateOperationsInput | $Enums.VoteValue
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: EnumVoteValueFieldUpdateOperationsInput | $Enums.VoteValue
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solution?: SolutionUpdateOneRequiredWithoutRequirementsNestedInput
  }

  export type RequirementUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    solutionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FRDDocumentUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solution?: SolutionUpdateOneRequiredWithoutFrdDocumentsNestedInput
    approver?: UserUpdateOneWithoutApprovedFRDsNestedInput
  }

  export type FRDDocumentUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    solutionId?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FRDDocumentUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    solutionId?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FRDDocumentUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solution?: SolutionUpdateOneRequiredWithoutFrdDocumentsNestedInput
    creator?: UserUpdateOneRequiredWithoutFrdDocumentsNestedInput
  }

  export type FRDDocumentUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    solutionId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FRDDocumentUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    solutionId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputGroupUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    inputCount?: IntFieldUpdateOperationsInput | number
    avgPriority?: NullableFloatFieldUpdateOperationsInput | number | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUpdateManyWithoutGroupsNestedInput
  }

  export type InputGroupUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    inputCount?: IntFieldUpdateOperationsInput | number
    avgPriority?: NullableFloatFieldUpdateOperationsInput | number | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: InputUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type InputGroupUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    inputCount?: IntFieldUpdateOperationsInput | number
    avgPriority?: NullableFloatFieldUpdateOperationsInput | number | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateManyDepartmentInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SignalCreateManyDepartmentInput = {
    id?: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    teamId?: string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: SignalUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signals?: SignalUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutSignalsNestedInput
    createdBy?: UserUpdateOneWithoutSignalsNestedInput
    hotspots?: HotspotSignalUpdateManyWithoutSignalNestedInput
  }

  export type SignalUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotspots?: HotspotSignalUncheckedUpdateManyWithoutSignalNestedInput
  }

  export type SignalUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalCreateManyTeamInput = {
    id?: string
    inputId: string
    timestamp: Date | string
    receivedAt?: Date | string
    schemaVersion?: string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType: string
    sourceId?: string | null
    systemName?: string | null
    title?: string | null
    description: string
    severity: $Enums.Severity
    severityScore?: number
    departmentId?: string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: string | null
    dedupeKey?: string | null
    embedding?: Uint8Array | null
    aiProcessed?: boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SignalUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutSignalsNestedInput
    createdBy?: UserUpdateOneWithoutSignalsNestedInput
    hotspots?: HotspotSignalUpdateManyWithoutSignalNestedInput
  }

  export type SignalUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotspots?: HotspotSignalUncheckedUpdateManyWithoutSignalNestedInput
  }

  export type SignalUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schemaVersion?: StringFieldUpdateOperationsInput | string
    sourceJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    attachmentsJson?: NullableJsonNullValueInput | InputJsonValue
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    systemName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    severityScore?: IntFieldUpdateOperationsInput | number
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    metricsJson?: NullableJsonNullValueInput | InputJsonValue
    baselineJson?: NullableJsonNullValueInput | InputJsonValue
    impactJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    entitiesJson?: NullableJsonNullValueInput | InputJsonValue
    privacyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    aiProcessed?: BoolFieldUpdateOperationsInput | boolean
    aiTagsJson?: NullableJsonNullValueInput | InputJsonValue
    lineageJson?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SolutionCreateManyInitiativeInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    hotspotId?: string | null
    ideaId?: string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    targetDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    estimatedEffort?: string | null
    businessValue?: string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    inputId?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SolutionUpdateWithoutInitiativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotspot?: HotspotUpdateOneWithoutSolutionsNestedInput
    idea?: IdeaUpdateOneWithoutSolutionNestedInput
    input?: InputUpdateOneWithoutSolutionsNestedInput
    creator?: UserUpdateOneRequiredWithoutSolutionsNestedInput
    requirements?: RequirementUpdateManyWithoutSolutionNestedInput
    frdDocuments?: FRDDocumentUpdateManyWithoutSolutionNestedInput
  }

  export type SolutionUncheckedUpdateWithoutInitiativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    hotspotId?: NullableStringFieldUpdateOperationsInput | string | null
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    inputId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirements?: RequirementUncheckedUpdateManyWithoutSolutionNestedInput
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutSolutionNestedInput
  }

  export type SolutionUncheckedUpdateManyWithoutInitiativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    hotspotId?: NullableStringFieldUpdateOperationsInput | string | null
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    inputId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotspotSignalCreateManySignalInput = {
    hotspotId: string
    membershipStrength?: number
    isOutlier?: boolean
    addedAt?: Date | string
  }

  export type HotspotSignalUpdateWithoutSignalInput = {
    membershipStrength?: FloatFieldUpdateOperationsInput | number
    isOutlier?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotspot?: HotspotUpdateOneRequiredWithoutSignalsNestedInput
  }

  export type HotspotSignalUncheckedUpdateWithoutSignalInput = {
    hotspotId?: StringFieldUpdateOperationsInput | string
    membershipStrength?: FloatFieldUpdateOperationsInput | number
    isOutlier?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotspotSignalUncheckedUpdateManyWithoutSignalInput = {
    hotspotId?: StringFieldUpdateOperationsInput | string
    membershipStrength?: FloatFieldUpdateOperationsInput | number
    isOutlier?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotspotSignalCreateManyHotspotInput = {
    signalId: string
    membershipStrength?: number
    isOutlier?: boolean
    addedAt?: Date | string
  }

  export type IdeaCreateManyHotspotInput = {
    id?: string
    title?: string | null
    description: string
    origin: string
    votes?: number
    status?: string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SolutionCreateManyHotspotInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    initiativeId?: string | null
    ideaId?: string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    targetDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    estimatedEffort?: string | null
    businessValue?: string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    inputId?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotspotSignalUpdateWithoutHotspotInput = {
    membershipStrength?: FloatFieldUpdateOperationsInput | number
    isOutlier?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signal?: SignalUpdateOneRequiredWithoutHotspotsNestedInput
  }

  export type HotspotSignalUncheckedUpdateWithoutHotspotInput = {
    signalId?: StringFieldUpdateOperationsInput | string
    membershipStrength?: FloatFieldUpdateOperationsInput | number
    isOutlier?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotspotSignalUncheckedUpdateManyWithoutHotspotInput = {
    signalId?: StringFieldUpdateOperationsInput | string
    membershipStrength?: FloatFieldUpdateOperationsInput | number
    isOutlier?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdeaUpdateWithoutHotspotInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutIdeasNestedInput
    solution?: SolutionUpdateOneWithoutIdeaNestedInput
  }

  export type IdeaUncheckedUpdateWithoutHotspotInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solution?: SolutionUncheckedUpdateOneWithoutIdeaNestedInput
  }

  export type IdeaUncheckedUpdateManyWithoutHotspotInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    evidenceJson?: NullableJsonNullValueInput | InputJsonValue
    tagsJson?: NullableJsonNullValueInput | InputJsonValue
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SolutionUpdateWithoutHotspotInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initiative?: InitiativeUpdateOneWithoutSolutionsNestedInput
    idea?: IdeaUpdateOneWithoutSolutionNestedInput
    input?: InputUpdateOneWithoutSolutionsNestedInput
    creator?: UserUpdateOneRequiredWithoutSolutionsNestedInput
    requirements?: RequirementUpdateManyWithoutSolutionNestedInput
    frdDocuments?: FRDDocumentUpdateManyWithoutSolutionNestedInput
  }

  export type SolutionUncheckedUpdateWithoutHotspotInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    inputId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirements?: RequirementUncheckedUpdateManyWithoutSolutionNestedInput
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutSolutionNestedInput
  }

  export type SolutionUncheckedUpdateManyWithoutHotspotInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    inputId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SolutionCreateManyInputInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SolutionStatus
    hotspotId?: string | null
    initiativeId?: string | null
    ideaId?: string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: number
    targetDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    estimatedEffort?: string | null
    businessValue?: string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SolutionUpdateWithoutInputInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotspot?: HotspotUpdateOneWithoutSolutionsNestedInput
    initiative?: InitiativeUpdateOneWithoutSolutionsNestedInput
    idea?: IdeaUpdateOneWithoutSolutionNestedInput
    creator?: UserUpdateOneRequiredWithoutSolutionsNestedInput
    requirements?: RequirementUpdateManyWithoutSolutionNestedInput
    frdDocuments?: FRDDocumentUpdateManyWithoutSolutionNestedInput
  }

  export type SolutionUncheckedUpdateWithoutInputInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    hotspotId?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirements?: RequirementUncheckedUpdateManyWithoutSolutionNestedInput
    frdDocuments?: FRDDocumentUncheckedUpdateManyWithoutSolutionNestedInput
  }

  export type SolutionUncheckedUpdateManyWithoutInputInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSolutionStatusFieldUpdateOperationsInput | $Enums.SolutionStatus
    hotspotId?: NullableStringFieldUpdateOperationsInput | string | null
    initiativeId?: NullableStringFieldUpdateOperationsInput | string | null
    ideaId?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: NullableJsonNullValueInput | InputJsonValue
    progress?: FloatFieldUpdateOperationsInput | number
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    successMetrics?: NullableJsonNullValueInput | InputJsonValue
    expectedImpactJson?: NullableJsonNullValueInput | InputJsonValue
    actualImpactJson?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputGroupUpdateWithoutInputsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    inputCount?: IntFieldUpdateOperationsInput | number
    avgPriority?: NullableFloatFieldUpdateOperationsInput | number | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutInputGroupsNestedInput
  }

  export type InputGroupUncheckedUpdateWithoutInputsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    inputCount?: IntFieldUpdateOperationsInput | number
    avgPriority?: NullableFloatFieldUpdateOperationsInput | number | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputGroupUncheckedUpdateManyWithoutInputsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    inputCount?: IntFieldUpdateOperationsInput | number
    avgPriority?: NullableFloatFieldUpdateOperationsInput | number | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementCreateManySolutionInput = {
    id?: string
    title: string
    description: string
    acceptanceCriteria: JsonNullValueInput | InputJsonValue
    priority?: $Enums.Priority
    status?: $Enums.RequirementStatus
    estimatedEffort?: string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: string | null
    riskAssessment?: string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FRDDocumentCreateManySolutionInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    aiGenerated?: boolean
    aiConfidence?: number | null
    aiPromptUsed?: string | null
    version?: string
    status?: $Enums.FRDStatus
    executiveApproved?: boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: string | null
    generationTime?: number | null
    wordCount?: number | null
    lastExportedAt?: Date | string | null
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequirementUpdateWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutRequirementsNestedInput
  }

  export type RequirementUncheckedUpdateWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementUncheckedUpdateManyWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: JsonNullValueInput | InputJsonValue
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    estimatedEffort?: NullableStringFieldUpdateOperationsInput | string | null
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    riskAssessment?: NullableStringFieldUpdateOperationsInput | string | null
    stakeholders?: NullableJsonNullValueInput | InputJsonValue
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FRDDocumentUpdateWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutFrdDocumentsNestedInput
    approver?: UserUpdateOneWithoutApprovedFRDsNestedInput
  }

  export type FRDDocumentUncheckedUpdateWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FRDDocumentUncheckedUpdateManyWithoutSolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiPromptUsed?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumFRDStatusFieldUpdateOperationsInput | $Enums.FRDStatus
    executiveApproved?: BoolFieldUpdateOperationsInput | boolean
    exportFormats?: NullableJsonNullValueInput | InputJsonValue
    templateUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyThreadInput = {
    id?: string
    content: string
    entityType: $Enums.EntityType
    entityId: string
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: boolean
    editedAt?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUpdateManyWithoutThreadNestedInput
    creator?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    mentions?: NullableJsonNullValueInput | InputJsonValue
    edited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    department?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutInputsNestedInput
    solutions?: SolutionUpdateManyWithoutInputNestedInput
  }

  export type InputUncheckedUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    department?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    solutions?: SolutionUncheckedUpdateManyWithoutInputNestedInput
  }

  export type InputUncheckedUpdateManyWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumInputTypeFieldUpdateOperationsInput | $Enums.InputType
    department?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: NullableStringFieldUpdateOperationsInput | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    aiTags?: NullableJsonNullValueInput | InputJsonValue
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInputStatusFieldUpdateOperationsInput | $Enums.InputStatus
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}